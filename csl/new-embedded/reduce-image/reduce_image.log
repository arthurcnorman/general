+++ Transcript to reduce_image.log started at Wed Oct 28 11:56:41 2020 +++

3

nil

!*savedef

!*backtrace

nil

!*noinlines
(!*noinlines set to nil)

nil

nil

t


(make!-special '!*native_code)
!*native_code

(setq !*native_code nil)
nil


(cond ((and (null !*savedef)
            (null (memq 'jlisp lispsystem!*))
            (or (boundp 'force_c_code)
                (null (memq 'embedded lispsystem!*)))) (progn

   (de c!:install (name env c!-version !&optional c1)
      (cond
        (c1 (check!-c!-code name env c!-version c1))
        (t (progn
              (put name 'c!-version c!-version)
              (cond (env (prog (v n)
                 (setq v (mkvect (sub1 (length env))))
                 (setq n 0)
            top  (cond
                    ((null env) (progn
                     (put name 'funarg v)
                     (return (symbol!-set!-env name v)))))
                 (putv v n (car env))
                 (setq n (add1 n))
                 (setq env (cdr env))
                 (go top))))
              name))))

   (prog (name names)
      (setq names '(
         "u01.lsp"   "u02.lsp"   "u03.lsp"   "u04.lsp"   "u05.lsp"
         "u06.lsp"   "u07.lsp"   "u08.lsp"   "u09.lsp"   "u10.lsp"
         "u11.lsp"   "u12.lsp"   "u13.lsp"   "u14.lsp"   "u15.lsp"
         "u16.lsp"   "u17.lsp"   "u18.lsp"   "u19.lsp"   "u20.lsp"
         "u21.lsp"   "u22.lsp"   "u23.lsp"   "u24.lsp"   "u25.lsp"
         "u26.lsp"   "u27.lsp"   "u28.lsp"   "u29.lsp"   "u30.lsp"
         "u31.lsp"   "u32.lsp"   "u33.lsp"   "u34.lsp"   "u35.lsp"
         "u36.lsp"   "u37.lsp"   "u38.lsp"   "u39.lsp"   "u40.lsp"
         "u41.lsp"   "u42.lsp"   "u43.lsp"   "u44.lsp"   "u45.lsp"
         "u46.lsp"   "u47.lsp"   "u48.lsp"   "u49.lsp"   "u50.lsp"
         "u51.lsp"   "u52.lsp"   "u53.lsp"   "u54.lsp"   "u55.lsp"
         "u56.lsp"   "u57.lsp"   "u58.lsp"   "u59.lsp"   "u60.lsp"))
   top(cond ((null names) (return nil)))
      (setq name (car names))
      (setq names (cdr names))
% If I am "generic" I will find u01.lsp etc in the current directory...
      (cond
        ((or (memq 'embedded lispsystem!*)
             (not (memq 'generic lispsystem!*)))
         (setq name (compress (cons '!"
            (append (explodec "$reduce/cslbuild/generated-c/")
                    (cdr (explode name))))))))
      (rdf name)
      (go top)))))
Reading "$reduce/cslbuild/generated-c/u01.lsp"

% u01.lsp           Machine generated Lisp

(c!:install "u01" 155351 4382164 1390646)
nil


(c!:install 'mchkopt '(mchkopt mchkopt1) 17870479248354630069)
mchkopt


(c!:install 'smember '(smember) 13191502175548781548)
smember


(c!:install '!*n2f '(!*n2f) 10289146006010272445)
!*n2f


(c!:install 'setdiff '(setdiff) 10882386784744671254)
setdiff


(c!:install 'nth '(nth pnth) 13103979795264948375)
nth


(c!:install 'terminalp '(terminalp !*int ifl!*) 14405872713976495584)
terminalp


(c!:install 'multf '(multf !*physop!-loaded physop!-multf poly!-multf) 
494727110790351985)
multf


(c!:install 'monomgetvariabledegree '(monomgetvariabledegree) 
8023262334649356999)
monomgetvariabledegree


(c!:install 'quotelist '(quotelist list) 1574403703834970305)
quotelist


(c!:install 'num!-exponents '(num!-exponents) 15463308288451653383)
num!-exponents


(c!:install 'simpcar '(simpcar simp) 3553785855597976598)
simpcar


(c!:install 'wuconstantp '(wuconstantp wuvarlist!*) 12941656753920697454
)
wuconstantp


(c!:install 'mkcopy '(mkcopy nreverse) 7183001257258168070)
mkcopy


(c!:install 'revpr '(revpr) 3648246328003253418)
revpr


(c!:install 'talp_getl '(talp_getl talp_lang!*) 10605522302596989277)
talp_getl


(c!:install 'kernels '(kernels kernels1) 10365596704375016327)
kernels


(c!:install 'qqe_rqopp '(qqe_rqopp (qequal qneq)) 9487265644821376008)
qqe_rqopp


(c!:install 'powers '(powers powers0) 12547666331220240574)
powers


(c!:install 'lto_hashid '(lto_hashid string2list) 12756331278654427960)
lto_hashid


(c!:install 'noncomfp '(noncomfp !*ncmp noncomfp1) 11957482738418472085)
noncomfp


(c!:install 'ioto_prtb '(ioto_prtb) 6884062130396396443)
ioto_prtb


(c!:install 'delall '(delall) 1756895226056909811)
delall


(c!:install 'ordop '(ordop !*physop!-loaded kord!* physop!-ordop ordp) 
3890858479330319784)
ordop


(c!:install 'ps!:getv '(ps!:getv !:ps!: tps "PS:GETV: not a ps" eval
rerror) 16942942242138714985)
ps!:getv


(c!:install 'prepf '(prepf prepf1a replus1) 9856160862572892849)
prepf


(c!:install 'c!:ordxp '(c!:ordxp) 2602976016472606765)
c!:ordxp


(c!:install 'zero2nil '(zero2nil !:zerop) 10633115001215793252)
zero2nil


(c!:install 'mval '(mval) 11011388250209885205)
mval


(c!:install 'reval '(reval reval1) 607148151428708743)
reval


(c!:install 'evcomp '(evcomp dipsortevcomp!* apply) 11458319438815987135
)
evcomp


(c!:install 'evmatrixcomp2 '(evmatrixcomp2 iequal evmatrixcomp3) 
17134931270508499986)
evmatrixcomp2


(c!:install 'xval '(xval wedgefax) 4982697926302997625)
xval


(c!:install 'times!: '(times!: !:rd!:) 13918419094490476156)
times!:


(c!:install 'mkvar '(mkvar) 11824711320760967426)
mkvar


(c!:install 'physopp '(physopp physop) 14198226529859723595)
physopp


(c!:install 'memq_edgelist '(memq_edgelist) 16418766517129154613)
memq_edgelist


(c!:install 'mo_comp '(mo_comp) 7822316642505852903)
mo_comp


(c!:install 'c_zero '(c_zero) 1032248116684792182)
c_zero


(c!:install 'sieve_pv0 '(sieve_pv0 reduce_pv0) 13154362390419875934)
sieve_pv0


(c!:install 'listp '(listp) 12303291008233215571)
listp


(c!:install 'modzerop!: '(modzerop!:) 5977998997490276172)
modzerop!:


(c!:install 'getrtypeor '(getrtypeor getrtype) 6980262008830534162)
getrtypeor


(c!:install 'lalr_productions '(lalr_productions lalr_produces) 
3298372555673516867)
lalr_productions


(c!:install 'random_new_seed '(random_new_seed "positive integer"
randommodulus!* unidev_vec!* unidev_next!* unidev_nextp!* typerr) 
5608916306279639031)
random_new_seed


(c!:install 'monomcompare '(monomcompare fluidbibasismonomialorder lex
deglex monomcomparelex monomcomparedeglex monomcomparedegrevlex) 
11668802883052497314)
monomcompare


(c!:install 'makelist '(makelist list) 15515310845748409871)
makelist


(c!:install 'quotf '(quotf !*exp quotf1) 10208944217213743985)
quotf


(c!:install 'mchk!* '(mchk!* !*mcd mchk sfp prepf) 15002136098479593556)
mchk!*


(c!:install 'get!+mat!+entry '(get!+mat!+entry nth) 6094923771698919845)
get!+mat!+entry


(c!:install 'talp_getextl '(talp_getextl talp_extlang!*) 
12538925215258623962)
talp_getextl


(c!:install 'ibalp_clmember '(ibalp_clmember ibalp_cequal) 
12615747429273137966)
ibalp_clmember


(c!:install 'aex_ex '(aex_ex nth) 6874894332184563799)
aex_ex


(c!:install 'argsofopr '(argsofopr) 14485097781522944211)
argsofopr


(c!:install 'find2 '(find2 (stop)) 3919817123441467574)
find2


(c!:install 'noncomp '(noncomp !*ncmp noncomp1) 7281023392677228180)
noncomp


(c!:install 'ps!:order '(ps!:order !:ps!: ps!:getv) 10995295834433152897
)
ps!:order


(c!:install 'prepf1a '(prepf1a prepf1a_reversed) 17523181497977731895)
prepf1a


(c!:install 'pm!:free '(pm!:free unbound binding) 6755412176488262089)
pm!:free


(c!:install 'vbcsize '(vbcsize) 10149681502585176508)
vbcsize


(c!:install 'pnth '(pnth alg "Index out of range" rerror) 
9023406246188284074)
pnth


(c!:install 'wedgefax '(wedgefax wedge) 9774641278439376054)
wedgefax


(c!:install 'convprec '(convprec round!* convchk) 4406448051485643347)
convprec


(c!:install '!*physopp '(!*physopp) 17193575244302011073)
!*physopp


(c!:install 'wideid2list '(wideid2list id2string widestring2list) 
14899334837554163239)
wideid2list


(c!:install 'termsf '(termsf) 5142070612029737275)
termsf


(c!:install 'mkspm '(mkspm subfg!* asymplis!* sub2chk to) 
12924718737372251795)
mkspm


(c!:install 'dssoc '(dssoc) 9943343782137733392)
dssoc


(c!:install 'noncomlistp '(noncomlistp noncomp1) 11410168196383151040)
noncomlistp


(c!:install 'rnzerop!: '(rnzerop!:) 16731020569996446694)
rnzerop!:


(c!:install 'mksp '(mksp fkern getpower) 5150597736874327244)
mksp


(c!:install 'aeval '(aeval reval1) 7849631381568206072)
aeval


(c!:install 'lalr_first '(lalr_first union) 16041187756973293382)
lalr_first


(c!:install 'addcomment '(addcomment cursym!*) 1372804578070059914)
addcomment


(c!:install 'arrayp '(arrayp array) 7480162614326499458)
arrayp


(c!:install 'cl_cflip '(cl_cflip cl_flip) 11247492121595187556)
cl_cflip


(c!:install 'subs3f '(subs3f !*match subs3f1) 5708552445967467259)
subs3f


(c!:install 'kernlp '(kernlp) 4776685139720076559)
kernlp


(c!:install 'talp_invp '(talp_invp talp_op talp_getl talp_getextl) 
18265295900233247614)
talp_invp


(c!:install 'qqe_rbopp '(qqe_rbopp (equal neq lessp leq geq greaterp)) 
4174886615890578722)
qqe_rbopp


(c!:install 'sub2chk '(sub2chk subfg!* powlis!* (expt sqrt) !*sub2) 
13289057268120537615)
sub2chk


(c!:install 'butes '(butes !  !$) 12675838350938118425)
butes


(c!:install 'ps!:last!-term '(ps!:last!-term !:ps!: ps!:max!-order
ps!:getv) 9653922917099831857)
ps!:last!-term


(c!:install 'exchk '(exchk exchk1) 11606904193205051154)
exchk


(c!:install 'expchk '(expchk !*exp offexpchk) 9915809864728027311)
expchk


(c!:install 'dm!-abs '(dm!-abs !:minusp dm!-minus) 5836926462620992597)
dm!-abs


(c!:install 'binding '(binding) 4680970127765444998)
binding


(c!:install 'evlexcomp '(evlexcomp (0) iequal) 15296642623206294172)
evlexcomp


(c!:install 'sc_getmat '(sc_getmat) 58534311512400522)
sc_getmat


(c!:install 'getrtypecar '(getrtypecar getrtype) 15058805869473325106)
getrtypecar


(c!:install 'isanindex '(isanindex physopindices!* physopvarind!*
frlis!* frasc!* revassoc) 12508025661076306506)
isanindex


(c!:install 'poly!-multf '(poly!-multf !*exp ncmp!* wtl!* !*!*processed
plus !*asymp!* !*mcd multd mkprod noncomfp noncomp poly!-multfnc reval
to mkspm addf ordop) 6319512014551894727)
poly!-multf


(c!:install 'mo_divides!? '(mo_divides!? mo!=modiv1) 
17637252768363875233)
mo_divides!?


(c!:install 'dlesslex '(dlesslex) 11955018107554220526)
dlesslex


(c!:install 'hasonevector '(hasonevector vecp) 12564010309464711379)
hasonevector


(c!:install 'reduce_pv0 '(reduce_pv0 pv_den lcm pv_multc pv_add) 
5153456908751287689)
reduce_pv0


(c!:install 'modonep!: '(modonep!:) 5158574548373630293)
modonep!:


(c!:install 'remainder!-in!-vector '(remainder!-in!-vector
"Attempt to divide by zero" errorf) 4351866787004292850)
remainder!-in!-vector


(c!:install 'smemql '(smemql nreverse) 4082635428198047081)
smemql


(c!:install 'lalr_add_lookahead '(lalr_add_lookahead) 
13974897791435704310)
lalr_add_lookahead


(c!:install 'setkorder '(setkorder kord!* alglist!*) 1274397398323497919
)
setkorder


(c!:install 'mtchp1 '(mtchp1 frlis!* !*mcd mchk!* powmtch mapcons) 
8040862986504420322)
mtchp1


(c!:install 'get!+row!+nr '(get!+row!+nr) 619237314739600394)
get!+row!+nr


(c!:install 'rl_negateat '(rl_negateat rl_negateat!* apply) 
284003718963730135)
rl_negateat


(c!:install 'kernels1 '(kernels1) 11809629817331374048)
kernels1


(c!:install 'lpri '(lpri " ") 354308775184825461)
lpri


(c!:install 'addd '(addd nreverse adddm) 3070103899685532212)
addd


(c!:install 'compress!* '(compress!* !/ !- !; !. !!) 
11549636611627544158)
compress!*


(c!:install 'noncomfp1 '(noncomfp1 noncomp) 10476302401066043959)
noncomfp1


(c!:install 'ldepends '(ldepends depends) 11339890901733305229)
ldepends


(c!:install 'numlis '(numlis) 15211646017088965144)
numlis


(c!:install '!:minusp '(!:minusp) 3782016383522340347)
!:minusp


(c!:install 'evzero!? '(evzero!?) 4595356540037025948)
evzero!?


(c!:install 'factorordp '(factorordp worderp) 18023367160266015232)
factorordp


(c!:install 'degr '(degr) 4574746505718608755)
degr


(c!:install 'mkround '(mkround !:rd!:) 16376423073134403457)
mkround


(c!:install 'collectindices '(collectindices collectindices_reversed) 
13350879772651161584)
collectindices


(c!:install 'union_edge '(union_edge memq_edgelist) 18402163738355741286
)
union_edge


(c!:install 'ring_ecart '(ring_ecart nth) 9144020264867069358)
ring_ecart


(c!:install 'mtp '(mtp frlis!*) 16156939807690480451)
mtp


(c!:install 'reduce_pv '(reduce_pv reduce_pv0) 7786781876430233123)
reduce_pv


(c!:install 'rnequiv '(rnequiv) 13456506203434818050)
rnequiv


(c!:install 'general!-modular!-times '(general!-modular!-times
current!-modulus) 12723973456730574931)
general!-modular!-times


(c!:install 'multd '(multd nreverse multdm) 9364600233547318720)
multd


(c!:install 'lalr_lr0_move_dot '(lalr_lr0_move_dot !.) 
8933058430108074818)
lalr_lr0_move_dot


(c!:install 'aex_ctx '(aex_ctx nth) 17701972192989521900)
aex_ctx


(c!:install 'prin2x '(prin2x outl!*) 8707702100765069327)
prin2x


(c!:install 'minusf '(minusf) 458362134412293575)
minusf


(c!:install 'reorder '(reorder rmultpf raddf) 12871853738173991382)
reorder


(c!:install 'aconc!* '(aconc!*) 12129366969500193987)
aconc!*



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u01.lsp"

Reading "$reduce/cslbuild/generated-c/u02.lsp"

% u02.lsp           Machine generated Lisp

(c!:install "u02" 169761 5971315 9509929)
nil


(c!:install 'mchk '(mchk !*sq frlis!* minus difference plus prepsqxx
mchkopt mcharg mchkminus) 148810512295251760)
mchk


(c!:install 'quotsq '(quotsq invsq multsq) 16017804956025636103)
quotsq


(c!:install 'tayexp!-greaterp '(tayexp!-greaterp tayexp!-lessp) 
1123168781243193893)
tayexp!-greaterp


(c!:install '!*d2q '(!*d2q !:zerop) 2942878362772793713)
!*d2q


(c!:install 'talp_simplt '(talp_simplt talp_simplt1) 
17444896794875062292)
talp_simplt


(c!:install 'qqe_qoptailp '(qqe_qoptailp (rtail ltail)) 
17434519072488697490)
qqe_qoptailp


(c!:install 'multdm '(multdm dmode!* times dcombine) 6516973467835205199
)
multdm


(c!:install '!*q2a '(!*q2a !*nosq !*q2a1) 11555987202239149450)
!*q2a


(c!:install '!:onep '(!:onep) 4011829079803763631)
!:onep


(c!:install 'buchvevdivides!? '(buchvevdivides!? gmodule!* vevmtest!?
gevcompatible1) 11196724188458402298)
buchvevdivides!?


(c!:install 'vevmtest!? '(vevmtest!? vevzero!?1) 11706374004685961547)
vevmtest!?


(c!:install 'sublistp '(sublistp) 3169363773062908815)
sublistp


(c!:install 'csl_normbf '(csl_normbf (!:rd!: 0 . 0) !:rd!: lsd lshift) 
13915775592432571512)
csl_normbf


(c!:install 'round!* '(round!*) 15435073396947745909)
round!*


(c!:install 'collectindices_reversed '(collectindices_reversed isanindex
) 15344220528776217650)
collectindices_reversed


(c!:install 'reval_without_mod '(reval_without_mod dmode!* !:mod!: reval
) 11636295117530310728)
reval_without_mod


(c!:install 'mo!=sprod '(mo!=sprod) 9344181336102125413)
mo!=sprod


(c!:install 'pappl '(pappl unpkp) 8550675407748926371)
pappl


(c!:install '!*i2mod '(!*i2mod general!-modular!-number !*modular2f) 
15015861616903927392)
!*i2mod


(c!:install 'general!-modular!-plus '(general!-modular!-plus
current!-modulus) 8526843358129128471)
general!-modular!-plus


(c!:install '!*d2n '(!*d2n) 3633340374767821611)
!*d2n


(c!:install 'delcp '(delcp) 9134181419118630333)
delcp


(c!:install 'getpower '(getpower expt !*sub2) 5825647195735019199)
getpower


(c!:install 'sort '(sort stable!-sortip) 17468245960117337925)
sort


(c!:install 'finde '(finde) 15015524044270863670)
finde


(c!:install 'sfp '(sfp) 5333901289349618817)
sfp


(c!:install 'tayexp!-lessp '(tayexp!-lessp tayexp!-difference !:minusp) 
2420807945700247452)
tayexp!-lessp


(c!:install 'get!+vec!+entry '(get!+vec!+entry nth) 13540592547955936973
)
get!+vec!+entry


(c!:install 'rl_simplat1 '(rl_simplat1 rl_simplat1!* apply) 
1119653501954174848)
rl_simplat1


(c!:install 'mri_floorkernelp '(mri_floorkernelp kernels mri_floorp) 
12260307348955726856)
mri_floorkernelp


(c!:install 'get_token '(get_token ch !> !$) 9412163165595484911)
get_token


(c!:install 'xsimp '(xsimp simp!* expchk) 3255895205295822210)
xsimp


(c!:install 'prepsqxx '(prepsqxx prepsqx negnumberchk) 
331390757553135339)
prepsqxx


(c!:install 'aeval!* '(aeval!* alglist!* reval1) 7399874288010001339)
aeval!*


(c!:install 'adddm '(adddm dmode!* plus !*n2f int!-equiv!-chk dcombine) 
15272508536123350498)
adddm


(c!:install 'cali_bc_prod '(cali_bc_prod multf bc!=simp) 
10442551923468604639)
cali_bc_prod


(c!:install 'sieve_pv '(sieve_pv sieve_pv0) 8777934566637263854)
sieve_pv


(c!:install 'lalr_closure '(lalr_closure !. lalr_productions lalr_first
lalr_item_with_rule setdiff lalr_add_lookahead) 11861106866886183000)
lalr_closure


(c!:install 'list2wideid '(list2wideid list2widestring) 
3523675516333595609)
list2wideid


(c!:install 'rl_varlat '(rl_varlat rl_varlat!* apply) 
5027893105409685837)
rl_varlat


(c!:install 'monomclone '(monomclone) 14855044415434424746)
monomclone


(c!:install 'comfac!-to!-poly '(comfac!-to!-poly) 4709435520467114160)
comfac!-to!-poly


(c!:install 'mtchk '(mtchk noncomp mtchp1 lispeval nocp) 
8584926739393883147)
mtchk


(c!:install 'exptchksq '(exptchksq !*combineexpt exptchk invsq multsq) 
6994235192515332434)
exptchksq


(c!:install 'talp_varlt '(talp_varlt talp_varlt1) 5444361619200117433)
talp_varlt


(c!:install 'lprim '(lprim !*msg "***" lpriw) 7798764165975688666)
lprim


(c!:install 'notstring '(notstring !  !" delall) 2964729193865468950)
notstring


(c!:install 'c!:ordexn '(c!:ordexn c!:ordxp) 4047906876943858375)
c!:ordexn


(c!:install 'constp '(constp domainlist!*) 4795165005821108387)
constp


(c!:install 'bczero!? '(bczero!? !*grmod!*) 5570695932568861154)
bczero!?


(c!:install 'multpfsq '(multpfsq nreverse multsq) 5143380340612129390)
multpfsq


(c!:install 'negnumberchk '(negnumberchk minus) 17451271898430660305)
negnumberchk


(c!:install 'opmtch!* '(opmtch!* subfg!* opmtch) 4529636177027904564)
opmtch!*


(c!:install 'sinitl '(sinitl eval) 1398428616857584375)
sinitl


(c!:install 'smemqlp '(smemqlp quote) 8501739837946035427)
smemqlp


(c!:install 'angles!-equal '(angles!-equal) 16566385185896185115)
angles!-equal


(c!:install 'pappl0 '(pappl0 unpkp pappl pkp) 16766546389216365062)
pappl0


(c!:install 'rnonep!: '(rnonep!:) 10970430191720549988)
rnonep!:


(c!:install 'multiply!-by!-constant!-mod!-p '(
multiply!-by!-constant!-mod!-p !*n2f) 6160203573024828849)
multiply!-by!-constant!-mod!-p


(c!:install 'lalr_prin_symbol '(lalr_prin_symbol "$" terminal_codes
cdrassoc explode2uc) 11673478962445058462)
lalr_prin_symbol


(c!:install 'aex_mk '(aex_mk aex) 14887199082447899676)
aex_mk


(c!:install 'monomisdivisibleby '(monomisdivisibleby) 
14863886936527861088)
monomisdivisibleby


(c!:install 'setcdr '(setcdr) 14832354553454505069)
setcdr


(c!:install 'powers0 '(powers0 repasc) 6537133265482714906)
powers0


(c!:install 'remove!-free!-vars!-l '(remove!-free!-vars!-l !*sq prepsq!*
remove!-free!-vars) 109993854797769662)
remove!-free!-vars!-l


(c!:install 'get!+vec!+dim '(get!+vec!+dim) 9629896398144938975)
get!+vec!+dim


(c!:install 'rl_ordatp '(rl_ordatp rl_ordatp!* apply) 
2629721809518774616)
rl_ordatp


(c!:install 'qqe_qopaddp '(qqe_qopaddp (ladd radd)) 11458331942659716410
)
qqe_qopaddp


(c!:install 'attributes '(attributes !  (!$) atts) 2379865991065383663)
attributes


(c!:install 'fast!-row!-dim '(fast!-row!-dim) 9304921290682235866)
fast!-row!-dim


(c!:install 'evmatrixcomp1 '(evmatrixcomp1 evmatrixcomp2 iequal) 
1762009739234747312)
evmatrixcomp1


(c!:install 'i2rd!* '(i2rd!* chkint!* mkround) 5437373606316795850)
i2rd!*


(c!:install 'getphystype!*sq '(getphystype!*sq getphystypesf) 
6440093314568178873)
getphystype!*sq


(c!:install 'union_edges '(union_edges union_edge) 16071474792195485152)
union_edges


(c!:install 'mo!=modiv1 '(mo!=modiv1) 10533875034678584595)
mo!=modiv1


(c!:install 'unpkp '(unpkp !0 diglist!*) 1739572093140679399)
unpkp


(c!:install 'modtimes!: '(modtimes!: general!-modular!-times !*modular2f
) 18159281788179474687)
modtimes!:


(c!:install 'times!-in!-vector '(times!-in!-vector) 4779664854939156595)
times!-in!-vector


(c!:install 'gcdfd '(gcdfd dmode!* gcdfd1) 9690821169017690901)
gcdfd


(c!:install 'cdrassoc '(cdrassoc "ASSOC trouble: " " " "assoc trouble"
rederr) 1475441646810113968)
cdrassoc


(c!:install 'cl_atmlc '(cl_atmlc) 17505962978350274030)
cl_atmlc


(c!:install 'delallasc '(delallasc nreverse) 12463333164811695390)
delallasc


(c!:install 'rank '(rank !*mcd degr) 13785758358482167955)
rank


(c!:install 'sizchk '(sizchk nreverse) 12235146735279254117)
sizchk


(c!:install 'rl_smcpknowl '(rl_smcpknowl rl_smcpknowl!* apply) 
16284918986271660351)
rl_smcpknowl


(c!:install 'qqe_qopheadp '(qqe_qopheadp (lhead rhead)) 
15180717920636906257)
qqe_qopheadp


(c!:install 'lto_hashequalq '(lto_hashequalq lto_hashid iequal) 
9738948250641085975)
lto_hashequalq


(c!:install 'get_content '(get_content ch !< !$eof!$ !  !" !$
list2string delall) 9268416252380254427)
get_content


(c!:install 'ps!:evaluate '(ps!:evaluate ps ps!:get!-term ps!:last!-term
ps!:evaluate!-next) 10007725786071766620)
ps!:evaluate


(c!:install '!:zerop '(!:zerop) 2700266875788551690)
!:zerop


(c!:install 'initcomb '(initcomb) 12815586964691946178)
initcomb


(c!:install 'bcprod '(bcprod !*grmod!* times bcfi bcint2op multsq
bccheckz) 5527952162054297686)
bcprod



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u02.lsp"

Reading "$reduce/cslbuild/generated-c/u03.lsp"

% u03.lsp           Machine generated Lisp

(c!:install "u03" 31472 3075116 3574010)
nil


(c!:install 'rd!:zerop '(rd!:zerop) 17709990252071441276)
rd!:zerop


(c!:install 'ordpp '(ordpp kord!* ordpa) 12822298693234152376)
ordpp


(c!:install 'monordp '(monordp wedge xorder) 12478659793155962360)
monordp


(c!:install '!*physopp!* '(!*physopp!* physopp!* getphystype) 
948670675597052586)
!*physopp!*


(c!:install 'cdiv '(cdiv resimp) 11683222651518251092)
cdiv


(c!:install 'pv_multc '(pv_multc) 9879545177389591922)
pv_multc


(c!:install 'upbve '(upbve) 1327966133220664679)
upbve


(c!:install 'striptag '(striptag) 17326995988230344292)
striptag


(c!:install 'lalr_compute_lr0_goto '(lalr_compute_lr0_goto
lalr_lr0_move_dot lalr_lr0_closure) 2461723306240185358)
lalr_compute_lr0_goto


(c!:install 'monomcomparedegrevlex '(monomcomparedegrevlex) 
5379678862617958039)
monomcomparedegrevlex


(c!:install 'lt!* '(lt!* !*mcd degr) 7232897656725575641)
lt!*


(c!:install 'subs2f '(subs2f simpcount!* simplimit!* poly
"Simplification recursion too deep" !*sub2 powlis1!* !*resubs rerror
subs2f1 subs2q) 10051676709538020572)
subs2f


(c!:install 'talp_simpat '(talp_simpat talp_arg2l talp_arg2r talp_tordp
talp_op talp_mk2) 3469360596094058181)
talp_simpat


(c!:install 'kernord!-sort '(kernord!-sort maxdeg delallasc) 
4668489427632091701)
kernord!-sort


(c!:install 'printout '(printout !*web indent " " !:rd!: !:rn!: ma_print
) 17135296235608100067)
printout


(c!:install 'mgenp '(mgenp mgen) 14519754117186260097)
mgenp


(c!:install 'evcompless!? '(evcompless!? evcomp) 656781853352752310)
evcompless!?


(c!:install 'evmatrixcomp '(evmatrixcomp vdpmatrix!* evmatrixcomp1) 
16587571580785743131)
evmatrixcomp


(c!:install 'wedgepf2 '(wedgepf2 wedget2 addpf) 12770300117273750368)
wedgepf2


(c!:install 'pprin2 '(pprin2 !*pprinbuf!* !*posn!*) 2238797775385437809)
pprin2


(c!:install '!*collectphysops_reversed '(!*collectphysops_reversed
physopp) 158985461405150257)
!*collectphysops_reversed


(c!:install 'constimes '(constimes cstimes) 7039731577920185829)
constimes


(c!:install 'errorp '(errorp) 8490585414243727613)
errorp


(c!:install 'timesip '(timesip times i) 450242453837008834)
timesip


(c!:install 'fs!:timestermterm '(fs!:timestermterm (1 . 2) sin cos
multsq negsq make!-term fs!:plus) 15534087645662146267)
fs!:timestermterm


(c!:install 'mo_vdivides!? '(mo_vdivides!? mo_comp mo_divides!?) 
4801467432489937362)
mo_vdivides!?


(c!:install 'dless '(dless ordering lex glex grev dlesslex) 
13675625109103645543)
dless


(c!:install 'pkp '(pkp !*ppacked diglist!* !0 dssoc) 3262876245839786418
)
pkp


(c!:install '!*i2rn '(!*i2rn !:rn!:) 8350483260431827809)
!*i2rn


(c!:install 'gcdfd1 '(gcdfd1 gcddd) 7828869281505561653)
gcdfd1


(c!:install 'lalr_propagate_lookaheads '(lalr_propagate_lookaheads
lalr_add_lookahead) 11371262137067644413)
lalr_propagate_lookaheads


(c!:install 'add2calls '(add2calls cinthis nolist xseen!* calls!*) 
5257137815112412235)
add2calls


(c!:install 'getrtype2 '(getrtype2 !3vector matmapfn matrix vecp
getrtype) 15939234473122355531)
getrtype2


(c!:install 'maxdeg '(maxdeg) 15858359606410142356)
maxdeg


(c!:install 'symbollessp '(symbollessp wukord!* wuorderp) 
6195008246583528310)
symbollessp


(c!:install 'multsq '(multsq multf gcdf quotf!-fail canonsq) 
12731693028284618669)
multsq


(c!:install 'rl_smupdknowl '(rl_smupdknowl rl_smupdknowl!* apply) 
13044180732527790587)
rl_smupdknowl


(c!:install 'ibalp_varlt '(ibalp_varlt ibalp_varlt1) 
11883918343511078755)
ibalp_varlt


(c!:install 'get!-print!-name '(get!-print!-name) 12554519722649643614)
get!-print!-name


(c!:install 'bftrim!: '(bftrim!: !:bprec!: round!:mt normbf) 
4135539689745124938)
bftrim!:


(c!:install 'on1 '(on1 onoff) 15736753824152232296)
on1


(c!:install 'bcint2op '(bcint2op dmode!* times plus) 4308300868984228201
)
bcint2op


(c!:install 'atomf '(atomf) 6612718896541201503)
atomf


(c!:install 'negsq '(negsq negf) 254780190327480257)
negsq


(c!:install 'hasonephysop '(hasonephysop physopp!*) 2192203047103297718)
hasonephysop


(c!:install 'arraychk '(arraychk array) 14768056252572375151)
arraychk


(c!:install 'fs!:angle!-order '(fs!:angle!-order sin) 
4968391117210088667)
fs!:angle!-order


(c!:install 'cali_trace '(cali_trace cali) 7527151419452896228)
cali_trace


(c!:install 'pcmult '(pcmult cprod) 1325726446480199114)
pcmult


(c!:install 'pv_renorm '(pv_renorm pv_neg gcdf!*) 2913080176010837600)
pv_renorm


(c!:install 'plus!-mod!-p '(plus!-mod!-p !*n2f ordop) 
11495117821214418486)
plus!-mod!-p


(c!:install 'split_form '(split_form split_f) 17958201723664562249)
split_form


(c!:install 'lalr_goto '(lalr_goto goto_table gethash) 
11789687400657200353)
lalr_goto


(c!:install 'toknump '(toknump !:dn!: !:int!:) 10408367941981424399)
toknump


(c!:install 'getrtype '(getrtype (scalar generic) physop sub
yetunknowntype getrtype1 eval physopp!* getrtype2) 17463766755553874190)
getrtype


(c!:install 'rmultpf '(rmultpf prepf simp!* !*q2f) 1878017964621528160)
rmultpf


(c!:install 'mtchp '(mtchp mtchp1 lispeval simp exptsq to multsq) 
15770205112570652726)
mtchp


(c!:install 'nocp '(nocp noncomp) 14841654342875670650)
nocp


(c!:install 'subs2q '(subs2q subs2f quotsq) 7705154240234812399)
subs2q


(c!:install 'qqe_nytidp '(qqe_nytidp) 1483882309597552990)
qqe_nytidp


(c!:install 'subs2!* '(subs2!* !*sub2 subs2) 8913029558719780175)
subs2!*


(c!:install 'off1 '(off1 onoff) 3726041070032633484)
off1


(c!:install 'prepsq '(prepsq prepf sqform) 7967683921450212310)
prepsq


(c!:install 'evsum '(evsum) 11202217146848191637)
evsum


(c!:install 'rd!:minusp '(rd!:minusp minusp!:) 6192968839908774165)
rd!:minusp


(c!:install 'reordop '(reordop !*ncmp reordablep ordop noncomp1) 
2895570421945065422)
reordop


(c!:install 'errorset!* '(errorset!* !*backtrace errorset) 
17780892343249883991)
errorset!*


(c!:install 'fs!:timesterm '(fs!:timesterm fs!:timestermterm fs!:plus) 
4213227144414903097)
fs!:timesterm


(c!:install '!:minus '(!:minus minus times dcombine) 
13211720288274851664)
!:minus


(c!:install 'rev '(rev) 18392574721571992098)
rev


(c!:install '!*!*s2a '(!*!*s2a) 14753551702131982369)
!*!*s2a


(c!:install 'lnc '(lnc) 9828819496956821615)
lnc


(c!:install 'stable!-sortip '(stable!-sortip) 349688021140228034)
stable!-sortip


(c!:install 'qqe_btidp '(qqe_btidp bt) 1084299208955020670)
qqe_btidp



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u03.lsp"

Reading "$reduce/cslbuild/generated-c/u04.lsp"

% u04.lsp           Machine generated Lisp

(c!:install "u04" 127950 6638866 7359898)
nil


(c!:install 'lex '(lex safe_atts char atts ch !$eof!$ space !< count
list2string get_token get_content notstring butes isvalid attributes) 
6774383505700854689)
lex


(c!:install 'ps!:get!-term '(ps!:get!-term !:ps!: ps!:order
ps!:last!-term ps!:getv) 10856925109236479609)
ps!:get!-term


(c!:install '!*q2a1 '(!*q2a1 mk!*sq prepsqxx) 927688556363511767)
!*q2a1


(c!:install 'replus1 '(replus1 plus) 3501446451937526220)
replus1


(c!:install 'peel '(peel (liedf innerprod) quotient worderp) 
1474301296103034713)
peel


(c!:install 'quotfm '(quotfm !*mcd quotf) 1152006984286044194)
quotfm


(c!:install 'idlistp '(idlistp) 14853692317672070322)
idlistp


(c!:install 'formlis '(formlis form1 reversip!*) 761340711108558520)
formlis


(c!:install 'bas_rep '(bas_rep nth) 5301928451121572698)
bas_rep


(c!:install 'pv_sort2 '(pv_sort2 pv_sort2a) 12843234465109260842)
pv_sort2


(c!:install 'ofsf_posdefp '(ofsf_posdefp !*rlpos ofsf_posdefp!-pos
sfto_tsqsumf) 3541930251710259147)
ofsf_posdefp


(c!:install 'quotf!-fail '(quotf!-fail !*rounded !*roundall poly
"UNEXPECTED DIVISION FAILURE" quotf rerror) 12538164146904265902)
quotf!-fail


(c!:install 'free!-powerp '(free!-powerp) 14743946471998162386)
free!-powerp


(c!:install 'invsq '(invsq poly "Zero divisor" !*rationalize rerror
revpr gcdchk canonsq) 5653382361166941628)
invsq


(c!:install 'kernord '(kernord kernord!-split kernord!-sort) 
15540519272858472938)
kernord


(c!:install 'negf '(negf dmode!* nreverse !:minus) 18425682831999215169)
negf


(c!:install 'mkwedge '(mkwedge) 6371839370084388030)
mkwedge


(c!:install 'scprint '(scprint !*utf8 posn!* utf8_scprint) 
12093415061379873120)
scprint


(c!:install 'qassoc '(qassoc) 11801307530585957207)
qassoc


(c!:install 'nonzero!-length '(nonzero!-length) 13279789547682091641)
nonzero!-length


(c!:install 'mo_ecart '(mo_ecart cali!=degrees cali!=basering mo_comp
mo_sum ring_ecart mo!=sprod) 3017722440507251153)
mo_ecart


(c!:install 'add_prin_char '(add_prin_char !*nat !*unicode_in_off_nat
posn!* ycoord!* pline!*) 9500969400492242253)
add_prin_char


(c!:install 'pv_sort '(pv_sort pv_sort1) 12067222525334524779)
pv_sort


(c!:install 'general!-modular!-number '(general!-modular!-number
current!-modulus) 15968753272500439570)
general!-modular!-number


(c!:install 'bfzerop!: '(bfzerop!:) 4144869744488506707)
bfzerop!:


(c!:install 'flatten!-sorted!-tree '(flatten!-sorted!-tree) 
15115184242697306585)
flatten!-sorted!-tree


(c!:install 'ordopcar '(ordopcar ordop) 15013377272736434367)
ordopcar


(c!:install 'checkargcount '(checkargcount name naryargs curfun!* hasarg
instdof) 11779892391777123742)
checkargcount


(c!:install 'treesizep1 '(treesizep1) 4179991401639837357)
treesizep1


(c!:install 'listeval '(listeval simpcount!* simplimit!*
"Simplification recursion too deep" rederr eval reval1) 
2250432181165746339)
listeval


(c!:install 'get!+col!+nr '(get!+col!+nr) 2016147149417159660)
get!+col!+nr


(c!:install 'cl_simplat '(cl_simplat !*rlidentify cl_identifyat
rl_simplat1 cl_apply2ats) 13024413398561650547)
cl_simplat


(c!:install 'fac!-merge '(fac!-merge multf) 9464410801670856120)
fac!-merge


(c!:install 'retimes '(retimes !*bool times minus retimes1) 
10466653925941673875)
retimes


(c!:install 'vevcompless!? '(vevcompless!? evcomp) 2298241748517527985)
vevcompless!?


(c!:install 'ordad '(ordad ordp) 5232203268885888725)
ordad


(c!:install 'round!:last '(round!:last !:rd!: lshift) 
11771289043284577007)
round!:last


(c!:install 'update!-pline '(update!-pline) 8413433348725287400)
update!-pline


(c!:install 'fprin2 '(fprin2 !*lower !*fortupper prin2!-upcase
prin2!-downcase) 11224564587785184818)
fprin2


(c!:install 'tensopp '(tensopp tensor isanindex) 15497026400427711128)
tensopp


(c!:install 'widestring2list '(widestring2list
"Improper byte in utf-8 string" string2list land moan!-if!-truncated
lshift error) 5728454958190311291)
widestring2list


(c!:install 'mo!=sum '(mo!=sum) 9378274341461733991)
mo!=sum


(c!:install 'lcm '(lcm gcdf quotf!-fail multf) 2991433227697465912)
lcm


(c!:install 'arzerop!: '(arzerop!:) 5710966682414274736)
arzerop!:


(c!:install 'simpexpon '(simpexpon simp!* simpexpon1) 
16107270373750224130)
simpexpon


(c!:install 'lalr_lr0_closure '(lalr_lr0_closure !. lalr_productions
union) 13122931596552059001)
lalr_lr0_closure


(c!:install 'rat_sgn '(rat_sgn rat_numrn sgn) 1641969354060249299)
rat_sgn


(c!:install 'anform '(anform !*globals locls!* glb2rf globs!* anform1) 
2819029936396861794)
anform


(c!:install 'praddf '(praddf addf) 17932848155221706316)
praddf


(c!:install 'tayexp!-plus2 '(tayexp!-plus2 !*i2rn rnplus!:) 
17543982543919753841)
tayexp!-plus2


(c!:install 'tmsf!* '(tmsf!* tmsf) 17129046060010787571)
tmsf!*


(c!:install 'cl_smrmknowl '(cl_smrmknowl) 9448754117248704526)
cl_smrmknowl


(c!:install 'isvalid '(isvalid functions!* !/ char compress!*) 
17957404616594273213)
isvalid


(c!:install 'revlis '(revlis reval) 12784786891327265868)
revlis


(c!:install 'rmsubs '(rmsubs !*sqvar!* alglist!*) 15196636406925854400)
rmsubs


(c!:install 'getroad '(getroad qassoc) 3298571974922732838)
getroad


(c!:install 'expdrmacro '(expdrmacro noexpand !*cref expand !*force
getrmacro) 18039924872036670149)
expdrmacro


(c!:install 'mo!=degcomp '(mo!=degcomp) 8626677450942799514)
mo!=degcomp


(c!:install 'dquot '(dquot) 3560671920954253512)
dquot


(c!:install 'insert_pv '(insert_pv sieve_pv pv_renorm insert_pv1) 
3928730491069730406)
insert_pv


(c!:install 'noncomp1 '(noncomp1 !*sq taylor!* mat noncomfp noncomlistp)
 16592810344229548862)
noncomp1


(c!:install 'rntimes!: '(rntimes!: mkrn) 16843820830970689749)
rntimes!:


(c!:install 'noncomdel '(noncomdel noncomp!* noncomdel1) 
9512117499868604191)
noncomdel


(c!:install 'frvarsof '(frvarsof frlis!*) 4938463613637485786)
frvarsof


(c!:install 'orderactions '(orderactions shift ordp) 9345515028130377688
)
orderactions


(c!:install 'ofsf_clnegrel '(ofsf_clnegrel ofsf_lnegrel) 
10718404464395059854)
ofsf_clnegrel


(c!:install 'quotf1 '(quotf1 !*mcd quotfd rank lt!* to negf multf addf
aconc!* rnconc ordop quotk) 8745973449872565457)
quotf1


(c!:install 'remove!-free!-vars '(remove!-free!-vars !~ !*!*noremove!*!*
frasc!* "free variable" frlis!* typerr get!-free!-form union
remove!-free!-vars!-l) 6786054341651147999)
remove!-free!-vars


(c!:install 'tayexp!-minusp '(tayexp!-minusp rnminusp!:) 
11440009276948992143)
tayexp!-minusp


(c!:install 'subs2 '(subs2 subfg!* !*sub2 powlis1!* slash !*match !*exp
subs2q exptchksq resimp subs3q subs4q) 9661079352785559604)
subs2


(c!:install 'mri_floorp '(mri_floorp floor) 15639793372292956144)
mri_floorp


(c!:install 'xxsort '(xxsort lambda_qrvi5bym67r22 sort) 
3188861117163028558)
xxsort


(c!:install 'lambda_qrvi5bym67r22 '(lambda_qrvi5bym67r22 termorder) 
16174915286514799361)
lambda_qrvi5bym67r22



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u04.lsp"

Reading "$reduce/cslbuild/generated-c/u05.lsp"

% u05.lsp           Machine generated Lisp

(c!:install "u05" 59962 9967390 5314157)
nil


(c!:install 'ibalp_cequal '(ibalp_cequal lto_setequalq) 
7258514506553550344)
ibalp_cequal


(c!:install 'vdp_poly '(vdp_poly) 1621136418650712159)
vdp_poly


(c!:install 'ev_comp '(ev_comp dip_sortevcomp!* apply) 
6308362367969480729)
ev_comp


(c!:install 'fullcopy '(fullcopy nreverse) 15320005618721388603)
fullcopy


(c!:install 'dm!-times '(dm!-times zero2nil !:times) 
10142955220570690041)
dm!-times


(c!:install 'getrtype1 '(getrtype1 !3vector) 17623002873539832421)
getrtype1


(c!:install 'vevtdeg '(vevtdeg) 390444595040601212)
vevtdeg


(c!:install 'safe!-fp!-minus '(safe!-fp!-minus !*nonegzerominus 0.0) 
5053334932847537604)
safe!-fp!-minus


(c!:install 'prin2!-downcase '(prin2!-downcase red!-char!-downcase) 
2999629200536730834)
prin2!-downcase


(c!:install 'readch1 '(readch1 peekchar!* !$eof!$ !*psl !*raise !*lower
!$eol!$ curline!* crbuf1!* crbuf!* !# !; unicode_character
named!-character!* u !U x !X hexdigit red!-char!-downcase char!-downcase
char!-upcase terminalp id2string string!-length list2string int2wideid) 
7903236607841033996)
readch1


(c!:install 'fs!:plus '(fs!:plus angles!-equal addsq fs!:angle!-order) 
13903516929866200135)
fs!:plus


(c!:install 'mo!=shorten '(mo!=shorten) 12559554740446522352)
mo!=shorten


(c!:install 'prin2!* '(prin2!* !*utf8 outputhandler!* overflowed!*
overflowed !*fort !*nat pi !.pi infinity !*rounded posn!* spare!*
testing!-width!* utf8_prin2!* fprin2!* symbol widelengthc i2rd!*
rd!:prin terpri!* add_prin_char prin2lint) 1841416926161410357)
prin2!*


(c!:install 'insert_pv1 '(insert_pv1 reduce_pv pv_renorm) 
13461779201674913131)
insert_pv1


(c!:install 'noncomp!* '(noncomp!* expt noncomp) 11520600477447941211)
noncomp!*


(c!:install 'mkgi '(mkgi !:gi!:) 5211409146390769880)
mkgi


(c!:install 'polynomclone '(polynomclone monomclone) 
16945265351910705256)
polynomclone


(c!:install 'gcdf '(gcdf !*exp !*rounded !*mcd !*ezgcd dmode!*
!*combineexpt free!-powerp gcdf1 ezgcdf minusf negf) 940727046805833939)
gcdf


(c!:install 'reordsq '(reordsq reorder) 6551028279869735544)
reordsq


(c!:install 'addsq '(addsq !*exp !*lcm !*gcd addf mkprod gcdf!* gcdf
quotf!-fail canonsq multf) 3539849522071400094)
addsq


(c!:install 'ckrn1 '(ckrn1 gck2 noncomp) 7007800398806749316)
ckrn1


(c!:install 'talp_negateat '(talp_negateat equal neq talp_op talp_arg2l
talp_arg2r talp_mk2) 6845920600026038126)
talp_negateat


(c!:install 'sort!-factors '(sort!-factors orderfactors sort) 
15458406081081601622)
sort!-factors


(c!:install 'mathml_list2string '(mathml_list2string) 
18208425034285005617)
mathml_list2string


(c!:install 'findrow '(findrow sparsemat) 7693175182874322505)
findrow


(c!:install 'groebsearchinlist '(groebsearchinlist buchvevdivides!?) 
8824115933558065593)
groebsearchinlist


(c!:install 'find_item '(find_item) 11091868128839770907)
find_item


(c!:install 'prin2la '(prin2la ncharspr!* laline!* chundexp) 
16636695083161034415)
prin2la


(c!:install 'command1 '(command1 cursym!* key!* scan setcloc!* xread1) 
15384879614138737363)
command1


(c!:install 'getel1 '(getel1 "array index" rlisp "Array out of bounds"
typerr rerror) 14149257150581464448)
getel1


(c!:install 'prepsqx '(prepsqx !*intstr prepsq!* prepsq) 
2057516612996716158)
prepsqx


(c!:install 'mo_sum '(mo_sum mo!=sum mo!=shorten mo!=deglist) 
11690513269509191580)
mo_sum


(c!:install 'resimp '(resimp varstack!* resimp1) 245030305365798647)
resimp


(c!:install 'pv_add '(pv_add) 13132997057459499096)
pv_add


(c!:install 'sgn '(sgn) 1074806718032526601)
sgn


(c!:install 'xcomment '(xcomment comment aconc) 312308063884810300)
xcomment


(c!:install 'absf '(absf minusf negf) 9890379060160977735)
absf


(c!:install 'talp_mkinv '(talp_mkinv) 9881918859696743090)
talp_mkinv


(c!:install 'rl_prepat '(rl_prepat rl_prepat!* apply) 
7678146107771699444)
rl_prepat


(c!:install 'ev_tdeg '(ev_tdeg) 2776263759101515019)
ev_tdeg


(c!:install 'listsum '(listsum) 4359773221243097064)
listsum


(c!:install 'indent!* '(indent!* indent ind) 15041536051208217428)
indent!*


(c!:install 'multi_isarb_int '(multi_isarb_int isarb_int) 
13178152468178755731)
multi_isarb_int


(c!:install 'c!:ordexp '(c!:ordexp c!:ordxp) 16045650534029472007)
c!:ordexp


(c!:install 'int!-equiv!-chk '(int!-equiv!-chk !*noequiv) 
3177926317644332068)
int!-equiv!-chk


(c!:install '!*collectphysops '(!*collectphysops
!*collectphysops_reversed) 16819877731731729102)
!*collectphysops


(c!:install 'dp_term '(dp_term) 1030431448728476156)
dp_term


(c!:install 'pv_sort1 '(pv_sort1 pv_sort2) 18324050516951395998)
pv_sort1


(c!:install 'modplus!: '(modplus!: general!-modular!-plus !*modular2f) 
10334211820605972842)
modplus!:


(c!:install 'ofsf_vareqnp '(ofsf_vareqnp sfto_varisnump) 
609914299391789314)
ofsf_vareqnp


(c!:install 'polynomadd '(polynomadd monomcompare) 2116639427254958855)
polynomadd


(c!:install 'rl_smmkatl '(rl_smmkatl rl_smmkatl!* apply) 
4189128276617618692)
rl_smmkatl


(c!:install 'setcar '(setcar) 8503541034644394161)
setcar


(c!:install 'multi_isarb_compl '(multi_isarb_compl isarb_compl) 
5408831469196759241)
multi_isarb_compl


(c!:install 'minus!: '(minus!: !:rd!:) 10147849189749433953)
minus!:


(c!:install 'depends '(depends frlis!* depl!* domain!-depends!-fn tensor
ldepends) 4176191591124326081)
depends


(c!:install 'dm!-difference '(dm!-difference zero2nil !:difference) 
15526280912238833915)
dm!-difference


(c!:install 'rd!:onep '(rd!:onep 1.0 !!fleps1 bfone!* bftrim!: equal!:) 
10840846068437734264)
rd!:onep


(c!:install 'simpminus '(simpminus minus carx simp negsq) 
5896211553045019281)
simpminus


(c!:install 'xdiv '(xdiv sublistp listdiff) 5481178236408994693)
xdiv


(c!:install 'getrmacro '(getrmacro macro inline smacro getd) 
14258017769871059051)
getrmacro


(c!:install 'mo_compare '(mo_compare cali!=basering revlex mo!=degcomp
ring_tag mo!=revlexcomp mo!=lexcomp) 1248999113790946364)
mo_compare


(c!:install 'vecp '(vecp !3vector vectorfn varithop vectormapping
isvectorindex hasonevector) 2250899134802842041)
vecp


(c!:install 'pv_applp '(pv_applp pappl0 pv_sort) 7635752925502425505)
pv_applp


(c!:install 'aronep!: '(aronep!:) 6005702156452897888)
aronep!:


(c!:install 'mod!# '(mod!# current!-modulus) 15684098227533559362)
mod!#


(c!:install 'gen!-mult!-by!-const!-mod!-p '(gen!-mult!-by!-const!-mod!-p
general!-modular!-times !*n2f) 13583715677638801333)
gen!-mult!-by!-const!-mod!-p


(c!:install 'copy!-vector '(copy!-vector) 18040727933833995838)
copy!-vector


(c!:install 'aconc '(aconc) 4286747449048000529)
aconc



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u05.lsp"

Reading "$reduce/cslbuild/generated-c/u06.lsp"

% u06.lsp           Machine generated Lisp

(c!:install "u06" 147316 9258670 4977558)
nil


(c!:install 'lalr_print_collection '(lalr_print_collection
"=== LALR ITEMSET COLLECTION ===" itemset_collection "Itemset " ordp " "
" ->" " [" "]" "/" symbols "GOTO(" ") = " sort lalr_prin_symbol
lalr_goto) 2909634294833788172)
lalr_print_collection


(c!:install 'convertmode '(convertmode form1 convertmode1) 
1419734818002222436)
convertmode


(c!:install 'subs3q '(subs3q mchfg!* subs3f quotsq) 3545428769602154647)
subs3q


(c!:install 'talp_smwcpknowl '(talp_smwcpknowl !*rlsusi cl_susicpknowl
cl_smcpknowl) 13028224229960715909)
talp_smwcpknowl


(c!:install 'qqe_qtidp '(qqe_qtidp qt) 4509446187774578496)
qqe_qtidp


(c!:install 'algid '(algid) 3742255102945651473)
algid


(c!:install 'emtch '(emtch opmtch) 9395393102454316218)
emtch


(c!:install 'pnthxzz '(pnthxzz) 4749855178029359567)
pnthxzz


(c!:install 'csl_timbf '(csl_timbf (!:rd!: 0 . 0) !:bprec!: !:rd!: inorm
) 18165318944716659070)
csl_timbf


(c!:install 'putpline '(putpline posn!* spare!* orig!* ycoord!* pline!*
ymin!* ymax!* terpri!* update!-pline min max) 9984476619971481198)
putpline


(c!:install '!:times '(!:times times dcombine) 7317178501310073043)
!:times


(c!:install 'mkrn '(mkrn !:rn!:) 8615064137746325980)
mkrn


(c!:install 'gperm1 '(gperm1 rev) 5120862869177590181)
gperm1


(c!:install 'evaluate!-in!-order '(evaluate!-in!-order !*d2n
horner!-rule) 9840903884908678569)
evaluate!-in!-order


(c!:install 'delete_from_alglist '(delete_from_alglist remhash) 
16769384104373499423)
delete_from_alglist


(c!:install 'gcdf!* '(gcdf!* !*gcd gcdf) 4435744738542786350)
gcdf!*


(c!:install 'prin2t '(prin2t) 5370635860544999099)
prin2t


(c!:install 'reval1 '(reval1 !*revalp varstack!* dmode!* subfg!* evfn
structfn !*sq !*resimp cleanupfn alg "Missing evaluation for type" list
aggregatefn matrixmap matmapfn boolean !*listargs listargp reval2
recursiveerror apply errpri2 prepsqxx rmmbreval opfneval arrayp getelv
getrtype rerror) 7659408201389900324)
reval1


(c!:install 'sfto_dcontentf1 '(sfto_dcontentf1 absf sfto_gcdf) 
10251860885825888217)
sfto_dcontentf1


(c!:install 'sqchk '(sqchk prepf) 15584170906883106856)
sqchk


(c!:install 'removev '(removev "Vertex" "is absent." cerror) 
11755252615704088808)
removev


(c!:install 'talp_simplat1 '(talp_simplat1 true false talp_simpat
talp_op talp_arg2l talp_arg2r talp_simplat2) 4143642023805816654)
talp_simplat1


(c!:install 'ibalp_varlat '(ibalp_varlat ibalp_arg2l ibalp_varlt
ibalp_arg2r union) 3082100373558802606)
ibalp_varlat


(c!:install 'quotfd '(quotfd dmode!* divd quotdd quotk) 
12457232032859727359)
quotfd


(c!:install 'mathml '(mathml lex sub_math) 2254284459118856999)
mathml


(c!:install 'sortcolelem '(sortcolelem) 2821064227035305453)
sortcolelem


(c!:install 'prepf1a_reversed '(prepf1a_reversed plus difference minus
k!* prepd exchk retimes) 3920782612352183888)
prepf1a_reversed


(c!:install 'comm_kernels '(comm_kernels comm_kernels1) 
1085729417501072384)
comm_kernels


(c!:install 'fast!-column!-dim '(fast!-column!-dim) 6536696017703085317)
fast!-column!-dim


(c!:install 'evtdeg '(evtdeg) 11402388914802951445)
evtdeg


(c!:install 'mknwedge '(mknwedge wedge) 9273441016196573903)
mknwedge


(c!:install '!:plus '(!:plus plus dcombine) 14295972896338778478)
!:plus


(c!:install 'getelv '(getelv reval_without_mod getel) 
16897334088165199342)
getelv


(c!:install 'dp!=ecart '(dp!=ecart dp_lmon mo_ecart) 1513483039109638609
)
dp!=ecart


(c!:install 'tsym4 '(tsym4 pv_applp sieve_pv pv_renorm insert_pv) 
11594712105546691380)
tsym4


(c!:install 'set_svf '(set_svf setk) 15603250658461753273)
set_svf


(c!:install 'gcddd '(gcddd gcd fieldp dcombine) 6392150503747631200)
gcddd


(c!:install 'anform1 '(anform1 dclglb glb2rf globs!* locls!* noanl anlfn
anforml add2calls checkargcount) 11765923365426148039)
anform1


(c!:install 'freeofl '(freeofl freeof) 1695728625742780640)
freeofl


(c!:install 'mri_type '(mri_type) 14400215089325008231)
mri_type


(c!:install 'pasf_dec '(pasf_dec negf addf) 13159550184310097093)
pasf_dec


(c!:install 'cgp_evlmon '(cgp_evlmon cgp_rp dip_evlmon) 
11503118130341470008)
cgp_evlmon


(c!:install 'times!-mod!-p '(times!-mod!-p
multiply!-by!-constant!-mod!-p times!-term!-mod!-p plus!-mod!-p ordop) 
11674828902396525929)
times!-mod!-p


(c!:install 'omobj '(omobj char omfuncs!* compress!* apply) 
552316010938588333)
omobj


(c!:install 'sqform '(sqform quotient) 12561050226564334981)
sqform


(c!:install 'mk!*sq '(mk!*sq list !*sq !*resubs !*sqvar!* expchk kernp) 
6963996289700059966)
mk!*sq


(c!:install 'subscriptedvarp '(subscriptedvarp subscripted symtabget) 
10047303296984028393)
subscriptedvarp


(c!:install 'exptchk '(exptchk comm_kernels exptchk0) 
7218657526841631203)
exptchk


(c!:install 'order!: '(order!: msd) 2743596083191641400)
order!:


(c!:install 'areallindices '(areallindices isanindex) 299020035761465616
)
areallindices


(c!:install '!*ssave '(!*ssave !*uncached alglist!* !*sub2
alglist_count!* alglist_limit!* 2.0 simpcount!* mkhash puthash) 
17682649696344827703)
!*ssave


(c!:install 'red!-weight '(red!-weight nonzero!-length red!-weight1) 
4249037292437646850)
red!-weight


(c!:install 'dp_diff '(dp_diff dp_neg dp_sum) 12366907914249003617)
dp_diff


(c!:install 'resimp1 '(resimp1 !*sub2 subf1 quotsq) 16917756133474648583
)
resimp1


(c!:install 'pv_sort2a '(pv_sort2a) 13353353018645474506)
pv_sort2a


(c!:install 'starts!-with '(starts!-with !\ !/) 7337007207677606629)
starts!-with


(c!:install 'sfto_davp '(sfto_davp) 17491099964523223853)
sfto_davp


(c!:install 'talp_varlt1 '(talp_varlt1 talp_getl lto_insert talp_argl
union) 17322878992346705249)
talp_varlt1


(c!:install 'mri_simplfloor '(mri_simplfloor mri_floorkernelp
mri_simplfloor1) 16657927298066891305)
mri_simplfloor


(c!:install 'qqe_prepat '(qqe_prepat) 18399950725634295861)
qqe_prepat


(c!:install 'eolcheck '(eolcheck !*eoldelimp nxtsym!* !$eol!$ cursym!*
end !; token) 279026188828444361)
eolcheck


(c!:install 'mcharg1 '(mcharg1 matchlength!* mchcomb mkbin mchsarg mtp
pair mcharg2) 7180069116472231263)
mcharg1


(c!:install 'boundindp '(boundindp) 7981918625673461700)
boundindp


(c!:install 'chundexp '(chundexp !_ !\) 8745084979690390780)
chundexp


(c!:install 'red!-char!-downcase '(red!-char!-downcase charassoc!*) 
11739339504623139397)
red!-char!-downcase


(c!:install 'physopp!* '(physopp!* physopfn physoparith physopmapping
physopp hasonephysop) 4688643543797558505)
physopp!*


(c!:install 'macrochk '(macrochk symbolic macrofn expdrmacro) 
6624621222934061550)
macrochk


(c!:install 'getel '(getel dimension rlisp "Incorrect array reference"
rerror getel1) 10029705835642610942)
getel


(c!:install 'mo!=lexcomp '(mo!=lexcomp (0)) 12857211769790526072)
mo!=lexcomp


(c!:install 'gperm '(gperm gperm0 pkp) 6978857666060417365)
gperm


(c!:install 'copy '(copy nreverse) 11644407946646413746)
copy


(c!:install '!*modular2f '(!*modular2f !*balanced_mod current!-modulus
!:mod!:) 17480095946135970011)
!*modular2f


(c!:install 'general!-modular!-quotient '(general!-modular!-quotient
general!-modular!-reciprocal general!-modular!-times) 
10028416593412426364)
general!-modular!-quotient


(c!:install 'minus!-mod!-p '(minus!-mod!-p nreverse) 
13865097314770874216)
minus!-mod!-p



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u06.lsp"

Reading "$reduce/cslbuild/generated-c/u07.lsp"

% u07.lsp           Machine generated Lisp

(c!:install "u07" 19092 3978830 9998442)
nil


(c!:install 'clear!-column '(clear!-column null!-space!-basis) 
2174171855257234860)
clear!-column


(c!:install 'lalr_add_goto '(lalr_add_goto goto_table gethash puthash) 
17729286800343653061)
lalr_add_goto


(c!:install 'wulessp '(wulessp wuconstantp symbollessp) 
799452387677490987)
wulessp


(c!:install 'talp_smwupdknowl '(talp_smwupdknowl !*rlsusi cl_smupdknowl
talp_smupdknowl) 11365454144261299625)
talp_smwupdknowl


(c!:install 'mri_0mk2 '(mri_0mk2) 16051666004088395260)
mri_0mk2


(c!:install 'rl_simpat '(rl_simpat rl_simpat!* apply) 
14907637319273239108)
rl_simpat


(c!:install 'ibalp_varlt1 '(ibalp_varlt1 lto_insertq ibalp_argn) 
15073405374690958584)
ibalp_varlt1


(c!:install 'ev_invlexcomp '(ev_invlexcomp iequal) 301871774651962531)
ev_invlexcomp


(c!:install 'powers2 '(powers2 powers4) 18389454131571423670)
powers2


(c!:install 'find '(find != !" !$ (stop) !/ (d e f i n i t i o n u r l)
!  find2 delall compress!*) 16338933635983901873)
find


(c!:install 'simp!* '(simp!* !*asymp!* !*sq !*resimp mul!* !*sub2
!*nospurp (isimpq) !*combinelogs dmode!* !:gi!: !*norationalgi
!*rationalize simp union subs2 clogsq!* girationalize!: rationalizesq
rationalizei gcdchk) 14819034963591409791)
simp!*


(c!:install 'downwght '(downwght delhisto downwght1 inshisto) 
16079583727061489875)
downwght


(c!:install 'freexp '(freexp pm!:free) 2227958442769940130)
freexp


(c!:install 'termordp '(termordp wedgefax monordp) 217193576870404836)
termordp


(c!:install 'gizerop!: '(gizerop!:) 15668976833653917251)
gizerop!:


(c!:install 'repeatsp '(repeatsp) 8005844584162456289)
repeatsp


(c!:install 'bc!=simp '(bc!=simp cali
"recursion depth of bc!=simp too high" qremf multf addf rederr) 
15256469392559574114)
bc!=simp


(c!:install 'gperm2 '(gperm2 rev gperm1) 18064284019234804902)
gperm2


(c!:install 'exptmod!: '(exptmod!: general!-modular!-expt !*modular2f) 
15369828140386100024)
exptmod!:


(c!:install 'convprec!* '(convprec!* !:rd!: convchk) 1859208267860746683
)
convprec!*


(c!:install 'rat_numrn '(rat_numrn) 10709366573743677142)
rat_numrn


(c!:install 'freeof '(freeof depl!* smember) 3637959333020234962)
freeof


(c!:install 'gcdf1 '(gcdf1 !*anygcd !*gcd dmode!* (!:rd!: !:cr!:)
"gcdf failed" gcdfd num!-exponents quotf1 gcdf2 noncomfp prepf errach) 
418753600749232228)
gcdf1


(c!:install 'talp_smupdknowl '(talp_smupdknowl false break
talp_smupdknowl1) 2521773602485433729)
talp_smupdknowl


(c!:install 'qqe_id!-nyt!-branchb '(qqe_id!-nyt!-branchb qqe_btidp
qqe_nytidp qqe_qopaddp qqe_qoptailp) 13310094407739766078)
qqe_id!-nyt!-branchb


(c!:install 'pasf_deci '(pasf_deci pasf_dec) 7606875779504539690)
pasf_deci


(c!:install 'ibalp_litlp '(ibalp_litlp ibalp_litp) 8695577270835652998)
ibalp_litlp


(c!:install 'mintype '(mintype) 7023828771997735570)
mintype


(c!:install 'prepd '(prepd minus prepfn !:minus prepd1) 
16549409407206613223)
prepd


(c!:install 'quotematrix '(quotematrix matrix) 9634185097357256809)
quotematrix


(c!:install 'deg!*farg '(deg!*farg deg!*form addf) 11582492540121933055)
deg!*farg


(c!:install 'make!-set '(make!-set set!-ordp sort makelist) 
17863511358970148213)
make!-set


(c!:install 'optype '(optype !*optype!*) 3778890871487542886)
optype


(c!:install 'setcloc!* '(setcloc!* ifl!* curline!* cloc!*) 
3259902650283198162)
setcloc!*


(c!:install 'red_divtestbe '(red_divtestbe bas_dpecart bas_dpoly dp_lmon
mo_vdivides!?) 8745092154154609337)
red_divtestbe


(c!:install 'pappl_pv '(pappl_pv pappl0 pv_sort) 12865351114010935612)
pappl_pv


(c!:install '!*i2ar '(!*i2ar !:ar!:) 10560348635455940300)
!*i2ar


(c!:install 'general!-modular!-minus '(general!-modular!-minus
current!-modulus) 7446043339403337171)
general!-modular!-minus


(c!:install 'lalr_analyze_lookaheads '(lalr_analyze_lookaheads
itemset_collection (-1) !. lalr_closure lalr_goto lalr_lr0_move_dot
lalr_item_with_rule lalr_add_lookahead) 2902620670388623196)
lalr_analyze_lookaheads


(c!:install 'powers1 '(powers1 powers3 powers2) 7558645644074747293)
powers1


(c!:install 'cl_atfp '(cl_atfp true false or and not impl repl equiv ex
all bex ball) 16317418177497158700)
cl_atfp


(c!:install 'quotk '(quotk quotf1) 7655743017610255852)
quotk


(c!:install 'multi_elem '(multi_elem expression) 15754855898525001441)
multi_elem


(c!:install 'letmtr3 '(letmtr3 sparsemat matrix "Matrix" "not set" hold
cx rerror revlis numlis errpri2 sortcolelem) 14473509980124684464)
letmtr3


(c!:install 'nextarg '(nextarg symm s!-nextarg o!-nextarg) 
16482704159804204717)
nextarg


(c!:install 'diplength '(diplength) 14871242854063033043)
diplength


(c!:install 'divide!: '(divide!: !:rd!: msd conv!:mt round!:mt) 
822680077161613832)
divide!:


(c!:install 'list2widestring '(list2widestring ""
"Invalid item in arg to list2widestring"
"Negative integer in list2widestring"
"Integer too large in list2widestring" widestring2list rederr error
allocate!-string string!-store lshift land string!-store2 string!-store3
string!-store4) 4879502497584558050)
list2widestring


(c!:install 'groeb!=testa '(groeb!=testa nth mo_divides!?) 
4982525962249251425)
groeb!=testa


(c!:install 'dv_skelhead '(dv_skelhead dv_cambhead) 17417041200199632033
)
dv_skelhead


(c!:install 'rnplus!: '(rnplus!: mkrn) 1535836573879756582)
rnplus!:


(c!:install 'lalr_remove_duplicates '(lalr_remove_duplicates) 
13596569393979284913)
lalr_remove_duplicates


(c!:install 'sfto_gcdf '(sfto_gcdf !*rldavgcd !*ezgcd gcdf sfto_davp
ezgcdf) 16666557222424495593)
sfto_gcdf


(c!:install 'totallessp '(totallessp less totalcompare) 
2780895902761703900)
totallessp


(c!:install 'talp_tcfrp '(talp_tcfrp talp_invp) 1030780893080362627)
talp_tcfrp


(c!:install 'pasf_susitf '(pasf_susitf) 13004730534395993431)
pasf_susitf


(c!:install 'times!-term!-mod!-p '(times!-term!-mod!-p
multiply!-by!-constant!-mod!-p mksp times!-mod!-p ordop) 
12134610716879626746)
times!-term!-mod!-p


(c!:install 'omobjs '(omobjs char (!/ o m a) omobj lex) 
13807968452401441856)
omobjs


(c!:install 'bound '(bound unbound binding) 13956817632156004274)
bound


(c!:install 'freeindexchk '(freeindexchk indxl!*
form!-with!-free!-indices indxchk) 11921768991783730918)
freeindexchk


(c!:install 'worderp '(worderp kord!* indexvarordp ordop peel) 
6886687244145475157)
worderp


(c!:install 'vecopp '(vecopp vector isanindex) 3613955425733007325)
vecopp


(c!:install 'sroad '(sroad nreverse) 3816325071880864422)
sroad


(c!:install 'simpplus '(simpplus ckpreci!# simpcar addsq) 
13307383627601434855)
simpplus


(c!:install 'mv!-pow!-mv!-term!-!+ '(mv!-pow!-mv!-term!-!+ mv!-pow!-!+) 
10270817876720591082)
mv!-pow!-mv!-term!-!+


(c!:install 'dp_ecart '(dp_ecart dp!=ecart dp_lmon mo_ecart) 
6091531937966727815)
dp_ecart


(c!:install 'adddummy1a '(adddummy1a pappl_pv insert_pv) 
17246486385526803890)
adddummy1a



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u07.lsp"

Reading "$reduce/cslbuild/generated-c/u08.lsp"

% u08.lsp           Machine generated Lisp

(c!:install "u08" 11333 5477096 8454293)
nil


(c!:install 'general!-plus!-mod!-p '(general!-plus!-mod!-p nreverse
general!-modular!-plus !*n2f ordop) 15694382996916044951)
general!-plus!-mod!-p


(c!:install 'get_first_kernel '(get_first_kernel gfk) 
15648336848191114505)
get_first_kernel


(c!:install 'lalr_precedence '(lalr_precedence precedence_table) 
5285271617135623330)
lalr_precedence


(c!:install 'diff '(diff multf diffp1 addf) 2605274499258555896)
diff


(c!:install 'talp_varlat '(talp_varlat talp_arg2l talp_varlt talp_arg2r
union) 16180238194531187409)
talp_varlat


(c!:install 'rl_gettype '(rl_gettype) 1792825115883707683)
rl_gettype


(c!:install 'quotfail!-mod!-p '(quotfail!-mod!-p exact!-quotient!-flag
"Quotient not exact (mod p)" quotient!-mod!-p errorf) 
1317977702197480167)
quotfail!-mod!-p


(c!:install 'retattributes '(retattributes find) 17993207373981413162)
retattributes


(c!:install 'round!:mt '(round!:mt !:rd!: msd round!:last ashift
bflerrmsg) 5455266803712742649)
round!:mt


(c!:install 'eofcheck '(eofcheck program!* !$eof!$ ttype!* eof!*) 
12693317518809967104)
eofcheck


(c!:install 'divd '(divd poly "0/0 formed" "Zero divisor" rerror
nreverse divdm) 14596174159620176409)
divd


(c!:install 'dp_times_bc '(dp_times_bc cali_bc_prod) 7292056026877438446
)
dp_times_bc


(c!:install 'pdmult '(pdmult pair) 1769095089218186773)
pdmult


(c!:install 'mcharg2 '(mcharg2 mchk updtemplate msappend lastpair) 
8310717807567935274)
mcharg2


(c!:install 'cancel '(cancel !*mcd multsq mk!*sq simpexpt) 
2615146117212680732)
cancel


(c!:install 'canonsq '(canonsq asymplis!* difference dmode!* unitsfn
gcdf quotf!-fail lnc negf fieldconv) 1341355762807092992)
canonsq


(c!:install 'rassoc '(rassoc) 4874041693837250365)
rassoc


(c!:install 'anforml '(anforml !*globals locls!* glb2rf globs!* anform) 
14423759540013469578)
anforml


(c!:install 'cdarx '(cdarx cdar carx) 3213420843911737010)
cdarx


(c!:install 'talp_atfp '(talp_atfp (neq equal) talp_op) 
11744740902497746626)
talp_atfp


(c!:install 'ibalp_simpat '(ibalp_simpat ibalp_simpterm ibalp_mk2) 
12585734351966318121)
ibalp_simpat


(c!:install 'checktag '(checktag char "Problem" "problem" errorml) 
11657895875962433019)
checktag


(c!:install 'subs2f1 '(subs2f1 powlis!* expt quotient alglist!* dmode!*
powlis1!* !*structure !*exp times !*d2q degr subs2p simp exptsq cancel
raddsq multsq mtchp addsq mkprod mksq simpexpt) 127942258716955345)
subs2f1


(c!:install 'bcsum '(bcsum !*grmod!* plus2 bcfi bcint2op addsq bccheckz)
 8246123458018695289)
bcsum


(c!:install 'vevmaptozero1 '(vevmaptozero1) 5413646659924096645)
vevmaptozero1


(c!:install 'deg!*form '(deg!*form wedge d hodge dimex!* partdf liedf
innerprod (plus minus difference quotient) times !*sq deg!*farg addd
negf addf simp!* prepsq) 5903215969894583510)
deg!*form


(c!:install 'physopsim!* '(physopsim!* !:dn!: simp prepsq !*physopp!*
physopsm!*) 9272985490652343806)
physopsim!*


(c!:install 'rread '(rread " '" prin2x rread1) 11718658437400776781)
rread


(c!:install 'reval2 '(reval2 !*combineexpt dmode!* !*mcd simp!* !*q2a1) 
14942434520619058194)
reval2


(c!:install 'red!-weight1 '(red!-weight1) 18193212404213536799)
red!-weight1


(c!:install 'bas_make1 '(bas_make1 dp_ecart) 8684791487173625242)
bas_make1


(c!:install 'hevenp '(hevenp) 18344645686636477175)
hevenp


(c!:install 'yyreadch '(yyreadch lex_peek_char lex_char !$eol!$
which_line !$eof!$ last64p last64) 9000167786505618202)
yyreadch


(c!:install 'talp_candp '(talp_candp true talp_arg2l talp_arg2r
talp_invp talp_invarg) 14705223956677754842)
talp_candp


(c!:install 'ibalp_litp '(ibalp_litp not ibalp_atomp) 
14968165359185496103)
ibalp_litp


(c!:install 'rationalizei '(rationalizei i kord!* (i . 1) reordsq to
negf multf addf) 14087879749653327036)
rationalizei


(c!:install 'genp '(genp gen mgenp) 15549188022134307524)
genp


(c!:install 'xdegreemon '(xdegreemon xdegreelist!* mknwedge xdegree) 
11940686756163340154)
xdegreemon


(c!:install 'evaluate0 '(evaluate0 evaluate!-horner evaluate1) 
13985323310385376309)
evaluate0


(c!:install 'domain!*p '(domain!*p domainlist!*) 2444284547095513599)
domain!*p


(c!:install 'rnquotient!: '(rnquotient!: mkrn) 12337815946570309451)
rnquotient!:


(c!:install 'gintequiv!: '(gintequiv!:) 170157521522791609)
gintequiv!:


(c!:install 'procstat '(procstat procstat1) 2761016754500269744)
procstat


(c!:install '!*sqprint '(!*sqprint sqprint) 14862046607707741929)
!*sqprint


(c!:install 'mcharg '(mcharg minus slash reform!-minus mcharg1
reform!-minus2 lastpair) 4756747130301868943)
mcharg


(c!:install 'tayexp!-min2 '(tayexp!-min2 tayexp!-lessp) 
450066141476525100)
tayexp!-min2


(c!:install 'talp_smupdknowl1 '(talp_smupdknowl1 or false rl_negateat
talp_chkknowl) 18164921448930879520)
talp_smupdknowl1


(c!:install 'ibalp_atomp '(ibalp_atomp true false equal ibalp_arg2l
ibalp_arg2r) 17773256308332994895)
ibalp_atomp


(c!:install 'isarb_int '(isarb_int arbint found_int multi_isarb_int) 
8903692645515055984)
isarb_int


(c!:install 'retimes1 '(retimes1 !*bool minus times nreverse) 
17736752905380124428)
retimes1


(c!:install 'vdpsave '(vdpsave) 15921798368784988889)
vdpsave


(c!:install 'gsetsugar '(gsetsugar !*gsugar sugar vdptdeg vdpputprop) 
5956100697013325100)
gsetsugar


(c!:install 'add2inputbuf '(add2inputbuf !*nosave!* statcounter
inputbuflis!* terminalp) 3273988650128620738)
add2inputbuf


(c!:install 'simpdiff '(simpdiff ckpreci!# simpcar simpminus addsq) 
8946894650303966450)
simpdiff


(c!:install 'mv!-pow!-minusp '(mv!-pow!-minusp) 6164394581063889849)
mv!-pow!-minusp


(c!:install 'mo!=deglist '(mo!=deglist cali!=basering cali!=degrees
ring_degrees mo!=sprod mo!=sum) 15139313571954972261)
mo!=deglist


(c!:install 'psum '(psum dless csum c_zero) 15539650795427356691)
psum


(c!:install 'pv_neg '(pv_neg) 14910564455100054419)
pv_neg


(c!:install 'klistt '(klistt list nreverse carx) 4034108837235650161)
klistt



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u08.lsp"

Reading "$reduce/cslbuild/generated-c/u09.lsp"

% u09.lsp           Machine generated Lisp

(c!:install "u09" 17393 87383 7123850)
nil


(c!:install 'quotdd '(quotdd quotient dcombine) 15747830918764825106)
quotdd


(c!:install 'xread '(xread !*eoldelimp cursym!* !*semicol!* scan xread1)
 11023064693632726099)
xread


(c!:install 'prepsq!*2 '(prepsq!*2 prepsq!*1 replus) 
18407660482813847948)
prepsq!*2


(c!:install 'talp_invf '(talp_invf talp_op) 9779812008113020496)
talp_invf


(c!:install 'bc_prod '(bc_prod multsq) 1177742759903326742)
bc_prod


(c!:install 'redmsg '(redmsg !*wsm !*msg ("operator" "predicate")
"Declare" "?" "declared" terminalp get!-print!-name yesp lprim) 
6641158512662921381)
redmsg


(c!:install 'multiom '(multiom objectom) 15929192743078869346)
multiom


(c!:install 'isarb_compl '(isarb_compl arbcomplex found_compl
multi_isarb_compl) 15012797369163340989)
isarb_compl


(c!:install 'rdprep1 '(rdprep1 !:bprec!: round!:mt) 18216582633526192308
)
rdprep1


(c!:install 'variables '(variables dipvars!* setcar) 
10343379667208443626)
variables


(c!:install 'layout!-formula '(layout!-formula ycoord!* ymin!* ymax!*
posn!* pline!* testing!-width!* overflowed!* orig!* inbrackets "(" ")"
prin2!* oprin maprint) 12015381067414281630)
layout!-formula


(c!:install 'noncomp2f '(noncomp2f) 14081071292129621302)
noncomp2f


(c!:install 'contrsp2 '(contrsp2) 14356978763788615465)
contrsp2


(c!:install 'token1 '(token1 crchar!* !$eof!$ !$eol!$ !*eoldelimp
tokprop !% !*savecomments!* !! !*micro!-version !*defn !" !\ ttype!* ! 
nxtsym!* !- !*minusliter minus !*raise !*lower escaped!* !_ !:
!*line!-marker curline!* !*file!-marker ifl!* "Terminal" (!\ e n d !{ r
e d u c e !}) peekchar!* (!\ b e g i n !{ r e d u c e !})
"Name with double colon in detected:" named!-character!*
"***** End-of-file in string" id2string string!-length readch1
token!-number lispapply filenderr delcp wideid2list reversip!*
list2wideid string2list lprim lpriw list2widestring) 4739059618500721391
)
token1


(c!:install 'ckpreci!# '(ckpreci!# !*complex timesip ckprec2!#) 
13289633892301930237)
ckpreci!#


(c!:install 'mo_diff '(mo_diff mo_neg mo_sum) 4737960852278499905)
mo_diff


(c!:install 'pneg '(pneg cneg) 3398941309386812445)
pneg


(c!:install 'th_match0 '(th_match0) 2982220586190952863)
th_match0


(c!:install 'general!-times!-term!-mod!-p '(general!-times!-term!-mod!-p
gen!-mult!-by!-const!-mod!-p general!-times!-mod!-p mksp ordop) 
14419219641158729975)
general!-times!-term!-mod!-p


(c!:install 'abs!: '(abs!: !:rd!:) 7892898378426028628)
abs!:


(c!:install 'gionep!: '(gionep!:) 11176582685932153680)
gionep!:


(c!:install 'cde_position2 '(cde_position2) 14901444118537836697)
cde_position2


(c!:install 'valid_as_variable '(valid_as_variable invalid_as_variable) 
6252451321075174222)
valid_as_variable


(c!:install 'talp_simplat2 '(talp_simplat2 talp_invp talp_simplatrinv
talp_simplatat talp_simplatlinv talp_simplatfn) 3139232003655203481)
talp_simplat2


(c!:install 'cl_varl2 '(cl_varl2 true false or and not impl repl equiv
ex all bex ball lto_insertq rl_varlat) 10566558371690964264)
cl_varl2


(c!:install 'ev_revgradlexcomp '(ev_revgradlexcomp iequal ev_tdeg
ev_invlexcomp) 8235021195797815324)
ev_revgradlexcomp


(c!:install 'equal!: '(equal!: normbf) 11244774644015991854)
equal!:


(c!:install 'difff '(difff domain!-diff!-fn s s_changes_parity
t_changes_parity fermionicp negf multsq diffdp diffp addsq) 
14512842943860019511)
difff


(c!:install 'symtabget '(symtabget name !*symboltable!* (!*type!*
!*params!* !*decs!*)) 5525571283205113483)
symtabget


(c!:install 'getphystype '(getphystype scalar vector tensor state
phystypefn "PHYSOP type conflict in" physopp scalopp vecopp tensopp
po!:statep collectphystype rederr2) 838306680328065380)
getphystype


(c!:install 'lispapply '(lispapply rlisp "Apply called with non-id arg"
rerror apply) 4669262363814808279)
lispapply


(c!:install 'mv!-pow!-!+ '(mv!-pow!-!+ nreverse) 10908168933389479128)
mv!-pow!-!+


(c!:install 'kernp '(kernp) 9280616224236729168)
kernp


(c!:install 'conv!:bf2i '(conv!:bf2i ashift) 6030167484524119975)
conv!:bf2i


(c!:install 'qcputx '(qcputx quote cref compile) 7237109528981265370)
qcputx


(c!:install 'rmplus '(rmplus plus) 17073056096781679049)
rmplus


(c!:install 'comfac '(comfac dmode!* lnc !:recip multd degr noncomp gcdf
) 5277967335908146726)
comfac


(c!:install 'talp_ordatp '(talp_ordatp true talp_simpat talp_arg2l
talp_tordp talp_arg2r) 16605772488172605382)
talp_ordatp


(c!:install 'searchpl '(searchpl searchtm setunion) 12905123180357682487
)
searchpl


(c!:install 'intexprnp '(intexprnp !*revalp integer intfn intexprlisp) 
14587433259339952408)
intexprnp


(c!:install 'lpriw '(lpriw ofl!* !*fort !*nat !*defn lpri) 
5536387859388148444)
lpriw


(c!:install 'testred '(testred codmat maxvar downwght1) 
4753241407180497846)
testred


(c!:install 'off_mod_reval '(off_mod_reval !*modular modular off reval
on) 12140980420647729975)
off_mod_reval


(c!:install 'simpindexvar '(simpindexvar partitindexvar !*pf2sq) 
17822470104714462053)
simpindexvar


(c!:install 'dim!<deg '(dim!<deg dimex!* deg!*farg negf addf) 
7251850768166510267)
dim!<deg


(c!:install 'opnum!* '(opnum!* opnum collectindices removeindices) 
4437767772325788303)
opnum!*


(c!:install 'mapcons '(mapcons) 18184870184519584626)
mapcons


(c!:install '!*i2gi '(!*i2gi !:gi!:) 1223087745230862844)
!*i2gi



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u09.lsp"

Reading "$reduce/cslbuild/generated-c/u10.lsp"

% u10.lsp           Machine generated Lisp

(c!:install "u10" 87015 5957201 2180113)
nil


(c!:install 'ptoken '(ptoken !) outl!* !  !( token prin2x) 
8915379530439987008)
ptoken


(c!:install 'formc '(formc !*rlisp88 modefn symbolic
"algebraic expression" "Rlisp88 form" algebraic typerr intexprnp
convertmode) 7997369177657568609)
formc


(c!:install 'wuorderp '(wuorderp wukord!* yes no) 8906965046080400780)
wuorderp


(c!:install 'freevarinexptchk '(freevarinexptchk) 4178118939591073996)
freevarinexptchk


(c!:install 'talp_smwmkatl '(talp_smwmkatl !*rlsusi cl_susimkatl
cl_smmkatl) 4396288828514490291)
talp_smwmkatl


(c!:install 'chknewnam '(chknewnam) 14053735864040956746)
chknewnam


(c!:install 'smtp '(smtp sparsemat spm matrix "Matrix" "not set"
mkempspmat rerror findrow letmtr3) 17327195793579896949)
smtp


(c!:install 'take!-realpart '(take!-realpart repartf multsq) 
9070378222395813219)
take!-realpart


(c!:install 'assert_analyze '(assert_analyze assertstatistics!*
lambda_46uwl1lq71ua2 (function !#calls !#bad! calls
!#assertion! violations) sum " " "-" sort prin2t) 4783383686943766855)
assert_analyze


(c!:install 'lambda_46uwl1lq71ua2 '(lambda_46uwl1lq71ua2 ordp) 
1813469934075966741)
lambda_46uwl1lq71ua2


(c!:install 'dp_sum '(dp_sum dp_lmon mo_compare dp_lc cali_bc_sum
cali_bc_zero!? dp_term) 13531247209958170102)
dp_sum


(c!:install '!*q2f '(!*q2f polynomial prepsq typerr) 8910299028062321553
)
!*q2f


(c!:install 'exptf1 '(exptf1 multf) 10681007596565985967)
exptf1


(c!:install 'portable_print '(portable_print portable_prin) 
231109164927082807)
portable_print


(c!:install 'polynommultiplybymonom '(polynommultiplybymonom
polynomclone polynommultiplybyvariable) 7544476021699951062)
polynommultiplybymonom


(c!:install 'wulessp!* '(wulessp!* wulessp totallessp) 
17553717216871474355)
wulessp!*


(c!:install 'matrix!+p '(matrix!+p) 14190898046507498077)
matrix!+p


(c!:install 'cl_fvarl1 '(cl_fvarl1 cl_varl1) 8522948151680983405)
cl_fvarl1


(c!:install 'lastnondomain '(lastnondomain "non-domain" errach) 
6067694052669692)
lastnondomain


(c!:install 'numeric!-content '(numeric!-content absf gcddd) 
2164575511070702558)
numeric!-content


(c!:install 'objectom '(objectom ir2mml!* apply fnom basicom) 
12657950036901911207)
objectom


(c!:install 'initbrsea '(initbrsea rowmin rowmax codmat maxvar codhisto
headhisto initwght redcodmat inshisto) 11730998601544262957)
initbrsea


(c!:install '!:difference '(!:difference difference !:minus dcombine) 
5542252668030939367)
!:difference


(c!:install 'statep!* '(statep!* state getphystype) 5416643641890959130)
statep!*


(c!:install 'take!-impart '(take!-impart impartf multsq) 
7102534019139876260)
take!-impart


(c!:install 'errorset2 '(errorset2 !*protfg errorset) 
10046103611928419598)
errorset2


(c!:install 'maprint '(maprint p!*!* physoppri minus "(" ")" failed
orig!* posn!* obrkp!* !*comma!* physopp vec!-maprin prin2!* inprint) 
15396926397083613611)
maprint


(c!:install 'dl_get '(dl_get dl_get2) 6068215078811186188)
dl_get


(c!:install 'lalr_list_of_actions '(lalr_list_of_actions !. shift !S!'
reduce (accept) lalr_goto lalr_reduction_index lalr_remove_duplicates) 
5040498890216049320)
lalr_list_of_actions


(c!:install 'aex_simpleratp '(aex_simpleratp aex_ex) 
12227076808602370977)
aex_simpleratp


(c!:install 'polynomlistfinddivisor '(polynomlistfinddivisor
monomisdivisibleby monomispommaretdivisibleby) 12254397565235369759)
polynomlistfinddivisor


(c!:install 'diffp1 '(diffp1 to multd) 14863547682706988853)
diffp1


(c!:install 'removeg '(removeg "Free edge" "in vertex" qg g3
"Invalid type of vertex" finde cerror removeg1 removeg2) 
16725121117381506512)
removeg


(c!:install 'poly!-abs '(poly!-abs poly!-minusp negf) 
10232561214688345619)
poly!-abs


(c!:install 'freeofdepl '(freeofdepl smember) 4679369376547301521)
freeofdepl


(c!:install 'talp_acfrp '(talp_acfrp talp_arg2l talp_tcfrp talp_arg2r) 
6494946179951514378)
talp_acfrp


(c!:install 'searchtm '(searchtm searchpl) 15031410852730542525)
searchtm


(c!:install 'rl_simpbop '(rl_simpbop rl_simp1) 186782563312927961)
rl_simpbop


(c!:install 'vdp_zero!? '(vdp_zero!? vdp_poly) 3453044351461631223)
vdp_zero!?


(c!:install 'spmultm2 '(spmultm2 mkempspmat empty findrow simp multsq
addsq mk!*sq letmtr3) 15010669306500582066)
spmultm2


(c!:install 'on '(on on1) 16078868938563539050)
on


(c!:install 'covposp '(covposp) 884478413950111432)
covposp


(c!:install 'contrsp '(contrsp contrsp2) 2156789623939615128)
contrsp


(c!:install 'cali_bc_fi '(cali_bc_fi) 9127641074191274606)
cali_bc_fi


(c!:install 'oprin '(oprin " " !*fort !*list obrkp!* (plus minus)
testing!-width!* overflowed!* prin2!* terpri!*) 11168596242216730671)
oprin


(c!:install 'split_ext '(split_ext ext split_form cancel) 
13164207896762615599)
split_ext


(c!:install 'aex_simplenullp '(aex_simplenullp aex_ex) 
2580805947154704858)
aex_simplenullp


(c!:install 'ofsf_ordatp '(ofsf_ordatp ordp ofsf_ordrelp) 
18168501514376577914)
ofsf_ordatp


(c!:install 'janettreefind '(janettreefind fluidbibasisjanettreerootnode
monomgetvariabledegree) 5486742964862227594)
janettreefind


(c!:install 'talp_simplt1 '(talp_simplt1 talp_invp talp_invarg talp_getl
stack_top talp_mkinv stack_pop talp_op stack_push talp_invf talp_fargl
talp_invn nth talp_fop) 15600087823852371460)
talp_simplt1


(c!:install 'mri_2pasfat '(mri_2pasfat mri_op mri_arg2l) 
10558619212887814312)
mri_2pasfat


(c!:install 'qqe_number!-of!-tails!-in!-qterm '(
qqe_number!-of!-tails!-in!-qterm (ladd radd) qqe_op qqe_arg2r qqe_arg2l)
 10999794327935236573)
qqe_number!-of!-tails!-in!-qterm


(c!:install 'ibalp_simpatom '(ibalp_simpatom used!* "nil" "Boolean term"
"number" "string" rl_gettype reval ibalp_simpterm typerr) 
16992201105121814522)
ibalp_simpatom


(c!:install 'dip_moncomp '(dip_moncomp) 1856663348448561505)
dip_moncomp


(c!:install 'omair '(omair matrix (!/ o m a) lex omobj omobjs checktag) 
17078550959365752745)
omair


(c!:install 'off '(off off1) 11885465020214804935)
off


(c!:install 'xord_lex '(xord_lex factorordp) 11579299816355622930)
xord_lex


(c!:install 'has_parents '(has_parents !?) 1621164923762247183)
has_parents



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u10.lsp"

Reading "$reduce/cslbuild/generated-c/u11.lsp"

% u11.lsp           Machine generated Lisp

(c!:install "u11" 49994 7990876 9021729)
nil


(c!:install 'form1 '(form1 ed idfn "operator" comment noform symbolic
getel vector vecfn formfn rlis !*comma!* type rlisp
"Syntax error: , invalid after" quote !*micro!-version !*defn
!*composites current!-modulus algebraic list set!-global!-mode form2
typerr lastpair arrayp intargfn getvect convertmode macrochk formrlis
blocktyperr rerror argnochk formlis intexprnp algid) 6680787676292511794
)
form1


(c!:install 'ord '(ord ordering lex plus eval) 6669722106281443466)
ord


(c!:install '!*id2num '(!*id2num pair_id_num!*) 14219724972386172061)
!*id2num


(c!:install 'sc_kern '(sc_kern g_sc_ve) 18384385763232841337)
sc_kern


(c!:install 'list_assoc '(list_assoc) 14494301727655934033)
list_assoc


(c!:install 'get_action_without_lookahead '(get_action_without_lookahead
parser_action_table) 12900232614062859550)
get_action_without_lookahead


(c!:install 'revv0 '(revv0) 9181593057275922086)
revv0


(c!:install 'rl_external '(rl_external) 12707140363234579363)
rl_external


(c!:install 'quotfx '(quotfx !*exp !*mcd quotf quotfx1) 
13124979871990313218)
quotfx


(c!:install 'ibalp_clauselp '(ibalp_clauselp ibalp_clausep) 
4432524955812383249)
ibalp_clauselp


(c!:install 'expression '(expression ir2mml!* !*sq constsml apply prepsq
operator_fn) 2391987690299582439)
expression


(c!:install 'ident '(ident op identity) 18106207035159510332)
ident


(c!:install 'vdpgetprop '(vdpgetprop vdp dipoly
"vdpgetprop given a non-vdp as 1st parameter" rerror) 
4835172904987027563)
vdpgetprop


(c!:install 'xdegree '(xdegree deg!*form) 18238910096532210186)
xdegree


(c!:install 'sfpx '(sfpx sfpx1) 13178870049014996340)
sfpx


(c!:install 'mv!-domainlist!-!- '(mv!-domainlist!-!- nreverse) 
13370949475782114239)
mv!-domainlist!-!-


(c!:install 'exptf '(exptf "exptf" !*exp errach !:expt kernlp exptf1
mksfpf) 6799958631473734497)
exptf


(c!:install 'lalr_generate_lr0_collection '(lalr_generate_lr0_collection
itemset_collection symbols lalr_lr0_initial_itemset
lalr_compute_lr0_goto lalr_add_goto) 14701506318557506624)
lalr_generate_lr0_collection


(c!:install 'convertmode1 '(convertmode1 real algebraic (integer scalar
real) convertmode typerr) 17828960826457123473)
convertmode1


(c!:install 'ofsf_posvarpat '(ofsf_posvarpat (greaterp geq) sfto_varp) 
11032796653786499669)
ofsf_posvarpat


(c!:install 'monommultiplybyvariable '(monommultiplybyvariable) 
17172159374623842453)
monommultiplybyvariable


(c!:install 'totalcompare '(totalcompare equal less greater wulessp
wuconstantp totalcompareconstants) 11251330360413400364)
totalcompare


(c!:install 'tayexp!-difference '(tayexp!-difference !*i2rn
rndifference!:) 5539778557453719521)
tayexp!-difference


(c!:install 'cl_smcpknowl '(cl_smcpknowl) 8596525473378925871)
cl_smcpknowl


(c!:install 'exchk2 '(exchk2 !*nosqrts expt (quotient 1 2) sqrt 0.5
prepsqx) 8408209472902095226)
exchk2


(c!:install 'mkuwedge '(mkuwedge wedge fkern) 15537515151797265826)
mkuwedge


(c!:install 'formop '(formop multop raddf) 18374765434994294328)
formop


(c!:install 'leftzeros '(leftzeros) 1541631738247837761)
leftzeros


(c!:install 'arintequiv!: '(arintequiv!: !:rn!:) 5145923688412295730)
arintequiv!:


(c!:install 'reduce!-mod!-p '(reduce!-mod!-p !*n2f) 1615371093659384512)
reduce!-mod!-p


(c!:install 'mconv '(mconv dmode!* dmconv0 mconv1) 11305980058139582012)
mconv


(c!:install 'lalr_lr0_itemset_to_lalr_kernel '(
lalr_lr0_itemset_to_lalr_kernel !S!' !.) 8429948008393873139)
lalr_lr0_itemset_to_lalr_kernel


(c!:install 'formclis '(formclis formc reversip!*) 12847314577098192759)
formclis


(c!:install 'preptayexp '(preptayexp rnprep!:) 11781688924428039998)
preptayexp


(c!:install 'ofsf_prepat '(ofsf_prepat prepf) 12200178279664987678)
ofsf_prepat


(c!:install 'image!-of!-power '(image!-of!-power image!-set
next!-random!-number) 17797210803896837455)
image!-of!-power


(c!:install 'addpf '(addpf nreverse addmpf addsq termordp!!) 
189716299280573791)
addpf


(c!:install 'id2bytelist '(id2bytelist id2string string2bytelist) 
11750583731547930828)
id2bytelist


(c!:install 'scan '(scan cursym!* !*semicol!* escaped!* nxtsym!* else
outl!* comment !C!O!M!M!E!N!T !Comment !*comment !% ttype!*
percent_comment !#if !#else !#elif !#endif !#eval !*backtrace
curescaped!* !#define (rread) newnam "*** " " => " !$eof!$ !'
"Invalid QUOTE" !*eoldelimp !$eol!$ !# crchar!* !*rpar!* !*comment!*
comment!* if elif endif eval define semic!* string " " token toknump
prin2x read!-comment1 rread errorset errorp filenderr rederr addcomment
read!-comment list2string) 12633109008148600643)
scan


(c!:install 'ra_budancount '(ra_budancount ra_transform ra_budan!-0!-1) 
2201881580874814603)
ra_budancount


(c!:install 'lalr_prin_nonterminal '(lalr_prin_nonterminal
nonterminal_codes cdrassoc explode2uc) 12680425989593305962)
lalr_prin_nonterminal


(c!:install 'remflagss '(remflagss) 4435156902296550872)
remflagss


(c!:install 'ordpa '(ordpa ordp) 8806040821570593621)
ordpa


(c!:install 'rl_smrmknowl '(rl_smrmknowl rl_smrmknowl!* apply) 
2293746311521066408)
rl_smrmknowl


(c!:install 'kernord!-split '(kernord!-split powers) 
14774245284254905622)
kernord!-split


(c!:install 'basicom '(basicom integerom floatom variableom) 
1834273756308251849)
basicom


(c!:install 'dfn_prop '(dfn_prop dfn dfn2 dfn3 mkid) 3602831462996363265
)
dfn_prop


(c!:install 'initwght '(initwght codmat maxvar dm!-abs !:onep) 
1049804139918570648)
initwght


(c!:install 'bcone!? '(bcone!? !*grmod!*) 11162750296414462727)
bcone!?


(c!:install 'vdplength '(vdplength diplength) 13611916425205023055)
vdplength


(c!:install 'plus!: '(plus!: !:rd!: ashift) 12247297853357438346)
plus!:


(c!:install 'getphystypesf '(getphystypesf domain!*p getphystype) 
15012319228892138193)
getphystypesf


(c!:install 'split!-road '(split!-road sroad) 3337914756389053626)
split!-road



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u11.lsp"

Reading "$reduce/cslbuild/generated-c/u12.lsp"

% u12.lsp           Machine generated Lisp

(c!:install "u12" 169557 2701747 1894550)
nil


(c!:install 'simp '(simp varstack!* dmode!* simpcount!* simplimit!* alg
"Simplification recursion too deep" !*sq !*resimp !*uncached alglist!*
!*sub2 "operator" name mat yetunknowntype "scalar" simpiden getelemfn
boolean "algebraic operator" nochange recursiveerror rerror gethash
simpatom !*ssave typerr revlis numlis nth errpri2 opfneval getrtype
simp_without_resimp reval argnochk to simp!* !*q2f lispapply opmtchrevop
lispeval redmsg mkop) 6417605007174974761)
simp


(c!:install 'red!-weight!-less!-p '(red!-weight!-less!-p) 
15527512240772958019)
red!-weight!-less!-p


(c!:install 'pv_times3 '(pv_times3 pappend) 3691900178785916296)
pv_times3


(c!:install 'raiseind!: '(raiseind!:) 8505176479277464392)
raiseind!:


(c!:install 'set!-general!-modulus '(set!-general!-modulus
current!-modulus modulus!/2) 1874468985716972133)
set!-general!-modulus


(c!:install 'ra_budan!-transform '(ra_budan!-transform x to addf exptf
multf) 8807291508851030473)
ra_budan!-transform


(c!:install 'lalr_make_compressed_action_row '(
lalr_make_compressed_action_row lalr_list_of_actions
lalr_resolve_conflicts lalr_make_compressed_action_row1) 
2852074745146579353)
lalr_make_compressed_action_row


(c!:install 'ofsf_smwcpknowl '(ofsf_smwcpknowl !*rlsusi cl_susicpknowl
ofsf_smcpknowl) 7089546550580279020)
ofsf_smwcpknowl


(c!:install 'color1 '(color1 qg g3 "Invalid structure of c0-graph."
times addsq removeg split3gv cerror) 4352621750118498595)
color1


(c!:install 'cl_simpl '(cl_simpl !*rlsism inctheo and false cl_simpl1
cl_sitheo rl_exc rl_smupdknowl) 8977132422883725116)
cl_simpl


(c!:install 'ibalp_clausep '(ibalp_clausep or ibalp_litp ibalp_litlp) 
720166200090794143)
ibalp_clausep


(c!:install 'omiir '(omiir char lex) 5366513475899983678)
omiir


(c!:install 'writepri '(writepri eval assgnpri) 14111625423404019942)
writepri


(c!:install 'argnochk '(argnochk !*argnochk variadic !*strict_argcount
"+++++ " rlisp "called with" "argument" "arguments" "instead of"
number!-of!-args argsofopr rerror lprim) 4181807411543066481)
argnochk


(c!:install 'compactfmatch2 '(compactfmatch2 !~) 224475548025507060)
compactfmatch2


(c!:install 'make!-term '(make!-term sin cos (-1 . 1) multsq) 
9078954940219746692)
make!-term


(c!:install 'listtest '(listtest) 16706901539491943115)
listtest


(c!:install 'lalr_prin_action '(lalr_prin_action " " "shift to state "
"accept" lalr_prin_reduction) 15880402724542237190)
lalr_prin_action


(c!:install 'formprogn '(formprogn progn formclis) 2107028119090928800)
formprogn


(c!:install 'processcarpartitie1 '(processcarpartitie1 processpartitie1)
 15456138832529220939)
processcarpartitie1


(c!:install 'subs3f1 '(subs3f1 !*mymatch mchfg!* !*resubs !*sub2
powlis1!* addsq !*subs3tnc subs3t subs2q subs3q) 5861254699348922205)
subs3f1


(c!:install 'get_rep_matrix_in '(get_rep_matrix_in
"error in get representation matrix" rederr) 15349649042341146497)
get_rep_matrix_in


(c!:install 'cl_fvarl '(cl_fvarl ordp cl_fvarl1 sort) 
15724032967646760359)
cl_fvarl


(c!:install 'qsort '(qsort ordop) 12064808041959192184)
qsort


(c!:install 'integerom '(integerom "<OMI> " " </OMI>" printout) 
17516490804314905868)
integerom


(c!:install 'c!:extadd '(c!:extadd addf c!:ordexp) 12741461048729794588)
c!:extadd


(c!:install 'lessp!: '(lessp!: greaterp!:) 15260863818086175057)
lessp!:


(c!:install 'condterpri '(condterpri !*output !*echo !*extraecho !*int
ifl!* !*defn !*demo) 3886476464251229633)
condterpri


(c!:install 'red_better '(red_better bas_dplen) 8582264097889148431)
red_better


(c!:install 'gperm3 '(gperm3 gperm2) 7591388445554053377)
gperm3


(c!:install 'ordn '(ordn ord2 ordad) 10332192838769180338)
ordn


(c!:install 'rnminus!: '(rnminus!: !:minus) 10114202910328867344)
rnminus!:


(c!:install 'split_f '(split_f "SPLIT_F: expression not linear w.r.t."
list multf addf get_first_kernel msgpri update_kc_list) 
1686252993858126732)
split_f


(c!:install 'rl_simp '(rl_simp rl_simp1 rl_csimpl) 1301825759816865816)
rl_simp


(c!:install 'get_group_in '(get_group_in) 7681727314505217329)
get_group_in


(c!:install 'ibalp_simpterm '(ibalp_simpterm "Boolean function"
ibalp_simpatom ibalp_boolfp reval typerr) 15506151739196029020)
ibalp_simpterm


(c!:install 'gb_buch!-ev_divides!? '(gb_buch!-ev_divides!? ev_mtest!?) 
3408037194448717213)
gb_buch!-ev_divides!?


(c!:install 'cgb_buch!-ev_divides!? '(cgb_buch!-ev_divides!? ev_mtest!?)
 9685527381017281983)
cgb_buch!-ev_divides!?


(c!:install 'naryrd '(naryrd mathml) 1312667547952411945)
naryrd


(c!:install 'sc_setmat '(sc_setmat) 16207821621747946256)
sc_setmat


(c!:install 'flatindxl '(flatindxl) 4768325691543994563)
flatindxl


(c!:install 'gfrsq '(gfrsq gfdot) 11530621920894201651)
gfrsq


(c!:install 'ncmpchk '(ncmpchk noncommuting physop!-ordop) 
14541186059863612535)
ncmpchk


(c!:install 'mv!-pow!-!- '(mv!-pow!-!- nreverse) 14925617278174881589)
mv!-pow!-!-


(c!:install 'dp!=mocompare '(dp!=mocompare mo_compare) 
15094876893358009668)
dp!=mocompare


(c!:install 'eqdummy '(eqdummy) 18076016336838887221)
eqdummy


(c!:install 'b!:ordexn '(b!:ordexn) 7748619897744485377)
b!:ordexn


(c!:install 'horner!-rule '(horner!-rule !*d2n evaluate!-in!-order) 
9012840665532260081)
horner!-rule


(c!:install 'cde_lassoc2 '(cde_lassoc2 "Error: bad alist" rederr) 
12470965637166428923)
cde_lassoc2


(c!:install 'gcdf2 '(gcdf2 asymplis!* !*anygcd !*gcd num!-exponents
kernord setkorder reorder comfac gcdf1 comfac!-to!-poly quotf1 gcdk
multf noncomp gcdfnc ordop) 10016176172079722155)
gcdf2


(c!:install 'qqe_arg!-check!-b '(qqe_arg!-check!-b qqe_id!-nyt!-branchb
qqe_qtidp qqe_nytidp qqe_btid qqe_add2rollbackids qqe_arg!-check) 
7263150955247412042)
qqe_arg!-check!-b


(c!:install 'rl_susibin '(rl_susibin rl_susibin!* apply) 
14790073274071796983)
rl_susibin


(c!:install 'aex_varl '(aex_varl aex_ex kernels) 12138312432367490705)
aex_varl


(c!:install 'omvir '(omvir name atts hex "wrong att" dec find errorml) 
16856227075493975039)
omvir


(c!:install 'spquotematrix '(spquotematrix sparse) 5925900773705317900)
spquotematrix


(c!:install 'vdpzero '(vdpzero a2vdp) 6559425673910558182)
vdpzero


(c!:install 'tokquote '(tokquote crchar!* nxtsym!* curescaped!* ttype!*
readch1 rread) 14220838049894060213)
tokquote


(c!:install 'red!-ratios1 '(red!-ratios1 red!-ratios2) 
5051240859727381882)
red!-ratios1


(c!:install 'multop '(multop kord!* k!* multf rmultpf) 
2569549041218447668)
multop


(c!:install 'red_divtest '(red_divtest bas_dpoly dp_lmon mo_vdivides!?) 
7632384483205331330)
red_divtest


(c!:install 'pdif '(pdif pneg psum) 12118561974533042045)
pdif


(c!:install 'pv_intequiv '(pv_intequiv) 5767065334788154536)
pv_intequiv


(c!:install 'crprcd '(crprcd convprec!*) 18117100781347588171)
crprcd


(c!:install 'simpexpon1 '(simpexpon1 !*numval dmode!* !:rd!: !:cr!:
alglist!*) 16238152524484848804)
simpexpon1


(c!:install 'talp_simplatrinv '(talp_simplatrinv equal talp_simplt
talp_invp talp_eqtp talp_mk2 talp_simplat2) 11822902135988021640)
talp_simplatrinv


(c!:install 'mkzl '(mkzl nreverse) 17272778361100409105)
mkzl



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u12.lsp"

Reading "$reduce/cslbuild/generated-c/u13.lsp"

% u13.lsp           Machine generated Lisp

(c!:install "u13" 146828 5652819 2386908)
nil


(c!:install 'ibalp_vequal '(ibalp_vequal) 5437926664406397851)
ibalp_vequal


(c!:install 'lesspcdr '(lesspcdr) 14122941759879918979)
lesspcdr


(c!:install 'sub_math '(sub_math char (i d e n t !/) ident (v e c t o r)
(!/ v e c t o r) "</vector>" constructors!* csymbol fn vectorrd errorml
compress!* apply) 18419925095686531214)
sub_math


(c!:install 'rd!:minus '(rd!:minus !:rd!: safe!-fp!-minus minus!:) 
1785567278384127790)
rd!:minus


(c!:install 'zeropp '(zeropp !:rd!: rd!:zerop) 13949595092336381551)
zeropp


(c!:install 'comm_kernels1 '(comm_kernels1 noncomp) 3100368076730526959)
comm_kernels1


(c!:install 'sc_null '(sc_null) 11307350938126117219)
sc_null


(c!:install 'fortranop '(fortranop !*fortranop!*) 7164010240171970054)
fortranop


(c!:install 'simptimes '(simptimes tstack!* mul!* alglist!* simpcar
multsq) 7488974973212079865)
simptimes


(c!:install 'dividef '(dividef) 7696426718935484752)
dividef


(c!:install 'noncomperm '(noncomperm failed noncomdel mapcons lastpair) 
8755064335032433944)
noncomperm


(c!:install 'lalr_most_common_reduction '(lalr_most_common_reduction
reduce accept) 14292451567014797944)
lalr_most_common_reduction


(c!:install 'undefdchk '(undefdchk defd undefns!*) 5023456470512908736)
undefdchk


(c!:install 'mk!+mat!+mult!+mat '(mk!+mat!+mult!+mat "no matrix in mult"
"matrices can not be multiplied" !*sub2 matrix!+p rederr get!+col!+nr
get!+row!+nr get!+mat!+entry multsq addsq subs2) 5423986245894603407)
mk!+mat!+mult!+mat


(c!:install 'talp_chkknowl '(talp_chkknowl neq true talp_candp
talp_arg2l talp_arg2r talp_invf talp_op talp_invp talp_invarg) 
8314572981169472499)
talp_chkknowl


(c!:install 'qqe_ofsf_prepat '(qqe_ofsf_prepat qqe_op qqe_rqopp
qqe_prepat ofsf_prepat) 1589176860606541047)
qqe_ofsf_prepat


(c!:install 'powers4 '(powers4 nreverse ordop) 1447856910578025462)
powers4


(c!:install 'unbind '(unbind binding) 12882119460731612857)
unbind


(c!:install 'listdiff '(listdiff) 14461502497108036326)
listdiff


(c!:install 'deletemult!* '(deletemult!*) 8201013927535965436)
deletemult!*


(c!:install 'aminusp!: '(aminusp!: !*modular modular aminusp!:1
"arithmetic expression" setdmode errorset2 errorp typerr) 
5331318887694205961)
aminusp!:


(c!:install 'mo_neg '(mo_neg) 3737353681207043185)
mo_neg


(c!:install 'wtchk '(wtchk k!* "weight confusion" to quotf errach) 
3502032153783501086)
wtchk


(c!:install 'put!-kvalue '(put!-kvalue !*sq kvalue sq_member smember
recursiveerror aconc) 13372840733956172816)
put!-kvalue


(c!:install 'removeg1 '(removeg1 n!*!*2!-1 "Free edge" "in vertex"
su_order "Invalid structure of c-graph" times removev multsq finde
cerror quotsq mkcopy) 7980733250654109105)
removeg1


(c!:install 'cl_varl1 '(cl_varl1 cl_varl2) 9987905465539996329)
cl_varl1


(c!:install 'qqe_ofsf_varlterm '(qqe_ofsf_varlterm qepsilon lto_insertq)
 7995573586547159696)
qqe_ofsf_varlterm


(c!:install 'rl_simp1 '(rl_simp1 rl_cid!* "select a context"
!*strict_argcount rl_simpfn simpfnname " (" ")" "predicate" simpdefault
rederr rl_simpatom argnochk apply reval ioto_form2str lto_sconcat redmsg
) 11833055585289989692)
rl_simp1


(c!:install 'wedget2 '(wedget2 multsq wedgek2 multpfsq) 
4666025021054316281)
wedget2


(c!:install 'set!-ordp '(set!-ordp ordp) 11286157267328432309)
set!-ordp


(c!:install 'map__edges '(map__edges union_edges) 9827530180937595202)
map__edges


(c!:install 'assert_dyntypep '(assert_dyntypep assert_dyntype) 
17777038173041719451)
assert_dyntypep


(c!:install 'dd '(dd ordering lex nc!* varlist!* dquot dless leftzeros
class) 129747970404352349)
dd


(c!:install 'pv_times2 '(pv_times2 pv_times3 pv_add) 
10666651998379876444)
pv_times2


(c!:install 'exptsq '(exptsq poly " 0**0 formed" !*exp "Zero divisor"
rerror mk!*sq simpexpt mksfpf kernp mksq exptf !:expt multsq multf
canonsq) 12315468031512248083)
exptsq


(c!:install 'p_princ '(p_princ bldmsg_chars!* !  !*ll!* " ") 
2900324150656089120)
p_princ


(c!:install 'gcref_mknode!-tgf '(gcref_mknode!-tgf " " prin2t) 
4018093252830256111)
gcref_mknode!-tgf


(c!:install 'quotfail1 '(quotfail1 polyzero quotf errorf) 
5553416668947438442)
quotfail1


(c!:install 'msappend '(msappend) 11032271548117645485)
msappend


(c!:install 'exceeds!-order '(exceeds!-order tayexp!-plus2 tayexp!-lessp
) 11075431926768230131)
exceeds!-order


(c!:install 'ckrn '(ckrn dmode!* (!:rd!: !:cr!:) lnc quotfd ckrn1 multf)
 8963949368468510905)
ckrn


(c!:install 'talp_rnf '(talp_rnf cl_simpl talp_rnf1) 
10476314859936877117)
talp_rnf


(c!:install 'qqe_qprefix!-var '(qqe_qprefix!-var (ltail rtail lhead
rhead) qqe_op qqe_arg2l qqe_arg2r) 15201380281209160393)
qqe_qprefix!-var



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u13.lsp"

Reading "$reduce/cslbuild/generated-c/u14.lsp"

% u14.lsp           Machine generated Lisp

(c!:install "u14" 72515 9525852 89327)
nil


(c!:install 'xread1 '(xread1 commentlist!* cursym!* !*lpar!* !*rpar!*
!*reduce4 type decstat !$eol!$ nxtsym!* !( !*eoldelimp times
curescaped!* proc "Syntax error in procedure header" struct paren
!*comma!* lambda "Improper delimiter" group "Too many right parentheses"
unary "Redundant operator" !*!*un!*!* "Missing operator"
"Please use parentheses around use of the unary operator" right (lambda
paren) not member "NOT" "infix operator" endstat go endstatfn !,
procedure "proc form" !*semicol!* !*colon!* for !*blockp nodel (
!*rsqbkt!* !*rcbkt!* !*rsqb!*) "Too few right parentheses"
"Please send hearn@rand.org your program!!" lispapply toknump chknewnam
symerr scan eolcheck remcomma xread mkvar typerr delcp procstat1
xcomment) 11814043184281624487)
xread1


(c!:install 'binomial!-coefft!-mod!-p '(binomial!-coefft!-mod!-p !*n2f
min) 18069998271637071980)
binomial!-coefft!-mod!-p


(c!:install '!*kp2f '(!*kp2f mksq) 666337834992111105)
!*kp2f


(c!:install 'revalind '(revalind alglist!* dmode!* subfg!* !0 simp
prepsq) 14428625574767194711)
revalind


(c!:install 'scalopp '(scalopp scalar vector tensor tensdimen isanindex
nth areallindices) 12955472892045792015)
scalopp


(c!:install 'lalr_reduction_index '(lalr_reduction_index
lalr_productions cdrassoc) 11756333825059727427)
lalr_reduction_index


(c!:install 'rempropss '(rempropss) 11396279580091513007)
rempropss


(c!:install 'rl_simpl '(rl_simpl rl_simpl!* apply) 12955744972546707629)
rl_simpl


(c!:install 'cl_smmkatl '(cl_smmkatl or lastpair rl_negateat) 
12227125609069066198)
cl_smmkatl


(c!:install 'ibalp_vmember '(ibalp_vmember ibalp_vequal) 
1354869335745791598)
ibalp_vmember


(c!:install 'make!-univariate!-image!-mod!-p '(
make!-univariate!-image!-mod!-p !*n2f image!-of!-power times!-mod!-p
plus!-mod!-p) 9498715387900674649)
make!-univariate!-image!-mod!-p


(c!:install 'minusp!: '(minusp!: !:rd!:) 2935256932381667861)
minusp!:


(c!:install 'isimplicit '(isimplicit implicit! ) 14035966247736076855)
isimplicit


(c!:install 'getmat '(getmat off_mod_reval unchecked_getmatelem) 
575108285554068056)
getmat


(c!:install 'groebcpcompless!? '(groebcpcompless!? !*gsugar number
vevcomp vdpgetprop vevcompless!?) 45463741637778272)
groebcpcompless!?


(c!:install 'vevdif '(vevdif backtrace dipoly
"Vevdif, difference would be < 0" vevzero!?1 getd rerror) 
3535859941191441732)
vevdif


(c!:install 'red!-ratios2 '(red!-ratios2 red!-lowest!-terms) 
3376847918635603851)
red!-ratios2


(c!:install 'cali_bc_zero!? '(cali_bc_zero!? !*hardzerotest prepf simp
bc!=simp) 4394829021658017818)
cali_bc_zero!?


(c!:install 'gperm0 '(gperm0 gperm3) 8730090614928443564)
gperm0


(c!:install 'portable_prin '(portable_prin !*ll!* p_prinl2) 
4548240548968345519)
portable_prin


(c!:install 'aex_deg '(aex_deg aex_ex sfto_vardeg) 3607510624473054238)
aex_deg


(c!:install 'ofsf_smwupdknowl '(ofsf_smwupdknowl !*rlsusi
cl_susiupdknowl ofsf_smupdknowl) 9736546518660035619)
ofsf_smwupdknowl


(c!:install 'removeg2 '(removeg2 g3 "Edge" "is absent in vertex" qg
cerror revv0 mkcopy negsq) 6511137687378053788)
removeg2


(c!:install 'pasf_susipost '(pasf_susipost) 2506054533815200357)
pasf_susipost


(c!:install 'vdp_plist '(vdp_plist) 16380982896306623454)
vdp_plist


(c!:install 'mathml2 '(mathml2 sub_math) 17551767027574496826)
mathml2


(c!:install 'setdmode1 '(setdmode1 tag dmode!* gdmode!* (rounded
complex!-rounded) realtype domainlist!* !:gi!: !* "Domain mode"
"changed to" rmsubs offmoderr !!mfefix lprim) 14607247357730800588)
setdmode1


(c!:install 'sc_minussq '(sc_minussq minusf) 10710327319336543990)
sc_minussq


(c!:install 'vevlcm '(vevlcm) 18414229144108724852)
vevlcm


(c!:install 'mksgnsq '(mksgnsq evenfree mk!*sq simpexpt) 
4016211607104099856)
mksgnsq


(c!:install 'defined_edge '(defined_edge old_edge_list new_edge_list
all_edge defined_all_edge) 17071500137057330346)
defined_edge


(c!:install 'rnconc '(rnconc !*ncmp noncomfp1 addf) 466226041312299716)
rnconc


(c!:install 'evalneq '(evalneq evalequal) 13844996325675159343)
evalneq


(c!:install 'dp_times_bcmo '(dp_times_bcmo mo_sum cali_bc_prod) 
7642691351532011130)
dp_times_bcmo


(c!:install 'ra_budan!-0!-1 '(ra_budan!-0!-1 ra_budan!-transform minusf)
 15518973105210631036)
ra_budan!-0!-1


(c!:install 'p_prin '(p_prin !_ !! bldmsg_chars!* !  !*ll!* " ") 
14632487754332920832)
p_prin


(c!:install 'ofsf_entry2at1 '(ofsf_entry2at1 and ofsf_clnegrel addsq) 
16980845921898880700)
ofsf_entry2at1


(c!:install 'polynommultiplybyvariable '(polynommultiplybyvariable
monomgetvariabledegree monommultiplybyvariable polynomadd) 
16583926328334196556)
polynommultiplybyvariable


(c!:install 'intexprlisp '(intexprlisp intexprnp) 6347235130115113606)
intexprlisp


(c!:install 'cl_sitheo '(cl_sitheo !*rlsiexpla !*rlsithok false inctheo
true cl_simplat) 15244933074264938711)
cl_sitheo


(c!:install 'qqe_ofsf_simplat1 '(qqe_ofsf_simplat1 (true false)
qqe_simplat1 qqe_op qqe_rqopp ofsf_simplat1) 4071328728144776747)
qqe_ofsf_simplat1


(c!:install 'sf2ss '(sf2ss searchpl qsort sq2sspl lx2xx) 
12717373165686143115)
sf2ss



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u14.lsp"

Reading "$reduce/cslbuild/generated-c/u15.lsp"

% u15.lsp           Machine generated Lisp

(c!:install "u15" 143239 1709677 6224182)
nil


(c!:install 'diff!-over!-k!-mod!-p '(diff!-over!-k!-mod!-p
quotfail!-mod!-p times!-mod!-p mksp) 15305212507911809722)
diff!-over!-k!-mod!-p


(c!:install 'c!:subs2multf '(c!:subs2multf !*sub2 matrix
"Sub error in glnrsolve" multf subs2 rerror) 9238164989815300843)
c!:subs2multf


(c!:install 'testredh '(testredh codmat maxvar rowdel testredzz) 
17389003401682745904)
testredh


(c!:install 'getcomb '(getcomb i comb nextcomb setdiff) 
17896886103709319914)
getcomb


(c!:install 'bc2a '(bc2a !*grmod!* prepsq) 12731770465936355733)
bc2a


(c!:install 'lid '(lid) 17189129716112135001)
lid


(c!:install 'list!+list '(list!+list nreverse !:plus) 
3588448022400956151)
list!+list


(c!:install 'physop!-multf '(physop!-multf !*exp ncmp!* wtl!*
!*!*processed !*contract2 !*asymp!* !*mcd multd mkprod noncomp2f
physop!-multfnc physop!-ordop physopp mkspm addf) 16688548001939892138)
physop!-multf


(c!:install 'form '(form always_nform !*rlisp88 !*vars!* !*mode symbolic
modefn "algebraic expression" "Rlisp88 form" n_form form1 typerr) 
892566736032357707)
form


(c!:install 'lengthcdr '(lengthcdr) 6543389359225820768)
lengthcdr


(c!:install 'mo_neworder '(mo_neworder mo!=shorten mo!=deglist) 
3498630001384855489)
mo_neworder


(c!:install 'dl_get2 '(dl_get2 di_insert) 14233851812246089122)
dl_get2


(c!:install 'general!-times!-mod!-p '(general!-times!-mod!-p
gen!-mult!-by!-const!-mod!-p general!-times!-term!-mod!-p
general!-plus!-mod!-p ordop) 17334083889051163507)
general!-times!-mod!-p


(c!:install 'efface1 '(efface1) 12879838724924137848)
efface1


(c!:install 'rsubla '(rsubla rassoc) 16645073108331555335)
rsubla


(c!:install 'cl_smsimpl!-junct '(cl_smsimpl!-junct !*rlsism false and
cl_gand!-col rl_smcpknowl cl_cflip cl_atfp cl_simplat rl_smupdknowl
cl_smsimpl!-junct1) 11682729181179643947)
cl_smsimpl!-junct


(c!:install 'sq2sspl '(sq2sspl sq2sstm) 9696884435459883490)
sq2sspl


(c!:install 'sq2sscfpl '(sq2sscfpl mkzl sq2sstm) 7910318926466258719)
sq2sscfpl


(c!:install 'horner!-rule!-mod!-p '(horner!-rule!-mod!-p expt!-mod!-p
times!-mod!-p plus!-mod!-p) 17881801528335960065)
horner!-rule!-mod!-p


(c!:install 'downwght1 '(downwght1 codmat maxvar dm!-abs !:onep) 
15360006528447657581)
downwght1


(c!:install 'newenv '(newenv unbound bind) 7633756221636202719)
newenv


(c!:install 'arg2of2 '(arg2of2) 4375772679821807059)
arg2of2


(c!:install 'evenfree '(evenfree qremd absf addf) 18154060703490971120)
evenfree


(c!:install 'fortranprecedence '(fortranprecedence !*fortranprecedence!*
) 11537112185118381901)
fortranprecedence


(c!:install 'assert_typesyntaxp '(assert_typesyntaxp !*assert
assert_dyntypep) 17209299985469235662)
assert_typesyntaxp


(c!:install 'mo!=revlexcomp '(mo!=revlexcomp mo!=degcomp) 
2383043388671786395)
mo!=revlexcomp


(c!:install 'artimes!: '(artimes!: dmode!* !*exp !:ar!: multf
reducepowers) 6267152915256128623)
artimes!:


(c!:install 'lexer_word_continues '(lexer_word_continues !_
lexer_style!* !. !' land) 10021294736520097938)
lexer_word_continues


(c!:install 'quotfdx '(quotfdx dmode!* divd quotdd quotkx) 
2190569667429103273)
quotfdx


(c!:install 'simpexpt '(simpexpt !*qsum!-simpexpt qsum!-simpexpt
basic!-simpexpt) 7166383482056185520)
simpexpt


(c!:install 'lx2xx '(lx2xx lastnondomain delet xxsort) 
3267089086882027254)
lx2xx


(c!:install 'ibalp_negateat '(ibalp_negateat ibalp_op ibalp_arg2l
ibalp_arg2r ibalp_negatet ibalp_mk2) 11674072354734338620)
ibalp_negateat


(c!:install 'dip_fmon '(dip_fmon) 16129702713853537519)
dip_fmon


(c!:install 'maxtype '(maxtype) 12508132550171625112)
maxtype


(c!:install 'bind '(bind binding) 3225494593516835221)
bind


(c!:install 'freeoffl '(freeoffl freeoff) 15078241996436078632)
freeoffl


(c!:install 'triviallcm '(triviallcm xdiv) 9232098139641841924)
triviallcm


(c!:install 'aminusp!:1 '(aminusp!:1 !*sq "invalid in FOR statement"
!:minusp aeval!* reval msgpri) 7805626647496889307)
aminusp!:1


(c!:install 'dcombine '(dcombine (!:crn!: !:gi!:) (!:rd!: !:cr!:) cmpxfn
!:ps!: noconvert !:rd!: !:cr!: !:rn!: !:gi!: !:crn!: !*rounded
!*roundall divide !*rn2rd !*crn2cr int!-equiv!-chk) 8297924674976742843)
dcombine


(c!:install 'setk '(setk evalargfn matrix setk0 revlis) 
1991935475192031166)
setk


(c!:install 'lalr_resolve_conflicts '(lalr_resolve_conflicts
orderactions shift !:left !:right sort lalr_warn_reduce_reduce_conflict
lalr_precedence lalr_associativity lalr_warn_shift_reduce_conflict) 
3536485786551802083)
lalr_resolve_conflicts


(c!:install 'cl_atml1 '(cl_atml1 cl_atmlc cl_f2ml) 7205542292703730976)
cl_atml1


(c!:install 'mri_realvarp '(mri_realvarp mri_type real) 
9365097956254588946)
mri_realvarp


(c!:install 'cl_qb '(cl_qb ex all) 16899144078553875742)
cl_qb


(c!:install 'quotient!-mod!-p '(quotient!-mod!-p "b=0 in quotient-mod-p"
exact!-quotient!-flag errorf safe!-modular!-reciprocal
multiply!-by!-constant!-mod!-p xquotient!-mod!-p ordop) 
17360224290089459535)
quotient!-mod!-p


(c!:install 'matsm!*1 '(matsm!*1 mat !*sub2 subs2!* !*q2a) 
14068891089045412209)
matsm!*1


(c!:install 'dipprodin1 '(dipprodin1 dipzero nreverse evsum bcprod) 
336795414234623694)
dipprodin1


(c!:install 'gsugar '(gsugar !*gsugar sugar "*** missing sugar"
vdpgetprop backtrace vdptdeg gsetsugar) 6798198097628900815)
gsugar


(c!:install 'noncommuting '(noncommuting noncommutes) 
2165035912138483362)
noncommuting


(c!:install 'remcomma '(remcomma !*comma!*) 2662719881749733707)
remcomma


(c!:install 'mv!-domainlist!-!* '(mv!-domainlist!-!* nreverse) 
18354663546968624885)
mv!-domainlist!-!*


(c!:install 'modquotient!: '(modquotient!: general!-modular!-reciprocal
general!-modular!-times !*modular2f) 8939512638981961561)
modquotient!:


(c!:install 'conv!:mt '(conv!:mt !:rd!: msd ashift round!:last bflerrmsg
) 8776247917539304474)
conv!:mt


(c!:install 'multd!* '(multd!* kernel xtype value to multd) 
884659770052925628)
multd!*



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u15.lsp"

Reading "$reduce/cslbuild/generated-c/u16.lsp"

% u16.lsp           Machine generated Lisp

(c!:install "u16" 81729 1102922 2761808)
nil


(c!:install 'use!-berlekamp '(use!-berlekamp dpoly poly!-vector
current!-modulus remainder!-in!-vector times!-in!-vector
find!-null!-space) 10421087587991988417)
use!-berlekamp


(c!:install 'rread1 '(rread1 ttype!* !*quotenewnam quotenewnam !:dn!:
symbolic !( !+ !- " " nxtsym!* "Syntax error: improper number" minus
ptoken dnform rrdls symerr) 12546366611473069056)
rread1


(c!:install 'aex_mvartest '(aex_mvartest aex_ex sfto_mvartest) 
18072716557489035181)
aex_mvartest


(c!:install 'idsort '(idsort idcompare sort) 16171354139434438841)
idsort


(c!:install 'talp_subalchk '(talp_subalchk) 17141478711458429059)
talp_subalchk


(c!:install 'qqe_ofsf_chsimpterm '(qqe_ofsf_chsimpterm expt (ltail rtail
) qqe_op qqe_arg2l qqe_chsimpterm setcar) 14229263982680834276)
qqe_ofsf_chsimpterm


(c!:install 'pasf_sisub!-gand '(pasf_sisub!-gand and true false
pasf_sisub) 5209455540577850077)
pasf_sisub!-gand


(c!:install 'ibalp_negatet '(ibalp_negatet bnot) 13505881871668969693)
ibalp_negatet


(c!:install 'mapins '(mapins nreverse) 6208819712836974700)
mapins


(c!:install 'cird '(cird atts (type) char ci retattributes lex errorml
compress!*) 12338498677706727103)
cird


(c!:install 'bsubs '(bsubs bound binding) 7609595528360115474)
bsubs


(c!:install 'wedgepf '(wedgepf !*pf2wedgepf wedgepf2 !*wedgepf2pf) 
13071033742882856573)
wedgepf


(c!:install 'all_edge '(all_edge nreverse) 10186315727852983129)
all_edge


(c!:install 'mkid '(mkid "MKID root" "MKID index" typerr
get!-print!-name) 4804688465473772125)
mkid


(c!:install 'mv!-pow!-chk '(mv!-pow!-chk mv!-pow!-!- mv!-pow!-minusp) 
6252537058940825)
mv!-pow!-chk


(c!:install 'dp_neg '(dp_neg cali_bc_neg) 2538534716641995404)
dp_neg


(c!:install 'pappend '(pappend unpkp pkp) 1433589190293901459)
pappend


(c!:install 'b!:extmult '(b!:extmult b!:ordexn multf negf b!:extadd) 
13693123787237902409)
b!:extmult


(c!:install 'tr_write '(tr_write !*trsolve) 9464242599202146762)
tr_write


(c!:install 'difference!-mod!-p '(difference!-mod!-p minus!-mod!-p
plus!-mod!-p) 3422566790670487414)
difference!-mod!-p


(c!:install 'reduce!-degree!-mod!-p '(reduce!-degree!-mod!-p
multiply!-by!-constant!-mod!-p plus!-mod!-p mksp times!-term!-mod!-p) 
4277033915637549791)
reduce!-degree!-mod!-p


(c!:install 'lalr_make_compressed_action_row1 '(
lalr_make_compressed_action_row1 shift accept reduce
lalr_most_common_reduction) 5198313706442512203)
lalr_make_compressed_action_row1


(c!:install 'powers3 '(powers3) 3323641930007482181)
powers3


(c!:install 'ibalp_redclause '(ibalp_redclause ibalp_vmember) 
614149274002913780)
ibalp_redclause


(c!:install 'matrixrowrd '(matrixrowrd mathml) 8180101794268303607)
matrixrowrd


(c!:install 'opmtch '(opmtch rpt inf subfg!* sroot1 oldmtch) 
1273851279168509676)
opmtch


(c!:install 'mkinds '(mkinds) 1345525827787502947)
mkinds


(c!:install 'flatsizec '(flatsizec widelengthc) 5640450612806210361)
flatsizec


(c!:install 'general!-modular!-reciprocal '(general!-modular!-reciprocal
!*balanced_mod current!-modulus general!-reciprocal!-by!-gcd) 
5044102815253907391)
general!-modular!-reciprocal


(c!:install 'ra_transform '(ra_transform x negsq addsq to multsq
sfto_qsub1) 17488387270339013101)
ra_transform


(c!:install 'rl_prepfof '(rl_prepfof rl_csimpl rl_prepfof1) 
3787519806660725985)
rl_prepfof


(c!:install 'poly!-minusp '(poly!-minusp) 3466468193239228631)
poly!-minusp


(c!:install 'delet '(delet nreverse) 4196219192857472711)
delet


(c!:install 'ibalp_emptyclausep '(ibalp_emptyclausep) 
12892062950656430122)
ibalp_emptyclausep


(c!:install 'c!:extmult '(c!:extmult "should never get here" c!:ordexn
c!:subs2multf negf c!:extadd rederr) 571422204684123209)
c!:extmult


(c!:install 'dpmat_coldegs '(dpmat_coldegs nth) 3174626191889732937)
dpmat_coldegs


(c!:install 'nb '(nb) 376134941141328322)
nb


(c!:install 'lex_start_block_comment '(lex_start_block_comment !/ !*
lexer_style!* !( yypeek land) 9039175858474494968)
lex_start_block_comment


(c!:install 'setpage '(setpage title!* pgnum!*) 17822129394673273623)
setpage


(c!:install 'mri_pasf2mriat '(mri_pasf2mriat mri_0mk2) 
15615781468990213430)
mri_pasf2mriat


(c!:install 'qqe_simplterm '(qqe_simplterm (ltail rtail) (lhead rhead) (
ladd radd) qqe_op qqe_simplterm!-tail qqe_simplterm!-head
qqe_simplterm!-add) 1706402166110397533)
qqe_simplterm


(c!:install 'pasf_mkpos '(pasf_mkpos true false (cong ncong) minusf
pasf_anegateat negf) 8021095345706867023)
pasf_mkpos


(c!:install 'ibalp_process!-var '(ibalp_process!-var !! setcar) 
18440587624209677374)
ibalp_process!-var


(c!:install 'cgp_ci '(cgp_ci nth) 4627297506477717357)
cgp_ci


(c!:install 'diff!-k!-times!-mod!-p '(diff!-k!-times!-mod!-p
binomial!-coefft!-mod!-p times!-mod!-p mksp) 3948337365085810727)
diff!-k!-times!-mod!-p


(c!:install 'terpri!* '(terpri!* outputhandler!* terpri testing!-width!*
overflowed!* !*fort !*nat pline!* ymax!* ymin!* orig!* posn!* ycoord!*
fterpri scprint) 2556988473238841502)
terpri!*


(c!:install 'find_sub_df '(find_sub_df is_sub_df) 18402242121722157452)
find_sub_df


(c!:install 'redcodmat '(redcodmat rowmin rowmax testred) 
7242402052009170639)
redcodmat


(c!:install 'exchk1 '(exchk1 expt times exchk2 simpexpon assoc2 addsq
sqchk) 3243638504056923274)
exchk1


(c!:install 'modminusp!: '(modminusp!: !*balanced_mod current!-modulus) 
16263133944667833744)
modminusp!:


(c!:install 'unchecked_getmatelem '(unchecked_getmatelem mat matrix
"Matrix" "not set" rerror nth) 3837257970903198919)
unchecked_getmatelem


(c!:install 'termordp!! '(termordp!! guesspftype termordp) 
14621044041233121472)
termordp!!


(c!:install 'scal!*list '(scal!*list nreverse !:times) 
8705273445897821808)
scal!*list


(c!:install 'actual_alst '(actual_alst nreverse) 7220919755738193858)
actual_alst


(c!:install 'symbid '(symbid fname!* ftype!* (macro smacro inline)
!*comp !*cref constant!? "nonlocal use of undeclared variable"
"in procedure" lprim) 1282567562781113822)
symbid


(c!:install 'nzeros '(nzeros nreverse) 13195653878633323743)
nzeros


(c!:install 'cali_bc_inv '(cali_bc_inv qremf) 1879288417171672158)
cali_bc_inv


(c!:install 'subsetp '(subsetp) 7573611723859556093)
subsetp


(c!:install 'wi_new '(wi_new wi_number !: windex mkid) 
16180821180526704178)
wi_new



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u16.lsp"

Reading "$reduce/cslbuild/generated-c/u17.lsp"

% u17.lsp           Machine generated Lisp

(c!:install "u17" 178071 4720664 5981409)
nil


(c!:install 'simpatom '(simpatom dmode!* !:mod!: current!-modulus
"String" "identifier" !*numval constant lispapply !:rd!: scalar rd!:simp
!*d2q typerr lispeval mksq simp errorset!* errorp complexp getrtype) 
2731299654662377707)
simpatom


(c!:install 'get_goto '(get_goto parser_goto_table) 5242891756119734055)
get_goto


(c!:install 'aex_subrat1 '(aex_subrat1 aex_ex sfto_qsubhor1 kernels
aex_ctx ctx_filter aex_mk) 8596099509159613937)
aex_subrat1


(c!:install 'collect_cars '(collect_cars nreverse) 13682026793595834967)
collect_cars


(c!:install 'qremf '(qremf !*exp qremd praddf multf to negf addf ordop) 
8572729870254090815)
qremf


(c!:install 'updtemplate '(updtemplate reval!-without) 
6684292596128315330)
updtemplate


(c!:install 'tmsf '(tmsf sfp tmsf!*) 14540052551771722099)
tmsf


(c!:install 'talp_td '(talp_td talp_fargl lto_max) 3753277161145513143)
talp_td


(c!:install 'qqe_id!-nyt!-branchq '(qqe_id!-nyt!-branchq qqe_qtidp
qqe_nytidp qqe_qopaddp qqe_qoptailp) 11050168470374905022)
qqe_id!-nyt!-branchq


(c!:install 'pasf_vf '(pasf_vf true false (cong ncong) pasf_evalatp) 
18406771852544693406)
pasf_vf


(c!:install 'ibalp_readclause '(ibalp_readclause true false not
ibalp_arg2l ibalp_arg2r iequal setcar ibalp_process!-var) 
9540077995733504917)
ibalp_readclause


(c!:install 'expt!-mod!-p '(expt!-mod!-p times!-mod!-p) 
17085857477794159462)
expt!-mod!-p


(c!:install 'omsir '(omsir name atts cd (v e c t o r) (vectorml linalg1)
mmleq!* special_cases!* special_cases2!* valid_om!* find apply encodeir)
 15719045185100625031)
omsir


(c!:install 'ps!:expression '(ps!:expression !:ps!: ps!:getv) 
18283141111150797452)
ps!:expression


(c!:install 'evallessp '(evallessp evalgreaterp) 1093636265455228741)
evallessp


(c!:install 'dipilcomb1 '(dipilcomb1 !*gcd vbcsize evzero!? dipprod
evsum evcomp bcprod bczero!? bcsum) 14052257147707387263)
dipilcomb1


(c!:install 'mkprogn '(mkprogn progn) 16326704874711010330)
mkprogn


(c!:install 'getmatelem '(getmatelem "matrix element" matrix "matrix"
mat "Matrix" "not set" "positive integer" typerr rerror
reval_without_mod nth) 1667832788066605898)
getmatelem


(c!:install 'di_restore '(di_restore di_restore1) 7191922973657611938)
di_restore


(c!:install 'negate!-term '(negate!-term minus!-mod!-p) 
15424624617406357051)
negate!-term


(c!:install 'lalr_associativity '(lalr_associativity precedence_table) 
5173428193707042643)
lalr_associativity


(c!:install 'simplify!-filename '(simplify!-filename "/packages/"
starts!-with list2string) 16691211218299472791)
simplify!-filename


(c!:install 'wureducedpolysp '(wureducedpolysp wureducedp) 
14055942286802406885)
wureducedpolysp


(c!:install 'talp_smwrmknowl '(talp_smwrmknowl !*rlsusi cl_susirmknowl
cl_smrmknowl) 1099794248977726135)
talp_smwrmknowl


(c!:install 'setunion '(setunion) 942439817850394096)
setunion


(c!:install 'cl_pnf2 '(cl_pnf2 ex all or and true false not impl repl
equiv bex ball "cl_pnf2():" "invalid as operator" cl_pnf2!-quantifier
cl_pnf2!-junctor rl_external apply rederr) 2844749681406684364)
cl_pnf2


(c!:install 'attributesml '(attributesml ">" " " "=""" definitionurl
vectorml "vector" """" mathml_list2string) 314911681028717662)
attributesml


(c!:install 'spband_matrix '(spband_matrix spm
"Error in spband_matrix(second argument): should be an integer." list
"Error in spband_matrix(first argument): should be single value or list."
"Error in spband matrix(first argument): number of elements must be odd."
quotient
"Error in spband_matrix: too many elements. Band matrix is overflowing."
mkempspmat rederr reval nth letmtr3) 12477874448771780044)
spband_matrix


(c!:install 'dm!-eq '(dm!-eq dm!-difference !:zerop) 
11122949172106058183)
dm!-eq


(c!:install 'removeindices '(removeindices "u= " " x= "
"invalid arguments to removeindices" trwrite !*physopp isanindex idlistp
areallindices rederr2) 1411264797663108431)
removeindices


(c!:install 'il_simp '(il_simp il_simp1) 4935923963562041708)
il_simp


(c!:install 'b!:ordexp '(b!:ordexp) 6049226428041095357)
b!:ordexp


(c!:install 'invbf '(invbf bfone!* !:bprec!: divide!: normbf) 
11480348212648515783)
invbf


(c!:install 'xremainder!-mod!-p '(xremainder!-mod!-p minus!-mod!-p
quotient!-mod!-p multiply!-by!-constant!-mod!-p plus!-mod!-p mksp
times!-term!-mod!-p) 3946349209265973118)
xremainder!-mod!-p


(c!:install 'simpiden '(simpiden list nosimp !*sq odd nonzero ncmp!*
subfg!* linear opvalfn antisymmetric even valuechk aeval mksq fnreval
prepsqxx formlnr simp opmtch ordn repeats permp negsq minusf) 
17265303734153583015)
simpiden


(c!:install 'ra_refine1 '(ra_refine1 x sfto_avgq sfto_qsub1
ra_budancount) 4048150596571684560)
ra_refine1



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u17.lsp"

Reading "$reduce/cslbuild/generated-c/u18.lsp"

% u18.lsp           Machine generated Lisp

(c!:install "u18" 65019 3311847 2073648)
nil


(c!:install 'lex_restore_context '(lex_restore_context lex_fixed_code
lex_next_code lex_dipthong lex_code lex_codename lex_keyword_names
lex_cleanup) 8552250953619299359)
lex_restore_context


(c!:install 'outdefr '(outdefr outref) 18442974756550478845)
outdefr


(c!:install 'processpartitie1 '(processpartitie1 times ext
all_graded_der ordn processcarpartitie1 aeval nth) 5270571181269673177)
processpartitie1


(c!:install 'remove!-free!-vars!* '(remove!-free!-vars!*
!*!*noremove!*!* remove!-free!-vars) 4819420631164452905)
remove!-free!-vars!*


(c!:install 'degree!-in!-variable '(degree!-in!-variable
"Polynomial with a zero coefficient found" errorf max) 
10609189495188617154)
degree!-in!-variable


(c!:install 'constsml '(constsml "<cn" " type=""real""> "
" type=""integer""> " "> " " </cn>" constants!*
"<cn type=""constant""> " "<ci" " type=""list""> " " type=""vector""> "
" </ci>" printout listp) 5623348492682102215)
constsml


(c!:install 'ldt!-tvar '(ldt!-tvar df) 1507920018313660544)
ldt!-tvar


(c!:install 'maprin '(maprin outputhandler!* overflowed!* maprint) 
4776319739805101826)
maprin


(c!:install 'findnewvars '(findnewvars genp lastpair) 935728443037538372
)
findnewvars


(c!:install 'xord_gradlex '(xord_gradlex xord_lex) 15896039013277011291)
xord_gradlex


(c!:install 'physopaeval '(physopaeval !*sq psimpfn physopp !*q2a
opmtch!*) 12861057458750378330)
physopaeval


(c!:install 'contr1!-strand '(contr1!-strand contr2!-strand) 
11639404597423064168)
contr1!-strand


(c!:install 'simp!-sign '(simp!-sign reval simp!-sign1) 
8598755088569764858)
simp!-sign


(c!:install 'sqp '(sqp sfpx) 10901859175073036387)
sqp


(c!:install 'mo_from_a '(mo_from_a cali!=basering "dpoly variable"
ring_all_names typerr mo!=shorten mo!=deglist) 17438636991179603879)
mo_from_a


(c!:install 'get_action '(get_action parser_action_table) 
2610735660823891640)
get_action


(c!:install 'read_typed_name '(read_typed_name cursym!* !*colon!*
general scan read_type) 10497267313877367188)
read_typed_name


(c!:install 'rl_bestgaussp '(rl_bestgaussp rl_bestgaussp!* apply) 
16475081778650507996)
rl_bestgaussp


(c!:install 'mkkl '(mkkl) 18093329309246472598)
mkkl


(c!:install 'findremainder '(findremainder wupseudodivide) 
405066793970175807)
findremainder


(c!:install 'prepsq!* '(prepsq!* !*combinelogs ordl!* factors!*
prepsq!*fn ordop kord!* wtl!* !*rat !*div upl!* dnl!* prepsq!*2
setkorder lastpair sort formop prepsq!*1 replus sqform) 
5539442557942804057)
prepsq!*


(c!:install 'talp_eqtp '(talp_eqtp) 12077953681667779134)
talp_eqtp


(c!:install 'qqe_number!-of!-adds!-in!-qterm '(
qqe_number!-of!-adds!-in!-qterm (ladd radd) qqe_op qqe_arg2r qqe_arg2l) 
14869044607652472136)
qqe_number!-of!-adds!-in!-qterm


(c!:install 'subf '(subf alglist!* ncmp!* expt varstack!* !*d2q
noncomexpf subf1 kernord intersection setkorder reorder kernels prepsq
simp) 17978689418572348717)
subf


(c!:install 'cl_nnf1 '(cl_nnf1 not impl or repl equiv and true false ex
all bex ball cl_cflip rl_negateat) 4862873486018472541)
cl_nnf1


(c!:install 'cgp_number '(cgp_number nth) 3932898882118499463)
cgp_number


(c!:install 'nary '(nary e power exp "<apply>" "<" "/" "</apply>" unary
printout attributesml indent!* multi_elem) 11829697404901466361)
nary


(c!:install 'sacar '(sacar) 4142193243579579156)
sacar


(c!:install 'inshisto '(inshisto codmat maxvar codhisto headhisto min) 
11848284699196277464)
inshisto


(c!:install 'bcplus!? '(bcplus!?) 7742897583963382144)
bcplus!?


(c!:install 'groebbuchcrit4t '(groebbuchcrit4t) 8809090727100979647)
groebbuchcrit4t


(c!:install '!*pf2wedgepf '(!*pf2wedgepf nreverse wedgefax) 
458561407058774177)
!*pf2wedgepf


(c!:install 'pv_times1 '(pv_times1 pv_times2) 5264998160665848358)
pv_times1


(c!:install 'general!-reduce!-degree!-mod!-p '(
general!-reduce!-degree!-mod!-p general!-modular!-minus
general!-modular!-quotient general!-multiply!-by!-constant!-mod!-p
general!-plus!-mod!-p mksp general!-times!-term!-mod!-p) 
1728089144768213125)
general!-reduce!-degree!-mod!-p


(c!:install 'update_kc_list '(update_kc_list list_assoc addf) 
8917953687871662656)
update_kc_list


(c!:install 'ofsf_pow2q '(ofsf_pow2q to) 9555663570031789959)
ofsf_pow2q


(c!:install 'prepreform '(prepreform ordl!* factors!* prepreform1) 
5970433628684237291)
prepreform


(c!:install 'exptcompare '(exptcompare) 5372125586460383598)
exptcompare


(c!:install 'cl_smsimpl!-junct2 '(cl_smsimpl!-junct2 !*rlsichk !*rlsiso
rl_ordatp !*rlsisocx cl_sordp rl_smmkatl lto_insert sort cl_flip) 
10742815408394509146)
cl_smsimpl!-junct2


(c!:install 'cl_pnf2!-junctor '(cl_pnf2!-junctor all ex cl_pnf2 cl_qb
cl_interchange) 17851120715859743429)
cl_pnf2!-junctor


(c!:install 'aex_fvarl '(aex_fvarl aex_varl aex_ctx ctx_idl lto_setminus
) 750318054444415879)
aex_fvarl


(c!:install 'variablesir '(variablesir char (!/ o m b v a r) omvir lex) 
2307334160926180555)
variablesir


(c!:install 'freeoff '(freeoff sfp ndepends) 8924154528667918378)
freeoff


(c!:install 'deleteall '(deleteall) 8011811616758810551)
deleteall


(c!:install 'cstimes '(cstimes times) 13052923761714089834)
cstimes


(c!:install 'simprepart '(simprepart !*factor simp!* repartsq) 
15241199411347169298)
simprepart


(c!:install 'command '(command errmsg!* loopdelimslist!* !*demo ifl!*
!*slin !*reduce4 lreadfn!* crchar!* !$eol!$ !*struct !*pret (in out shut
) cursym!* end symbolic key!* quote nochange intfn list (setq setel setf
) !*mode !*debug "Parse: " !*semicol!* "Form: " commdemo setcloc!*
lispapply readch1 command1 structchk rprint form convertmode1
prettyprint n_form) 7395038323042452601)
command


(c!:install 'sf_member '(sf_member mvar_member) 14719990412433707996)
sf_member


(c!:install '!:divide '(!:divide poly "zero divisor" divide rerror
dividef dcombine) 229903107460967749)
!:divide


(c!:install 'b!:extadd '(b!:extadd addf b!:ordexp) 18403102327845111352)
b!:extadd


(c!:install 'in_list1 '(in_list1 in_list1a) 14837564741053915885)
in_list1



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u18.lsp"

Reading "$reduce/cslbuild/generated-c/u19.lsp"

% u19.lsp           Machine generated Lisp

(c!:install "u19" 80086 4912990 3394247)
nil


(c!:install 'polynomheadreduceby '(polynomheadreduceby
fluidbibasisreductionsmade monomisdivisibleby monomdivide
polynommultiplybymonom polynomadd) 9096444161962194715)
polynomheadreduceby


(c!:install 'wusort '(wusort wulessp!* sort) 18081394487224094920)
wusort


(c!:install 'talp_simplatat '(talp_simplatat equal talp_getl talp_mk2
talp_telp talp_simplt) 2110880859993528509)
talp_simplatat


(c!:install 'qqe_simplat1 '(qqe_simplat1 (qequal qneq) qequal qqe_op
qqe_simplbtat qqe_simplqequal qqe_simplqneq) 12685611520394717593)
qqe_simplat1


(c!:install 'cl_mkstrict '(cl_mkstrict true false or and not impl repl
equiv ex all bex ball "BUG IN cl_mkstrict" cl_flip rederr) 
14791651113633268151)
cl_mkstrict


(c!:install 'variableom '(variableom constantsom!* "<OMS " "cd=""" """ "
"name=""" """/>" "<OMV " printout) 12706099796162667316)
variableom


(c!:install 'onoff '(onoff "switch" rlisp "not defined as switch" !*
!*switchcheck simpfg progn !*raise !*!L!O!W!E!R !*lower typerr rerror
list2string lispeval) 9564493937238698320)
onoff


(c!:install 'guesspftype '(guesspftype (wedge d partdf hodge innerprod
liedf) xvarlistp mknwedge) 6617237155091291956)
guesspftype


(c!:install 'equalreplaceby '(equalreplaceby replaceby) 
5829985681306237097)
equalreplaceby


(c!:install 'prinfit '(prinfit !*nat testing!-width!* oprin maprint
layout!-formula putpline) 5379266790443549343)
prinfit


(c!:install 'gpexp1p '(gpexp1p gpexpp) 14677648976422768513)
gpexp1p


(c!:install 'copyd '(copyd !*savedef rlisp "has no definition in copyd"
lose getd rerror putd) 644475855128438402)
copyd


(c!:install 'class '(class ordering lex ord leftzeros) 
1327487842138551510)
class


(c!:install 'lexer_word_starter '(lexer_word_starter !_ lexer_style!* !'
!\ land) 4067608986831865765)
lexer_word_starter


(c!:install 'gcref_mkedges!-tgf '(gcref_mkedges!-tgf " " prin2t) 
410047465957300676)
gcref_mkedges!-tgf


(c!:install 'replus '(replus plus unplus) 8598976190420398820)
replus


(c!:install 'rl_subat '(rl_subat rl_subat!* apply) 3129701482753207433)
rl_subat


(c!:install 'subf1 '(subf1 dmode!* resimplify varstack!* wtl!*
asymplis!* k!* yetunknowntype list "substituted expression" frlis!*
simpatom !*d2q prepf simp degr wtchk subsublis getrtype
eval!-yetunknowntypeexpr typerr setkorder reordsq kernp prepsq simpexpt
exptsq subs2 multsq addsq sub2chk simprecip) 12224686838927291519)
subf1


(c!:install 'cl_rename!-vars1 '(cl_rename!-vars1 or and not impl repl
equiv ex all rl_varsubstat bex ball setcdr mkid setcar cl_apply2ats1) 
12642081936849877370)
cl_rename!-vars1


(c!:install 'bc_2sq '(bc_2sq) 2666237714914294559)
bc_2sq


(c!:install 'termorder '(termorder listsum termorder1) 
7713265788379872149)
termorder


(c!:install 'stats_getargs '(stats_getargs mathml) 13284419938155693538)
stats_getargs


(c!:install 'convchk '(convchk !*!*roundbf !:rd!: fl2bf read!:num normbf
bf2flck) 2300856283230210226)
convchk


(c!:install 'bcquot '(bcquot !*grmod!* !*vdpinteger quotientx bcfi
bcint2op quotfx quotsq) 10560766879555860784)
bcquot


(c!:install 'vdpputprop '(vdpputprop dipoly
"vdpputprop given a non-vdp as 1st parameter" rerror) 
6517493718410928961)
vdpputprop


(c!:install 'add2resultbuf '(add2resultbuf !*libreduce_active semic!* !$
statcounter !*mode symbolic !*reduce4 empty_list !*nosave!* ws alglist!*
resultbuflis!* lr_result lr_printer lr_statcounter lr_mode lr_posttext
putobject terminalp) 7966353812840996655)
add2resultbuf


(c!:install 'groeb!=better '(groeb!=better nth mo_compare) 
13353753091460686345)
groeb!=better


(c!:install 'ord2 '(ord2 ordp) 16225334524871574020)
ord2


(c!:install 'moduntag '(moduntag !:mod!: nreverse) 12941555493178756383)
moduntag


(c!:install 'mksq '(mksq subfg!* wtl!* k!* !*nosubs used!* asymplis!*
powlis!* (expt sqrt) !*sub2 mksqsubfn !*resubs fkern getpower multsq
aconc simpcar exptsq) 3239795195940164016)
mksq


(c!:install 'rrdls '(rrdls ttype!* !) !. " " nxtsym!*
"Invalid S-expression" rread1 ptoken symerr) 13495039264772142997)
rrdls


(c!:install 'read_namelist '(read_namelist cursym!* !*comma!*
valid_as_variable read_typed_name scan) 3194005069515663249)
read_namelist


(c!:install 'sfto_ucontentf1 '(sfto_ucontentf1 sfto_gcdf!*) 
3961881911748146012)
sfto_ucontentf1


(c!:install 'expnd1 '(expnd1 sfp multf exptf addf) 14859460201852111458)
expnd1


(c!:install 'ev_sum '(ev_sum) 3122904571819917221)
ev_sum


(c!:install 'mml2om '(mml2om "Intermediate representation: " mml2ir
terpri!* ir2om) 10393749499664844907)
mml2om


(c!:install 'vbcgcd '(vbcgcd (1 . 1) vbcsize gcdf!*) 
15164924111555833188)
vbcgcd


(c!:install 'mkarray1 '(mkarray1 symbolic) 6129314003741608478)
mkarray1


(c!:install 'idcons_ordp '(idcons_ordp atom_compare cons_ordp) 
17803095815279840494)
idcons_ordp


(c!:install 'general!-expt!-mod!-p '(general!-expt!-mod!-p
general!-times!-mod!-p) 12454319538062397665)
general!-expt!-mod!-p


(c!:install 'lex_start_line_comment '(lex_start_line_comment !%
lexer_style!* !# !/ land yypeek) 16879018531008787476)
lex_start_line_comment


(c!:install 'rl_atl '(rl_atl rl_atl!* apply) 6673392338047636236)
rl_atl


(c!:install 'om2mml '(om2mml "Intermediate representation:" om2ir
terpri!* ir2mml) 10011268629939126471)
om2mml


(c!:install 'floatprop '(floatprop !:rd!:) 9827860526588982079)
floatprop


(c!:install '!*wedgepf2pf '(!*wedgepf2pf nreverse mkuwedge) 
5371658738046325164)
!*wedgepf2pf


(c!:install 'delete!-dups '(delete!-dups nreverse) 12574236897102092115)
delete!-dups


(c!:install 'inttovec '(inttovec inttovec!-solve inttovec1) 
13972934414845309666)
inttovec



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u19.lsp"

Reading "$reduce/cslbuild/generated-c/u20.lsp"

% u20.lsp           Machine generated Lisp

(c!:install "u20" 81147 5184750 9366662)
nil


(c!:install 'physop!-ordop '(physop!-ordop physopname specoplist!*
!*physopp ordop2 opnum!*) 16931902939745874235)
physop!-ordop


(c!:install 'zero!-roads '(zero!-roads z!-roads) 3317503514972784561)
zero!-roads


(c!:install 'addgt '(addgt ordering lex plus eval) 8619459172360026762)
addgt


(c!:install 'lex_save_context '(lex_save_context lex_codename
lex_dipthong) 11187934857878174740)
lex_save_context


(c!:install 'ctx_filter '(ctx_filter ctx ctx_ial lastpair) 
17427181523192344843)
ctx_filter


(c!:install 'ofsf_entry2at '(ofsf_entry2at !*rlidentify ofsf_entry2at1
cl_identifyat) 12102495547416178926)
ofsf_entry2at


(c!:install 'monomdivide '(monomdivide) 13462168600263362237)
monomdivide


(c!:install 'rl_nnf '(rl_nnf rl_nnf!* apply) 3613698152756377119)
rl_nnf


(c!:install 'innprodkp '(innprodkp reversip2) 18318363658522855146)
innprodkp


(c!:install 'talp_rnf1 '(talp_rnf1 true false cl_simpl talp_atfp
talp_acfrp talp_raf talp_op talp_argl) 3402747954690578402)
talp_rnf1


(c!:install 'distribute!.multiplicity '(distribute!.multiplicity) 
499274864297745022)
distribute!.multiplicity


(c!:install 'ibalp_readform '(ibalp_readform and true !*rlverbose
"Detected empty clause" "Tautology detected"
"Deleted redundant clauses: " cl_mkstrict ibalp_readclause
ibalp_emptyclausep ibalp_clmember ibalp_redclause ibalp_undoclause
ioto_tprin2t) 5947913626491699670)
ibalp_readform


(c!:install 'ir2om '(ir2om ind indent "<OMOBJ>" "</OMOBJ>" printout
indent!* objectom) 13344185890426862144)
ir2om


(c!:install 'xord_deglex '(xord_deglex xdegreemon xord_lex) 
6562052768447853320)
xord_deglex


(c!:install 'contr '(contr nreverse split!-road) 14248345332913076555)
contr


(c!:install 'repasc '(repasc alg "key" "not found" rerror nreverse) 
17544293124976533301)
repasc


(c!:install 'general!-reduce!-mod!-p '(general!-reduce!-mod!-p
general!-modular!-number !*n2f) 13879095035151486545)
general!-reduce!-mod!-p


(c!:install 'ordexn '(ordexn ordop) 11796463192895462512)
ordexn


(c!:install 'ofsf_smmkatl1 '(ofsf_smmkatl1 and ofsf_smmkatl!-and
ofsf_smmkatl!-or) 5746707685276759436)
ofsf_smmkatl1


(c!:install 'ibalp_calcmom '(ibalp_calcmom) 12531742832238813395)
ibalp_calcmom


(c!:install 'groebcplistsortin '(groebcplistsortin groebcplistsortin1) 
6911557174824682766)
groebcplistsortin


(c!:install 'invp '(invp unit inverse (comm anticomm) quotient) 
12723263780771004771)
invp


(c!:install 'th_match '(th_match th_match0 dl_get) 16649238676373897991)
th_match


(c!:install '!:expt '(!:expt poly "0/0 formed" expt rerror fieldp
mkratnum !:recip) 1906246832538517278)
!:expt


(c!:install 'print_with_margin_sub '(print_with_margin_sub "(" " " ". "
" ." ")" "\" apply) 12678370922493737021)
print_with_margin_sub


(c!:install 'simp!*sq '(simp!*sq !*resimp resimp1) 5817631147132282818)
simp!*sq


(c!:install 'talp_invn '(talp_invn talp_op) 3909389058722197269)
talp_invn


(c!:install 'cl_susiminlevel '(cl_susiminlevel ignore min) 
14130220163383969551)
cl_susiminlevel


(c!:install 'tobvarir '(tobvarir bvar) 4702481268318296806)
tobvarir


(c!:install 'formcond '(formcond cond formcond1) 16529543232591512534)
formcond


(c!:install 'evalequal '(evalequal difference getrtype reval) 
9329211343958556356)
evalequal


(c!:install 'mv2sf1 '(mv2sf1 to) 1194448756361659613)
mv2sf1


(c!:install 'di_insert '(di_insert eqdummy) 17399345672664134114)
di_insert


(c!:install 'decprec2internal '(decprec2internal !!log2of10 ceiling) 
11314076629012560127)
decprec2internal


(c!:install 'carrassoc '(carrassoc "RASSOC trouble: " " "
"rassoc trouble" rassoc rederr) 3017662206685756414)
carrassoc


(c!:install 'make_tuple_type '(make_tuple_type unit times collect_cdrs) 
8488267518516290328)
make_tuple_type


(c!:install 'triplesetprolongset '(triplesetprolongset) 
2405898036471723158)
triplesetprolongset


(c!:install 'findnthroot '(findnthroot) 9176337541059857052)
findnthroot


(c!:install 'basic!-simpexpt '(basic!-simpexpt kord!* expt resimp carx
simpexpon simpexpon1 simpexpt1) 16670121342641082923)
basic!-simpexpt


(c!:install 'applyrd '(applyrd atts (type definitionurl encoding)
mmlatts char functions!* lex retattributes compress!* apply errorml) 
5937752342201095232)
applyrd


(c!:install 'merge!-ind!-vars '(merge!-ind!-vars !*nocommutedf
!*commutedf derad!* derad) 14484345647347537311)
merge!-ind!-vars


(c!:install 'vdpred '(vdpred vdp !*gsugar sugar vdpgetprop gsetsugar) 
8803224557537834395)
vdpred


(c!:install 'indexvarordp '(indexvarordp kord!* indxl!* ordop flatindxl
boundindp indordlp) 574791126496740713)
indexvarordp


(c!:install 'cut!:mt '(cut!:mt !:rd!: msd ashift bflerrmsg) 
17626522596820174603)
cut!:mt


(c!:install 'lispassignp '(lispassignp setq) 2642839349066567258)
lispassignp


(c!:install 'begin1a '(begin1a otime!* gctime ogctime!* otime3!*
otime2!* otime1!* ogctime3!* ogctime2!* ogctime1!* peekchar!*
!*semicol!* cursym!* curescaped!* !*nosave!* statcounter !*strind !*time
(showtime nil) !*output ofl!* !*defn !*lessspace tslin!* !*slin
lreadfn!* initl!* forkeywords!* delim repeatkeywords!* whilekeywords!*
!*int erfg!* end key!* ed promptexp!* (command) symbolic xmodule err2
err3 crbuf1!* "Closing object improperly removed. Redo edit." eof!*
"End-of-file read" (bye) crbuf!* "BEGIN invalid" !*errcont !*echo cmsg!*
"Continuing with parsing only ..." getd terminalp add2buflis
update_prompt lispeval sinitl comm1 printprompt errorset!* condterpri
errorp eval xmodloop begin11 lprim eofcheck resetparser lprie pause1) 
15464049452614239342)
begin1a


(c!:install 'bas_newnumber '(bas_newnumber) 16517938802484585713)
bas_newnumber


(c!:install 'traput '(traput toplv!*) 3292699011526603121)
traput


(c!:install 'ofsf_varlat '(ofsf_varlat !*rlbrkcxk kernels lto_lpvarl
lastpair) 832260251403056635)
ofsf_varlat


(c!:install 'rl_csimpl '(rl_csimpl !*rlsimpl rl_simpl getd) 
14355992846025687008)
rl_csimpl


(c!:install 'mkprod '(mkprod !*exp !*sub2 !*mcd !*sqfree !*factor !*gcd
!*group kernlp subs2 ckrn quotf expnd multf fctrf mksp!* tmsf) 
5396723553033127465)
mkprod


(c!:install 'lto_max1 '(lto_max1 max) 6102494270337772939)
lto_max1


(c!:install 'bc_fd '(bc_fd) 17852619050421096071)
bc_fd


(c!:install 'ir2mml '(ir2mml (indent) ind indent "<math>" "</math>"
fluid printout indent!* expression) 10494619312634463605)
ir2mml


(c!:install 'testredzz '(testredzz codmat maxvar testredh) 
13911561270740505926)
testredzz


(c!:install 'list!-mgen '(list!-mgen i mgenp) 11037495168508222293)
list!-mgen


(c!:install 'expand!-imrepart '(expand!-imrepart expand!-imrepartpow
multsq addsq) 4340953945397562236)
expand!-imrepart



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u20.lsp"

Reading "$reduce/cslbuild/generated-c/u21.lsp"

% u21.lsp           Machine generated Lisp

(c!:install "u21" 46859 36522 886874)
nil


(c!:install 'mvar_member '(mvar_member arglist_member) 
6863625781480248750)
mvar_member


(c!:install 'rnminusp!: '(rnminusp!:) 15441971619235793483)
rnminusp!:


(c!:install 'mo_times_ei '(mo_times_ei mo!=deglist) 17361248855841632455
)
mo_times_ei


(c!:install 'reverse!-num '(reverse!-num ilog2 reverse!-num1) 
18206649692555189733)
reverse!-num


(c!:install 'mkcr '(mkcr !:cr!: striptag) 8740268834466376872)
mkcr


(c!:install 'lalr_prin_rhs '(lalr_prin_rhs "<empty>" " "
lalr_prin_symbol) 14916345468253414621)
lalr_prin_rhs


(c!:install 'cl_nnf '(cl_nnf cl_nnf1) 8829395629140112282)
cl_nnf


(c!:install 'cl_simpl1 '(cl_simpl1 true false or and not ex all !*rlsism
bex ball impl repl equiv cl_simpl "cl_simpl1(): unknown operator"
cl_smsimpl!-junct cl_flip cl_atfp rl_negateat cl_negate!-invol
rl_smrmknowl cl_fvarl cl_simplbq cl_smsimpl!-imprep cl_smsimpl!-equiv
rl_external apply cl_simplat rl_smcpknowl rl_smupdknowl rl_smmkatl
rederr) 7900051791536078423)
cl_simpl1


(c!:install 'pasf_pdp '(pasf_pdp indef ndef pdef psdef nsdef) 
10778362112038030753)
pasf_pdp


(c!:install 'bc_zero!? '(bc_zero!?) 3361078047900863411)
bc_zero!?


(c!:install 'get!-height '(get!-height max) 14864850226468545265)
get!-height


(c!:install 'mchkopt1 '(mchkopt1 mchk) 10998985577953184966)
mchkopt1


(c!:install 'simprecip '(simprecip !*mcd recip carx simpexpt simp invsq)
 13770365170578457092)
simprecip


(c!:install 'rd!:prep '(rd!:prep !*noconvert rdprep1 rd!:onep rd!:minus)
 11603492088250160958)
rd!:prep


(c!:install 'evmtest!? '(evmtest!? evzero!?) 15886030283057574368)
evmtest!?


(c!:install 'expvec2a '(expvec2a dipvars!* expvec2a1) 
3930427775688298587)
expvec2a


(c!:install 'treesizep '(treesizep treesizep1) 10453696496790543754)
treesizep


(c!:install 'ncoeffs '(ncoeffs) 12409446099339202337)
ncoeffs


(c!:install 'next!-random!-number '(next!-random!-number unidev_next!*
unidev_nextp!* unidev_vec!* randommodulus!*) 9218661205682165902)
next!-random!-number


(c!:install 'nfactorial '(nfactorial fac!-part) 11955986384875425120)
nfactorial


(c!:install 'reducepowers '(reducepowers repowl!* multf addf to) 
12483380312515197174)
reducepowers


(c!:install 'setk0 '(setk0 frasc!* setelemfn alglist!* setkfn
setstructfn getrtype let2) 4233801245120844391)
setk0


(c!:install 'gcref_select '(gcref_select defd gcref_nolist!* lastpair) 
7902127832781297365)
gcref_select


(c!:install 'vintersection '(vintersection) 1055362262337549666)
vintersection


(c!:install 'cl_atl '(cl_atl rl_ordatp cl_atl1 sort) 
15765875926403321009)
cl_atl


(c!:install 'pasf_sisub '(pasf_sisub ex all bex ball and true false or
not impl repl equiv pasf_sisub!-gand subf pasf_simplat1) 
12594235870663624231)
pasf_sisub


(c!:install 'dipevlcomp '(dipevlcomp evcompless!?) 9202483066576761064)
dipevlcomp


(c!:install 'assert_format '(assert_format !! !) !  !- !> !, !: !() 
232553727999427196)
assert_format


(c!:install 'mv!-domainlist '(mv!-domainlist nreverse) 
11825405860212261670)
mv!-domainlist


(c!:install 'rnprep!: '(rnprep!: quotient prepf) 9263574273757246310)
rnprep!:


(c!:install 'rootrnd '(rootrnd acc!# rtrnda) 6336503232854120811)
rootrnd


(c!:install 'prin_with_margin '(prin_with_margin explode
print_with_margin_sub) 6076479413304500728)
prin_with_margin


(c!:install 'mk!+unit!+mat '(mk!+unit!+mat gen!+can!+bas) 
14051174035683025759)
mk!+unit!+mat


(c!:install 'fctrf1 '(fctrf1 dmode!* unitsfn lnc !:recip multd comfac
comfac!-to!-poly quotf to multf minusf negf factor!-prim!-f fac!-merge) 
10808334927500479478)
fctrf1


(c!:install 'sfto_b!:ordexn '(sfto_b!:ordexn) 17261733892501122236)
sfto_b!:ordexn


(c!:install 'dm!-gt '(dm!-gt dm!-difference !:minusp) 123006194363475270
)
dm!-gt


(c!:install 'chk '(chk bsubs freexp reval) 17717158727759000305)
chk


(c!:install 'coposp '(coposp contposp covposp) 11725766072842963279)
coposp


(c!:install 'partitexdf '(partitexdf partitop exdfpf) 
7123755117058510409)
partitexdf


(c!:install 'inttovec!-solve '(inttovec!-solve) 14272456348591913501)
inttovec!-solve


(c!:install 'contr2!-strand '(contr2!-strand contrsp contr2) 
12378258184561139660)
contr2!-strand


(c!:install 'sf2mv1 '(sf2mv1 nzeros) 1882801885337988282)
sf2mv1


(c!:install '!:rn2rd '(!:rn2rd !*roundall !*rounded !*rn2rd) 
10693778180305933844)
!:rn2rd


(c!:install 'tensorp '(tensorp tensor) 17302022901939332459)
tensorp


(c!:install 'ilcm '(ilcm) 2240973133276570764)
ilcm


(c!:install 'general!-reciprocal!-by!-gcd '(general!-reciprocal!-by!-gcd
alg "Invalid modular division" current!-modulus rerror) 
9632722898683028321)
general!-reciprocal!-by!-gcd


(c!:install 'lalr_precalculate_first_sets '(lalr_precalculate_first_sets
nonterminals lalr_first (nil) lalr_productions union) 
18330027650390435958)
lalr_precalculate_first_sets


(c!:install 'squared!+matrix!+p '(squared!+matrix!+p matrix!+p
get!+row!+nr get!+col!+nr) 14307445742045415676)
squared!+matrix!+p


(c!:install 'cl_flip '(cl_flip and or all ex ball bex true false
"cl_flip(): don't know" rederr) 5068947937171819402)
cl_flip


(c!:install 'rl_susitf '(rl_susitf rl_susitf!* apply) 
2152268618212021997)
rl_susitf


(c!:install 'vsl_boundtype '(vsl_boundtype vsl_boundtype1) 
3575532393259757734)
vsl_boundtype


(c!:install 'sfto_b!:extmult '(sfto_b!:extmult sfto_b!:ordexn multf negf
sfto_b!:extadd) 16650362805446348592)
sfto_b!:extmult



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u21.lsp"

Reading "$reduce/cslbuild/generated-c/u22.lsp"

% u22.lsp           Machine generated Lisp

(c!:install "u22" 115631 7526481 6375096)
nil


(c!:install 'ps!:expt!-erule '(ps!:expt!-erule ps quotient ps!:order
ps!:evaluate prepsqxx simpexpt multsq addsq quotsq) 4861335937420962614)
ps!:expt!-erule


(c!:install 'setmat '(setmat !*modular modular mod_was_on !*mod_was_on
off on reval simp mk!*sq letmtr) 10636488396691815209)
setmat


(c!:install 'coordp '(coordp coord!*) 11743679015531548263)
coordp


(c!:install 'indord2 '(indord2 indordp) 6229707147736923103)
indord2


(c!:install 'begin11 '(begin11 errmsg!* newrule!* cursym!* end
!*lisp_hook !*semicol!* curescaped!* !*nosave!* !*reduce4 retry
programl!* "No previous expression" program!* c eof!* (bye quit) bye
!*byeflag!* ed cedit "ED not supported" !*defn erfg!* key!* ignore quote
eval !*output ifl!* !*echo !*lessspace ulimit!* err2 symbolic noval
semic!* !$ !*debug "Value:" print !*mode assgnpri list only err3
"of type: " terminalp comm1 lprim eofcheck add2inputbuf getd lispeval
dfprint errorset_with_timeout errorset!* errorp getsetvars mkobject type
value add2resultbuf prin2t rapply1) 7088378187182402808)
begin11


(c!:install 'mv!-pow!-mv!-!+ '(mv!-pow!-mv!-!+ nreverse
mv!-pow!-mv!-term!-!+) 1405175115176094435)
mv!-pow!-mv!-!+


(c!:install 'moid_member '(moid_member mo_vdivides!?) 
8335995647837504883)
moid_member


(c!:install 'arglist_member '(arglist_member mvar_member) 
1448133497086074019)
arglist_member


(c!:install 'exc '(exc) 3033767915002397882)
exc


(c!:install 'sfto_kexp '(sfto_kexp to) 16941872972440124794)
sfto_kexp


(c!:install 'gcref_mkgraph '(gcref_mkgraph !*gcrefudg gcref_mkgraph!-udg
gcref_mkgraph!-tgf) 16501711106482065827)
gcref_mkgraph


(c!:install 'setqget '(setqget fluidbibasissetq) 3614657392984134839)
setqget


(c!:install 'ezgcdf1 '(ezgcdf1 factor!-level gcdlist poly!-abs) 
12619626237804511922)
ezgcdf1


(c!:install 'talp_eqnrhskernels '(talp_eqnrhskernels talp_varlt) 
15705245276850491214)
talp_eqnrhskernels


(c!:install 'ctx_new '(ctx_new ctx) 16190024625074221445)
ctx_new


(c!:install 'evaluate!-mod!-p '(evaluate!-mod!-p
"Variable=NIL in evaluate-mod-p" errorf horner!-rule!-mod!-p) 
8495381782169598297)
evaluate!-mod!-p


(c!:install 'getsetvars '(getsetvars (setel setk) setq nreverse
getsetvarlis) 18250301885244068347)
getsetvars


(c!:install 'ps!:minusp!: '(ps!:minusp!:) 12865032380111219041)
ps!:minusp!:


(c!:install 'xdegreecheck '(xdegreecheck xtruncate!* xdegree) 
16134868831849171205)
xdegreecheck


(c!:install 'indordp '(indordp indxl!*) 12196739466098183865)
indordp


(c!:install 'symbvarlst '(symbvarlst symbolic !*novarmsg
"local variable" "in procedure" fname!* "not used" lprim) 
11880543463868967817)
symbvarlst


(c!:install 'mv!-domainlist!-!+ '(mv!-domainlist!-!+ nreverse) 
8590847628761397511)
mv!-domainlist!-!+


(c!:install 'qremd '(qremd dmode!* !:recip multd !:divide qremf multf
praddf) 10425066619628788925)
qremd


(c!:install 'ad_numsort '(ad_numsort lambda_ygm6np4pcqv31 sort) 
16543228242407104281)
ad_numsort


(c!:install 'lambda_ygm6np4pcqv31 '(lambda_ygm6np4pcqv31) 
15088082726560262194)
lambda_ygm6np4pcqv31


(c!:install 'cde_delete '(cde_delete) 9823375113000725104)
cde_delete


(c!:install 'derivative!-mod!-p!-1 '(derivative!-mod!-p!-1
multiply!-by!-constant!-mod!-p mksp) 10394859023526844875)
derivative!-mod!-p!-1


(c!:install 'collect_cdrs '(collect_cdrs nreverse) 7170354752017259199)
collect_cdrs


(c!:install 'pasf_simplat1 '(pasf_simplat1 true false (cong ncong) (
equal neq) !*rlsifac pasf_zcong pasf_mkpos pasf_dt pasf_vf pasf_mr
pasf_cecong pasf_ceeq pasf_cein pasf_sc pasf_se pasf_or pasf_fact) 
16069071823626386981)
pasf_simplat1


(c!:install 'reln '(reln "<apply>" "<" "/" "</apply>" printout
attributesml indent!* multi_elem) 6783350485341983158)
reln


(c!:install 'diffsq '(diffsq difff multsq negsq addsq) 
16022676321092207227)
diffsq


(c!:install 'wedgek2 '(wedgek2 wedge deg!*form wedgef mksgnsq multpfsq
wedgewedge worderp multf addf wedgepf2) 3773862610735621281)
wedgek2


(c!:install 'fortexp '(fortexp fortexp1) 2129437788835831713)
fortexp


(c!:install 'repartf '(repartf i kord!* cmpxfn reorder int!-equiv!-chk
multf addf) 14224353227990139716)
repartf


(c!:install 'assert_uninstall1 '(assert_uninstall1 assert_installed
"assert not installed for" assert_noassertfn lprim copyd) 
607520633056819972)
assert_uninstall1


(c!:install 'setel1 '(setel1 "array index" rlisp "Array out of bounds"
typerr rerror) 3794863250471577185)
setel1


(c!:install 'fs!:times '(fs!:times fs!:timesterm fs!:plus) 
15873497473748151398)
fs!:times


(c!:install 'splitlist!: '(splitlist!: nreverse) 18308525391940220589)
splitlist!:


(c!:install 'resimpf '(resimpf varstack!* subf1) 2301003585008741541)
resimpf


(c!:install 'crprcd2 '(crprcd2 yy!! crprcd) 9422509343997585347)
crprcd2


(c!:install 'aex_mvar '(aex_mvar aex_ex sfto_mvarx) 825715285579730944)
aex_mvar


(c!:install '!*!*a2s '(!*!*a2s "tell Hearn!!" nochange getel random
lambda (!*uncached) progn (declare (special !*uncached)) !*!*a2sfn
rederr smember) 3091982019534209199)
!*!*a2s


(c!:install 'groebcplistsortin1 '(groebcplistsortin1 groebcpcompless!?) 
2335539680124099030)
groebcplistsortin1


(c!:install 'bytelist2id '(bytelist2id list2string) 12064254433591601924
)
bytelist2id


(c!:install 'mktails1 '(mktails1 replace_by_vector getroad mkinds) 
4039047385005761530)
mktails1


(c!:install 'one!-entry!-listp '(one!-entry!-listp one!-entryp) 
4274742246768401682)
one!-entry!-listp


(c!:install 'setelv '(setelv reval_without_mod setel) 
10897900906222372279)
setelv


(c!:install 'prepd1 '(prepd1 prepfn) 17356533224157260373)
prepd1


(c!:install 'pst_termnodep '(pst_termnodep) 9722157953327035154)
pst_termnodep


(c!:install 'ratn '(ratn !:rn!: arnum "Illegal domain in :ar:" rerror) 
11435966345470479614)
ratn


(c!:install 'quotfail!-in!-vector '(quotfail!-in!-vector
"Attempt to divide by zero" "Bad degrees in quotfail-in-vector"
"Quotient not exact in quotfail!-in!-vector" errorf) 2449513729194402360
)
quotfail!-in!-vector


(c!:install 'subsublis '(subsublis sqrt expt (quotient 1 2) subfunc !*sq
prepsq) 11015806341792197022)
subsublis


(c!:install 'homogp '(homogp lastnondomain listsum) 10718859950017304996
)
homogp


(c!:install 'unaryrd '(unaryrd mathml lex) 13082927852549454775)
unaryrd


(c!:install 'inttovec1 '(inttovec1 inttovec!-solve) 6831836483047742586)
inttovec1


(c!:install 'mkfortterpri '(mkfortterpri fortterpri) 
11375405539389178281)
mkfortterpri


(c!:install 'trwrite '(trwrite "**in procedure: ") 2614111771358147492)
trwrite


(c!:install 'lienjactest '(lienjactest lie_jtest difference plus times
lie_cc aeval setk aeval!* aminusp!: evalneq) 10602272048410938972)
lienjactest



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u22.lsp"

Reading "$reduce/cslbuild/generated-c/u23.lsp"

% u23.lsp           Machine generated Lisp

(c!:install "u23" 102378 8773268 1936030)
nil


(c!:install 'arplus!: '(arplus!: dmode!* !*exp !:ar!: addf) 
7059790470572779135)
arplus!:


(c!:install 'gfk '(gfk) 11262899965118494565)
gfk


(c!:install 'coeffs '(coeffs) 12529034742237044805)
coeffs


(c!:install 'dfprint '(dfprint dfprint!* cmsg!* progn lispapply
prettyprint) 2450076919034117572)
dfprint


(c!:install 'monomwrite '(monomwrite fluidbibasisnumberofvariables
fluidbibasisreversedvariables) 9581876070223371965)
monomwrite


(c!:install 'mkpartitions1 '(mkpartitions1) 7819729771628254956)
mkpartitions1


(c!:install 'rl_atnum '(rl_atnum rl_atnum!* apply) 8237877010188341013)
rl_atnum


(c!:install 'tayexp!-times2 '(tayexp!-times2 !*i2rn rntimes!:) 
13349100696667971078)
tayexp!-times2


(c!:install 'talp_subt '(talp_subt) 13420465045802095597)
talp_subt


(c!:install 'qqe_arg!-check '(qqe_arg!-check
"some arguments are not of queue type"
"some arguments are not of basic type" qqe_rqopp qqe_arg!-check!-lq!-rq
qqe_rbopp qqe_arg!-check!-lb!-rb qqe_qopheadp qqe_qoptailp
qqe_arg!-check!-q qqe_arg!-check!-marked!-ids!-rollback typerr
qqe_qopaddp qqe_arg!-check!-lb!-rq qqe_arg!-check!-b) 
5175762209027666479)
qqe_arg!-check


(c!:install 'sq2sstm '(sq2sstm mkzl sq2sscfpl mapins) 
5071099399776619737)
sq2sstm


(c!:install 'reform!-minus '(reform!-minus minus quotient) 
15276675690354575397)
reform!-minus


(c!:install 'dm!-minus '(dm!-minus !:minus) 10290397497140270953)
dm!-minus


(c!:install 'dip!-nc!-ev!-prod1 '(dip!-nc!-ev!-prod1 dip!-nc!-ev!-prod2)
 12179655020623235541)
dip!-nc!-ev!-prod1


(c!:install 'evgradlexcomp '(evgradlexcomp (0) iequal evtdeg) 
8775094928344431027)
evgradlexcomp


(c!:install 'collectphystype '(collectphystype physopp getphystype
deletemult!*) 13475269568287233990)
collectphystype


(c!:install 'replace1_parents '(replace1_parents replace2_parents) 
13308275718975735306)
replace1_parents


(c!:install 'pairxvars '(pairxvars scalar "Invalid parameter:" symerr
reversip!*) 9833767818965482635)
pairxvars


(c!:install 'scalprod '(scalprod matrix "Matrix mismatch" rerror multsq
addsq) 4771978532570979384)
scalprod


(c!:install 'simp!-prop!-order '(simp!-prop!-order prop!*) 
16175865636005428393)
simp!-prop!-order


(c!:install 'yypeek '(yypeek lex_char lex_peek_char yyreadch) 
11241116925781033268)
yypeek


(c!:install 'readprogn '(readprogn group cursym!* !*rsqbkt!* progn xread
aconc!* scan) 7154270127887575700)
readprogn


(c!:install 'rl_pnf '(rl_pnf rl_pnf!* apply) 5865664319110270144)
rl_pnf


(c!:install 'mri_pasf2mri '(mri_pasf2mri mri_pasf2mriat cl_apply2ats1) 
8416386070996061376)
mri_pasf2mri


(c!:install 'pasf_dt '(pasf_dt true false pdef (equal lessp leq) ndef (
equal greaterp geq) (neq greaterp geq) (neq lessp leq) psdef lessp nsdef
greaterp geq leq neq pasf_pdp) 7109903246663199772)
pasf_dt


(c!:install 'naryom '(naryom name var variance valid_om!* multiset
"<OMA>" indent "<OMS cd=""" """ name=""" """>" "</OMA>" printout multiom
) 1863984661094821308)
naryom


(c!:install 'subs4q '(subs4q slash opmtch slash!* quotient minus prepsq
reval simp!*) 7954872445197849127)
subs4q


(c!:install 'makeset '(makeset nreverse) 11107701159491364533)
makeset


(c!:install 'my_letmtr '(my_letmtr mat matrix "Matrix" "not set" hold
rerror reval numlis errpri2 nth pnth) 9315658091723113449)
my_letmtr


(c!:install 'xlcm '(xlcm nreverse factorordp) 13778369026778086959)
xlcm


(c!:install 'physopordchk '(physopordchk unit !*collectphysops
deletemult!* physopordchk!*) 14036063770928138049)
physopordchk


(c!:install 'def_edge '(def_edge) 16483285871857897044)
def_edge


(c!:install 'total!-degree!-in!-powers '(total!-degree!-in!-powers) 
12861997838909760792)
total!-degree!-in!-powers


(c!:install 'set!-global!-mode '(set!-global!-mode alglist!* !*mode null
setq) 15706706440601802369)
set!-global!-mode


(c!:install 'setel '(setel dimension rlisp "Incorrect array reference"
rerror setel1) 1520989627832643292)
setel


(c!:install 'groeb!=weight '(groeb!=weight mo_ecart bas_dpecart) 
12998200401714520111)
groeb!=weight


(c!:install 'general!-modular!-expt '(general!-modular!-expt alg
"0^0 formed" current!-modulus rerror primep general!-modular!-times
reverse!-num) 3819843854313685478)
general!-modular!-expt


(c!:install 'let2 '(let2 typeletfn direct frasc!* !*sq!* frlis!* mcond!*
"Unmatched free variable(s)" hold erfg!* getel immediate getrtype
lispapply errpri1 prepsq!* smemql setdiff lprie lispeval reval let3) 
12445699434854815159)
let2


(c!:install 'ordered!-gcd!-mod!-p '(ordered!-gcd!-mod!-p
reduction!-count reduce!-degree!-mod!-p monic!-mod!-p) 
819731155986328946)
ordered!-gcd!-mod!-p


(c!:install 'p_prinl2 '(p_prinl2 !*print!-level!* "#"
!*prinl_visited_nodes!* "=" "%(" !*print!-array!* !*print!-length!*
"..." ")" "(" "." p_princ gensymp p_prin gethash p_printref puthash) 
5430378124993520759)
p_prinl2


(c!:install 'talp_contains '(talp_contains) 10024885115666677780)
talp_contains


(c!:install 'qqe_eta!-in!-term '(qqe_eta!-in!-term (lhead rhead) qqe_op
qqe_eta!-in!-term1) 14466547472113716384)
qqe_eta!-in!-term


(c!:install 'ev_lexcomp '(ev_lexcomp iequal) 9797634101757613345)
ev_lexcomp


(c!:install 'row '(row expression) 10105843944902245972)
row


(c!:install 'xregister_wedge_pair '(xregister_wedge_pair) 
2318582258318504441)
xregister_wedge_pair


(c!:install 'gfdot '(gfdot gffdot gbfdot) 6877995353456363923)
gfdot


(c!:install '!:dmpluslst '(!:dmpluslst !:plus) 12550138157027600873)
!:dmpluslst


(c!:install 'putd '(putd funarg lambda "+++ " " not defined (LOSE flag)"
!*redefmsg " redefined" expr subr macro dm fexpr df
"Bad type ~S in putd" getd eval error) 7201762993093866511)
putd



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u23.lsp"

Reading "$reduce/cslbuild/generated-c/u24.lsp"

% u24.lsp           Machine generated Lisp

(c!:install "u24" 63807 1997501 6377117)
nil


(c!:install 'fs!:null!-angle '(fs!:null!-angle) 3383869902414511148)
fs!:null!-angle


(c!:install 'mo_equal!? '(mo_equal!? mo!=shorten) 15670774049899212826)
mo_equal!?


(c!:install 'st_sorttree '(st_sorttree st_sorttree1) 
15826997532839114877)
st_sorttree


(c!:install 'rlis '(rlis cursym!* !*reduce4 list lambda scan xread1
remcomma) 9247412777344633249)
rlis


(c!:install 'settinsert '(settinsert fluidbibasissett janettreeinsert) 
3518626782088466338)
settinsert


(c!:install 'get!*elements '(get!*elements elems) 8511605685852624688)
get!*elements


(c!:install 'dipcondense '(dipcondense dipevlist!* evcompless!? setcar
setcdr) 6483285118047512193)
dipcondense


(c!:install 'cut!:ep '(cut!:ep !:rd!: ashift bflerrmsg) 
4612005151744339248)
cut!:ep


(c!:install 'splitcomplex '(splitcomplex kord!* !*exp i expand!-imrepart
setkorder reorder subs2 take!-realpart take!-impart) 3105496883616040383
)
splitcomplex


(c!:install 'fs!:prin1 '(fs!:prin1 (1 . 1) "(" ")" "[" "-" "+"
fourier!-name!* "]" "1" prin2!* sqprint fs!:null!-angle) 
9305787713891364547)
fs!:prin1


(c!:install 'mo_lcm '(mo_lcm mo!=shorten mo!=deglist) 
3795952519888807833)
mo_lcm


(c!:install 'numlist_ordp '(numlist_ordp lambda_ygm6np4pcqv31 cons_ordp)
 12358394684798595155)
numlist_ordp


(c!:install 'lambda_ygm6np4pcqv31 '(lambda_ygm6np4pcqv31) 
15088082726560262194)
lambda_ygm6np4pcqv31


(c!:install 'remlocs '(remlocs !*globals locls!* begin " Lvar confused"
getd rederr error efface1) 12877371633144329667)
remlocs


(c!:install 'revalx '(revalx prepf reval) 8156248349020697701)
revalx


(c!:install 'rl_subalchk '(rl_subalchk rl_subalchk!* apply) 
1071720324883903940)
rl_subalchk


(c!:install 'pasf_zcong '(pasf_zcong (cong ncong) true false cong equal
neq ncong) 9907286930392888463)
pasf_zcong


(c!:install 'vdp_setsugar '(vdp_setsugar !*cgbsugar sugar vdp_putprop) 
11726319010469162367)
vdp_setsugar


(c!:install 'ps!:prepfn!: '(ps!:prepfn!:) 13254149713916799606)
ps!:prepfn!:


(c!:install 'ps!:putv '(ps!:putv !:ps!: tps "PS:PUTV: not a ps" eval
rerror) 1552922531143688513)
ps!:putv


(c!:install 'mktails '(mktails mktails1) 7834943372407695769)
mktails


(c!:install 'impartf '(impartf i kord!* cmpxfn reorder int!-equiv!-chk
addf multf) 6890187095049936448)
impartf


(c!:install 'riv_mk '(riv_mk iv) 9551821334654506150)
riv_mk


(c!:install 'aex_bvarl '(aex_bvarl aex_ctx ctx_idl) 18423336960980571701
)
aex_bvarl


(c!:install 'gcref_mkgraph!-tgf '(gcref_mkgraph!-tgf "#" calls
gcref_mknode!-tgf prin2t gcref_select gcref_mkedges!-tgf) 
8872697914026949222)
gcref_mkgraph!-tgf


(c!:install 'polynomlistreduce '(polynomlistreduce
polynomlistfinddivisor polynomreduceby polynomadd) 15512609324025294193)
polynomlistreduce


(c!:install 'opmtchrevop '(opmtchrevop !*val cons opmtch revlis) 
13637205868658300566)
opmtchrevop


(c!:install 'rl_eqnrhskernels '(rl_eqnrhskernels rl_eqnrhskernels!*
apply) 6620829222149597660)
rl_eqnrhskernels


(c!:install 'pasf_floor '(pasf_floor
"pasf_floor: not a domain valued sf in input" simp rederr) 
10610016429591635276)
pasf_floor


(c!:install 'bvarml '(bvarml "<bvar>" "</bvar>" printout indent!*
expression degreeml) 3283176515209679123)
bvarml


(c!:install 'band_matrix '(band_matrix
"Error in band_matrix(second argument): should be an integer." list
"Error in band_matrix(first argument): should be single value or list."
"Error in band matrix(first argument): number of elements must be odd."
quotient
"Error in band_matrix: too many elements. Band matrix is overflowing."
rederr reval mkmatrix nth setmat) 16171003517197563785)
band_matrix


(c!:install 'rd!:zerop!: '(rd!:zerop!: ft!:zerop round!* bfzerop!:) 
12671832289279500242)
rd!:zerop!:


(c!:install 'flatindl '(flatindl) 3390827990497104525)
flatindl


(c!:install 'formcond1 '(formcond1 nreverse formbool formc) 
7968214462921130653)
formcond1


(c!:install 'red_totalred '(red_totalred red_topred red_tailred) 
3900870141701127444)
red_totalred


(c!:install 'ilog2 '(ilog2 terrlst) 14882263704089128087)
ilog2


(c!:install 'lalr_prin_production '(lalr_prin_production " -> "
lalr_prin_symbol lalr_prin_rhs) 1726331608870260106)
lalr_prin_production


(c!:install 'defineargs '(defineargs name calledby hasarg instdof) 
18221869149588598285)
defineargs


(c!:install 'ofsf_ignshift '(ofsf_ignshift !*rlpos (equal neq) ignore
odd sfto_reorder) 4450930137153555454)
ofsf_ignshift


(c!:install 'tripleisprolongedby '(tripleisprolongedby) 
16701626957021610102)
tripleisprolongedby


(c!:install 'ofsf_smupdknowl '(ofsf_smupdknowl and false ofsf_negateat
ofsf_at2ir ofsf_sminsert setcdr) 17253290331117133432)
ofsf_smupdknowl


(c!:install 'cl_smsimpl!-junct1 '(cl_smsimpl!-junct1 !*rlsiidem true
false or and not impl repl equiv ex all bex ball cl_simpl1 cl_atfp
cl_flip rl_smupdknowl cl_smsimpl!-junct2) 5937380600637357641)
cl_smsimpl!-junct1


(c!:install 'om2ir '(om2ir (safe_atts char ch atts count temp space
temp2) space count ch temp2 char (o m o b j) "<omobj>" (!/ o m o b j)
"</omobj>" fluid list2string lex omobj errorml) 9072379775066504802)
om2ir


(c!:install 'mkmatrix '(mkmatrix mat) 13518421484045359134)
mkmatrix


(c!:install 'setdmode '(setdmode complex!-rational dmode!* complex
rational complex!-rounded rounded tag poly "Domain mode error:"
"is not a domain mode" package!-name !*complex onoff rerror
load!-package setcmpxmode setdmode1) 12705680654026163510)
setdmode


(c!:install 'gbfdot '(gbfdot csl_timbf plubf) 17363441284553368076)
gbfdot


(c!:install 'r2findindex '(r2findindex r2findindex1) 
14570535399614019817)
r2findindex


(c!:install 'comblog '(comblog domainlist!* plus times log nreverse
simp!* clogsq prepsq!*) 2258708424463560692)
comblog


(c!:install 'assert_check1 '(assert_check1 !*assertstatistics
assertstatistics!* assert_dyntypechk assert_ignore setcar apply
assert_error) 13554576978207690733)
assert_check1


(c!:install 'matop_pseudomod '(matop_pseudomod mod!*) 
7244224576917796558)
matop_pseudomod


(c!:install 'gcdout '(gcdout !*modular ljet ord gcdf!* pcdiv) 
11180239844353890253)
gcdout



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u24.lsp"

Reading "$reduce/cslbuild/generated-c/u25.lsp"

% u25.lsp           Machine generated Lisp

(c!:install "u25" 34501 2156620 9770729)
nil


(c!:install 'pa_coinc_split '(pa_coinc_split lambda_er1ez819f9yx2 upbve
sort) 126824076894980172)
pa_coinc_split


(c!:install 'lambda_er1ez819f9yx2 '(lambda_er1ez819f9yx2) 
13794168774309563647)
lambda_er1ez819f9yx2


(c!:install 'cde_position '(cde_position cde_position2) 
238037469412860599)
cde_position


(c!:install 'lto_sgnchg1 '(lto_sgnchg1 sgn) 261130623156442352)
lto_sgnchg1


(c!:install 'cl_pnf '(cl_pnf rl_nnf cl_pnf1) 8997355690223370541)
cl_pnf


(c!:install 'mri_prepat '(mri_prepat mri_2pasfat pasf_prepat) 
17918178496807478614)
mri_prepat


(c!:install 'vdp_make '(vdp_make vdp) 11832810818583622840)
vdp_make


(c!:install 'max!-degree '(max!-degree) 7631694807477571889)
max!-degree


(c!:install 'binaryrd '(binaryrd mathml lex) 8449682339876615316)
binaryrd


(c!:install 'rationalizesq '(rationalizesq !*structure !*sub2 dmode!*
rationalizefn (i 2 (nil . t) -1 nil) powlis!* !*algint !*rationalize
subs2q rationalizef multf gcdchk) 618899159186762670)
rationalizesq


(c!:install 'delhisto '(delhisto codmat maxvar codhisto min) 
12626252279824721122)
delhisto


(c!:install 'quoteequation '(quoteequation equation) 
13869360566276034417)
quoteequation


(c!:install 'gvarlis1 '(gvarlis1 gvar1 union) 15887984567229666111)
gvarlis1


(c!:install 'bcneg '(bcneg !*grmod!* current!-modulus negsq) 
10888953695802130557)
bcneg


(c!:install 'physopsimp '(physopsimp !*sq tensdimen antisymmetric minus
isanindex isavarindex physopsm!* prepsqxx opmtch!* scalopp tensopp nth
pnth ordn repeats permp vecopp listp putanewindex!*) 
17378261404484775512)
physopsimp


(c!:install 'ev!-denom2 '(ev!-denom2 ev!-edgeloop) 10469132586978593068)
ev!-denom2


(c!:install 'copy!-tree '(copy!-tree) 12578162027246836564)
copy!-tree


(c!:install 'safe!-modrecip '(safe!-modrecip !*msg !*protfg !:mod!:
general!-modular!-reciprocal erfg!* errorset errorp) 
14808290800131132436)
safe!-modrecip


(c!:install 'setk_super_vectorfield '(setk_super_vectorfield ext
variables "SETK_SUPER_VECTORFIELD:" "not a valid variable for" let2
msgpri) 16746388325699725758)
setk_super_vectorfield


(c!:install 'lalr_construct_fn '(lalr_construct_fn g lambda !*pwrds expr
lalr_make_arglist putd) 12504191962287692232)
lalr_construct_fn


(c!:install 'ctx_idl '(ctx_idl ctx_ial) 4891428736571764658)
ctx_idl


(c!:install 'wupseudodivide '(wupseudodivide setkorder reorder
wuconstantp gcdf!* quotf multf exptf qremf) 18397524205360628269)
wupseudodivide


(c!:install 'evaluatecoeffts '(evaluatecoeffts indexlist valuecoefft
!*multf addf) 5406277702025676168)
evaluatecoeffts


(c!:install 'vdp_getprop '(vdp_getprop vdp_plist) 10290374778868375321)
vdp_getprop


(c!:install 'dip_condense '(dip_condense) 7708418469248712677)
dip_condense


(c!:install 'mml2ir '(mml2ir mmlatts space count ch temp2 char (m a t h)
"<math>" (!/ m a t h) "</math>" list2string lex mathml errorml) 
4937673495003303041)
mml2ir


(c!:install 'pfordp '(pfordp termordp) 8068693215543952127)
pfordp


(c!:install 'prinlatom '(prinlatom font accent name "}" prin2la
testchar1) 6843894542313904978)
prinlatom


(c!:install 'exptpri '(exptpri !*utf8 !*list !*nat !*fort failed expt
!*eraise inbrackets indexprin !*ratpri quotient minus spare!* orig!*
posn!* "(" ")" utf8_exptpri layout!-formula indexpower negnumberchk
terpri!* prin2!* putpline oprin update!-pline) 1764904720989000181)
exptpri


(c!:install 'ordop2 '(ordop2 kord!* ordp) 1870441096632376356)
ordop2


(c!:install 'edges_parents '(edges_parents edge_new_parents) 
7989857538043128579)
edges_parents


(c!:install 'mo_zero '(mo_zero mo!=deglist) 17895098785328054484)
mo_zero


(c!:install '!*di2q0 '(!*di2q0 varlist!* ordering lex ljet pair multsq
addsq) 15148302668535177444)
!*di2q0


(c!:install 'dv_skel2factor1 '(dv_skel2factor1 !~dv !~dva minus listp) 
12834239992638262862)
dv_skel2factor1


(c!:install 'let3 '(let3 rtype avalue typeletfn yetunknowntype errpri1
getrtype lispapply typelet letscalar) 5648133096207602103)
let3


(c!:install 'lalr_print_compressed_action_table '(
lalr_print_compressed_action_table itemset_collection
"=== ACTION TABLE ===" "STATE" "TERMINAL" "ACTION" "<any>"
lalr_prin_symbol lalr_prin_action) 2209936760884675793)
lalr_print_compressed_action_table


(c!:install 'ofsf_subf '(ofsf_subf exptsq multsq addsq ofsf_pow2q) 
4899546410971666941)
ofsf_subf


(c!:install 'simpexpt11 '(simpexpt11 !*precise_complex simpexpt2 qremf
simpexpt1 multsq) 18016535449379762626)
simpexpt11


(c!:install 'quotelog '(quotelog logical) 17183556804632955927)
quotelog


(c!:install 'encodeir '(encodeir name char !  atts !$ semantic delall) 
1922988493163827553)
encodeir


(c!:install 'simpdf!* '(simpdf!* simpdf rootextractsq resimp) 
8201007124404162639)
simpdf!*


(c!:install 'evdif '(evdif (0)) 15090522352339989988)
evdif


(c!:install 'evaluate1 '(evaluate1 i dmode!* ivalue (nil)
"i used as indeterminate value" e pi !*evaluateerror "number"
force!-to!-dm apply rederr simp typerr evaluate2) 6309802894990943255)
evaluate1


(c!:install 'assert_install1 '(assert_install1 assert_installed
"assert already installed for" expr
"is not an expr procedure - ignoring assert" assert_noassertfn
assert_assertfn lprim getd copyd) 13732944119485760763)
assert_install1


(c!:install 'red!=cancelsimp '(red!=cancelsimp red_better bas_dpoly
dp_lmon mo_vdivides!?) 11561457350048644172)
red!=cancelsimp



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u25.lsp"

Reading "$reduce/cslbuild/generated-c/u26.lsp"

% u26.lsp           Machine generated Lisp

(c!:install "u26" 30665 1871264 4815787)
nil


(c!:install 'subs3t '(subs3t mchfg!* !*match subfg!* !*mcd sizchk mtchk
subs3f1 multsq to simpcar sfp simp kernp revop1 noncomp mksp multf
errach) 12893971692949833183)
subs3t


(c!:install 'dmconv0 '(dmconv0 !:rn!: !:gi!: !:crn!: dmd!*) 
1800770221870508758)
dmconv0


(c!:install 'ra_zerop '(ra_zerop ra_f) 156004460642436359)
ra_zerop


(c!:install 'refprint '(refprint cloc!* "*TTYINPUT*" pfiles!* curfun!* g
rccnam curlin!* locls!* globs!* calls!* anform outrefend) 
13080195673109096165)
refprint


(c!:install 'cl_f2ml '(cl_f2ml true false or and not impl repl equiv
plus2 ex all bex ball lto_almerge apply) 11115652893289182625)
cl_f2ml


(c!:install 'ofsf_at2ir '(ofsf_at2ir negf addf sfto_dcontentf quotf
quotsq) 7906019418542268564)
ofsf_at2ir


(c!:install 'expnd '(expnd !*really_off_exp !*sub2 expnd1 subs2f) 
11413463028146551512)
expnd


(c!:install 'groedeletip '(groedeletip setcdr) 16361312757688004926)
groedeletip


(c!:install 'insertparens '(insertparens !( !)) 9173971090588331245)
insertparens


(c!:install 'can_be_proved '(can_be_proved can_be_p) 
13352769274010193889)
can_be_proved


(c!:install 'log_assignment_list '(log_assignment_list log_assignment) 
3080942992296707352)
log_assignment_list


(c!:install 'dv_cambhead '(dv_cambhead expt minus listp) 
17214961675878932154)
dv_cambhead


(c!:install 'mod_eval_uni_poly '(mod_eval_uni_poly current!-modulus
mod!# general!-modular!-expt general!-modular!-plus) 
13950732281834820421)
mod_eval_uni_poly


(c!:install 'nonlnrsys '(nonlnrsys nonlnr) 16893386471568554588)
nonlnrsys


(c!:install 'lalr_make_arglist '(lalr_make_arglist !$ list2string) 
15120897132663416265)
lalr_make_arglist


(c!:install 'rl_bettergaussp '(rl_bettergaussp rl_bettergaussp!* apply) 
11229114519218706476)
rl_bettergaussp


(c!:install 'texstrlen '(texstrlen !!) 6161493772332996349)
texstrlen


(c!:install 'talp_list2vec '(talp_list2vec) 8253378456129271759)
talp_list2vec


(c!:install 'pasf_cein '(pasf_cein true false (leq greaterp geq lessp) (
leq greaterp) (geq lessp) pasf_deci sfto_dcontentf simp quotfx
pasf_floor negf pasf_ceil addf) 12169585565162376271)
pasf_cein


(c!:install 'unaryir '(unaryir name atts cd find encodeir) 
15303558210222542938)
unaryir


(c!:install 'ps!:evaluate!-next '(ps!:evaluate!-next ps ps!:erule
ps!:getv ps!:expression apply prepsqxx simp!* ps!:set!-term) 
1451468694344642539)
ps!:evaluate!-next


(c!:install 'vdpvevlcomp '(vdpvevlcomp dipevlcomp) 8388747943008313643)
vdpvevlcomp


(c!:install 'random '(random "positive number" unidev_fac!*
randommodulus!* typerr next!-random!-number) 12010203026302926177)
random


(c!:install 'getphystypecar '(getphystypecar getphystype) 
549554832887196808)
getphystypecar


(c!:install 'factorial '(factorial arith "invalid factorial argument"
rerror nfactorial) 6055321892875199978)
factorial


(c!:install 'random!-teeny!-prime '(random!-teeny!-prime all
teeny!-primes next!-random!-number) 10079275317954736717)
random!-teeny!-prime


(c!:install 'sfto_dgcd '(sfto_dgcd sfto_dcontentf sfto_gcdf) 
6977344806463788710)
sfto_dgcd


(c!:install 'outrefend '(outrefend calls!* calls toplv!* cinthis seen
seen!* calledby globs!* globs dclglb usedby gseen gseen!* usedunby
glb2rf glb2bd boundby glb2st setby union traput) 7779423426792506707)
outrefend


(c!:install 'simpcv '(simpcv "Invalid number of edges in vertex"
simpcgraph mul!* cerror aconc!* to) 4386196608547243983)
simpcv


(c!:install 'smemberlp '(smemberlp) 17268134400216882209)
smemberlp


(c!:install 'offexpchk '(offexpchk !*really_off_exp frlis!*
freevarinexptchk mkprod canprod) 8276034125479486993)
offexpchk


(c!:install 'formc!* '(formc!* !*!*a2sfn revalx formc) 
5216374250377475838)
formc!*


(c!:install 'physopordchk!* '(physopordchk!* ncmpchk invp) 
5368466983580771193)
physopordchk!*


(c!:install 'red_topredbe '(red_topredbe " reduce " bas_dpoly cali_trace
dp_print dp_lmon bas_dpecart red_divtestbe red_subst) 
17249925396800045955)
red_topredbe


(c!:install 'trailing!.coefft '(trailing!.coefft) 2741308890144995642)
trailing!.coefft


(c!:install 'gf2cr!: '(gf2cr!: !:cr!: striptag) 11144561141645672652)
gf2cr!:


(c!:install 'extmult '(extmult ordexn c!:subs2multf negf extadd) 
12972388777221124706)
extmult


(c!:install 'add2locs '(add2locs !*globals locls!* dclglb
"*** Variable " " nested declaration in " curfun!* glb2rf seen
"*** Function " " used as variable in " qerline princng newline globind)
 11177705230684184712)
add2locs


(c!:install 'monomcomparedeglex '(monomcomparedeglex) 
1333273324612623854)
monomcomparedeglex


(c!:install 'poly!-multfnc '(poly!-multfnc !*sstools!-loaded
!*!*processed sstools!-multfnc poly!-multf mkspm addf noncomp) 
4419973584290133566)
poly!-multfnc


(c!:install 'talp_telp '(talp_telp talp_invp talp_fargl) 
17432041448933105265)
talp_telp


(c!:install 'pasf_anegrel '(pasf_anegrel ((equal . equal) (neq . neq) (
leq . geq) (geq . leq) (lessp . greaterp) (greaterp . lessp) (cong .
cong) (ncong . ncong)) "pasf_anegrel: unknown operator " rederr) 
954062315791042135)
pasf_anegrel


(c!:install 'multi_args '(multi_args expression) 3695083030306321180)
multi_args


(c!:install 'getdec '(getdec symtabget implicitdec) 15548304567600766736
)
getdec


(c!:install 'memqcar '(memqcar) 3612662733220245317)
memqcar


(c!:install 'oprinla '(oprinla lapr lapop !  prin2la prinlatom) 
15336934279451026930)
oprinla


(c!:install 'gftimesn '(gftimesn gfftimes times!: difference!: plus!:) 
1300853096705473198)
gftimesn


(c!:install 'fieldconv '(fieldconv dmode!* !:rn!: quotient
"field conversion" dcombine multd errach simpgd divd) 
13145165320174665890)
fieldconv


(c!:install 'repeats '(repeats nreverse) 8853322230546325945)
repeats


(c!:install 'reduce!-mod!-p!* '(reduce!-mod!-p!* current!-modulus
general!-reduce!-mod!-p) 304745808878314680)
reduce!-mod!-p!*



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u26.lsp"

Reading "$reduce/cslbuild/generated-c/u27.lsp"

% u27.lsp           Machine generated Lisp

(c!:install "u27" 113617 1747335 6307610)
nil


(c!:install 'gcd!-in!-vector '(gcd!-in!-vector
"GCD with zero not allowed" errorf remainder!-in!-vector) 
9536082400961573796)
gcd!-in!-vector


(c!:install 'lalr_make_compressed_goto_column '(
lalr_make_compressed_goto_column goto_table gethash
lalr_most_common_dest) 770456876220403427)
lalr_make_compressed_goto_column


(c!:install 'aex_neg '(aex_neg aex_ex negsq aex_ctx aex_mk) 
17068603941868108587)
aex_neg


(c!:install 'innprodp2 '(innprodp2 innprodkp) 7780601364960729965)
innprodp2


(c!:install 'talp_subat '(talp_subat talp_op talp_arg2l talp_subt
talp_arg2r talp_mk2) 11237141710321951797)
talp_subat


(c!:install 'rl_updcache '(rl_updcache rl_bbl!* rl_cid!* rl_params
rl_servl!* rl_services) 9186472453951528676)
rl_updcache


(c!:install 'ioto_form2str1 '(ioto_form2str1 minus !( !) plus !,
ioto_prtb ioto_prtbpar ioto_prtbop) 11177515184618921647)
ioto_form2str1


(c!:install 'lambdafun '(lambdafun) 12041889918379956612)
lambdafun


(c!:install 'ft!:zerop '(ft!:zerop !:prec!:) 12657352824314599557)
ft!:zerop


(c!:install 'oldmtch '(oldmtch mcharg eval) 7900546910151258767)
oldmtch


(c!:install 'dipev2f '(dipev2f to multf) 4228879523329622026)
dipev2f


(c!:install 'sfpx1 '(sfpx1 assert_kernelp to ordpp) 2806206429579137979)
sfpx1


(c!:install 'pcdiv '(pcdiv cdiv) 12670010806150465859)
pcdiv


(c!:install 'sc_rep '(sc_rep g_sc_ve) 2373969952239389182)
sc_rep


(c!:install 'super_der_simp '(super_der_simp variables (ext) ext
even_dimension odd_dimension reval simp!* split_form nth split_ext
even_action odd_action addsq quotsq super_product_sq multf negsq
simpiden) 1026326478841048770)
super_der_simp


(c!:install 'yylex '(yylex lex_symbol_code lex_escaped lexer_style!*
yylval !#define "+++ " " => " !#eval lex_number_code lex_string_code
!*tracelex "yylex = " " type " lex_basic_token land
lex_process_directive read_s_expression errorset) 1838747078068114950)
yylex


(c!:install 'outrdefun '(outrdefun defd function dclglb locls!*
"**** Variable " " defined as function" naryarg naryargs gall curlin!*
globs!* calls!* curfun!* qtypnm recref qerline princng newline
defineargs) 11050453971390909373)
outrdefun


(c!:install 'ofsf_sippsubst '(ofsf_sippsubst ofsf_sippsubst1) 
16344775967043512851)
ofsf_sippsubst


(c!:install 'ofsf_surep '(ofsf_surep true cl_simpl) 17044374422311926793
)
ofsf_surep


(c!:install 'matpri '(matpri matpri1) 18350818851654774337)
matpri


(c!:install 'termorder1 '(termorder1) 8275765336605015274)
termorder1


(c!:install 'sfto_b!:extadd '(sfto_b!:extadd nreverse addf
sfto_b!:ordexp) 14555970045207833266)
sfto_b!:extadd


(c!:install 'matrixrowom '(matrixrowom "<OMA>"
"<OMS cd=""linalg1"" name=""matrixrow""/>" "</OMA>" printout indent!*
multiom) 1732016591589103317)
matrixrowom


(c!:install 'rootextractsq '(rootextractsq subs2q rootextractf) 
11993779801291799899)
rootextractsq


(c!:install 'meq '(meq unbound binding) 5890158521722239333)
meq


(c!:install 'edge_new_parent '(edge_new_parent new_edge_list) 
10693541134564247314)
edge_new_parent


(c!:install 'log_inlines '(log_inlines log_assignment log_freevars) 
4860750300544105035)
log_inlines


(c!:install 'red!=hidelt '(red!=hidelt bas_dpoly bas_nr bas_rep
red!=hide dp_sum bas_make1) 16913627379240696840)
red!=hidelt


(c!:install 'extract_dummy_ids '(extract_dummy_ids dummy_id!* nreverse) 
15585981994205037842)
extract_dummy_ids


(c!:install 'lalr_most_common_dest '(lalr_most_common_dest) 
5788833161221427184)
lalr_most_common_dest


(c!:install 'formrlis '(formrlis flagop list share algebraic !*comma!*
"identifier list" flag reversip!* formlis idlistp typerr) 
7385820666190966159)
formrlis


(c!:install 'get!-free!-form '(get!-free!-form frasc!* !~ (!! !~ !! !~)
(!! !~) optional) 15166660826411836818)
get!-free!-form


(c!:install 'get_char_value '(get_char_value
"error in get character element" rederr) 11725546894135015819)
get_char_value


(c!:install 'qqe_arg!-check!-q '(qqe_arg!-check!-q qqe_id!-nyt!-branchq
qqe_btidp qqe_nytidp qqe_qtid qqe_add2rollbackids qqe_arg!-check) 
3226144097054095863)
qqe_arg!-check!-q


(c!:install 'fortranname '(fortranname !*notfortranfuns!* !*stdout!*
"*** WARNING: " " is not an intrinsic Fortran function" !*double
!*doublename!* !*fortranname!* stringtoatom prin2t) 8730742722275511588)
fortranname


(c!:install 'assert_error '(assert_error !*lower !*assertstatistics
assertstatistics!* "declaration" "violated by result" "violated by" arg
!*assertbreak setcar assert_format mkid rederr lprim) 
6325146045031417776)
assert_error


(c!:install 'nf '(nf gg!* redtails gv!* tred "r e d u c t i o n :  " "/"
stars "*" reductions!* nforms!* zeros!* dless dd gcdf!* cdiv pcmult
dquot pdmult pdif gcdout) 4254518414598757272)
nf


(c!:install 'lalr_make_compressed_action_table '(
lalr_make_compressed_action_table itemset_collection !*lalr_verbose
lalr_make_compressed_action_row lalr_print_compressed_action_table) 
7857996445380963171)
lalr_make_compressed_action_table


(c!:install 'outref '(outref curfun!* calls!* globs!* locls!* toplv!* (
anp!!atom anp!!idb anp!!eq anp!!unknown) anp!!eq sameas alsois outrdefun
add2locs anform remlocs traput add2calls outrefend) 5769129379516808474)
outref


(c!:install 'ofsf_smwmkatl '(ofsf_smwmkatl !*rlsusi cl_susimkatl
ofsf_smmkatl) 14250039879880194131)
ofsf_smwmkatl


(c!:install 'ioto_smaprinbuf '(ioto_smaprinbuf !! rlsmaprinbuf!*) 
18419973655955222314)
ioto_smaprinbuf


(c!:install 'lambdavar '(lambdavar) 13345965240957427380)
lambdavar


(c!:install 'n_nary '(n_nary e power exp "<apply>" "<" "/>" indent
"</apply>" unary printout multi_elem) 17889661689617899542)
n_nary


(c!:install 'gcd2 '(gcd2) 18207054630592118474)
gcd2



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u27.lsp"

Reading "$reduce/cslbuild/generated-c/u28.lsp"

% u28.lsp           Machine generated Lisp

(c!:install "u28" 96065 1706130 30271)
nil


(c!:install 'inprint '(inprint times !*nat !*asterisk times2 infix prtch
" " plus !*revpri not setq tag setprifn inbrackets "(" ")" !*nosplit
testing!-width!* (setq !*comma!*) oprin getrtype prin2!* maprint prinfit
negnumberchk) 5888655686248825375)
inprint


(c!:install 'mksetq '(mksetq setq setfn "assignment argument" typerr) 
1047142451462299460)
mksetq


(c!:install 'general!-evaluate!-mod!-p '(general!-evaluate!-mod!-p
"Variable=NIL in GENERAL-EVALUATE-MOD-P" errorf
general!-horner!-rule!-mod!-p) 11683667927005855121)
general!-evaluate!-mod!-p


(c!:install 'bndtst '(bndtst tentothetenth!*!* abs!: greaterp!:) 
14872575748311463317)
bndtst


(c!:install 'setk1 '(setk1 !*uncached "not found" avalue scalar alg
"Invalid syntax: improper assignment" wtl!* !*sqrtrulep kvalue msgpri
put!-avalue rerror revlis delasc put!-kvalue updoldrules) 
18042705366889534398)
setk1


(c!:install 'lex_export_codes '(lex_export_codes lex_codename ordopcar
sort) 2806139020963600379)
lex_export_codes


(c!:install 'comm1 '(comm1 end cursym!* !*semicol!* (end else then until
!*rpar!* !*rsqbkt!*) "END-COMMENT NO LONGER SUPPORTED" scan lprim) 
12682233057318969179)
comm1


(c!:install 'createtriplewithancestor '(createtriplewithancestor
fluidbibasistripleid) 2496970852756381967)
createtriplewithancestor


(c!:install 'qqe_ofsf_simpat '(qqe_ofsf_simpat (qequal qneq) qqe_arg2l
qqe_ofsf_chsimpterm qqe_arg2r qqe_arg!-check qqe_op qqe_simpat
ofsf_simpat) 15868148505977473450)
qqe_ofsf_simpat


(c!:install 'ev_mtest!? '(ev_mtest!?) 5121257538194335172)
ev_mtest!?


(c!:install 'ombindir '(ombindir (!/ o m b i n d) lex omobj variablesir
tobvarir checktag) 1324113408450774951)
ombindir


(c!:install 'rowdel '(rowdel codmat maxvar delhisto downwght) 
16951615583918496840)
rowdel


(c!:install 'string!-of!-list '(string!-of!-list "" !; lastpair
list2string) 360023129920980546)
string!-of!-list


(c!:install 'rdcos!* '(rdcos!* convprec cos cos!* mkround) 
12803570736682264085)
rdcos!*


(c!:install 'mk!-numr '(mk!-numr difference nreverse) 
1867480981460826744)
mk!-numr


(c!:install 'assert_stat1 '(assert_stat1 !*lpar!*
"expecting '(' in assert but found" cursym!* !*rpar!* !*comma!*
"expecting ',' or ')' in assert but found" scan rederr) 
18363279491029694016)
assert_stat1


(c!:install 'mo_2a '(mo_2a cali!=basering ring_all_names mo!=expvec2a1) 
7244578972536245603)
mo_2a


(c!:install 'lalr_collect_terminals '(lalr_collect_terminals
nonterminals setdiff) 11963650507052955258)
lalr_collect_terminals


(c!:install 'gcref_remprops '(gcref_remprops seen!* (gall calls globs
calledby alsois sameas) (seen cinthis defd) gcref_exportl!* (exported)
gseen!* (usedby usedunby boundby setby) (dclglb gseen glb2rf glb2bd
glb2st) tseen!* funs haveargs!* rempropss remflagss) 
11893567273362530779)
gcref_remprops


(c!:install 'prepreform1 '(prepreform1 (plus difference minus times
quotient) !*sq sqhorner!* prepsq!* simp!*) 9267720552194100395)
prepreform1


(c!:install 'cl_atl1 '(cl_atl1 cl_atml1) 3748637150208340714)
cl_atl1


(c!:install 'internal!-factorf '(internal!-factorf current!-modulus
m!-image!-variable !*kernreverse kernord setkorder reorder minusf negf
comfac comfac!-to!-poly quotf1 factorize!-primitive!-polynomial
distribute!.multiplicity fctrf1 to fac!-merge) 16295624143771728723)
internal!-factorf


(c!:install 'sfto_b!:ordexp '(sfto_b!:ordexp) 17719563479385124546)
sfto_b!:ordexp


(c!:install 'nextcomb '(nextcomb i initcomb) 15020475301782554861)
nextcomb


(c!:install 'gcompatible '(gcompatible gmodule!* gevcompatible1) 
4395588156138570702)
gcompatible


(c!:install 'contr!-strand '(contr!-strand contr1!-strand) 
14991622701045679338)
contr!-strand


(c!:install 'nzero '(nzero nreverse) 15339904031012778709)
nzero


(c!:install 'merge '(merge) 11618120737974801924)
merge


(c!:install 'insert '(insert gg!* dless) 7587831350715892853)
insert


(c!:install 'charnump!: '(charnump!: !0 !1 !2 !3 !4 !5 !6 !7 !8 !9 !10
!11 !12 !13) 6078668565724893638)
charnump!:


(c!:install 'build!-null!-vector '(build!-null!-vector) 
9747352268713284531)
build!-null!-vector


(c!:install 'lalr_generate_collection '(lalr_generate_collection
itemset_collection !*lalr_verbose lalr_lr0_itemset_to_lalr_kernel
lalr_analyze_lookaheads carrassoc lalr_add_lookahead
lalr_propagate_lookaheads lalr_closure lalr_print_collection) 
11474905777161151162)
lalr_generate_collection


(c!:install 'normalform '(normalform fluidbibasisnormalforms
janettreefind polynomheadreduceby polynomadd) 396056162021076215)
normalform


(c!:install 'wureducedp '(wureducedp wuconstantp deginvar) 
5890090197619083285)
wureducedp


(c!:install 'get!-denom!-ll '(get!-denom!-ll nreverse get!-denom!-l lcmn
) 9865865357402086746)
get!-denom!-ll


(c!:install 'mksp!* '(mksp!* kernlp exptf minusf negf mksp) 
13752564552538872899)
mksp!*


(c!:install 'talp_try '(talp_try rl_pnf talp_invtscsimpl talp_lssimpl
talp_try1) 5158418108379367388)
talp_try


(c!:install 'vunion '(vunion) 10411977164311836912)
vunion


(c!:install 'cnrd '(cnrd atts type base char constant (real integer)
based_integer string (rational complex!-cartesian complex!-polar)
rational complex!-cartesian complex_cartesian complex!-polar
complex_polar find lex compress!* seprd) 5452920217414400978)
cnrd


(c!:install 'doublep '(doublep !:rd!:) 620829993394421821)
doublep


(c!:install 'groebsavelterm '(groebsavelterm !*groelterms
groebsaveltermbc) 8937397724607374132)
groebsavelterm


(c!:install 'permp '(permp) 7444515488059382937)
permp


(c!:install 'getphystypeor '(getphystypeor getphystype) 
15248518432785527981)
getphystypeor


(c!:install 'l!-subst '(l!-subst nreverse) 13157143314028632447)
l!-subst


(c!:install 'formde '(formde procedure symbolic expr progn formproc) 
6755753224063973974)
formde


(c!:install 'sqhorner!* '(sqhorner!* !*horner ordl!* kord!* reorder
hornerf hornersq) 11381696496110012456)
sqhorner!*


(c!:install 'delasc '(delasc) 1435038776993638387)
delasc


(c!:install 'lalr_prin_reduction '(lalr_prin_reduction reduction_info
"reduce by #" ": " " -> [" " symbols] " getv16 lalr_prin_nonterminal
getv8 getd prin_with_margin) 10719599618159484594)
lalr_prin_reduction


(c!:install 'co_new '(co_new) 12258803853388898570)
co_new


(c!:install 'ofsf_negateat '(ofsf_negateat ofsf_lnegrel) 
15688301884629082179)
ofsf_negateat


(c!:install 'mk!+conjugate!+sq '(mk!+conjugate!+sq conjsq) 
3432473840545199005)
mk!+conjugate!+sq


(c!:install 'dm!-mkfloat '(dm!-mkfloat !:rd!:) 13213154614696441939)
dm!-mkfloat


(c!:install 'bcfd '(bcfd !*grmod!* !:mod!: "Invalid modular coefficient"
mkbc bcfi rederr) 13380973671788613610)
bcfd


(c!:install 'vevstrictlydivides!? '(vevstrictlydivides!? vevmtest!?) 
5512672298824972725)
vevstrictlydivides!?


(c!:install 'equalreval '(equalreval substitution equal reval evalequal)
 954477476166961243)
equalreval


(c!:install 'contract!-strand '(contract!-strand zero!-roads
contr!-strand) 9470292292988133312)
contract!-strand


(c!:install 'sf2mv '(sf2mv sf2mv1) 6528544541958700990)
sf2mv


(c!:install 'fs!:prepfn!: '(fs!:prepfn!:) 17069206186485597780)
fs!:prepfn!:


(c!:install 'all_sml_opchar '(all_sml_opchar lexer_style!* sml_opchar
land) 12095717356018498271)
all_sml_opchar



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u28.lsp"

Reading "$reduce/cslbuild/generated-c/u29.lsp"

% u29.lsp           Machine generated Lisp

(c!:install "u29" 8587 9814989 8628605)
nil


(c!:install 'mkfil!* '(mkfil!* "file name" typerr eval string!-downcase)
 3379737960481829301)
mkfil!*


(c!:install 'sortedtriplelistinsert '(sortedtriplelistinsert
monomcompare) 2071273669837285275)
sortedtriplelistinsert


(c!:install 'cquotegex '(cquotegex !*guardian gex) 9110622552156672349)
cquotegex


(c!:install 'ofsf_facequal!* '(ofsf_facequal!* !*rlsifac !*rlsiexpla
!*rlsiexpl or equal ofsf_facequal) 18031237623516468984)
ofsf_facequal!*


(c!:install 'talp_copy '(talp_copy) 11070956600525334828)
talp_copy


(c!:install 'factor!-prim!-f '(factor!-prim!-f ncmp!* dmode!*
sqfrfactorfn !*factor factorfn lnc !:recip multd sqfrf
factor!-prim!-sqfree!-f fac!-merge) 8991535671753454553)
factor!-prim!-f


(c!:install 'evrevgradlexcomp '(evrevgradlexcomp (0) iequal evtdeg
evinvlexcomp) 1094894507621156151)
evrevgradlexcomp


(c!:install 'critical_element '(critical_element) 9077207970580493474)
critical_element


(c!:install 'bfplusn '(bfplusn plus!:) 12942028341686078589)
bfplusn


(c!:install 'st_consolidate '(st_consolidate !*) 14539257175106891559)
st_consolidate


(c!:install 'ratminus '(ratminus) 18049951065176878264)
ratminus


(c!:install 'cde_odd_derivatives '(cde_odd_derivatives
n_all_parametric_ext n_all_principal_ext svf_ext mkid super_vectorfield
set_svf) 7059385793284244930)
cde_odd_derivatives


(c!:install 'hasarg '(hasarg name haveargs!* maxarg!* "**** " " has "
" arguments" bldmsg number!-of!-args qerline newline) 
12062232363733440706)
hasarg


(c!:install 'ofsf_posvarp '(ofsf_posvarp and true false or not impl repl
equiv ex all bex ball ofsf_posvarpat) 5415125431123009782)
ofsf_posvarp


(c!:install 'rndifference!: '(rndifference!: mkrn) 3998651677307980197)
rndifference!:


(c!:install 'mk!+trace '(mk!+trace "no square matrix in add" !*sub2
squared!+matrix!+p rederr get!+row!+nr get!+mat!+entry addsq subs2) 
17172931487973600807)
mk!+trace


(c!:install 'talp_specsubat '(talp_specsubat talp_op talp_arg2l
talp_specsubt talp_arg2r talp_mk2 talp_simpat) 13087732386055039465)
talp_specsubat


(c!:install 'vdp_sugar '(vdp_sugar !*cgbsugar sugar vdp_zero!?
vdp_getprop) 15378252953677045083)
vdp_sugar


(c!:install 'unresidp '(unresidp !*reservedops!*) 17723194268344580602)
unresidp


(c!:install 'physop!-multfnc '(physop!-multfnc !*contract2 !*!*processed
physop!-multf physopp mkspm addf noncommuting physop!-ordop) 
16166522819702933346)
physop!-multfnc


(c!:install 'edge_new_parents '(edge_new_parents old_edge_list
edge_new_parent) 4434932712476921496)
edge_new_parents


(c!:install 'groeb!=newpair '(groeb!=newpair bas_dpoly dp_lmon mo_lcm
groeb!=weight) 10758289609240160604)
groeb!=newpair


(c!:install 'quotof '(quotof minus lcx quotofd mksp carx raddf to ordop)
 7735635630518353880)
quotof


(c!:install 'ra_wrapper1 '(ra_wrapper1 off1 apply on1) 
11745660691622589799)
ra_wrapper1


(c!:install 'negind '(negind) 3888326271223543550)
negind


(c!:install 'tayexp!-minus '(tayexp!-minus rnminus!:) 
9378126259797931177)
tayexp!-minus


(c!:install 'cl_rename!-vars '(cl_rename!-vars cl_replace!-varl
cl_rename!-vars1) 18151438177595091197)
cl_rename!-vars


(c!:install 'rl_susipost '(rl_susipost rl_susipost!* apply) 
5661986307684209988)
rl_susipost


(c!:install 'dip_f2dip1 '(dip_f2dip1 bc_fd bc_prod dip_fmon dip_f2dip2
dip_sum) 9099426871510152039)
dip_f2dip1


(c!:install 'omfir '(omfir atts dec name "wrong att" find errorml) 
9251066245444986048)
omfir


(c!:install 'getphystypetimes '(getphystypetimes
"PHYSOP type mismatch in" collectphystype deleteall rederr2) 
13992417970549162867)
getphystypetimes


(c!:install 'prop!-simp2 '(prop!-simp2) 8845509374503537807)
prop!-simp2


(c!:install 'quotpri '(quotpri !*ratpri !*nat !*fort !*list !*mcd failed
dmode!* ratmode ratfunpri1) 9313002402001459369)
quotpri


(c!:install 'red_tailred '(red_tailred !*noetherian red_topred
red_topredbe red_tailreddriver) 14658725045549140417)
red_tailred


(c!:install 'no_dum_varp '(no_dum_varp list splitlist!:) 
10014103318866339878)
no_dum_varp


(c!:install 'arminusp!: '(arminusp!: minusf) 7589179714353625469)
arminusp!:


(c!:install 'idtomind '(idtomind i2m_jetspace!* i2m_jetspace_odd!*) 
3282693554831447091)
idtomind


(c!:install 'expansion_name '(expansion_name lalr_internal_
expansion_count) 15783678150400557790)
expansion_name


(c!:install 'quotkx '(quotkx quotfx1) 10357113706780567590)
quotkx


(c!:install 'ifstat '(ifstat cursym!* then if else cond xread symerr
aconc!* scan xread1) 17341454388754897150)
ifstat


(c!:install 'add!-degrees '(add!-degrees tayexp!-plus2) 
11237719534741168631)
add!-degrees


(c!:install 'cl_sordpl '(cl_sordpl cl_sordp) 121928515430233144)
cl_sordpl


(c!:install 'pasf_or '(pasf_or true false (lessp greaterp leq geq) lessp
leq greaterp geq pasf_deci simp addf negf) 820847617144401066)
pasf_or


(c!:install 'sfto_subfwd '(sfto_subfwd to) 13000020750751605308)
sfto_subfwd


(c!:install 'opfneval '(opfneval noval nosimp fnreval lispeval) 
17387910540412874572)
opfneval


(c!:install 'initarg '(initarg op symm p r identity assoc !*sym!-assoc
mcontract acontract expand i upb comb ident mgenp list!-mgen initcomb) 
11987421245099069190)
initarg


(c!:install 'sc_geq '(sc_geq sc_subtrsq sc_minussq) 4195705267722748303)
sc_geq


(c!:install 'boolvalue!* '(boolvalue!*) 4038980927605819518)
boolvalue!*


(c!:install 'no!-side!-effect!-listp '(no!-side!-effect!-listp
no!-side!-effectp) 850758379198238797)
no!-side!-effect!-listp


(c!:install 'lalr_cleanup '(lalr_cleanup symbols lalr_produces
lalr_first lalr_nonterminal_code) 4255005295855002291)
lalr_cleanup


(c!:install 'open '(open input output append "bad direction ~A in open"
internal!-open error) 14317167635950447697)
open


(c!:install 'pushback '(pushback) 8836067283905998773)
pushback


(c!:install 'talp_getinvfsym '(talp_getinvfsym talp_getextl) 
9177800204687041786)
talp_getinvfsym


(c!:install 'qqe_eta!-in!-term1 '(qqe_eta!-in!-term1 qepsilon
qqe_simplterm qqe_op) 3218916659083563987)
qqe_eta!-in!-term1


(c!:install 'pasf_fact '(pasf_fact true false (equal neq) equal or and (
leq lessp geq greaterp) fctrf minusf pasf_anegrel pasf_fact1) 
12536055379840675589)
pasf_fact


(c!:install 'acfsf_0mk2 '(acfsf_0mk2) 3673531778556882783)
acfsf_0mk2


(c!:install 'degree!-order '(degree!-order) 3790283495092693237)
degree!-order


(c!:install 'lambdaom '(lambdaom "<OMBIND>"
"<OMS cd=""fns1"" name=""lambda""/>" "<OMBVAR>" "</OMBVAR>" "</OMBIND>"
printout indent!* objectom) 847063321728976000)
lambdaom


(c!:install 'inprinla '(inprinla alt maprintla oprinla negnumberchk) 
14378767123408814437)
inprinla



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u29.lsp"

Reading "$reduce/cslbuild/generated-c/u30.lsp"

% u30.lsp           Machine generated Lisp

(c!:install "u30" 169932 8869143 2112391)
nil


(c!:install 'pterpri '(pterpri !*pprinbuf!* !*outchanl!* gentranlang!*
fortran !*posn!* fprin2) 8185548319256861553)
pterpri


(c!:install 'assert_declarestat1 '(assert_declarestat1 assert!:
noassert!: a list de assert_check1 put (quote assert_assertfn) (quote
assert_noassertfn) (quote assert_installed) cond not member
assert_functionl!* setq cons progn mkid) 3292435740705044339)
assert_declarestat1


(c!:install 'mksf '(mksf !*sub2 mksq mksp) 16383421118374179651)
mksf


(c!:install 'dvfsf_susitf '(dvfsf_susitf) 8904607512669943908)
dvfsf_susitf


(c!:install 'ofsf_smmkatl '(ofsf_smmkatl !*rlsippatl ofsf_smmkatl1
ofsf_sippatl) 5237972885042561372)
ofsf_smmkatl


(c!:install 'cl_nnfnot '(cl_nnfnot cl_nnf1) 11231145940357742317)
cl_nnfnot


(c!:install 'fctrf '(fctrf !*exp ncmp!* !*ezgcd !*gcd !*limitedfactors
dmode!* !*mcd poly "Factorization invalid with MCD off" !:rn!: alglist!*
!*trfac "This polynomial is homogeneous - variables scaled" noncomfp
rerror resimp !*q2f prepf simp sf2ss homogp prin2t listsum subs0 ss2sf
fctrf1 rconst sort!-factors quotf!* setcar) 13332295977068126080)
fctrf


(c!:install 'ev_insert '(ev_insert nreverse) 12499144344132413115)
ev_insert


(c!:install 'testpr '(testpr jsi codmat maxvar pnthxzz dm!-times
dm!-difference zeropp) 5415271785955096851)
testpr


(c!:install 'embed!-null!-fn '(embed!-null!-fn null!-fn lastpair) 
17022345701138273670)
embed!-null!-fn


(c!:install 'vdpcondense '(vdpcondense dipcondense) 7472009799357661127)
vdpcondense


(c!:install 'subla!-q '(subla!-q quote go lambda prog delasc) 
9807319529802026966)
subla!-q


(c!:install 'changearg '(changearg nreverse) 3622155650508054526)
changearg


(c!:install 'cons_ordp '(cons_ordp) 5587147247341243531)
cons_ordp


(c!:install 'general!-ordered!-gcd!-mod!-p '(
general!-ordered!-gcd!-mod!-p reduction!-count
general!-reduce!-degree!-mod!-p general!-monic!-mod!-p) 
12646109401517478620)
general!-ordered!-gcd!-mod!-p


(c!:install 'gcref_off '(gcref_off btime!* pfiles!* cref_name !*gcrefall
seen!* !*saveprops gcref_off1 gcref_select gcref_mkgraph gcref_eselect
gcref_mkegraph gcref_remprops) 12454789395406789858)
gcref_off


(c!:install 'checku '(checku) 15822881287339415887)
checku


(c!:install 'make!-modular!-symmetric '(make!-modular!-symmetric
modulus!/2 current!-modulus !*n2f) 6815586440753749212)
make!-modular!-symmetric


(c!:install 'opfneval1 '(opfneval1 tracealg "+++ Calling %p (%w:%w)%n"
defined!-in!-file defined!-on!-line "Arg%w = %@p%n" quote !*backtrace
"+++ Error in call to %p (%w:%w)%n" "%p => %p%n" "%p => %@p%n"
printf_internal errorset!* errorp) 15613979931203860423)
opfneval1


(c!:install 'atomlis '(atomlis) 6501944974261703121)
atomlis


(c!:install 'bcminus!? '(bcminus!? !*grmod!* minusf) 6378942423523588168
)
bcminus!?


(c!:install 'dipprod '(dipprod diplength dipprodin) 14131312737934490340
)
dipprod


(c!:install 'basisformp '(basisformp basisforml!*) 4086774854439652781)
basisformp


(c!:install 'sgn1 '(sgn1 sgn) 4395985868830635280)
sgn1


(c!:install 'deginvar '(deginvar kord!* wuconstantp reorder) 
4021669980146091331)
deginvar


(c!:install 'dfconst '(dfconst zlist vp2) 15827301056878358237)
dfconst


(c!:install 'domainvalchk '(domainvalchk dmode!* valuechk mk!*sq) 
17043547302922129578)
domainvalchk


(c!:install 'qqe_arg!-check!-lb!-rb '(qqe_arg!-check!-lb!-rb
"type conflict: arguments don't fit
             binary op with basic type args" qqe_arg!-check!-b
qqe_arg!-check!-marked!-ids!-rollback typerr) 7561473729744837887)
qqe_arg!-check!-lb!-rb


(c!:install 'relnrd '(relnrd atts (type definitionurl) char relations!*
lex retattributes compress!* apply) 7698492374233116587)
relnrd


(c!:install 'unify '(unify op r p "UNIFY:pattern over-run for function "
symm comb identity mcontract acontract expand i upb resume ident mgenp
pm!:free genp initarg nextarg suspend bind chk mval unbind meq) 
5085765813978083439)
unify


(c!:install 'dipsum '(dipsum evcomp iequal bcsum bczero!? setcdr) 
17754619527837437931)
dipsum


(c!:install 'locate_member '(locate_member) 4764278102994726603)
locate_member


(c!:install 'repartsq '(repartsq splitcomplex multsq addsq invsq) 
1876562266233041932)
repartsq


(c!:install 'harmonicp '(harmonicp fourier!-angle) 6327494936315734929)
harmonicp


(c!:install 'simp!-prop2 '(simp!-prop2 propvars!* prop!* not_prop!*
union simp!-prop!-condense) 18327063984962764399)
simp!-prop2


(c!:install 'reverse!-num1 '(reverse!-num1 reverse!-num!-table!*) 
4190109204128489908)
reverse!-num1


(c!:install 'qtypnm '(qtypnm function seen seen!* tseen !( !) tseen!*
rccnam funs traput) 14045573743009214131)
qtypnm


(c!:install 'ofsf_siatsubf '(ofsf_siatsubf exptsq multsq addsq
ofsf_pow2q) 9348361271224187083)
ofsf_siatsubf


(c!:install 'ofsf_simplat1 '(ofsf_simplat1 (equal neq leq geq lessp
greaterp) true false !*rlsiatadv equal neq leq geq lessp greaterp
ofsf_evalatp sfto_dcontentf quotf minusf negf ofsf_anegrel
ofsf_simplequal ofsf_simplneq ofsf_simplleq ofsf_simplgeq
ofsf_simpllessp ofsf_simplgreaterp) 15985813956325357611)
ofsf_simplat1


(c!:install 'drop_rl_with '(drop_rl_with rl_with) 3316639232002376194)
drop_rl_with


(c!:install 'width '(width textag "cannot find item " fatal tri!-error) 
6407596289288209404)
width


(c!:install 'qqe_simplterm!-tail '(qqe_simplterm!-tail qepsilon (ladd
radd) ltail radd rtail ladd qqe_arg2l qqe_op qqe_arg2r qqe_simplterm) 
3376354025590589708)
qqe_simplterm!-tail



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u30.lsp"

Reading "$reduce/cslbuild/generated-c/u31.lsp"

% u31.lsp           Machine generated Lisp

(c!:install "u31" 85054 7291130 1149592)
nil


(c!:install 'factor!-prim!-sqfree!-f '(factor!-prim!-sqfree!-f !*msg
!*rounded !*complex !*rational rational !*limitedfactors dmode!*
internal!-factorf sqfrfactorfn factorfn factorf rounded univariatep
unifactor on resimp exptf factor!-prim!-sqfree!-f!-1) 
8599318140327015233)
factor!-prim!-sqfree!-f


(c!:install 'derad '(derad nreverse ordp) 6903141748124374193)
derad


(c!:install 'dip2vdp '(dip2vdp !*groebsubs vdp dipsubs2 a2bc) 
15231011002842528392)
dip2vdp


(c!:install 'indordn '(indordn indord2 indordad) 1270862301250861552)
indordn


(c!:install 'generic!-sub '(generic!-sub dfp list dfp!-sub) 
17996181599572078420)
generic!-sub


(c!:install 'symbol '(symbol !*utf8 !*utf82d utf8_2d!-symbol!-character
utf8_symbol!-character symbol!-character) 13739637880224446540)
symbol


(c!:install 'modp '(modp) 14828617985740440421)
modp


(c!:install 'horner!-rule!-for!-one!-var '(horner!-rule!-for!-one!-var
!*n2f multf addf) 3366819904428384819)
horner!-rule!-for!-one!-var


(c!:install 'letscalar '(letscalar hold df "operator" avalue rtype
antisymmetric infix kvalue linear noncom op opmtch simpfn symmetric
wtl!* opfn expt frlis!* sqrt !*sqrtrulep (quotient 1 2) varstack!*
!*precise errpri2 letdf getrtype reval let2 redmsg mkop let3 delasc
rmsubs to letexprn simp0 errpri1) 16640623747715855073)
letscalar


(c!:install 'ra_l '(ra_l ra_iv riv_l) 3312224385655881070)
ra_l


(c!:install 'lalr_process_productions '(lalr_process_productions
nonterminals lalr_produces carrassoc) 11669776550209890589)
lalr_process_productions


(c!:install 'read_signature '(read_signature cursym!* rlisp
"invalid as formal parameter name" !*semicol!* general !*colon!*
!*lpar!* !*rpar!* "found where right parenthesis expected"
valid_as_variable rerror scan read_type symerr read_typed_name
read_namelist) 15436169951084997305)
read_signature


(c!:install 'ofsf_smordtable '(ofsf_smordtable ((equal (equal . false) (
neq equal . t) (geq equal . t) (leq . false) (greaterp equal . t) (lessp
. false)) (neq (equal equal) (neq) (geq) (leq leq) (greaterp) (lessp
lessp)) (geq (equal . false) (neq geq . t) (geq geq . t) (leq . false) (
greaterp geq . t) (lessp . false)) (leq (equal equal) (neq) (geq) (leq
leq) (greaterp) (lessp lessp)) (greaterp (equal . false) (neq greaterp .
t) (geq greaterp . t) (leq . false) (greaterp greaterp . t) (lessp .
false)) (lessp (equal equal) (neq) (geq) (leq leq) (greaterp) (lessp
lessp)))) 14560317248216607311)
ofsf_smordtable


(c!:install 'mk!+squared!+norm '(mk!+squared!+norm mk!+inner!+product) 
3644133023429157522)
mk!+squared!+norm


(c!:install 'cgp_mk '(cgp_mk cgp) 1967345575831606739)
cgp_mk


(c!:install 'semanticml '(semanticml "<apply>" "<fn>" "<semantic>"
"<ci><mo>" "</mo></ci>" "<annotation-xml encoding=""OpenMath"">" "<" ">"
"</annotation-xml>" "</semantic>" "</fn>" "</apply>" printout indent!*
mathml_list2string multi_elem) 10713627020240037658)
semanticml


(c!:install 'evalvars '(evalvars intfn setelemfn nreverse
revlis_without_mode revlis) 9040418125506089064)
evalvars


(c!:install 'vdp2a '(vdp2a dip2a) 13099992034530689081)
vdp2a


(c!:install 'overall_factor '(overall_factor xval) 13640985980635654836)
overall_factor


(c!:install 'nconc2 '(nconc2) 8019592056523493459)
nconc2


(c!:install 'testchar1 '(testchar1 nochar!* nochar1!*) 
3304520668572494504)
testchar1


(c!:install 'gparg1p '(gparg1p gpargp) 11507040959066206646)
gparg1p


(c!:install 'formsetq '(formsetq symbolic list cons formsetq0 formsetq1
formsetq2) 14303897429664626038)
formsetq


(c!:install 'mv!-pow!-!> '(mv!-pow!-!>) 15823260743438036790)
mv!-pow!-!>


(c!:install 'red!=subst1 '(red!=subst1 !*bcsimp "---> " "." " uses "
bas_dpoly dp_lc bas_rep cali_bc_inv cali_bc_prod cali_bc_fi cali_bc_gcd
cali_bc_divmod dp_lmon mo_diff dp_times_bc dp_times_bcmo dp_diff
cali_trace dp_print bas_nr bas_make1) 9007145003661642186)
red!=subst1


(c!:install 'lalr_process_reductions '(lalr_process_reductions
nonterminals lalr_nonterminal_code lalr_productions mkvect16 mkvect8
putv16 putv8 lalr_construct_fn) 4573902986117076329)
lalr_process_reductions


(c!:install 'monomgetfirstmultivar '(monomgetfirstmultivar) 
13534559078993598004)
monomgetfirstmultivar


(c!:install 'talp_noffcts '(talp_noffcts talp_getl) 4637553578255174733)
talp_noffcts


(c!:install 'lesspcdadr '(lesspcdadr) 7964605696148437830)
lesspcdadr


(c!:install 'matrix_rows '(matrix_rows "<matrixrow>" "</matrixrow>"
printout indent!* row) 12368609926542696831)
matrix_rows


(c!:install 'noncomexpf '(noncomexpf noncomp) 5575421815131349904)
noncomexpf


(c!:install 'xriterion_1 '(xriterion_1 spoly_pair !*trxideal
"criterion 1 hit" last xval xdiv make_spoly_pair find_item writepri) 
13595331840087151417)
xriterion_1


(c!:install 'gfplusn '(gfplusn gffplus plus!:) 17488025135662503742)
gfplusn


(c!:install 'sign!-of '(sign!-of simp!-sign) 9585081512023966144)
sign!-of


(c!:install 'assert_stat!-parse '(assert_stat!-parse !*colon!*
"expecting ':' in assert but found" cursym!* difference greaterp
"expecting '->' in assert but found" "expecting end of assert but found"
scan rederr assert_stat1) 12520463969237406079)
assert_stat!-parse


(c!:install 'comb '(comb) 16651735446486970447)
comb


(c!:install 'gcref_off1 '(gcref_off1 dfprint!* !*defn !*algebraics
algebraic newnam seen!* calledby entpts!* tseen!* tseen funs rccnam
gseen!* usedunby undefg!* undefdchk idsort) 16304191943616561554)
gcref_off1


(c!:install 'sfto_updecf '(sfto_updecf !*sfto_yun !*sfto_musser
"sfto_updecf: select a decomposition method" sfto_yun!-updecf
sfto_musser!-updecf rederr) 9570799290316021347)
sfto_updecf


(c!:install 'simpexpt1 '(simpexpt1 !*allfac !*div e log alg
"0**0 formed" "Zero divisor" !*mcd expt simp simp!* prepsq!* simpexpt11
rerror minusf !*d2q !:expt resimp domainvalchk exptsq invsq expf mksfpf
multf subs2!*) 11760113747554941655)
simpexpt1


(c!:install 'get_char_group '(get_char_group) 8299995027405440554)
get_char_group



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u31.lsp"

Reading "$reduce/cslbuild/generated-c/u32.lsp"

% u32.lsp           Machine generated Lisp

(c!:install "u32" 143801 5677735 4526528)
nil


(c!:install 'talp_atnum '(talp_atnum or and not impl repl equiv ex all
true false) 11551283075179441224)
talp_atnum


(c!:install 'minusml '(minusml "<apply><minus/>" "</apply>" printout
indent!* multiminus) 1217897309786682102)
minusml


(c!:install 'exptplus '(exptplus "Bad exponent sum" interr) 
15800345272466755993)
exptplus


(c!:install 'add_minus '(add_minus !:rd!: minus) 16653397504775846537)
add_minus


(c!:install 'dipnumcontent '(dipnumcontent bcone!? vbcgcd) 
2900635658430140763)
dipnumcontent


(c!:install 'sc_getrow '(sc_getrow sc_igetv) 3551891752755930172)
sc_getrow


(c!:install 'f2dip11 '(f2dip11 !*notestparameters vdpvars!*
"occurs in a parameter and is member of the groebner variables." list
"groebner: LIST not allowed." rederr) 7234983498125750140)
f2dip11


(c!:install 'eqexpr '(eqexpr equalopr) 3505042047303045823)
eqexpr


(c!:install 'formatfort '(formatfort !*lower !*posn!* maxint !*double e
!D !E (d !0) fortlinelen!* lispeval i2rd!* fortcontline pprin2) 
11603302336187822563)
formatfort


(c!:install 'one!-entryp '(one!-entryp) 1880773745218423214)
one!-entryp


(c!:install 'subsq '(subsq alg "0/0 formed" "Zero divisor" subf subs2!*
rerror quotsq) 2328511050533666755)
subsq


(c!:install 'groeb!=rf1 '(groeb!=rf1 red_totalred) 7915201577852284808)
groeb!=rf1


(c!:install 'length_multiindex '(length_multiindex) 692022526224992757)
length_multiindex


(c!:install 'lex_basic_token '(lex_basic_token lex_peeked
lex_peeked_yylval yylval lex_peeked_escaped lex_escaped lex_char ! 
!$eol!$ !	 !$eof!$ lex_eof_code !! lexer_style!* !*raise !*lower
comment !; !$ lex_code !' lex_is_typename lex_typename_code
lex_symbol_code !~ !0 x !X lex_number_code !. e !E !+ !- !" !\
lex_string_code lex_char_code quote lex_list_code !` backquote !#
lex_dipthong sml_opchar (if else elif endif define eval)
lex_start_line_comment lex_skip_line_comment lex_start_block_comment
lex_skip_block_comment yyreadch lexer_word_starter land
lexer_word_continues list2widestring yypeek lex_hexval read_s_expression
widestring2list all_sml_opchar list2string) 6007149577768455066)
lex_basic_token


(c!:install 'in_list1a '(in_list1a !*echo !*reduce4 string !| !$ !/ !\
ifl!* !. (!/ !.) input linelist!* curline!* ipl!* contl!*
"FILE STACK CONFUSION" type typerr value mkfil!* list2string pipe!-open
open begin1a rederr) 5447568939486315732)
in_list1a


(c!:install 'formboollis '(formboollis formbool formc!* reversip!*) 
5288393440562812093)
formboollis


(c!:install 'talp_specsubt '(talp_specsubt talp_eqtp) 
3456373075680382027)
talp_specsubt


(c!:install 'multiminus '(multiminus expression) 3843225591671845349)
multiminus


(c!:install 'dm!-min '(dm!-min dm!-gt) 13325087570768997749)
dm!-min


(c!:install 'indxchk '(indxchk indxl!* nosuml!* union !*num2id) 
12525549298977096173)
indxchk


(c!:install 'incident '(incident incident1) 232370014167487459)
incident


(c!:install 'simp!-prop1 '(simp!-prop1 !'and !'or not implies or equiv
and true false (or !*true (not !*true)) (and !*true (not !*true))
boolean prop!* not_prop!* propvars!* multf addf reval simp) 
12573422058316044628)
simp!-prop1


(c!:install '!*di2q '(!*di2q varlist!* !*di2q0) 16228567822902602514)
!*di2q


(c!:install 'st_ad_numsorttree '(st_ad_numsorttree st_ad_numsorttree1) 
14827553760693438293)
st_ad_numsorttree


(c!:install 'expand_rule '(expand_rule expand_terminal) 
7297132048270984005)
expand_rule


(c!:install 'cl_susiupdknowl1 '(cl_susiupdknowl1 and cl_susiupdknowl2
rl_negateat) 14302886500742299120)
cl_susiupdknowl1


(c!:install 'ev_max!# '(ev_max!#) 15773274042070445237)
ev_max!#


(c!:install 'containerml '(containerml integer_interval interval "<" ""
"</" ">" printout attributesml indent!* multi_elem) 17496795682551813199
)
containerml


(c!:install 'ps!:constmult!-erule '(ps!:constmult!-erule ps!:evaluate
multsq) 14878993956804742982)
ps!:constmult!-erule


(c!:install 'mkempspmat '(mkempspmat sparsemat) 13492359742304325991)
mkempspmat


(c!:install 'insoccs '(insoccs subscriptedvarp insertocc constp) 
6756413965020670852)
insoccs


(c!:install 'module '(module !*mode mode!-list!* alglist!* symbolic) 
17191246551011286226)
module


(c!:install '!*xadd '(!*xadd) 17463717805747166282)
!*xadd


(c!:install 'chkrn!* '(chkrn!* !*!*roundbf bf2flck) 4426900711315584015)
chkrn!*


(c!:install '!*a2f '(!*a2f simp!* !*q2f) 1157670281669662903)
!*a2f


(c!:install 'lalr_extract_nonterminals '(lalr_extract_nonterminals
"Malformed production"
"(RHS should be a list of tokens, not a non-nil atom)" lex_fixed_code
"(atomic item in token list should be symbol or string)" (opt seq star
plus list listplus or) "(unrecognised item in rule)" nreverse rederr) 
14495628518251421958)
lalr_extract_nonterminals



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u32.lsp"

Reading "$reduce/cslbuild/generated-c/u33.lsp"

% u33.lsp           Machine generated Lisp

(c!:install "u33" 103635 4357356 7513239)
nil


(c!:install 'triplesetprolongedby '(triplesetprolongedby) 
18341923192646002043)
triplesetprolongedby


(c!:install '!*tayexp2q '(!*tayexp2q) 13103823873588407608)
!*tayexp2q


(c!:install 'vdelete '(vdelete nreverse) 1364860348438815528)
vdelete


(c!:install 'omatpir '(omatpir (!/ o m a t p) lex omsir omobj checktag) 
14637756025774761808)
omatpir


(c!:install 'suchp '(suchp such!-that) 2237043806669000480)
suchp


(c!:install '!*pf2sq '(!*pf2sq to multsq addsq) 13586119113996823355)
!*pf2sq


(c!:install 's_actual_world1 '(s_actual_world1) 13857407108230127468)
s_actual_world1


(c!:install 'subs2chk '(subs2chk subfg!* subs2f) 3120225543026791882)
subs2chk


(c!:install 'simp!-prop!-condense '(simp!-prop!-condense
lambda_rfde09ec49c92 sort subsetp ordn) 16837942846282228103)
simp!-prop!-condense


(c!:install 'lambda_rfde09ec49c92 '(lambda_rfde09ec49c92) 
4700859260019140216)
lambda_rfde09ec49c92


(c!:install 'skp_ordp '(skp_ordp atom_compare cons_ordp) 
18096101897370550795)
skp_ordp


(c!:install 'gitimes!: '(gitimes!: mkgi) 8275366031935422847)
gitimes!:


(c!:install 'ofsf_ir2atl '(ofsf_ir2atl ofsf_entry2at lastpair) 
3437061213404465222)
ofsf_ir2atl


(c!:install 'repr_a '(repr_a addf) 13167846556635871198)
repr_a


(c!:install 'dip_ilcomb2r '(dip_ilcomb2r ev_comp iequal bc_prod bc_sum
bc_zero!?) 6725495761887343420)
dip_ilcomb2r


(c!:install 'ev_2a '(ev_2a dip_vars!* ev_2a1) 40967775589971858)
ev_2a


(c!:install 'bvarrd '(bvarrd char (d e g r e e) "<bvar>" (!/ d e g r e e
) "</degree>" (!/ b v a r) bvar "</bvar>" lex errorml mathml2 mathml
error) 7637494499477649831)
bvarrd


(c!:install '!:dmtimeslst '(!:dmtimeslst !:times) 7422364972943705268)
!:dmtimeslst


(c!:install 'prop!-simp '(prop!-simp prop!-simp1) 8182520842950749849)
prop!-simp


(c!:install 'red_topred '(red_topred !*noetherian bas_dpoly red_topredbe
dp_lmon red_divtest red_subst red_update) 14392805755887232125)
red_topred


(c!:install 'list_is_all_free '(list_is_all_free nodum_varp) 
15714767976063944508)
list_is_all_free


(c!:install 'general!-horner!-rule!-mod!-p '(
general!-horner!-rule!-mod!-p general!-expt!-mod!-p
general!-times!-mod!-p general!-plus!-mod!-p) 6014534191802679692)
general!-horner!-rule!-mod!-p


(c!:install '!*a2k '(!*a2k kernel simp!* kernp typerr) 
4159766344436415377)
!*a2k


(c!:install 'formbool '(formbool symbolic boolvalue!* boolfn boolean
boolargs "Too many formbools" where bool!-eval formc formc!* intexprlisp
formclis formboollis rederr) 12736169941840665603)
formbool


(c!:install 'talp_sumd '(talp_sumd rl_atl talp_arg2l talp_td talp_arg2r)
 14348405121939397515)
talp_sumd


(c!:install 'sets '(sets "<apply>" "<" "/" "</apply>" printout
attributesml indent!* multi_elem) 535982809161287800)
sets


(c!:install 'alg_plus '(alg_plus plus aeval) 13889267068724863557)
alg_plus


(c!:install 'matrixp '(matrixp mat sparsemat reval) 14228403379404342080
)
matrixp


(c!:install 'amatch '(amatch r p !*semantic equal mval unify suchp
resume) 5585579030456768667)
amatch


(c!:install 'groebnormalform '(groebnormalform groebnormalform0) 
9246680682546895048)
groebnormalform


(c!:install 'evload '(evload) 11219261006708819634)
evload


(c!:install 'toolongexpp '(toolongexpp maxexpprintlen!* numprintlen) 
10528370960806224087)
toolongexpp


(c!:install 'find_buble '(find_buble is_buble) 12981048816766530333)
find_buble


(c!:install 'log_assignment '(log_assignment quote function setq
"+++ Assignment to parameter of inline: " "+++ Macro was: " inlineinfo
cond log_assignment_list_list log_assignment_list) 8320727009848696406)
log_assignment


(c!:install 'arglength '(arglength !*intstr reval) 8071143878740418471)
arglength


(c!:install 'fs!:onep!: '(fs!:onep!: fs!:onep) 16865939965197051073)
fs!:onep!:


(c!:install 'red!=hide '(red!=hide mo_neg mo_times_ei) 
5964687500655226768)
red!=hide


(c!:install 'dummyp '(dummyp minus g_dvnames g_dvbase listp !*id2num
upbve ad_splitname) 10097767703930092657)
dummyp


(c!:install 'ratdif '(ratdif ratminus ratplusm) 8523472214507921043)
ratdif


(c!:install 'letexprn '(letexprn times difference quotient mcond!*
!*match used!* df opmtch asymplis!* powlis!* replace frasc!* powlis1!*
let!-prepf let2 kernlp term!-split quotf!* klistt rmsubs xadd!* smember
fkern setk1 errpri1 xadd delasc) 17876340611196469351)
letexprn


(c!:install 'poly!-to!-vector '(poly!-to!-vector poly!-vector !*d2n) 
3599356024780753765)
poly!-to!-vector


(c!:install 'lex_process_directive '(lex_process_directive yylval
!#endif if_depth "+++ #endif not follopwing #if" !$eof!$
"+++ #endif missing at end of file" !#if !#else !#elif read_s_expression
errorset errorp lex_skip_to_else_or_endif) 7603308210475858270)
lex_process_directive


(c!:install 'arg1of2 '(arg1of2) 4218017190104628163)
arg1of2


(c!:install 'profile_a_package '(profile_a_package !*errcont cpulimit
jlisp lispsystem!* conslimit "PROFILING: " !*backtrace !*int
reduce_regression_tests folder "$reduce/packages/" testdirectory "/"
".tst" alglist!* algebraic !*mode "[Profile] " quit expr posn errorset
in_list1 erfg!* profile_compare_fn "buildlogs/flaguse.log" append
!*savedef lambda "profile.dat" "% +++++ Error: Resource limit exceeded"
"% @@@@@ Resources used: " !*resources!* "(" "  (" " " ")" "  )" input
!$eof!$ orderp ((symbol!-make!-fastget (quote lose) 1) (
symbol!-make!-fastget (quote noncom) 0)) (lose noncom) processed
symbol!-make!-fastget "buildlogs/fastgets.lsp" output
"% fastgets.lsp generated by profiling" progn "% end of fastgets.lsp"
"Profiling complete" (remake profile_a_package) get_configuration_data
load!-package concat list!-to!-string window!-heading getd putd
resource!-limit sort open bytecounts load!-source md60 prettyprint
restart!-csl) 2815953169272495238)
profile_a_package


(c!:install 'vp2 '(vp2 nreverse) 12682152641767427105)
vp2


(c!:install 'pasf_exprng '(pasf_exprng !*rlsism and true false or ball
bex not impl repl equiv pasf_exprng!-gand pasf_exprng!-gball cl_simpl) 
18106096511587248063)
pasf_exprng



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u33.lsp"

Reading "$reduce/cslbuild/generated-c/u34.lsp"

% u34.lsp           Machine generated Lisp

(c!:install "u34" 171997 7140639 1743420)
nil


(c!:install 'mapcarcar '(mapcarcar) 6573486607489535135)
mapcarcar


(c!:install 'matrixom '(matrixom "<OMA>"
"<OMS cd=""linalg1"" name=""matrix""/>" "</OMA>" printout indent!*
matrixrowom) 14726143653554891393)
matrixom


(c!:install 'close_forall '(close_forall flagg "</apply>" printout) 
14878609875013610813)
close_forall


(c!:install 'lispreadp '(lispreadp read) 7798977045561721809)
lispreadp


(c!:install 'reval3 '(reval3 simp mk!*sq) 5760933334693659966)
reval3


(c!:install 'color!-roads '(color!-roads) 17298579009205451982)
color!-roads


(c!:install 'remchkf '(remchkf remchkf1 kernels intersection) 
7564202488979874806)
remchkf


(c!:install 'split_cov_cont_ids '(split_cov_cont_ids minus) 
11739611569100803353)
split_cov_cont_ids


(c!:install 'proper!-simpsqrt '(proper!-simpsqrt carx simpsqrti) 
12726400845289891393)
proper!-simpsqrt


(c!:install 'make!-x!-to!-p '(make!-x!-to!-p dpoly poly!-vector
times!-in!-vector remainder!-in!-vector) 6629668419058198533)
make!-x!-to!-p


(c!:install 'lex_skip_line_comment '(lex_skip_line_comment lex_char
!$eol!$ !$eof!$ yyreadch) 17954792529991133834)
lex_skip_line_comment


(c!:install 'sortedpolynomlistinsert '(sortedpolynomlistinsert
polynomcompare) 15826984959678356939)
sortedpolynomlistinsert


(c!:install 'multdfconst '(multdfconst nreverse multsq subs2q) 
18239574063977063315)
multdfconst


(c!:install 'mri_congp '(mri_congp (cong ncong) mri_opn) 
8707192043286087915)
mri_congp


(c!:install 'rat_abs '(rat_abs absf) 8422367871539374234)
rat_abs


(c!:install 'applyfnrd '(applyfnrd fnrd stats_getargs) 
17843552477246788365)
applyfnrd


(c!:install 'ps!:times!-erule '(ps!:times!-erule ps ps!:order
ps!:evaluate multsq addsq) 11748419915097130968)
ps!:times!-erule


(c!:install 'matsm1 '(matsm1 !*div sparsemat mat matrix
"Matrix mismatch" sparse "Non square matrix" subfg!* inversefn
lnrsolvefn !*sub2 "Zero divisor" "Matrix" "not set" spmultm lispapply
multsm multm lchk rerror xsimp checksp spmatsm matsm subs2 revpr
generateident) 11861811968647949886)
matsm1


(c!:install 'recaliasbacksubst '(recaliasbacksubst constp) 
7026364058141692205)
recaliasbacksubst


(c!:install 'dipprodin '(dipprodin dipzero dipprodin1 dipsum) 
17397364834695958208)
dipprodin


(c!:install 'difference!: '(difference!: !:rd!: minus!: ashift) 
13627056831675126278)
difference!:


(c!:install 'evaluate!-horner '(evaluate!-horner horner!-cache!* simp!*
hornerf prepsq) 3733419029157992492)
evaluate!-horner


(c!:install 'indexsymmetrize '(indexsymmetrize indxsymmetrize) 
13445894356302575475)
indexsymmetrize


(c!:install 'po!:statep '(po!:statep state) 14306850752333635111)
po!:statep


(c!:install 'color!-strand '(color!-strand nreverse color!-roads) 
13048520133353012665)
color!-strand


(c!:install 'greaterpcdr '(greaterpcdr) 8968584287361009996)
greaterpcdr


(c!:install 'clogsq!* '(clogsq!* !*div !*combinelogs !*expandlogs
!*uncached prepsq simp prepsq!* comblog simp!*) 15398099386031094604)
clogsq!*


(c!:install 'fs!:prin '(fs!:prin " 0 " " + " prin2!* fs!:prin1) 
6908279454003400687)
fs!:prin


(c!:install 'dfprintfn '(dfprintfn !*nat !*fort !*dfprint failed !!df!!
layout!-formula putpline) 6576352468631490110)
dfprintfn


(c!:install 'msolve!-poly1 '(msolve!-poly1 erfg!* current!-modulus expt
safe!-modrecip negf multf moduntag general!-modular!-number lowestdeg
simp quotf general!-reduce!-mod!-p general!-evaluate!-mod!-p lastpair
prepf) 12122992026913452271)
msolve!-poly1


(c!:install 'cde_replace_nth '(cde_replace_nth nreverse) 
958148222290834626)
cde_replace_nth


(c!:install 'ra_qmk '(ra_qmk !:ra!: riv_mk) 3819616673865121068)
ra_qmk


(c!:install 'aex_lc '(aex_lc aex_mvartest aex_ex sfto_lcx quotsq kernels
aex_ctx ctx_filter aex_mk) 17965101807908454800)
aex_lc


(c!:install 'polynomwrite '(polynomwrite nreverse monomwrite) 
8019372385341136277)
polynomwrite


(c!:install 'taydegree!< '(taydegree!< tayexp!-greaterp tayexp!-lessp) 
13743525140988364063)
taydegree!<


(c!:install 'gen!+can!+bas '(gen!+can!+bas) 4195692412070013370)
gen!+can!+bas


(c!:install 'cl_bvarl1 '(cl_bvarl1 cl_varl1) 9380843449797521470)
cl_bvarl1


(c!:install 'qqe_ofsf_varlat '(qqe_ofsf_varlat qqe_ofsf_prepat qqe_arg2l
qqe_ofsf_varlterm qqe_arg2r union) 15296253903470199447)
qqe_ofsf_varlat


(c!:install 'cl_susiinter '(cl_susiinter delete ignore add lto_delqip) 
3710122244307141011)
cl_susiinter


(c!:install 'ev_dif '(ev_dif) 17835376965745009896)
ev_dif


(c!:install 'bc_mkat '(bc_mkat) 11608354390859674424)
bc_mkat


(c!:install 'vectorml '(vectorml "<vector" "" "</vector>" printout
attributesml indent!* multi_elem) 11686521336891622087)
vectorml


(c!:install 'delyzz '(delyzz nreverse) 3317795321810317837)
delyzz


(c!:install 'make!-unique!-freevars '(make!-unique!-freevars gen
freevarlist!* pm!:gensym) 2618527914134102580)
make!-unique!-freevars


(c!:install 'fieldp '(fieldp) 10650134519085569632)
fieldp


(c!:install 'dipsimpcont '(dipsimpcont !*vdpinteger !*groebdivide
dipsimpconti dipsimpcontr) 603366294860614937)
dipsimpcont


(c!:install 'greaterp!: '(greaterp!: !:bprec!: normbf ashift) 
7774966988171925016)
greaterp!:


(c!:install 'calc_coeff '(calc_coeff calc_world) 15849626058100044138)
calc_coeff



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u34.lsp"

Reading "$reduce/cslbuild/generated-c/u35.lsp"

% u35.lsp           Machine generated Lisp

(c!:install "u35" 183161 6110864 8115840)
nil


(c!:install 'log_freevars_list '(log_freevars_list log_freevars) 
5289505311670650718)
log_freevars_list


(c!:install 'ratfunpri1 '(ratfunpri1 spare!* posn!* orig!* ycoord!*
pline!* ymin!* ymax!* bar quotient p!*!* "(" ")" layout!-formula max
terpri!* update!-pline min symbol prin2!* maprint oprin negnumberchk) 
10056120397460243885)
ratfunpri1


(c!:install 'mo_zero!? '(mo_zero!? mo!=zero) 7961466638273179982)
mo_zero!?


(c!:install '!*f2di '(!*f2di varlist!* addgt pdmult pcmult psum) 
17461722156329616849)
!*f2di


(c!:install 'msolve!-polyn '(msolve!-polyn current!-modulus
msolve!-poly1 subf lastpair) 2360298124392123331)
msolve!-polyn


(c!:install 'reduce!-mod!-eigf '(reduce!-mod!-eigf !*sub2 cancel negsq
reduce!-eival!-powers subs2) 18377647075100431114)
reduce!-mod!-eigf


(c!:install 'ra_u '(ra_u ra_iv riv_u) 2540618869296221511)
ra_u


(c!:install 'vdp_putprop '(vdp_putprop) 16409054744709111877)
vdp_putprop


(c!:install 'listrd '(listrd atts (order) list retattributes
stats_getargs) 14769749089062405773)
listrd


(c!:install 'ps!:sqrt!-erule '(ps!:sqrt!-erule ps (quotient 1 2)
ps!:order ps!:evaluate prepsqxx simpexpt multsq addsq quotsq) 
10183546414698764261)
ps!:sqrt!-erule


(c!:install 'resume '(resume substitution amatch chk bsubs) 
17394164173255456306)
resume


(c!:install 'evinvlexcomp '(evinvlexcomp (0) evlexcomp iequal) 
3644866760103350735)
evinvlexcomp


(c!:install 'vdpilcomb1 '(vdpilcomb1 !*gsugar dipilcomb1 dip2vdp gsugar
vevtdeg max gsetsugar) 10167637561307787401)
vdpilcomb1


(c!:install 'unplus '(unplus plus nreverse) 554904849496138922)
unplus


(c!:install '!*!*a2i '(!*!*a2i ieval intexprnp) 17857848832979299686)
!*!*a2i


(c!:install 'dv_ind2var '(dv_ind2var g_dvnames g_dvbase upbve mkid) 
17529332376884670646)
dv_ind2var


(c!:install 'lalr_warn_shift_reduce_conflict '(
lalr_warn_shift_reduce_conflict "+++ Shift/reduce conflict in itemset #"
" on lookahead " "Reduce: " "Shift: to state #"
"Resolved in favour of the shift operation" lalr_prin_symbol
lalr_prin_production) 1635230266327942899)
lalr_warn_shift_reduce_conflict


(c!:install 'dvfsf_v '(dvfsf_v dvfsf_p!* qremf) 2793621462146063365)
dvfsf_v


(c!:install 'plusdf '(plusdf nreverse !*addsq orddf) 
10154485941733850895)
plusdf


(c!:install 'get!*inverse '(get!*inverse inverse give!*position nth) 
10046119299683993777)
get!*inverse


(c!:install 'cgp_lbc '(cgp_lbc cgp_rp dip_lbc) 6931679935384486887)
cgp_lbc


(c!:install 'getargsrd '(getargsrd char (b v a r) bvarrd lex) 
15523628145975880371)
getargsrd


(c!:install 'valuecoefft '(valuecoefft "Valuecoefft - no value" interr) 
11085630856475024248)
valuecoefft


(c!:install 'evaluate '(evaluate !*evaluateerror !*protfg !*msg
evaluate0 "error during function evaluation (e.g. singularity)" pair
errorset errorp rederr) 8549248470219636633)
evaluate


(c!:install 'assert_procstat!-argl '(assert_procstat!-argl cursym!*
!*rpar!* "Expecting identifier but found" !*colon!*
"Expecting type but found" (!*comma!* !*rpar!*)
"Expecting ',' or ')' but found" !*comma!* nxtsym!* !: returnvalue
eolcheck assert_rederr scan assert_typesyntaxp) 6719104097586060276)
assert_procstat!-argl


(c!:install 'ad_splitname '(ad_splitname charnump!:) 9997322121145538574
)
ad_splitname


(c!:install 'difbf '(difbf !:rd!: !:bprec!: minus!: msd ashift inorm) 
17984220760392890790)
difbf


(c!:install 'order_of_der_mind '(order_of_der_mind length_multiindex) 
501712109400027303)
order_of_der_mind


(c!:install 'lalr_get_lex_codes '(lalr_get_lex_codes lex_context
lex_save_context lex_cleanup lex_keywords lex_export_codes
lex_restore_context) 4037498215424840796)
lalr_get_lex_codes


(c!:install 'polynomcompare '(polynomcompare monomcompare) 
1281604190181789875)
polynomcompare


(c!:install 'ofsf_smcpknowl '(ofsf_smcpknowl) 16842228859866707994)
ofsf_smcpknowl


(c!:install 'multdf '(multdf multerm plusdf) 6296682842725154736)
multdf


(c!:install 'talp_specsub '(talp_specsub true false talp_atfp
talp_specsubat talp_op talp_argl) 8843642639735014270)
talp_specsub


(c!:install 'ithlistelem '(ithlistelem nth) 4936962979496750233)
ithlistelem


(c!:install 'maxl '(maxl max) 15330531340632273549)
maxl


(c!:install 'sc_subtrsq '(sc_subtrsq negsq addsq) 8269713965318093498)
sc_subtrsq


(c!:install 'getrlist '(getrlist list !*sq "list" prepsq typerr) 
13081520870141105431)
getrlist


(c!:install 'plubf '(plubf !:rd!: !:bprec!: msd ashift inorm) 
14385353088373813766)
plubf


(c!:install 'sublap '(sublap app sublap1) 3082966434538444150)
sublap


(c!:install 'min0 '(min0 min max) 12393225392512410134)
min0


(c!:install 'indordl2 '(indordl2 indordlp) 3423120191165119766)
indordl2


(c!:install 'getphystypeall '(getphystypeall "PHYSOP type mismatch in"
deleteall collectphystype rederr2) 11919110940414140279)
getphystypeall


(c!:install 'deletez1 '(deletez1 nreverse) 14734844965284007186)
deletez1


(c!:install 'realvaluedp '(realvaluedp realvalued alwaysrealvalued
condrealvalued realvaluedlist apply) 16698413258289320559)
realvaluedp


(c!:install 'assert_formproc '(assert_formproc symbolic
"asserted procedures are available in symbolic mode only" procedure expr
!*assert progn rederr formproc assert_declarestat1) 5727630391390359241)
assert_formproc


(c!:install 'subeval1 '(subeval1 subfn alg
"No substitution defined for type" !*sub2 getrtype rerror simp subsq
subs2 mk!*sq) 6660071289924290963)
subeval1


(c!:install 'remchkf1 '(remchkf1 !*trcompact "*** Remainder smaller"
termsf xremf prin2t) 9278271335112080814)
remchkf1


(c!:install 'subcare '(subcare subfunc nreverse) 16246309351900561860)
subcare


(c!:install 'mo!=zero '(mo!=zero) 13998459805112765093)
mo!=zero


(c!:install 'gvar1 '(gvar1 i !*complex (plus times expt difference minus
) quotient gvarlis1) 10478615922619036053)
gvar1


(c!:install 'ofsf_lnegrel '(ofsf_lnegrel equal neq leq greaterp lessp
geq "ofsf_lnegrel: unknown operator " rederr) 3663283369911138634)
ofsf_lnegrel



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u35.lsp"

Reading "$reduce/cslbuild/generated-c/u36.lsp"

% u36.lsp           Machine generated Lisp

(c!:install "u36" 166848 263349 8516143)
nil


(c!:install 'mk!+real!+inner!+product '(mk!+real!+inner!+product
"wrong dimensions in innerproduct" !*sub2 get!+vec!+dim rederr
get!+vec!+entry multsq addsq subs2) 7960805276825046221)
mk!+real!+inner!+product


(c!:install 'sqfrf '(sqfrf !*gcd !*msg !*rounded rational !*ezgcd
dmode!* rounded failed "sqfrf failure" on resimp diff gcdf quotf!-fail
lnc !:recip multd degr quotf multf rassoc rootxf aconc errach) 
10937586061064161386)
sqfrf


(c!:install 'fnrd '(fnrd char (c i) lex errorml mathml2) 
12513979410557079019)
fnrd


(c!:install 'physoptimes '(physoptimes tstack!* mul!* scalar physopsim!*
getphystype physop2sq multsq mk!*sq physopaeval physopordchk multopop!*)
 11430047265275158506)
physoptimes


(c!:install 'prop!-simp1 '(prop!-simp1 prop!-simp2) 8390697124977389921)
prop!-simp1


(c!:install 'liennewstruc '(liennewstruc lie_a expt difference plus
lie_lamb quotient times lientrans lie_cc minus matrix aeval setk aeval!*
aminusp!: clear) 5169052911349024914)
liennewstruc


(c!:install 'dp_neworder '(dp_neworder dp!=mocompare mo_neworder sort) 
14657201897860316967)
dp_neworder


(c!:install 'rl_fvarl '(rl_fvarl rl_fvarl!* apply) 4349438644931979515)
rl_fvarl


(c!:install 'give!*position '(give!*position "error in give position"
nth rederr) 12727423134272017288)
give!*position


(c!:install 'pasf_smwcpknowl '(pasf_smwcpknowl !*rlsusi cl_susicpknowl
cl_smcpknowl) 5549258679422128435)
pasf_smwcpknowl


(c!:install 'ciml '(ciml "<ci" "" "</ci>" printout attributesml) 
6087610867310095924)
ciml


(c!:install 'sparpri '(sparpri quote setq first (quote !$) last writepri
) 2859011705861866031)
sparpri


(c!:install 'groebspolynom3 '(groebspolynom3 groebspolynom4
groebsavelterm) 8179078728466715752)
groebspolynom3


(c!:install 'evalb '(evalb algebraic true false formbool eval) 
5861203536084675183)
evalb


(c!:install 'string2bytelist '(string2bytelist string2list) 
17726575049732048458)
string2bytelist


(c!:install 'lf!=zero '(lf!=zero) 4076842374495190263)
lf!=zero


(c!:install 'clean_numid '(clean_numid nreverse !*id2num) 
6328967194023589078)
clean_numid


(c!:install 'drnconv '(drnconv dmd!*) 12269271242945414679)
drnconv


(c!:install 'ra_intequiv0 '(ra_intequiv0 x ra_zerop ra_f negf ra_iv
riv_l riv_u negsq addsq sfto_greaterq ra_refine1 sfto_floorq addf
sfto_lessq sfto_fsub1) 14207901402562713221)
ra_intequiv0


(c!:install 'lex_init '(lex_init last64 last64p which_line if_depth
!*tracelex "yylex initialized" lex_peeked yyreadch) 2545617430861042629)
lex_init


(c!:install 'ofsf_sippsubst1 '(ofsf_sippsubst1 ofsf_siatsubf) 
8204819944402773185)
ofsf_sippsubst1


(c!:install 'even_action_sf '(even_action_sf even_action_term addsq) 
17992264046879664529)
even_action_sf


(c!:install 'maxfrom1 '(maxfrom1 nth max) 2038400951185798313)
maxfrom1


(c!:install 'get!-denom!-l '(get!-denom!-l lcmn) 1688803098278549094)
get!-denom!-l


(c!:install 'talp_maxd '(talp_maxd rl_atl talp_arg2l talp_td talp_arg2r)
 12517072239011711715)
talp_maxd


(c!:install 'symbolsom '(symbolsom name valid_om!* diff condition
"<condition> tag not supported in MathML" "<OMA>" int defint
"<OMS cd=""" """ name=""" """/>" lambda "</OMA>" errorml printout
indent!* objectom lambdaom) 16932333532394267659)
symbolsom


(c!:install 'degreef '(degreef max) 9999072322222969174)
degreef


(c!:install 'sc_mkmatrix '(sc_mkmatrix sc_simp sc_iputv) 
6937630376715149540)
sc_mkmatrix


(c!:install 'collectphysops_reversed '(collectphysops_reversed physopp
collectindices removeindices) 11260692883010774105)
collectphysops_reversed


(c!:install 'contr2 '(contr2 contr nreverse split!-road) 
18339366017502773054)
contr2


(c!:install 'listsub '(listsub subeval1 makelist) 8833380159140679301)
listsub


(c!:install 'fs!:make!-nullangle '(fs!:make!-nullangle) 
12989559702858593445)
fs!:make!-nullangle


(c!:install 'groeb!=crita '(groeb!=crita groeb!=testa listminimize) 
8426495118868161396)
groeb!=crita


(c!:install 'split!-further '(split!-further number!-needed
work!-vector1 dwork1 work!-vector2 dwork2 copy!-vector gcd!-in!-vector
quotfail!-in!-vector) 9811635046772757884)
split!-further


(c!:install 'rl_transform '(rl_transform rl_transform!* apply) 
4830843859496009028)
rl_transform


(c!:install 'evalnumberp '(evalnumberp !*sq numbertag aeval) 
16980738746779213824)
evalnumberp


(c!:install 'rl_convertarg '(rl_convertarg rl_conversionfunction apply) 
16762408709431988432)
rl_convertarg


(c!:install 'mconv1 '(mconv1 drnconv nreverse) 4365271436971912269)
mconv1


(c!:install 'setrd '(setrd atts (type) set retattributes stats_getargs) 
12239785899950230790)
setrd


(c!:install 'exdff0 '(exdff0 multsqpf exdfp0 multpfsq addpf) 
13966361513958058173)
exdff0


(c!:install 'r2findindex1 '(r2findindex1 "index not found" rederr) 
89207632565066563)
r2findindex1


(c!:install 'chkint!* '(chkint!* !*!*roundbf !:rd!: !!maxbflexp fl2bf
read!:num normbf msd rndbfon) 15655245400453327677)
chkint!*


(c!:install 'innprodpex '(innprodpex innprodp2 negf) 1676869073879482307
)
innprodpex


(c!:install 'rootextractf '(rootextractf sqrt expt quotient multd
simpexpt multf addf to) 13444072459892712479)
rootextractf



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u36.lsp"

Reading "$reduce/cslbuild/generated-c/u37.lsp"

% u37.lsp           Machine generated Lisp

(c!:install "u37" 151279 6388377 1372549)
nil


(c!:install 'lessppair '(lessppair) 2231640877476236480)
lessppair


(c!:install 'lalr_print_first_information '(lalr_print_first_information
"=== FIRST sets for each nonterminal ===" nonterminals ":" lalr_first
" " lalr_prin_symbol) 4398663868268776971)
lalr_print_first_information


(c!:install 'smt_prin2x '(smt_prin2x outl!*) 8183548821376389510)
smt_prin2x


(c!:install 'ofsf_simplequal '(ofsf_simplequal stsq false !*rlsitsqspl
!*rlsiexpla !*rlsiexpl and tsq ofsf_posdefp sfto_sqfpartf
ofsf_tsqsplequal ofsf_facequal!*) 11100723496419915682)
ofsf_simplequal


(c!:install 'pasf_exprng!-gand '(pasf_exprng!-gand and true false
pasf_exprng) 2135285197525282512)
pasf_exprng!-gand


(c!:install 'bvarom '(bvarom bvar objectom) 200324488163534067)
bvarom


(c!:install 's!-nextarg '(s!-nextarg !*udebug comb i upb (null!-fn)
acontract op mcontract null!-fn expand identity uprint initcomb getcomb
mval) 937573037739323696)
s!-nextarg


(c!:install 'wedgef '(wedgef hodge dimex!* d noxpnd lftshft!* dim!<deg
deg!*form deg!*farg mkuniquewedge1 hodgepf mkunarywedge wedgepf2 negf
addf multf mksgnsq multpfsq mkwedge smemqlp dwedge exdfk negsq addpf) 
2346008126061763515)
wedgef


(c!:install 'apply_e '(apply_e
"randpoly expons function must return an integer" apply rederr) 
11501076928014919792)
apply_e


(c!:install 'diff_vertex '(diff_vertex !_0edge nreverse) 
13748214954855354062)
diff_vertex


(c!:install 'assert_kernelp '(assert_kernelp exlist!*) 
15597765434816421582)
assert_kernelp


(c!:install 'evalgreaterp '(evalgreaterp difference "number" simp!*
minusf negsq mk!*sq typerr !:minusp) 12669567216885518850)
evalgreaterp


(c!:install 'solvealgdepends '(solvealgdepends root_of) 
4136039985782752003)
solvealgdepends


(c!:install 'make!-image '(make!-image m!-image!-variable
evaluate!-in!-order !*n2f) 4739506351694943003)
make!-image


(c!:install 'giplus!: '(giplus!: mkgi) 12497355129620666169)
giplus!:


(c!:install 'ext_mult '(ext_mult ext merge_lists !*a2k to) 
9547799705883413000)
ext_mult


(c!:install 'gcd!-with!-number '(gcd!-with!-number dmode!* gcddd) 
6716578182061466631)
gcd!-with!-number


(c!:install 'aex_sgn '(aex_sgn !*rlanuexsgnopt !*rlverbose
!*rlanuexverbose "[aex_sgn:num!]" aex_simpleratp aex_ex rat_sgn
aex_containment rat_0 iv_lb rat_less iv_rb aex_mvar aex_ctx ctx_get
aex_unbind aex_reduce aex_mklcnt aex_deg anu_dp aex_diff aex_mult
aex_sturmchain anu_iv aex_stchsgnch1) 8206311508880259828)
aex_sgn


(c!:install 'containerom '(containerom name "<OMA>" vectorml vector
valid_om!* set multiset multiset1 "vector" "<OMS cd=""" """ name="""
"""/>" "</OMA>" printout indent!* multiom) 13983074625164896069)
containerom


(c!:install 'mkexdf '(mkexdf d opmtch partitop mkupf) 
4388880663920067806)
mkexdf


(c!:install 'z!-roads '(z!-roads) 9627785030673955102)
z!-roads


(c!:install 'msolve!-psys1 '(msolve!-psys1 subf moduntag
general!-reduce!-mod!-p msolve!-poly) 5325365900206753023)
msolve!-psys1


(c!:install 'ratlessp '(ratlessp ratdif) 885470824671184428)
ratlessp


(c!:install 'lastcar '(lastcar) 9426693423145988947)
lastcar


(c!:install 'aex_divposcnt '(aex_divposcnt aex_ex sfto_ucontentf quotfx
kernels aex_ctx ctx_filter aex_mk aex_sgn aex_neg) 16751357098986179580)
aex_divposcnt


(c!:install 'settcollectnonmultiprolongations '(
settcollectnonmultiprolongations fluidbibasissett
fluidbibasissinglevariablemonomialss monomgetfirstmultivar
tripleisprolongedby polynommultiplybymonom triplesetprolongedby
createtriplewithancestor triplesetprolongset sortedtriplelistinsert) 
11180923753170602520)
settcollectnonmultiprolongations


(c!:install 'processpartitie1list1 '(processpartitie1list1
processpartitie1) 8905402871218447299)
processpartitie1list1


(c!:install 'mk!+outer!+list '(mk!+outer!+list list) 1120975289848745138
)
mk!+outer!+list


(c!:install 'repr_ldeg '(repr_ldeg) 15289004046501352154)
repr_ldeg


(c!:install 'dip_f2dip2 '(dip_f2dip2 dip_vars!* ev_insert dip_f2dip1
bc_pmon bc_prod) 16425107332824954865)
dip_f2dip2


(c!:install 'setfuncsnaryrd '(setfuncsnaryrd multiset mmlatts mathml) 
11760292879859386480)
setfuncsnaryrd


(c!:install 'sqprint '(sqprint !*prin!# orig!* !*nat posn!* !*pri wtl!*
" / " sqhorner!* prepsq!* prepreform maprin xprinf prin2!* xprinf2) 
181925929491622368)
sqprint


(c!:install 'red_tailreddriver '(red_tailreddriver bas_dpoly red!=hidelt
red!=recover) 11140311213774555509)
red_tailreddriver


(c!:install 'getavalue '(getavalue) 9120817111259796697)
getavalue


(c!:install 'reduce!-eival!-powers '(reduce!-eival!-powers
reduce!-eival!-powers1) 17145472828341619245)
reduce!-eival!-powers


(c!:install 'find!-null!-space '(find!-null!-space null!-space!-basis
clear!-column tidy!-up!-null!-vectors) 3931527872299889541)
find!-null!-space


(c!:install 'set_parser '(set_parser parser_action_table reduction_fn
reduction_rhs_n reduction_lhs parser_goto_table nonterminal_codes
terminal_codes lex_restore_context) 1610539588129598405)
set_parser


(c!:install 'sq_member '(sq_member sf_member) 383677299105792360)
sq_member


(c!:install 'orddf '(orddf "Orddf = case" "Orddf v longer than u"
"Orddf u longer than v" interr exptcompare) 10175549868695206343)
orddf


(c!:install 'cl_susiupdknowl '(cl_susiupdknowl false break
cl_susiupdknowl1) 5680824578260435233)
cl_susiupdknowl


(c!:install 'gftimes '(gftimes gfftimes gbftimes) 5154146903667630288)
gftimes


(c!:install 'calc_den_tar '(calc_den_tar denlist constimes) 
2091616914098872757)
calc_den_tar


(c!:install 'no!-side!-effectp '(no!-side!-effectp quote nosideeffects
no!-side!-effect!-listp) 8966344571412724319)
no!-side!-effectp


(c!:install 'atom_compare '(atom_compare) 14638703734338634116)
atom_compare


(c!:install 'lalr_expand_grammar '(lalr_expand_grammar pending_rules!*
lalr_check_grammar expand_rule) 3272494871112121132)
lalr_expand_grammar


(c!:install 'aex_stchsgnch1 '(aex_stchsgnch1 aex_subrat1 aex_sgn
lto_sgnchg) 14323618828463299304)
aex_stchsgnch1


(c!:install 'janettreenodebuild '(janettreenodebuild
monomgetvariabledegree setcdr) 2912401590804738272)
janettreenodebuild


(c!:install 'even_action_term '(even_action_term multf even_action_pow
even_action_sf addsq) 3380478610553922700)
even_action_term


(c!:install 'testord '(testord) 2601262472684569069)
testord


(c!:install 'my!+nullsq!+p '(my!+nullsq!+p) 13231798978309316526)
my!+nullsq!+p


(c!:install 'pasf_varlat '(pasf_varlat (cong ncong) !*rlbrkcxk kernels
lto_lpvarl lastpair) 495821386021008051)
pasf_varlat


(c!:install 'rl_surep '(rl_surep rl_surep!* apply) 1119419072422884408)
rl_surep


(c!:install 'minusrd '(minusrd mathml lex) 8109520012474094012)
minusrd


(c!:install 'assoc2 '(assoc2) 15546565872355360023)
assoc2


(c!:install 'rewrite '(rewrite findrow letmtr3) 16768568789508608917)
rewrite


(c!:install 'ndepends '(ndepends frlis!* depl!* domain!-depends!-fn
lndepends atomf) 4110452451038505699)
ndepends



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u37.lsp"

Reading "$reduce/cslbuild/generated-c/u38.lsp"

% u38.lsp           Machine generated Lisp

(c!:install "u38" 46748 6457982 2322238)
nil


(c!:install 'weak_xreduce1 '(weak_xreduce1 !*trxmod "   " first wedge
" +" last xval xdiv mknwedge wedgepf quotsq negsq multpfsq addpf subs2pf
writepri preppf) 10067255446068332118)
weak_xreduce1


(c!:install 'intrdsortin '(intrdsortin nreverse !:difference !:minusp) 
12946241828873678541)
intrdsortin


(c!:install 'all_defined_vertex '(all_defined_vertex al1_defined_vertex)
 7230922704161179724)
all_defined_vertex


(c!:install 'listeval0 '(listeval0 simpcount!* simplimit!* rlisp
"Simplification recursion too deep" array rerror eval getrtype getelv) 
16941628648368689335)
listeval0


(c!:install 'num_signsort '(num_signsort lambda_ygm6np4pcqv31
ad_signsort) 9981247964616828867)
num_signsort


(c!:install 'lambda_ygm6np4pcqv31 '(lambda_ygm6np4pcqv31) 
15088082726560262194)
lambda_ygm6np4pcqv31


(c!:install 'lpos '(lpos) 392504631650382707)
lpos


(c!:install 'makeqn!-maybe '(makeqn!-maybe equal) 10780296787096721220)
makeqn!-maybe


(c!:install 'lalr_lr0_initial_itemset '(lalr_lr0_initial_itemset !S!' !.
lalr_productions lalr_lr0_closure) 4845558967770285634)
lalr_lr0_initial_itemset


(c!:install 'aex_mklcnt '(aex_mklcnt aex_simpleratp aex_ctx ctx_idl
aex_fvarl aex_lc aex_nullp aex_red aex_sgn aex_0) 8386333306630211088)
aex_mklcnt


(c!:install 'multerm '(multerm !*multsq mulpower multdfconst) 
12104691084579091829)
multerm


(c!:install 'mri_opn '(mri_opn mri_op) 2036384330803727972)
mri_opn


(c!:install 'dip_sum '(dip_sum dip_evlmon ev_comp iequal dip_lbc
dip_moncomp dip_mred bc_sum setcdr) 3983088786451406200)
dip_sum


(c!:install 'ofsf_factsf '(ofsf_factsf negf addf multf) 
4753044934003228333)
ofsf_factsf


(c!:install 'determinantrd '(determinantrd mathml lex) 
13299823222255331775)
determinantrd


(c!:install 'greatertype '(greatertype optlang!* fortran conversion eval
typerror) 14283713471881068885)
greatertype


(c!:install 'mkupf '(mkupf mksq sfp partitsq!*) 350955710441535672)
mkupf


(c!:install '!:!:quotient '(!:!:quotient i2rd!* !:quotient) 
15132540149930532904)
!:!:quotient


(c!:install 'calc_coeffmap_ '(calc_coeffmap_ times calc_map_ calc_coeff)
 3656005963211299502)
calc_coeffmap_


(c!:install 'lalr_make_compressed_goto_table '(
lalr_make_compressed_goto_table nonterminals !S!' lalr_nonterminal_code
!*lalr_verbose lalr_make_compressed_goto_column
lalr_print_compressed_goto_table) 16494174393177441415)
lalr_make_compressed_goto_table


(c!:install 'setqinsertlist '(setqinsertlist fluidbibasissetq
monomcompare) 7255240212151745159)
setqinsertlist


(c!:install 'cl_bvarl '(cl_bvarl ordp cl_bvarl1 sort) 208407522678842217
)
cl_bvarl


(c!:install 'pasf_smwupdknowl '(pasf_smwupdknowl !*rlsusi
cl_susiupdknowl cl_smupdknowl) 14896785202626796851)
pasf_smwupdknowl


(c!:install 'omattrir '(omattrir (!/ o m a t t r) csymbol cn ci lex
omatpir omobj checktag) 15199935747480460102)
omattrir


(c!:install 'sptransmat '(sptransmat spm matlength aeval mkempspmat
letmtr3) 11078188207137486602)
sptransmat


(c!:install 'vdpcleanup '(vdpcleanup dipevlist!*) 9726310706373385971)
vdpcleanup


(c!:install 'contposp '(contposp) 8182456738789676309)
contposp


(c!:install 'toolongassignp '(toolongassignp toolongexpp) 
4118697004373164395)
toolongassignp


(c!:install 'simppartdf '(simppartdf partitpartdf !*pf2sq) 
18226010435382712502)
simppartdf


(c!:install 's_world_names '(s_world_names) 15003719730143642310)
s_world_names


(c!:install 'dp_from_ei '(dp_from_ei cali_bc_fi mo_from_ei dp_term) 
1551402700809790358)
dp_from_ei


(c!:install 'createmonomunit '(createmonomunit) 15320518510719391198)
createmonomunit


(c!:install 'pickbasicset '(pickbasicset wuvarlist!* symbollessp
wureducedpolysp) 11600875189995843870)
pickbasicset


(c!:install 'mri_ofsf2mriat '(mri_ofsf2mriat mri_0mk2) 
16306935581848189185)
mri_ofsf2mriat


(c!:install 'intervalom '(intervalom name lowupperlimit integer_interval
valid_om!* interval!* "<OMA>" "<OMS cd=""" """ name=""" """/>" "</OMA>"
printout indent!* multiom) 17922406443138092447)
intervalom


(c!:install 'remzzzz '(remzzzz nreverse) 12941972615663851898)
remzzzz


(c!:install 'sc_rowscalarproduct '(sc_rowscalarproduct sc_simp
fast!-column!-dim sc_getmat sc_multsq sc_addsq) 12509885332419258561)
sc_rowscalarproduct


(c!:install 'simpunion '(simpunion union empty_set applysetop ordn mksp)
 10879639108873967154)
simpunion


(c!:install 'gbfplus '(gbfplus plubf) 12825317034124909812)
gbfplus


(c!:install 'indxsymp '(indxsymp) 15395267106291607297)
indxsymp


(c!:install 'getphystypeexpt '(getphystypeexpt scalar getphystypecar) 
2421237881282221574)
getphystypeexpt


(c!:install 'fs!:minusp '(fs!:minusp minusf) 16879958195719117773)
fs!:minusp


(c!:install 'squashsqrt '(squashsqrt sqrtflag sqrt expt !*multfsqrt addf
prefix!-rational!-numberp !*multfexpt) 11918770788985965987)
squashsqrt


(c!:install 'ofsf_decdeg2 '(ofsf_decdeg2 !*gcd !*rlbrkcxk odd
ofsf_cxkdgcd cl_atl1 ofsf_ignshift sfto_reorder gcdf quotf) 
11775432427567021001)
ofsf_decdeg2


(c!:install 'mk!+scal!+mult!+mat '(mk!+scal!+mult!+mat
"no matrix in add" !*sub2 matrix!+p rederr multsq subs2) 
8701325537221077134)
mk!+scal!+mult!+mat


(c!:install 'cl_susiupdknowl2 '(cl_susiupdknowl2 false rl_susibin
cl_susiinter) 14100854535063077308)
cl_susiupdknowl2


(c!:install 'gcdld '(gcdld gcd!-with!-number) 1316750812650340790)
gcdld


(c!:install 'matrixelems '(matrixelems nreverse) 6488175335555744394)
matrixelems


(c!:install 'f2dip1 '(f2dip1 f2dip11 bcfd bcprod f2dip2 dipsum) 
14214282398288548756)
f2dip1


(c!:install 'add_item '(add_item !*xset!* setcar setcdr monordp) 
5074126693414448741)
add_item


(c!:install 'bflessp '(bflessp grpbf) 6727009590002545733)
bflessp


(c!:install 'spp '(spp kernelp) 2104866104876182072)
spp


(c!:install 's_noparents '(s_noparents nreverse has_parents) 
15571569376697139997)
s_noparents


(c!:install 'xremf '(xremf qremd termsf addf qremf multf to negf ordop) 
10707079095879704584)
xremf


(c!:install 'vector!-to!-poly '(vector!-to!-poly !*n2f to) 
12971166603679893390)
vector!-to!-poly



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u38.lsp"

Reading "$reduce/cslbuild/generated-c/u39.lsp"

% u39.lsp           Machine generated Lisp

(c!:install "u39" 152894 4012351 3584107)
nil


(c!:install 'lex_keywords '(lex_keywords
"Empty string passed to lex_keywords" lex_code lex_keyword_names
lex_next_code lex_codename !*tracelex "Token '" "' allocated code "
"dipthong data '" "' plus '" "' => '" "'" lex_dipthong widestring2list
rederr list2widestring lastcar) 5650203126095189328)
lex_keywords


(c!:install 'cl_atnum '(cl_atnum or and not impl repl equiv ex all bex
ball true false rl_external apply) 16613845702167105898)
cl_atnum


(c!:install 'cl_pnf1 '(cl_pnf1 cl_rename!-vars cl_pnf2 cl_qb) 
598750603176606671)
cl_pnf1


(c!:install 'fnom '(fnom "<OMA>" "<OMATTR>" "<OMATP>"
"<OMS cd=""typmml"" name=""type""/>" "<OMS cd=""typmml"" name="""
"fn_type" """/>" "</OMATP>" "</OMATTR>" "</OMA>" printout indent!*
objectom multiom) 11254068639714551012)
fnom


(c!:install 'plusrd '(plusrd mathml alg_plus) 353584120376949198)
plusrd


(c!:install 'simpimpart '(simpimpart !*factor simp!* impartsq) 
1318661892495599752)
simpimpart


(c!:install 'genexp '(genexp genp) 8146647324349884369)
genexp


(c!:install 'exdfprn '(exdfprn "d" prin2!* rembras) 5596773582070494333)
exdfprn


(c!:install 'aceq '(aceq) 12405514265448346600)
aceq


(c!:install 'log_freevars '(log_freevars constant!?
"+++ Use of free variable in smacro/inline body: " "+++ Macro was: "
inlineinfo quote function go prog lambda cond log_freevars_list
log_freevars_list_list) 17921410601274168701)
log_freevars


(c!:install 'bas_make '(bas_make dp_ecart) 11969008909803901740)
bas_make


(c!:install 'pst_subpst '(pst_subpst) 468417355526156341)
pst_subpst


(c!:install 'appn '(appn) 10856915010899932549)
appn


(c!:install 'multivariatep '(multivariatep) 6455206724317581613)
multivariatep


(c!:install 'lalr_augment_grammar '(lalr_augment_grammar !S!') 
6209230831193506242)
lalr_augment_grammar


(c!:install 'createsinglevariablemonom '(createsinglevariablemonom) 
8112136363574510503)
createsinglevariablemonom


(c!:install 'my_freeof '(my_freeof depl!* smember freeofdepl) 
17062619644645782754)
my_freeof


(c!:install 'giintgcd '(giintgcd !:gi!:) 13740428451164188103)
giintgcd


(c!:install 'talp_nextt1 '(talp_nextt1 talp_nextt!-atom talp_invp
talp_fargl setcdr setcar talp_get!-idx talp_get!-minfct) 
18100725233100552879)
talp_nextt1


(c!:install 'rl_onp '(rl_onp !* eval) 12324384732156656671)
rl_onp


(c!:install 'vectorrd '(vectorrd atts (type other) vectorml
retattributes matrixrowrd) 6733517731623441737)
vectorrd


(c!:install 'ldf!-simp '(ldf!-simp to prepf simp comfac quotf absf) 
15588029444650465051)
ldf!-simp


(c!:install 'transmat1 '(transmat1 spm avalue sparse rtype aeval
matlength mkempspmat letmtr3) 13407070583228247971)
transmat1


(c!:install 'on!-double1 '(on!-double1 !*double doublep) 
13186537529071107945)
on!-double1


(c!:install 'getupper '(getupper metricu!*) 15186515998889084419)
getupper


(c!:install 'replace2_parents '(replace2_parents) 14609136266563362727)
replace2_parents


(c!:install 'prepsq!*1 '(prepsq!*1 factors!* expt kord!* dnl!* !*allfac
upl!* !*div minus quotient prepsq!*0 to quotfm mksp nconc!* kernlp mkkl
ckrn ckrn!* quotof canonsq prepf addfactors rmplus exchk prepsq aconc!*
retimes) 8623262739272361502)
prepsq!*1


(c!:install 'reduce '(reduce !*yyy !*xxx reduce!-ratios set!-weights
reduce!-columns reduce!-weights) 9150259719354933981)
reduce


(c!:install 'fs!:minusp!: '(fs!:minusp!: fs!:minusp) 
12591440367648243122)
fs!:minusp!:


(c!:install 'xnsiz '(xnsiz !!log2of10 xnsiz1 ceiling) 
5834800755168866135)
xnsiz


(c!:install 'lalr_collect_nonterminals '(lalr_collect_nonterminals
lalr_remove_duplicates) 3662969860216128040)
lalr_collect_nonterminals


(c!:install 'simpexpt2 '(simpexpt2 expt !*precise_complex !*precise abs
sqrt !*keepsqrts times !*modular quotient !*mcd minus dmode!* frlis!*
simp multsq simpexpt1 split!-sign retimes posnump prepsq simp!* simpexpt
quotsq prepf simpx1 mksq) 15655962808424643348)
simpexpt2


(c!:install 'pasf_uprap '(pasf_uprap pasf_uprap1) 3232069444272176219)
pasf_uprap


(c!:install 'lowupperlimitrd '(lowupperlimitrd char (!/ l o w l i m i t)
"</lowlimit>" lowupperlimit mathml lex upperlimitrd errorml) 
17356792950860261456)
lowupperlimitrd


(c!:install 'spcol_dim '(spcol_dim !*fast_la
"Error in spcol_dim: input should be a matrix." matrixp rederr
spmatlength) 1864137754474694627)
spcol_dim


(c!:install 'inszzz '(inszzz nreverse dm!-plus zeropp) 
17252360909060105119)
inszzz


(c!:install 'qsum!-simpexpt1 '(qsum!-simpexpt1 minus (minus 1)
inside!-qsum!-simpexpt!* basic!-simpexpt multsq) 153397332093767487)
qsum!-simpexpt1


(c!:install 'simp_without_resimp '(simp_without_resimp !*resimp simp) 
8992338469488600133)
simp_without_resimp


(c!:install 'groebinvokecritm '(groebinvokecritm mcount!*
buchvevdivides!? groedeletip) 590440005261952739)
groebinvokecritm


(c!:install 'sc_columnscalarproduct '(sc_columnscalarproduct sc_simp
fast!-row!-dim sc_getmat sc_multsq sc_addsq) 14476979503128174459)
sc_columnscalarproduct


(c!:install 'mkbc '(mkbc !*grmod!* (1 . 1) f2dip11 bcfi minusf negf gcdf
quotfx) 188726536352607870)
mkbc


(c!:install 'applysetop '(applysetop list setvalued "set" setdiff reval
delete!-dups make!-set typerr aeval) 9669029901271027468)
applysetop


(c!:install 'mod!-dump1 '(mod!-dump1 nreverse l!-subst) 
5509476665427990407)
mod!-dump1


(c!:install 'quotodd '(quotodd mkrn int!-equiv!-chk lowest!-terms) 
680472806820485415)
quotodd



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u39.lsp"

Reading "$reduce/cslbuild/generated-c/u40.lsp"

% u40.lsp           Machine generated Lisp

(c!:install "u40" 135533 5952200 101974)
nil


(c!:install 'lengthreval '(lengthreval alg
"LENGTH called with wrong number of arguments" list dimension lengthfn
sparse "LENGTH not defined for argument of type" "LENGTH argument"
rerror arrayp aeval getrtype lprie typerr) 7036667717362130412)
lengthreval


(c!:install 'ra_intequiv '(ra_intequiv ra_intequiv0 ra_wrapper) 
4966337950892696655)
ra_intequiv


(c!:install 'component_action '(component_action ext_mult multsq addsq) 
7495819328308817992)
component_action


(c!:install 'fctargs '(fctargs depl!*) 7492744808037637563)
fctargs


(c!:install 'rl_mk!*fof '(rl_mk!*fof rl_csimpl rl_mk!*fof1) 
4409157602058082763)
rl_mk!*fof


(c!:install 'rl_bnfsimpl '(rl_bnfsimpl rl_bnfsimpl!* apply) 
12102889295070448289)
rl_bnfsimpl


(c!:install 'repr_n '(repr_n "repr_n : invalid REPR structure" rederr) 
9234101115622280862)
repr_n


(c!:install 'matrixrd '(matrixrd atts (type) char (m a t r i x r o w) (
!/ m a t r i x r o w) "</matrixrow>" matrix matrixrow retattributes lex
matrixrowrd errorml) 13063924941624522107)
matrixrd


(c!:install 'fnreval '(fnreval nreverse reval1) 14280642333297093583)
fnreval


(c!:install 'evweightedcomp1 '(evweightedcomp1 evweightedcomp2) 
1864450719058990833)
evweightedcomp1


(c!:install 'pa_list2vect '(pa_list2vect min eval) 5451357368922459589)
pa_list2vect


(c!:install 'fd2q '(fd2q !:ar!: !:rn!: multsq addsq) 7324173800691249502
)
fd2q


(c!:install 'outer!-simpsqrt '(outer!-simpsqrt !*inside!-int!*
proper!-simpsqrt simpsqrt) 18058139613902210605)
outer!-simpsqrt


(c!:install 'oddext '(oddext odd_var all_parametric_odd!* ext
all_principal_odd!* n_all_parametric_ext
"the argument of oddext must be an odd variable" cde_position rederr) 
2547200403774432413)
oddext


(c!:install 'polynomread '(polynomread fluidbibasisvariables
fluidbibasissinglevariablemonomialsa createmonomunit
polynommultiplybymonom polynomadd) 2488681923758697205)
polynomread


(c!:install 'expf '(expf frlis!* expt mkrn !:expt mksp!* fkern to sfp
exptf multf) 4757765179415139813)
expf


(c!:install 'mri_2ofsfat '(mri_2ofsfat mri_op mri_arg2l) 
9666639455723432082)
mri_2ofsfat


(c!:install 'quotfx1 '(quotfx1 quotfxerr quotfdx lt!* rnconc to cutf
multf negf addf aconc!* ordop quotkx) 9940331203536447535)
quotfx1


(c!:install 'rl_multsurep '(rl_multsurep rl_multsurep!* apply) 
3445218919925543971)
rl_multsurep


(c!:install 'upperlimitrd '(upperlimitrd char (u p l i m i t)
"<uplimit>" (!/ u p l i m i t) "</uplimit>" lex errorml mathml) 
2308004473999083423)
upperlimitrd


(c!:install 'compl '(compl nreverse) 9091191792981206695)
compl


(c!:install 'suspend '(suspend op r p amatch) 17827214845217231143)
suspend


(c!:install 'vdpequal '(vdpequal number vdpgetprop dipequal) 
17003390932381677455)
vdpequal


(c!:install 'evinsert '(evinsert nreverse) 9473338652992442538)
evinsert


(c!:install 'simpwedge '(simpwedge partitwedge !*pf2sq) 
8774782948149901481)
simpwedge


(c!:install 'divide!-by!-power!-of!-ten '(divide!-by!-power!-of!-ten
bften!* !:bprec!: bflerrmsg divide!: normbf lshift times!: cut!:mt) 
11769155870995793676)
divide!-by!-power!-of!-ten


(c!:install 'cvitimes2 '(cvitimes2 times) 1452841355575771990)
cvitimes2


(c!:install 'ratnump '(ratnump !:rn!: simp!*) 12588082219399414369)
ratnump


(c!:install 'miller!-rabin '(miller!-rabin set!-modulus) 
14156322706059773842)
miller!-rabin


(c!:install 'dfp!-sub '(dfp!-sub generic_function list dfp listsub reval
pair dfp!-sub1) 7670772426438171903)
dfp!-sub


(c!:install 'redall '(redall gg!* shortway!* thirdway!* gv!* path
" ==> " " --> " conds!* bv!* ljet nf ord dd insert) 862425875582441527)
redall


(c!:install 'get!-current!-representation '(get!-current!-representation
currep) 5098454424683034082)
get!-current!-representation


(c!:install 'prepsq!*0 '(prepsq!*0 gcdf quotf!-fail prepsq!*1) 
1045838241206605395)
prepsq!*0


(c!:install 'isimp1 '(isimp1 !*cvit calc_spurx spur0 multd index_simp
emult multf isimp2 addf) 16874276077515923660)
isimp1


(c!:install 'rl_qefsolset '(rl_qefsolset rl_qefsolset!* apply) 
18185265947675789221)
rl_qefsolset


(c!:install 'intervalrd '(intervalrd atts (closure) char (!/ i n t e r v
a l) interval "</interval>" retattributes mathml lex errorml) 
5723057958792845697)
intervalrd


(c!:install 'prlist '(prlist nreverse) 9664766906394956166)
prlist


(c!:install 'letmtr '(letmtr mat matrix "Matrix" "not set" hold rerror
revlis numlis errpri2 nth pnth) 508084208141511444)
letmtr


(c!:install 'a2bc '(a2bc !*grmod!* " Invalid coefficient " rederr bcfd
simp!*) 15749005389575975235)
a2bc


(c!:install 'gfplus '(gfplus gffplus gbfplus) 12495226635554652173)
gfplus


(c!:install 'numprintlen '(numprintlen !:rd!: (!:cr!: !:crn!: !:gi!:)
plus rd!:explode lispeval) 5981142656198358253)
numprintlen


(c!:install 'mk_binding '(mk_binding can_be_proved edge_bind) 
11011753991814478595)
mk_binding


(c!:install 'equiv!-coeffs '(equiv!-coeffs nzeros nreverse mv!-pow!-!>) 
8249380351838145758)
equiv!-coeffs


(c!:install 'taylorp '(taylorp taylor) 18210632415241541829)
taylorp


(c!:install 'lesspcar '(lesspcar) 10263904006278182342)
lesspcar


(c!:install 'rl_qe '(rl_qe rl_qe!* apply) 17320963409233102897)
rl_qe


(c!:install 'cl_apply2ats1 '(cl_apply2ats1 true false ex all bex ball or
and not impl repl equiv apply) 5930425794114745903)
cl_apply2ats1


(c!:install 'maxfrom '(maxfrom maxfrom1) 13525207612058789982)
maxfrom


(c!:install 'mk!+mat!+plus!+mat '(mk!+mat!+plus!+mat "no matrix in add"
"wrong dimensions in add" !*sub2 matrix!+p rederr get!+col!+nr
get!+row!+nr get!+mat!+entry addsq subs2) 13087818988067160932)
mk!+mat!+plus!+mat


(c!:install 'ezgcd!-comfac '(ezgcd!-comfac poly!-abs gcdlist) 
14275248721658190430)
ezgcd!-comfac


(c!:install 'transposerd '(transposerd mathml lex) 14810617089545403103)
transposerd



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u40.lsp"

Reading "$reduce/cslbuild/generated-c/u41.lsp"

% u41.lsp           Machine generated Lisp

(c!:install "u41" 117463 7222334 47046)
nil


(c!:install 'extbrsea '(extbrsea rowmin rowmax codmat maxvar times
initbrsea extbrsea1 expandprod shrinkprod) 18359082246896174113)
extbrsea


(c!:install 'copy_mat '(copy_mat matrix_input_test size_of_matrix
mkmatrix getmat setmat) 16348247403971186796)
copy_mat


(c!:install 'exdf0 '(exdf0 exdff0 negf multpfsq addpf) 
9904970085747053740)
exdf0


(c!:install 'multiply!-by!-power!-of!-ten '(multiply!-by!-power!-of!-ten
bften!* !:bprec!: bflerrmsg times!: normbf lshift cut!:mt) 
18394915745764875788)
multiply!-by!-power!-of!-ten


(c!:install 'formsetq0 '(formsetq0 quote symbolic !*savedef inline
smacro "+++ Assign via inline or smacro: " "assignment" setel vector
vecfn part list setpart!* setqfn !*rlisp88 structfetch rsetf setk
algebraic reserved setv convertmode typerr macrochk arrayp intargfn
putvect formlis aconc applsmacro form1 rsverr symbid mksetshare mksetq) 
3471389308416153098)
formsetq0


(c!:install 'simp!-prop!-dist '(simp!-prop!-dist plus times
lambda_iff2c8okfzyq1 simp!-prop!-order sort) 12624899860164811202)
simp!-prop!-dist


(c!:install 'lambda_iff2c8okfzyq1 '(lambda_iff2c8okfzyq1 ordp) 
2988551691672434219)
lambda_iff2c8okfzyq1


(c!:install 'lambda_iff2c8okfzyq1 '(lambda_iff2c8okfzyq1 ordp) 
2988551691672434219)
lambda_iff2c8okfzyq1


(c!:install 'list2vect!* '(list2vect!* algebraic nth symb_to_alg) 
6362396843862643552)
list2vect!*


(c!:install 'which_first '(which_first) 5362535682633495787)
which_first


(c!:install 'talp_trygaussvar '(talp_trygaussvar and or failed talp_atfp
talp_qesolset talp_gaussand talp_gaussor) 14921329553473086716)
talp_trygaussvar


(c!:install 'cl_gand!-col '(cl_gand!-col true and !*rlsichk cl_cflip
cl_flip cl_simpl1) 6160713033187959660)
cl_gand!-col


(c!:install 'pasf_susibinad '(pasf_susibinad false true (delete . t)
equal cl_susiminlevel pasf_susibineq pasf_dec pasf_susibinord kernels
negf pasf_subfof1 pasf_susibinad1) 13184230421889198236)
pasf_susibinad


(c!:install 'ctx_get '(ctx_get ctx_ial) 10695835100804838133)
ctx_get


(c!:install 'symbolsrd '(symbolsrd char (b v a r) "" "<bvar>" (l o w l i
m i t) (i n t e r v a l) (c o n d i t i o n) lex bvarrd errorml
lowupperlimitrd intervalrd conditionrd mathml2) 4467914345170814651)
symbolsrd


(c!:install 'findelem2 '(findelem2 sparsemat) 3441519714088510835)
findelem2


(c!:install 'init '(init fluidbibasisvariables
fluidbibasisreversedvariables fluidbibasissinglevariablemonomialss
fluidbibasissinglevariablemonomialsa fluidbibasissetq
fluidbibasisreductionsmade fluidbibasisnormalforms
fluidbibasisnonzeronormalforms initmonomials settreset) 
3772679028213484507)
init


(c!:install 'size_of_matrix '(size_of_matrix matrix_input_test) 
10923826081544999356)
size_of_matrix


(c!:install 'fl2bf '(fl2bf "Floating point infinity or NaN" !!nbfpd
!:rd!: fp!-finite rederr frexp normbf) 1498310614408507700)
fl2bf


(c!:install 'list!-evaluate '(list!-evaluate evaluate) 
16287211716014147173)
list!-evaluate


(c!:install 'consrecip '(consrecip recip) 706964435408471715)
consrecip


(c!:install 'splitup '(splitup) 2771208093256628215)
splitup


(c!:install 'simpquot '(simpquot alg "0/0 formed" "Zero divisor" dmode!*
(!:rd!: !:cr!:) !*modular simpcar simp rerror !:onep divd simprecip
multsq) 3293748250358531092)
simpquot


(c!:install 'mchsarg '(mchsarg times mtp noncomfree noncomperm pair
mcharg2 lastpair reversip!*) 15121871990663945559)
mchsarg


(c!:install 'algmodep '(algmodep (aeval aeval!*)) 17401596320637496471)
algmodep


(c!:install 'xnp '(xnp) 3670401420781418878)
xnp


(c!:install 'lalr_set_nonterminal_codes '(lalr_set_nonterminal_codes
nonterminals !S!' lalr_nonterminal_code !*lalr_verbose nonterminal_codes
) 4786341589204017049)
lalr_set_nonterminal_codes


(c!:install 'talp_invtscc '(talp_invtscc talp_arg2l talp_arg2r
talp_noffcts talp_invp talp_td talp_invarg) 13303176109906050936)
talp_invtscc


(c!:install 'pasf_sacat '(pasf_sacat) 3607541727113827278)
pasf_sacat


(c!:install 'diffrd '(diffrd char (b v a r) lex bvarrd mathml2 diff2) 
11168113424929237913)
diffrd


(c!:install 'insertocc '(insertocc) 16473203438804115313)
insertocc


(c!:install 'xreadlist '(xreadlist !*rcbkt!* list group cursym!*
!*semicol!* "Syntax error: semicolon in list" !*comma!*
"Syntax error: invalid comma in list" scan xread1 aconc nconc2 symerr) 
8996391974605582747)
xreadlist


(c!:install 'incident1 '(incident1) 11612625159021577600)
incident1


(c!:install 'set!-weights '(set!-weights) 7860336305574161332)
set!-weights


(c!:install '!*g2lex '(!*g2lex psum) 12149569950736608275)
!*g2lex


(c!:install '!*n2a '(!*n2a !*q2a) 13658156341575576597)
!*n2a


(c!:install 'basic!-kern '(basic!-kern basic!-kern1 union) 
13055878441452632155)
basic!-kern


(c!:install 'noncomfree '(noncomfree) 14852152156915043048)
noncomfree


(c!:install 'gadd '(gadd a ndims!* hephys
"Gamma5 not allowed unless vecdim is 4" rerror) 17275387982430996422)
gadd


(c!:install 'mk!+equation '(mk!+equation equal) 3655977449687579310)
mk!+equation


(c!:install 'talp_invtscsimpl '(talp_invtscsimpl or and (ex all)
talp_rnf talp_atfp talp_invtscc talp_simpat talp_invtscsimplat talp_op
talp_argl) 8503326907152582869)
talp_invtscsimpl


(c!:install 'repr_new '(repr_new "repr_new : invalid coefficient list"
rederr) 15740683123080672425)
repr_new


(c!:install 'prsubsetrd '(prsubsetrd mathml) 2207896389365212214)
prsubsetrd



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u41.lsp"

Reading "$reduce/cslbuild/generated-c/u42.lsp"

% u42.lsp           Machine generated Lisp

(c!:install "u42" 63265 8278215 5229974)
nil


(c!:install 'findoptrow '(findoptrow codmat maxvar roccup1 newnjsi
newjsi roccup2 pnthxzz testpr) 13494316580563076789)
findoptrow


(c!:install 'diplmon2sq '(diplmon2sq dipvars!* dipev2f multsq) 
15227123221674441372)
diplmon2sq


(c!:install 'remove_least_item '(remove_least_item
"How did we get here?" rederr remove_root_item) 4979620738984819027)
remove_least_item


(c!:install 'listpri '(listpri !*lcbkt!* orig!* posn!* listpri_depth!*
!*comma!* !*rcbkt!* prin2!* treesizep negnumberchk maprint oprin
terpri!*) 16221603008393779124)
listpri


(c!:install 'r2speclist1 '(r2speclist1 times r2speclist2) 
13339648047941911489)
r2speclist1


(c!:install 'mkassign '(mkassign setq) 1784845354946001370)
mkassign


(c!:install 'ev!-edgeloop '(ev!-edgeloop ndim!* binc) 
10671481024158201592)
ev!-edgeloop


(c!:install 'primep27 '(primep27 set!-modulus miller!-rabin) 
9158665175866916215)
primep27


(c!:install 'nonmult '(nonmult vjets!* nth) 6527037553161993770)
nonmult


(c!:install 'xquotient!-mod!-p '(xquotient!-mod!-p exact!-quotient!-flag
quotient!-mod!-p times!-mod!-p difference!-mod!-p mksp negate!-term
times!-term!-mod!-p plus!-mod!-p) 2976120306900312689)
xquotient!-mod!-p


(c!:install 'mkcrn '(mkcrn !:crn!:) 3117764722230454000)
mkcrn


(c!:install 'extadd '(extadd addf setcdr ordexp) 1336103341634382315)
extadd


(c!:install 'read!-comment1 '(read!-comment1 !*lower !*raise
named!-character!* crchar!* !$eol!$ !  id2string string!-length delcp
readch1 condterpri) 3003596910571484168)
read!-comment1


(c!:install 'sfto_yun!-updecf '(sfto_yun!-updecf !*gcd diff sfto_gcdf
quotf negf addf multf setcar setcdr) 10250296188671186867)
sfto_yun!-updecf


(c!:install 'rl_identity1 '(rl_identity1) 491532843247411839)
rl_identity1


(c!:install 'pasf_anegateat '(pasf_anegateat true false (cong ncong)
pasf_anegrel pasf_mkop negf) 9996326776010047622)
pasf_anegateat


(c!:install 'bc_sum '(bc_sum addsq) 2470970195362364800)
bc_sum


(c!:install 'ciom '(ciom "<OMATTR>" "<OMATP>"
"<OMS cd=""typmml"" name=""type"">" "<OMS cd=""typmml"" name="""
mmltypes!* """>" "</OMATP>" "</OMATTR>" printout indent!* objectom) 
414213925339740331)
ciom


(c!:install 'f4 '(f4 pi "<pi/>" euler_gamma "<eulergamma/>" true
"<true/>" false "<false/>" !Na!N "<notanumber/>" infinity !*web
"<cn type=""constant"">" "<cn type=&quot;constant&quot;>" "&infin;"
"</cn>" e "&ExponentialE;" i "&ImaginaryI;" "<cn" " type=""real"">"
" type=&quot;real&quot;>" " type=""integer"">"
" type=&quot;integer&quot;>" ">" "<ci" " type=""list"">"
" type=&quot;list&quot;>" " type=""vector"">"
" type=&quot;vector&quot;>" "</ci>" printout listp) 13386084776726673023
)
f4


(c!:install 'evzero '(evzero dipvars!*) 16713074392839796302)
evzero


(c!:install 'chksymmetries!&sub1 '(chksymmetries!&sub1 indxsymp) 
10352781567040591900)
chksymmetries!&sub1


(c!:install 'strand!-alg!-top '(strand!-alg!-top deletez1 color!-strand
contract!-strand dstr!-to!-alg) 3372204842910521221)
strand!-alg!-top


(c!:install 'cali!=min '(cali!=min listtest) 16234821378511320355)
cali!=min


(c!:install 'appr '(appr) 7217817733980180627)
appr


(c!:install 'sfto_psrem '(sfto_psrem sfto_lcx sfto_dgcd quotfx sfto_kexp
multf negf addf sfto_vardeg) 7530110796061676935)
sfto_psrem


(c!:install 'co_hfn '(co_hfn cl_fvarl1 rl_atnum) 8041559398047499050)
co_hfn


(c!:install 'ofsf_updsigndom '(ofsf_updsigndom equal greaterp lessp
"something wrong in ofsf_updSignDom:" rederr) 65917844509290034)
ofsf_updsigndom


(c!:install 'change!+int!+to!+sq '(change!+int!+to!+sq) 
14816472864499624533)
change!+int!+to!+sq


(c!:install 'cl_subfof '(cl_subfof rl_subalchk rl_eqnrhskernels
lto_alunion cl_varl1 lto_nconcn cl_subfof1) 3324571847770003605)
cl_subfof


(c!:install 'rl_sacatlp '(rl_sacatlp rl_sacatlp!* apply) 
1265259771237399829)
rl_sacatlp


(c!:install 'conditionml '(conditionml "<condition>" "</condition>"
printout indent!* expression) 7439993112548794210)
conditionml


(c!:install 'simpu '(simpu u ordn mksp) 8431280624889325808)
simpu


(c!:install 'qsimpcomb_standard_integer_part_sf '(
qsimpcomb_standard_integer_part_sf) 2059597484296139354)
qsimpcomb_standard_integer_part_sf


(c!:install 'a2vdp '(a2vdp vdp a2dip) 12718446759882275070)
a2vdp


(c!:install 'markedvarp '(markedvarp !*marked!*) 2259735358532423556)
markedvarp


(c!:install 'evalwhereexp '(evalwhereexp aeval where carx evalletsub) 
17778069659015691080)
evalwhereexp


(c!:install 'mv!-compact2 '(mv!-compact2 equiv!-coeffs mv!-domainlist
reduce mv!-domainlist!-!- mv!-coeff!-replace mv!-!+) 
18366684156009604270)
mv!-compact2


(c!:install 'extract_vars '(extract_vars variable nreverse raiseind!:) 
581001641406960949)
extract_vars


(c!:install 'expand_terminal '(expand_terminal opt (nil) pending_rules!*
seq star (cons !$1 !$2) plus (list !$1) list (cons !$2 !$3) listplus or
"Invalid item in a rule" expansion_name rederr) 15818890523742089676)
expand_terminal


(c!:install 'not_included '(not_included) 13035740386792352516)
not_included


(c!:install 'valuechk '(valuechk variadic !:rd!: !:rn!:
!*strict_argcount alg "Wrong number of arguments to" list rerror lprim
opfchk!! znumrnil) 3047585610233842763)
valuechk


(c!:install 'cgp_greenp '(cgp_greenp cgp_rp) 14495413788687484424)
cgp_greenp


(c!:install 'integralir '(integralir atts name (bvar x 1) defint lambda
find lex omobj lambdavar lambdafun) 16370928631215989033)
integralir


(c!:install 'specrd!:times '(specrd!:times minus add_minus mkround
rd!:times) 8213566267099448959)
specrd!:times


(c!:install 'dip2a '(dip2a dip2a1 dipreplus) 11861845728545505400)
dip2a


(c!:install 'evalmember '(evalmember getrlist) 5286359330849485084)
evalmember


(c!:install 'gbfdiff '(gbfdiff difbf) 11601477481004078606)
gbfdiff


(c!:install 'gpargp '(gpargp gpexpp gplogexpp) 3658154410741724482)
gpargp


(c!:install 'indexvp '(indexvp) 11663335178243527811)
indexvp


(c!:install 'mk_simpl_map_ '(mk_simpl_map_ mk_simpl_map_1) 
11429407052348500504)
mk_simpl_map_


(c!:install 'simpdfp '(simpdfp frlis!* dfp list generic_function (list)
dfp_commute kord!* ordp "generic differential" reval mksq simpdf
dfp!-normalize simp sort typerr) 18210698244860926008)
simpdfp


(c!:install 'balance_mod '(balance_mod) 9394762873806819714)
balance_mod


(c!:install 'super_vectorfield '(super_vectorfield "SUPER_VECTORFIELD:"
"is not an identifier" simpfn super_der_simp full list ext
"not a valid odd variable" variables even_dimension odd_dimension setkfn
setk_super_vectorfield msgpri max) 1658243385334407921)
super_vectorfield


(c!:install 'rtypepart '(rtypepart yetunknowntype getrtypecar) 
3648361854817758982)
rtypepart


(c!:install 'fctlength '(fctlength fctargs) 3620606859388514100)
fctlength



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u42.lsp"

Reading "$reduce/cslbuild/generated-c/u43.lsp"

% u43.lsp           Machine generated Lisp

(c!:install "u43" 27781 1588339 5383411)
nil


(c!:install 'gigcdsq '(gigcdsq giintgcd quotf) 2701479337646345197)
gigcdsq


(c!:install 'subtractinds '(subtractinds) 1781800755294678369)
subtractinds


(c!:install 'mk!+resimp!+mat '(mk!+resimp!+mat resimp) 
624978839118700389)
mk!+resimp!+mat


(c!:install 'freeof!-dfl '(freeof!-dfl freeof!-df) 7723985767789675549)
freeof!-dfl


(c!:install 'pasf_coeflst '(pasf_coeflst setkorder reorder negf) 
2841843459196695079)
pasf_coeflst


(c!:install 'vdp_mred '(vdp_mred vdp_poly dip_mred vdp_zero dip_lbc
dip_evlmon vdp_make vdp_sugar vdp_setsugar) 14120986251177878325)
vdp_mred


(c!:install 'vsl_subatsq '(vsl_subatsq ofsf_subf) 17394022548472661751)
vsl_subatsq


(c!:install 'numir '(numir atts name complex_cartesian plus times
!&imaginaryi!; complex_polar exp rational divide find lex omobj) 
204094701760676937)
numir


(c!:install 'diford '(diford lengthn) 7054798114156165767)
diford


(c!:install 'remdiff '(remdiff difference plus minus constp) 
14005009348996126671)
remdiff


(c!:install 'xpartitop '(xpartitop simp!* xpartitsq) 7201581560387780161
)
xpartitop


(c!:install 'gfdiffer '(gfdiffer gffdiff gbfdiff) 16488884687865265734)
gfdiffer


(c!:install 'reduce!-columns '(reduce!-columns red!-weight
mv!-domainlist!-!* mv!-domainlist!-!- red!-weight!-less!-p more!-apartp)
 5786827969176873939)
reduce!-columns


(c!:install 'groeb!=testc1 '(groeb!=testc1 nth bas_dpoly dp_lmon mo_sum
mo_equal!?) 8189644749997674322)
groeb!=testc1


(c!:install 'mk_dummy_ids '(mk_dummy_ids dummy reserved dummy_id!*
intersection clean_numid union) 3153376571271088760)
mk_dummy_ids


(c!:install 'aex_mult '(aex_mult aex_simplenullp aex_0 aex_ex multsq
aex_ctx ctx_union aex_mk) 7618504733165833430)
aex_mult


(c!:install 'createtriple '(createtriple fluidbibasistripleid) 
6471021107549576289)
createtriple


(c!:install 'mksfpf '(mksfpf asymplis!* subfg!* mkprod !:expt mksp
exptf2) 17030763414840607855)
mksfpf


(c!:install 'enter!-sorted '(enter!-sorted nreverse taydegree!<) 
17819389047023974106)
enter!-sorted


(c!:install 'pasf_premf '(pasf_premf remf pasf_premf1) 
3607949355089863932)
pasf_premf


(c!:install 'vsl_boundtype1 '(vsl_boundtype1 ub lb minusf) 
9650985489234634930)
vsl_boundtype1


(c!:install 'cols2rows2 '(cols2rows2 ithlistelem) 11761456053114286748)
cols2rows2


(c!:install 'reduceroots '(reduceroots sqrt tryreduction) 
3350904232692937563)
reduceroots


(c!:install 'ps!:set!-term '(ps!:set!-term tps "less than the order of "
"less than power of last term of " !:ps!: ps!:order rerror
ps!:last!-term ps!:getv ps!:putv) 14937873030979197144)
ps!:set!-term


(c!:install 'ldf!-dep!-var '(ldf!-dep!-var depl!* ldt!-tvar makeset) 
12329147144362832437)
ldf!-dep!-var


(c!:install 'o!-nextarg '(o!-nextarg !*udebug i upb (null!-fn) acontract
op mcontract null!-fn expand identity uprint first0 last0 mval) 
13277592091299982766)
o!-nextarg


(c!:install 'e!* '(e!* !:bprec!: !:e) 15144487963355805024)
e!*


(c!:install 'physoppri '(physoppri "x= " " y= " "nat= " !*nat
" contract= " !*contract !" "(" obrkp!* !*comma!* ")" !- !1 !+ " z= "
" x1= " expt trwrite prin2!* inprint pnth exptpri) 3600671553507879763)
physoppri


(c!:install 'ev!-poles '(ev!-poles) 8441536304507899222)
ev!-poles


(c!:install 'quotofd '(quotofd nreverse quotodd) 6958130723683420292)
quotofd


(c!:install 'negex '(negex nreverse negf) 2507449366090575275)
negex


(c!:install 'revalpart '(revalpart alg "part called without arguments"
!*intstr list listfn !*hold "Invalid argument" "to part" partop rerror
getrtype reval listeval0 parterr2 msgpri nth) 16122698882590425009)
revalpart


(c!:install 'prepcadr '(prepcadr prepsq) 17465412849862105063)
prepcadr


(c!:install 'ra_wrapper '(ra_wrapper dmode!* ra_wrapper1 !*backtrace
"caught error - restoring domain mode" errorset errorp lprim on1) 
17490729383560982244)
ra_wrapper


(c!:install 'qqe_simplbtat '(qqe_simplbtat neq false true equal
rl_prepat qqe_op qqe_arg2l qqe_eta!-in!-term qqe_arg2r rl_simpat) 
13126731773829347008)
qqe_simplbtat


(c!:install 'pasf_ordatp '(pasf_ordatp true false ordp pasf_ordrelp) 
9850023449766335042)
pasf_ordatp


(c!:install 'conditionrd '(conditionrd char (!/ c o n d i t i o n)
"</condition>" condition mathml lex errorml) 13950345929221872061)
conditionrd



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u43.lsp"

Reading "$reduce/cslbuild/generated-c/u44.lsp"

% u44.lsp           Machine generated Lisp

(c!:install "u44" 46891 2685123 9816267)
nil


(c!:install 'diffp '(diffp !*sq dfform plus wtl!* k!* dmode!* powlis!*
!*depend !*expanddf depl!* df !*commutedf !*simpnoncomdf int
!*allowdfint !*df_partial (!! !! !_) simpfn simpiden (df int)
"Possible inconsistent dependencies in" noncomp simpdf simpexpt multsq
to addsq difff diffsq dfn_prop simp pair int!-equiv!-chk rationalizesq
depends df!-chain!-rule opmtch mksq quotsq simp!* not_df_p mk!*sq reval
smember get!-all!-kernels ldepends merge!-ind!-vars find_sub_df mkid
dependsl msgpri) 10518100153410283175)
diffp


(c!:install 'get!:const '(get!:const save!:c not_found round!:mt
bflerrmsg) 14945302858520531928)
get!:const


(c!:install 'nspaces '(nspaces !! ! ) 9403753038800802083)
nspaces


(c!:install 'all_defined_map_ '(all_defined_map_ al1_defined_map_) 
11847781095836290666)
all_defined_map_


(c!:install 'quotexf!* '(quotexf!* nreverse quotfexf!*1) 
16925846353836221873)
quotexf!*


(c!:install 'general!-multiply!-by!-constant!-mod!-p '(
general!-multiply!-by!-constant!-mod!-p general!-modular!-times !*n2f) 
13076077458684898091)
general!-multiply!-by!-constant!-mod!-p


(c!:install 'rl_nnfnot '(rl_nnfnot rl_nnfnot!* apply) 
11366376447126177282)
rl_nnfnot


(c!:install 'makecoeffpairshom '(makecoeffpairshom ((nil))
tayexp!-difference tayexp!-times2 tayexp!-minusp tayexp!-plus2 lastpair)
 15245645716957047788)
makecoeffpairshom


(c!:install 'pasf_exprng!-gball '(pasf_exprng!-gball
"pasf_exprng: bad bound " " with free variables " !*rlexprngnatural and
true false cl_fvarl rederr pasf_exprng pasf_qff2ivl pasf_sisub) 
7187494486004864692)
pasf_exprng!-gball


(c!:install 'matrixml '(matrixml "<matrix" "" matrixrow "</matrix>"
printout attributesml indent!* matrix_rows cols2rows) 
14211731179809632096)
matrixml


(c!:install 'convprc2 '(convprc2 yy!! !*roundbf !:rd!: convprec fl2bf
read!:num normbf) 2754024750176128811)
convprc2


(c!:install 'findhr '(findhr headhisto codhisto psi npsi codmat maxvar
rcoccup) 13838382850889596042)
findhr


(c!:install 'r2oaddspecies '(r2oaddspecies "new species: " prin2t) 
13662323801649141225)
r2oaddspecies


(c!:install 'ordpl '(ordpl ordp) 17076256259373343265)
ordpl


(c!:install 'evalletsub '(evalletsub alg "Invalid simplification"
evalletsub2 errorp rerror) 336294914740379549)
evalletsub


(c!:install 'lieninstruc '(lieninstruc difference lie_cc lienstrucin
minus plus aeval!* aminusp!: setk) 1855164136878405455)
lieninstruc


(c!:install 'gcdlist '(gcdlist "Term content division failed" poly!-abs
gcdld mapcarcar powers1 numeric!-content vintersection gcddd mksp multf
quotfail1 gcdlist1) 14143677021300326377)
gcdlist


(c!:install 'nlist '(nlist nreverse) 10472874980530235129)
nlist


(c!:install 'pasf_ceil '(pasf_ceil
"pasf_ceil: not a domain valued sf in input" simp rederr) 
14816327850986668498)
pasf_ceil


(c!:install 'lowupperlimitml '(lowupperlimitml "<lowlimit>"
"</lowlimit>" "<uplimit>" "</uplimit>" printout indent!* expression) 
8410065134618955200)
lowupperlimitml


(c!:install 'ps!:plus!-erule '(ps!:plus!-erule ps!:evaluate addsq) 
13435718629095729272)
ps!:plus!-erule


(c!:install 'make_spoly_pair '(make_spoly_pair spoly_pair pfordp xval
xlcm triviallcm mknwedge xdegreecheck) 16730509289712052345)
make_spoly_pair


(c!:install 'simpsetdiff '(simpsetdiff setdiff empty_set applysetop mksp
) 7728987522191007542)
simpsetdiff


(c!:install 'defined_all_edge '(defined_all_edge def_edge p_def_edge
rep_edge_prop_) 7466336925229487161)
defined_all_edge



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u44.lsp"

Reading "$reduce/cslbuild/generated-c/u45.lsp"

% u45.lsp           Machine generated Lisp

(c!:install "u45" 95899 2283492 5024683)
nil


(c!:install 'applsmacro '(applsmacro name inlineinfo rlisp
"Argument mismatch for SMACRO" !*loginlines g lambda rerror log_inlines
no!-side!-effect!-listp one!-entry!-listp pair subla!-q
no!-side!-effectp one!-entryp aconc) 10980045500133507434)
applsmacro


(c!:install 'prsum '(prsum nreverse to) 4168678173511487947)
prsum


(c!:install 'subs2p '(subs2p simp exptsq to multsq) 14762464268078506714
)
subs2p


(c!:install 'prim!-part '(prim!-part comfac comfac!-to!-poly quotf1) 
1260543398647750397)
prim!-part


(c!:install 'totalcompareconstants '(totalcompareconstants equal less
greater wukord!* wuvarlist!* symbollessp) 1087222859431793036)
totalcompareconstants


(c!:install 'quotientml '(quotientml !*web "<cn type=""rational""> "
"<cn type=&quot;rational&quot;> " " <sep/> " " </cn>" "<apply>" "<" "/>"
"</apply>" printout indent!* expression) 2636813940372006033)
quotientml


(c!:install 'simpsqrtsq '(simpsqrtsq simpsqrt2) 16857662672342576259)
simpsqrtsq


(c!:install 'ps!:arg!-values '(ps!:arg!-values !:ps!: ps!:value) 
15612600895103978694)
ps!:arg!-values


(c!:install 'wedgewedge '(wedgewedge wedgepf2) 17383049050819657757)
wedgewedge


(c!:install 'mksqrt '(mksqrt !*keepsqrts expt quotient !*!*sqrt (x) (
let00 (quote ((equal (expt (sqrt x) 2) x)))) sqrt forall aeval) 
6961194266824060434)
mksqrt


(c!:install 'fermionicp '(fermionicp fermionic d df s s_changes_parity
t_changes_parity) 1561662599579503643)
fermionicp


(c!:install 'rule '(rule !*sq!* mcond!* "Unmatched free variable(s)"
hold erfg!* getel errpri1 prepsq!* smemql setdiff lprie lispeval let3) 
17927910212934432100)
rule


(c!:install 'depend!-f '(depend!-f depend!-p) 7582361734257302030)
depend!-f


(c!:install 'mri_ofsf2mri '(mri_ofsf2mri mri_ofsf2mriat cl_apply2ats1) 
9220106144109790875)
mri_ofsf2mri


(c!:install 'csymbolrd '(csymbolrd fnrd stats_getargs) 
2269378548414956256)
csymbolrd


(c!:install '!*rn2rd '(!*rn2rd r2bf chkrn!* mkround) 4804769577357159913
)
!*rn2rd


(c!:install 'dipcontevmin '(dipcontevmin) 5891717190099008862)
dipcontevmin


(c!:install 'subfindices '(subfindices alglist!* (wedge d partdf
innerprod liedf hodge vardf) sfp exptsq simpindexvar subindk simp multsq
addsq) 8932382147427070096)
subfindices


(c!:install 'gd_gcasesimpl '(gd_gcasesimpl gd_simpl) 3106971393313232138
)
gd_gcasesimpl


(c!:install 'ofsf_sippsignchkf '(ofsf_sippsignchkf unknown
ofsf_updsigndom ofsf_updsignvar ofsf_updsignpow ofsf_updsignmult
ofsf_updsignadd) 14134957242467567077)
ofsf_sippsignchkf


(c!:install 'mri_prifloor '(mri_prifloor !*nat failed "[" "]" prin2!*
maprin) 3143759303351340392)
mri_prifloor


(c!:install 'make!-image!-mod!-p '(make!-image!-mod!-p unlucky!-case
degree!-in!-variable make!-univariate!-image!-mod!-p) 
8264417465749283354)
make!-image!-mod!-p


(c!:install 'matrixir '(matrixir matrixcolumn matrixrow matrix lex
omobjs matrixelems) 16908110675907796155)
matrixir


(c!:install 'simpdf '(simpdf subfg!* df "kernel or integer"
domain!-diff!-fn dmode!* alglist!* "kernel" mksq simp!* prepsq typerr
prepf prekernp diffsq d2int) 10496397630730647885)
simpdf


(c!:install 'findhc '(findhc njsi jsi codmat maxvar) 538885150119599152)
findhc


(c!:install 'gfstorval '(gfstorval !*xnlist) 12264309616471478407)
gfstorval


(c!:install 'fortassign '(fortassign mkffortassign) 6624076633711203064)
fortassign


(c!:install 'new_prove '(new_prove new_provev) 13959116656364361077)
new_prove


(c!:install 'sign!-abs '(sign!-abs minus sign!-of simp) 
6340523605258900088)
sign!-abs


(c!:install 'setmatelem '(setmatelem "matrix element" matrix "matrix"
mat "Matrix" "not set" "positive integer" typerr rerror
reval_without_mod nth pnth) 9548262577267566440)
setmatelem


(c!:install 'dfp!-rule!-found '(dfp!-rule!-found dfp) 
9877567616346544088)
dfp!-rule!-found


(c!:install 'fs!:timescoeff '(fs!:timescoeff (nil . 1) "zero in times"
multsq) 5406645140491289302)
fs!:timescoeff


(c!:install 'mkindxlist '(mkindxlist minus !*num2id) 4162138526201494400
)
mkindxlist


(c!:install 'inormmat '(inormmat ilcm) 17106946690286213239)
inormmat


(c!:install 'no_of_tm_sf_limited '(no_of_tm_sf_limited) 
15651175340902815823)
no_of_tm_sf_limited


(c!:install 'settreset '(settreset fluidbibasisjanettreerootnode
fluidbibasissett) 11886008700691594736)
settreset


(c!:install 'ofsf_updsignvar '(ofsf_updsignvar equal greaterp lessp geq
leq neq unknown) 6623497294712404882)
ofsf_updsignvar


(c!:install 'mkexpt '(mkexpt expt) 5754935854877136791)
mkexpt


(c!:install 'iv_cutn '(iv_cutn iv_cut) 18130037756634153349)
iv_cutn


(c!:install 'bc_gcd '(bc_gcd gcdf!*) 4947837562519671859)
bc_gcd


(c!:install 'cnml '(cnml "<cn" "" "</cn>" printout attributesml) 
14691654203402877146)
cnml


(c!:install 'znumrnil '(znumrnil znumr) 3406126826241646652)
znumrnil


(c!:install 'scar '(scar) 14714868972199026410)
scar


(c!:install 'copy_vect '(copy_vect sparsemat fullcopy) 
1385142974386378902)
copy_vect


(c!:install 'partitwedge '(partitwedge partitop xpndwedge mkuniquewedge)
 17466341504292213163)
partitwedge


(c!:install 'endmodule '(endmodule mode!-list!*
"ENDMODULE called outside module" exportslist!* importslist!* alglist!*
!*mode rederr) 13502524214384896680)
endmodule


(c!:install 'mkforttab '(mkforttab forttab fortcurrind!*) 
3348229086508012781)
mkforttab


(c!:install 'coeff_calc '(coeff_calc plus coeff1_calc reval) 
7462814040679763528)
coeff_calc


(c!:install 'split!-comfac!-part '(split!-comfac!-part split!-comfac) 
16472164186914038891)
split!-comfac!-part


(c!:install 'listminimize '(listminimize cali!=min) 12763062043939354477
)
listminimize


(c!:install 'zfactor1 '(zfactor1 !*primelist!* nreverse add!-factor
mcfactor!*) 5360192074139528345)
zfactor1


(c!:install 'precision '(precision arith "positive number required"
rerror precision1) 13453333914508305559)
precision


(c!:install 'mkrootsql '(mkrootsql !*d2q mkrootsq exptsq multsq) 
7401308018124398825)
mkrootsql


(c!:install 'talp_simplatlinv '(talp_simplatlinv talp_simplt talp_invp
talp_mk2 talp_simplat2) 12087196483435887150)
talp_simplatlinv



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u45.lsp"

Reading "$reduce/cslbuild/generated-c/u46.lsp"

% u46.lsp           Machine generated Lisp

(c!:install "u46" 154649 3418922 6913421)
nil


(c!:install 'pasf_smwmkatl '(pasf_smwmkatl !*rlsusi cl_susimkatl
cl_smmkatl) 14491224678262139805)
pasf_smwmkatl


(c!:install 'gb_searchinlist '(gb_searchinlist vdp_evlmon
gb_buch!-ev_divides!?) 13011741950046030798)
gb_searchinlist


(c!:install 'd2int '(d2int !:rd!: !!fleps1) 2860821044592396078)
d2int


(c!:install 'tchscheme2 '(tchscheme2 rowmax removechild to!*scheme) 
10670630006658404031)
tchscheme2


(c!:install 'sroot1 '(sroot1 freevars substitution rpt inf !*trpm
"Trying rule  " "against      " "producing    " "failed" findnewvars
union newenv rprint amatch embed!-null!-fn restorenv) 
4065155521512325602)
sroot1


(c!:install 'xregister_spoly_pair '(xregister_spoly_pair) 
16809458969016319347)
xregister_spoly_pair


(c!:install 'evaluate2 '(evaluate2 !:dn!: plus times dmarith!* dn!:simp
evaluate1 !:dmpluslst !:dmtimeslst apply prepf simp force!-to!-dm) 
6157296650697590590)
evaluate2


(c!:install 'mv!-compact '(mv!-compact mv!-reverse mv!-pow!-chk
mv!-pow!-mv!-!+ mv!-compact2 mv!-pow!-!+ mv!-pow!-assoc) 
9240000233549075625)
mv!-compact


(c!:install 'simp!-prop '(simp!-prop propvars!* and or !'and !'or !'true
!'false times not full boolean reval simp!-prop1 prepf simp
simp!-prop!-dist simp!-prop2 simp!-prop!-form to) 14478673112857946646)
simp!-prop


(c!:install 'try!-all!-constants '(try!-all!-constants number!-needed
current!-modulus split!-further) 14167453229868141545)
try!-all!-constants


(c!:install 'polynomlistautoreduce '(polynomlistautoreduce
polynomlistreduce monomisdivisibleby pushback) 1357424796153139693)
polynomlistautoreduce


(c!:install 'ofsf_qesubqat '(ofsf_qesubqat !*rlqesubf !*rlqelocal equal
neq geq ofsf_varlat prepsq subf ofsf_subf ofsf_qesubqat!-local
ofsf_surep sfto_pdecf multf) 10452000760203204783)
ofsf_qesubqat


(c!:install 'tayexp!-max2 '(tayexp!-max2 tayexp!-lessp) 
17858461924541832237)
tayexp!-max2


(c!:install 'cl_replace!-varl '(cl_replace!-varl cl_varl1) 
1771464919472448494)
cl_replace!-varl


(c!:install 'qqe_simplqneq '(qqe_simplqneq qequal true false qneq
qqe_mk2 qqe_simplqequal qqe_arg2l qqe_arg2r) 12147848576444979923)
qqe_simplqneq


(c!:install 'pdiffvars '(pdiffvars ind nth) 11152193338476678657)
pdiffvars


(c!:install 'rnfix!* '(rnfix!*) 3256443848001070039)
rnfix!*


(c!:install 'newsym1 '(newsym1 cindex!* cname!*) 426404548351141204)
newsym1


(c!:install 'nestzerop!: '(nestzerop!: simp) 1274628154170026995)
nestzerop!:


(c!:install 'dipdivmon '(dipdivmon nreverse evdif bcquot) 
17103397929728998226)
dipdivmon


(c!:install 'sc_scalarproduct '(sc_scalarproduct sc_simp fast!-row!-dim
sc_getmat sc_multsq sc_addsq) 14834557765495777788)
sc_scalarproduct


(c!:install 'delete_edge '(delete_edge nreverse) 15292113970921095755)
delete_edge


(c!:install 'mkimpart '(mkimpart impart sfp realvaluedp!-sf impartsq
realvaluedp mksq) 18194972465079704462)
mkimpart


(c!:install 'mv2sf '(mv2sf mv2sf1 addf) 1593951586347486978)
mv2sf


(c!:install 'nodum_varp '(nodum_varp g_dvbase !~dv !~dva listp
ad_splitname) 3996221814626008533)
nodum_varp


(c!:install 'mkrootsq '(mkrootsq (minus 1) i expt !*precise_complex
factorbound!* !*ifactor quotient !*d2q simp exptsq zfactor1 mkrootsql
mksqrt opmtch mksq) 447351031222923455)
mkrootsq


(c!:install 'ofsf_facequal '(ofsf_facequal equal or and true false
sfto_fctrf) 12995514954362860058)
ofsf_facequal


(c!:install 'polynomreduceby '(polynomreduceby
fluidbibasisreductionsmade monomisdivisibleby monomdivide
polynommultiplybymonom polynomadd) 3389395153734211277)
polynomreduceby


(c!:install 'cl_sacat '(cl_sacat keep) 18128826745512667418)
cl_sacat


(c!:install 'aex_simplenumberp '(aex_simplenumberp aex_fvarl) 
16106721348376309280)
aex_simplenumberp


(c!:install 'operator_fn '(operator_fn "<apply>" "<csymbol>" "<ci>"
"</ci>" "</csymbol>" "</apply>" printout indent!* multi_args) 
4202184310625661376)
operator_fn


(c!:install 'qsum!-simpexpt '(qsum!-simpexpt inside!-qsum!-simpexpt!*
!*exp !*factor !*mcd !*precise !*allfac qsum!-simpexpt1 rmsubs) 
1865262126138033327)
qsum!-simpexpt


(c!:install 'calc_atlas '(calc_atlas calc_map_2d) 9734104227373875648)
calc_atlas


(c!:install 'rfirst '(rfirst list "list or bag" reval bagp typerr
parterr) 4610944224751221558)
rfirst


(c!:install 'reduce!-ratios '(reduce!-ratios red!-ratios1
mv!-domainlist!-!* mv!-domainlist!-!- reddom_zeros) 9374687512318225182)
reduce!-ratios


(c!:install 'check_letop '(check_letop letop
"Presence of letop, jetspace too small!" freeof rederr) 
3231886767849345546)
check_letop


(c!:install 'cl_identifyonoff '(cl_identifyonoff cl_identify!-atl!*) 
111440064799115096)
cl_identifyonoff


(c!:install 'mri_simplat1 '(mri_simplat1 !*rlsimplfloor int real mri_op
mri_arg2l mri_simplfloor mri_type mri_0mk2 mri_dettype mri_2pasfat
pasf_simplat1 mri_pasf2mri mri_congp mri_2ofsfat ofsf_simplat1
mri_ofsf2mri) 11559093591740106542)
mri_simplat1


(c!:install 'limitom '(limitom "<OMA>"
"<OMS cd=""limit1"" name=""limit""/>" lowlimit
"<OMS cd=""limit1"" name=""null""/>" condition
"<OMS cd=""limit1"" name=""" """/>" limit "</OMA>" printout indent!*
objectom lambdaom) 3650259326440300538)
limitom


(c!:install 'solvealgtrig01 '(solvealgtrig01 (sin cos tan cot sinh cosh
tanh coth) constant_exprp union) 8913583277979887080)
solvealgtrig01


(c!:install 'gfftimes '(gfftimes) 16571310599605003544)
gfftimes


(c!:install 'asymmetrize!-inds '(asymmetrize!-inds nth repeats indordn
indordln permp flatindl pair) 12851078889283767221)
asymmetrize!-inds


(c!:install 'ctx_union '(ctx_union arg1of2 ctx ordopcar ctx_ial
lto_almerge sort) 17896863293973972637)
ctx_union


(c!:install 'monomcomparelex '(monomcomparelex) 11051507336604097688)
monomcomparelex



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u46.lsp"

Reading "$reduce/cslbuild/generated-c/u47.lsp"

% u47.lsp           Machine generated Lisp

(c!:install "u47" 157940 6721509 9423787)
nil


(c!:install 'ofsf_smmkatl!-and1 '(ofsf_smmkatl!-and1 (lessp greaterp)
and ofsf_smmkat!-and2 ofsf_entry2at lastpair) 9168707611537321621)
ofsf_smmkatl!-and1


(c!:install 'simpx1 '(simpx1 !*minus!* quotient expt i frlis!* !*mcd
!*notseparate !*keepsqrts sqrt minus plus !*expandexpt times used!* (
minus 1) difference (quotient 1 2) simp simpexpt multsq negsq smemqlp
mksq invsq exptsq simp!* simprad) 217428944454050099)
simpx1


(c!:install 'vdp_monp '(vdp_monp vdp_poly dip_monp) 7810046384283950709)
vdp_monp


(c!:install 'dip!-nc!-ev!-prod '(dip!-nc!-ev!-prod bcprod
dip!-nc!-ev!-prod1) 13753880069992538933)
dip!-nc!-ev!-prod


(c!:install 'lndepends '(lndepends ndepends) 245971449668139068)
lndepends


(c!:install 'listquotient '(listquotient list quotient reval1
listquotient2) 6929506952944788535)
listquotient


(c!:install 'vecsimp!* '(vecsimp!* vecp vecsm!*) 15537020803561331903)
vecsimp!*


(c!:install 'verify_tens_ids '(verify_tens_ids cantens
"are inconsistent lists of indices" extract_dummy_ids repeats rerror) 
2124580761287725659)
verify_tens_ids


(c!:install 'evaluate!-in!-order!-mod!-p '(evaluate!-in!-order!-mod!-p
!*d2n horner!-rule!-in!-order!-mod!-p) 11194639884761491694)
evaluate!-in!-order!-mod!-p


(c!:install 'domainp_list '(domainp_list) 12010184099986036243)
domainp_list


(c!:install '!*a2kwoweight '(!*a2kwoweight !*uncached wtl!* kernel
simp!* kernp typerr) 10341696069689992804)
!*a2kwoweight


(c!:install 'drop_dec_with '(drop_dec_with dec_with_rl dec_with) 
4637449164887897132)
drop_dec_with


(c!:install 'cl_sordp '(cl_sordp true false or and not impl repl equiv
ex all bex ball rl_ordatp cl_ordopp ordp cl_sordpl) 1766985440902024458)
cl_sordp


(c!:install 'rl_sacat '(rl_sacat rl_sacat!* apply) 944955371135587480)
rl_sacat


(c!:install 'acfsf_clnegrel '(acfsf_clnegrel acfsf_lnegrel) 
12459359460298823286)
acfsf_clnegrel


(c!:install 'dipretimes '(dipretimes times) 14088869305807271599)
dipretimes


(c!:install 'indordln '(indordln indordl2 indordlad) 
16254463786900959556)
indordln


(c!:install 'free '(free freeind) 5972707798710380332)
free


(c!:install '!*multf '(!*multf !*noncomp (expt sqrt) sqrt expt
squashsqrt multd multf ordop addf makeupsf !*multfsqrt
prefix!-rational!-numberp !*multfexpt mkspm) 3112641827313326709)
!*multf


(c!:install 'nonlnr '(nonlnr freeofl) 8210815413809985732)
nonlnr


(c!:install 'janettreeinsert '(janettreeinsert
fluidbibasisjanettreerootnode janettreenodebuild monomgetvariabledegree
setcar setcdr) 6692586595300419199)
janettreeinsert


(c!:install 'ofsf_smeqtable '(ofsf_smeqtable ((equal (equal . equal) (
neq . false) (geq . equal) (leq . equal) (greaterp . false) (lessp .
false)) (neq (neq . neq) (geq . greaterp) (leq . lessp) (greaterp .
greaterp) (lessp . lessp)) (geq (geq . geq) (leq . equal) (greaterp .
greaterp) (lessp . false)) (leq (leq . leq) (greaterp . false) (lessp .
lessp)) (greaterp (greaterp . greaterp) (lessp . false)) (lessp (lessp .
lessp)))) 8132877551901091129)
ofsf_smeqtable


(c!:install 'ev_init '(ev_init) 1151919986852689506)
ev_init


(c!:install 'spinnerprod '(spinnerprod plus times) 4756109932931016172)
spinnerprod


(c!:install 'dipequal '(dipequal evequal) 2402755849245862783)
dipequal


(c!:install 'natnump '(natnump) 3143551995880890331)
natnump


(c!:install 'defined_vertex '(defined_vertex memq_edgelist) 
12315488129214510238)
defined_vertex


(c!:install 'reduce!-weights '(reduce!-weights red!-weight
mv!-domainlist!-!+ red!-weight!-less!-p mv!-domainlist!-!-) 
10521538158462096126)
reduce!-weights


(c!:install 'fs!:prin!: '(fs!:prin!: "[" "]" prin2!* fs!:prin) 
12620491596942070734)
fs!:prin!:


(c!:install 'bagp '(bagp bag) 17072741318794064055)
bagp


(c!:install 'bfminus '(bfminus minus!:) 13086388068205214699)
bfminus


(c!:install 'get!-new!-prime '(get!-new!-prime !*force!-prime all
smallest!-prime random!-teeny!-prime random!-small!-prime) 
16039629042702163743)
get!-new!-prime


(c!:install 'girationalize!: '(girationalize!: !*gcd !:gi!: conjgd addf
negf multf gcdf quotf quotf!-fail gigcdsq) 5436218136478886805)
girationalize!:


(c!:install 'talp_lssimpl '(talp_lssimpl or and (ex all) talp_rnf
talp_atfp talp_op talp_argl talp_lssimpl1) 10177797432189751992)
talp_lssimpl


(c!:install 'bc_dcont '(bc_dcont sfto_dcontentf) 756698739986786000)
bc_dcont


(c!:install 'cr!:prep '(cr!:prep !:rd!: rd!:prep crprep1) 
5680819172236842863)
cr!:prep


(c!:install 'vdplsort '(vdplsort vdpvevlcomp sort) 11562137722065177216)
vdplsort



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u47.lsp"

Reading "$reduce/cslbuild/generated-c/u48.lsp"

% u48.lsp           Machine generated Lisp

(c!:install "u48" 63073 7272097 8612076)
nil


(c!:install 'maprintla '(maprintla laprifn fulla failed indexed !:rd!:
!*nat ncharspr!* laline!* orig!* posn!* equal !( !) minus prinlatom
prin2la apply prinidop rd!:prin oprinla prinpopargs inprinla) 
10666225449942779319)
maprintla


(c!:install 'mkdmoderr '(mkdmoderr lambda (!*x!*) dmoderr) 
560371362299189013)
mkdmoderr


(c!:install 'reset_opnums '(reset_opnums oporder!* opnum !*xadd) 
5325307124938520491)
reset_opnums


(c!:install 'mk_names_map_2 '(mk_names_map_2) 6630788302055002628)
mk_names_map_2


(c!:install 'njets '(njets combin) 13405465310925955507)
njets


(c!:install 'pst_mkpst '(pst_mkpst pst_mkpst1 pst_equitable) 
17260450864783093708)
pst_mkpst


(c!:install 'general!-modular!-difference '(general!-modular!-difference
current!-modulus) 3483344910142386874)
general!-modular!-difference


(c!:install 'aex_psrem '(aex_psrem aex_fvarl aex_0 aex_ex aex_lc aex_sgn
sfto_psrem kernels aex_ctx ctx_union ctx_filter aex_mk aex_mklcnt) 
4904291359702063744)
aex_psrem


(c!:install 'f2df '(f2df zlist dfconst vp2df multdf plusdf multdfconst) 
7539343109042374941)
f2df


(c!:install 'get_dimension_in '(get_dimension_in id get_rep_matrix_in
mk!+trace change!+sq!+to!+int) 14407917089983539275)
get_dimension_in


(c!:install 'talp_qesolset '(talp_qesolset ignore equal failed
talp_arg2l talp_arg2r talp_contains) 3902272268693375787)
talp_qesolset


(c!:install 'cl_susicpknowl '(cl_susicpknowl) 360722150036072037)
cl_susicpknowl


(c!:install 'gpexpp '(gpexpp (!:rd!: !:cr!: !:crn!: !:gi!:) plus (minus
recip) (difference quotient expt) times !:rd!: (!:cr!: !:crn!: !:gi!:)
gpexp1p unresidp gparg1p) 1997977812855299707)
gpexpp


(c!:install 'mo_support '(mo_support cali!=basering ring_names mo_from_a
mo_divides!?) 18038819699181796544)
mo_support


(c!:install 'addnew '(addnew gv!* bv!* ljet insert) 6824181854034253868)
addnew


(c!:install 'flattens1 '(flattens1) 12333193806801555492)
flattens1


(c!:install 'mkexpvec '(mkexpvec dipvars!* "dipoly variable" typerr) 
1312027724317386792)
mkexpvec


(c!:install 'qroundup '(qroundup) 10750519726693016495)
qroundup


(c!:install 'aex_unbind '(aex_unbind aex_ex aex_ctx ctx_remove aex_mk) 
9664124840895833839)
aex_unbind


(c!:install 'min2!-order '(min2!-order nreverse tayexp!-plus2
tayexp!-greaterp tayexp!-min2) 13926684584939521754)
min2!-order


(c!:install 'mk!+inner!+product '(mk!+inner!+product
"wrong dimensions in innerproduct" !*complex !*sub2 get!+vec!+dim rederr
mk!+conjugate!+vec get!+vec!+entry multsq addsq subs2) 
18064794597700778148)
mk!+inner!+product


(c!:install 'mri_simplfloor1 '(mri_simplfloor1 mri_simplfloor
mri_irsplit addf exptf multf) 16810088525014662784)
mri_simplfloor1


(c!:install 'cl_bnfsimpl '(cl_bnfsimpl !*rlbnfsac cl_sac) 
6603799946669511995)
cl_bnfsimpl


(c!:install 'vdp_zero '(vdp_zero invalid vdp_make) 17290158580285103512)
vdp_zero


(c!:install 'countof '(countof) 5339181945143252659)
countof


(c!:install 'evalgeq '(evalgeq evallessp) 6541910110406929399)
evalgeq


(c!:install 'lengthn '(lengthn) 6286815763906199918)
lengthn


(c!:install 'spmatlength '(spmatlength sparsemat matrix "Matrix"
"not set" list rerror) 5714151694477294631)
spmatlength


(c!:install 'sfpf '(sfpf sfp) 17563026604267880041)
sfpf


(c!:install 'pnth!* '(pnth!*) 13080433998780208293)
pnth!*


(c!:install 'generic_arguments '(generic_arguments list generic_function
) 14840104320580484157)
generic_arguments


(c!:install 'fs!:subang '(fs!:subang make!-term fs!:plus) 
9132207302041089259)
fs!:subang


(c!:install 'cali_bc_from_a '(cali_bc_from_a simp!* bc!=simp) 
5173823590854030894)
cali_bc_from_a


(c!:install 'dv_skel2factor '(dv_skel2factor st_ad_numsorttree
st_flatten dv_ind2var dv_skel2factor1) 7917221492997085944)
dv_skel2factor


(c!:install 'alistp '(alistp) 15293333801659366688)
alistp


(c!:install 'add!-factor '(add!-factor) 7843512598483340436)
add!-factor


(c!:install 'dfdeg '(dfdeg) 10704968414028685461)
dfdeg


(c!:install 'talp_get!-idx '(talp_get!-idx talp_fop talp_invf talp_invn)
 6245453212222089412)
talp_get!-idx


(c!:install 'iv_new '(iv_new) 3426832229457806045)
iv_new


(c!:install 'mulpower '(mulpower sqrtlist zlist addexptsdf reduceroots
multdf) 14418985785262293380)
mulpower


(c!:install 'parfool '(parfool) 5261984326391102730)
parfool


(c!:install 'spmatsm!* '(spmatsm!* sparsemat spmatsm matsm!*1) 
1097875971497327075)
spmatsm!*


(c!:install 'matsm!* '(matsm!* matsm matsm!*1) 14890198389059652316)
matsm!*


(c!:install 'f2dip '(f2dip evzero bcfd f2dip1) 9587368216975151565)
f2dip


(c!:install 'dim!<!=deg '(dim!<!=deg dimex!* deg!*form negf addf) 
15432143120275206384)
dim!<!=deg


(c!:install 'mk_parents_prim '(mk_parents_prim s_noparents
mk_edge_parents) 2468381646525202115)
mk_parents_prim


(c!:install 'expand!-imrepartpow '(expand!-imrepartpow !*exp cmpxsplitfn
i to mkrepart simp mkimpart multsq addsq exptsq) 12425961166904866094)
expand!-imrepartpow


(c!:install 'bfrsq '(bfrsq csl_timbf plubf) 6817557628069572305)
bfrsq


(c!:install 'sfchk '(sfchk sfp prepf) 8894828728941178290)
sfchk


(c!:install 'replace!-next '(replace!-next nreverse) 
14091638087168046101)
replace!-next


(c!:install 'talp_mkinvop '(talp_mkinvop inv_) 6289931570559624594)
talp_mkinvop


(c!:install 'bc_zero '(bc_zero) 15962626216446594231)
bc_zero


(c!:install 'gfquotient '(gfquotient gffquot gbfquot) 
11165314299645826300)
gfquotient


(c!:install 'mkrepart '(mkrepart repart sfp realvaluedp!-sf to repartsq
realvaluedp mksq) 1938415490342039633)
mkrepart


(c!:install 'mo!=expvec2a1 '(mo!=expvec2a1 expt nreverse) 
17299033867504388525)
mo!=expvec2a1


(c!:install 'sub01 '(sub01 nreverse) 5029894297379851509)
sub01


(c!:install 'depend!-sq '(depend!-sq depend!-f) 6771514811325703769)
depend!-sq


(c!:install 'mri_irsplit1 '(mri_irsplit1 to exptf mri_realvarp multf
addf) 13947086387411447854)
mri_irsplit1


(c!:install 'pasf_smordtable '(pasf_smordtable "abused smordtable"
pasf_smordtable2 pasf_smordtable1 rederr) 15835215276850649327)
pasf_smordtable


(c!:install 'den '(den simp!* mk!*sq) 11489848385305094078)
den


(c!:install 'groebcplistmerge '(groebcplistmerge groebcpcompless!?) 
2832212071468860374)
groebcplistmerge


(c!:install 'subs2pf '(subs2pf resimp subs2) 12462583401050515357)
subs2pf


(c!:install '!:log2 '(!:log2 not_found bftwo!* get!:const log!:
save!:const) 9908259478374416725)
!:log2


(c!:install 'lispcodeexp '(lispcodeexp e exp 1.0 (!:rd!: !:cr!: !:crn!:
!:gi!:) irena!-constants expt (quotient 1 2) sqrt !:rd!: (1 . 2)
quotient recip !*period difference plus minus !*lisparithexpops!*
!*lisplogexpops!* check!-for!-irena!-constants realrat) 
4974330400605947032)
lispcodeexp


(c!:install 'physopsubs '(physopsubs alglist!* physoplist!* rtype simpfn
simpiden (dot) physopfn dot physop physop2sq subs2 !*q2a) 
12042423606794197418)
physopsubs



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u48.lsp"

Reading "$reduce/cslbuild/generated-c/u49.lsp"

% u49.lsp           Machine generated Lisp

(c!:install "u49" 74332 6242435 4565881)
nil


(c!:install 'mk_world1 '(mk_world1 map_2_from_map_1) 
11864793233031236250)
mk_world1


(c!:install 'fs!:zerop!: '(fs!:zerop!:) 9574036079916408229)
fs!:zerop!:


(c!:install 'dp!=retimes '(dp!=retimes times) 7894493552316191125)
dp!=retimes


(c!:install 'st_sorttree1 '(st_sorttree1 !* !+ cdr_sort cdr_signsort) 
18254977221322318624)
st_sorttree1


(c!:install 'even_action '(even_action even_action_sf addsq) 
587366358427156605)
even_action


(c!:install 'dvfsf_0mk2 '(dvfsf_0mk2) 16558020518709937741)
dvfsf_0mk2


(c!:install 'nextu '(nextu subtractinds evaluatecoeffts) 
17007332787641938455)
nextu


(c!:install 'xadd!* '(xadd!* newrule!* plus difference times expt
powlisp simp prepsq updoldrules) 17515286503557943635)
xadd!*


(c!:install 'pasf_smordtable2 '(pasf_smordtable2 ((lessp (lessp 2) (leq
2) (equal 2) (neq nil) (geq nil) (greaterp nil) (cong nil) (ncong nil))
(leq (lessp 2) (leq 2) (equal 2) (neq nil) (geq nil) (greaterp nil) (
cong nil) (ncong nil)) (equal (lessp false) (leq false) (equal false) (
neq 1) (geq 1) (greaterp 1) (cong nil) (ncong nil)) (neq (lessp 2) (leq
2) (equal 2) (neq nil) (geq nil) (greaterp nil) (cong nil) (ncong nil))
(geq (lessp false) (leq false) (equal false) (neq 1) (geq 1) (greaterp 1
) (cong nil) (ncong nil)) (greaterp (lessp false) (leq false) (equal
false) (neq 1) (geq 1) (greaterp 1) (cong nil) (ncong nil)))) 
9462935011446529459)
pasf_smordtable2


(c!:install 'rat_leq '(rat_leq negsq addsq rat_sgn) 4872512845191832278)
rat_leq


(c!:install 'prload '(prload) 18162336246972013353)
prload


(c!:install 'dipcontenti '(dipcontenti !*groebrm dipcontenti1) 
6332376665279487617)
dipcontenti


(c!:install '!:log10 '(!:log10 not_found bften!* get!:const log!:
save!:const) 7733354448000993096)
!:log10


(c!:install 'monic '(monic lcof quotient aeval) 2125350396752250749)
monic


(c!:install 'pa_part2list '(pa_part2list upbve copy lastpair) 
1920806523503313950)
pa_part2list


(c!:install 'baglistp '(baglistp list bag) 16976112971610824149)
baglistp


(c!:install 'random!-small!-prime '(random!-small!-prime
small!-random!-number primep) 9679341110865623475)
random!-small!-prime


(c!:install 'acell_getsp '(acell_getsp nth) 13917821517315204692)
acell_getsp


(c!:install 'ofsf_smmkatl!-and '(ofsf_smmkatl!-and !*rlsipw !*rlsipo and
ofsf_irl2atl ofsf_ir2atl ofsf_smmkatl!-and1 lastpair) 
15202418740806621157)
ofsf_smmkatl!-and


(c!:install 'impartsq '(impartsq splitcomplex multsq negsq addsq invsq) 
3210318514076963511)
impartsq


(c!:install 'qqe_length!-graph!-neighbor!-edge '(
qqe_length!-graph!-neighbor!-edge) 2958539446646825932)
qqe_length!-graph!-neighbor!-edge


(c!:install 'ev_divides!? '(ev_divides!? ev_mtest!?) 1493885560001405582
)
ev_divides!?


(c!:install 'addexptsdf '(addexptsdf "X too long" "Y too long" nreverse
interr exptplus) 1213714791709377960)
addexptsdf


(c!:install 'mkunarywedge '(mkunarywedge nreverse) 17561137377864885515)
mkunarywedge


(c!:install 'newvar '(newvar "free variable" != typerr id2bytelist
bytelist2id) 3759729610965086259)
newvar


(c!:install 'endofstmtp '(endofstmtp cursym!* (!*semicol!* !*rsqbkt!*
end)) 7315433669680639686)
endofstmtp


(c!:install 'get!-all!-kernels '(get!-all!-kernels simp kernels union) 
5093584196795559363)
get!-all!-kernels


(c!:install 'evaluate!-in!-vector '(evaluate!-in!-vector) 
12859432698374091534)
evaluate!-in!-vector


(c!:install 'atree_rootcell '(atree_rootcell nth) 11382204984858785124)
atree_rootcell


(c!:install 'ofsf_anegrel '(ofsf_anegrel ((equal . equal) (neq . neq) (
leq . geq) (geq . leq) (lessp . greaterp) (greaterp . lessp))
"ofsf_anegrel: unknown operator " rederr) 5691787172200909886)
ofsf_anegrel


(c!:install 'mktag '(mktag texprec !\!( !\!) texexplode makefunc) 
16006631035263225041)
mktag


(c!:install 'makecoeffpairs '(makecoeffpairs makecoeffpairs1) 
757218381450057705)
makecoeffpairs


(c!:install 'pasf_leqp '(pasf_leqp minf pinf) 4630993796736544245)
pasf_leqp


(c!:install 'ldf!-deg '(ldf!-deg degreef maxl) 7875327071353158834)
ldf!-deg


(c!:install '!*ff2a '(!*ff2a wtl!* cancel prepsq mk!*sq) 
15086146504593339516)
!*ff2a


(c!:install 'groebcplistsort '(groebcplistsort groebcplistsortin) 
9083304943977416811)
groebcplistsort


(c!:install 'groebreduceonestepint '(groebreduceonestepint secondvalue!*
!*groebdivide !*groebprot vdpvars!* thirdvalue!* vdpred vevdif vbcfi
vbcgcd vbcquot vdpvbcprod vbcneg groebreductionprotocol vevmaptozero1
vdpilcomb1) 4658219020147169405)
groebreduceonestepint


(c!:install 'mk!-contract!-coeff '(mk!-contract!-coeff ndim!* mk!-numr
constimes) 17958584504185035815)
mk!-contract!-coeff


(c!:install 'isimp2 '(isimp2 cons g eps xnp dotsum esum isimp1 multf
appn gadd nb multd!*) 8588240526968828927)
isimp2


(c!:install 'derivative!-mod!-p '(derivative!-mod!-p
derivative!-mod!-p!-1) 10459348148582663089)
derivative!-mod!-p


(c!:install 'ofsf_bestgaussp '(ofsf_bestgaussp failed gignore lin con) 
8187982741908739180)
ofsf_bestgaussp


(c!:install 'taymindegreel '(taymindegreel nreverse tayexp!-plus2
tayexp!-min2) 14005103839088980420)
taymindegreel


(c!:install 'vdp_fdip '(vdp_fdip vdp_zero dip_lbc dip_evlmon vdp_make) 
4680168212571246300)
vdp_fdip


(c!:install 'ldf!-sep!-var '(ldf!-sep!-var ldf!-pow!-var ldf!-dep!-var
compl ldf!-spf!-var) 2549914095850826325)
ldf!-sep!-var


(c!:install 'sprow_dim '(sprow_dim !*fast_la
"Error in sprow_dim: input should be a matrix." matrixp rederr
spmatlength) 11838293185522517120)
sprow_dim


(c!:install 'dm!-lt '(dm!-lt dm!-difference !:minusp) 
8816706277676926929)
dm!-lt


(c!:install 'vdpsimpcont '(vdpsimpcont monfac dipsimpcont dip2vdp
evzero!? evtdeg vdpputprop) 13090543412159800981)
vdpsimpcont


(c!:install 'force!-to!-dm '(force!-to!-dm "number" dmode!*
"conversion error with " prepf typerr apply rederr) 1724544386227275857)
force!-to!-dm


(c!:install 'is_buble '(is_buble diff_vertex) 4718446988208433996)
is_buble


(c!:install 'positive!-powp '(positive!-powp (abs norm)) 
13879753600986516090)
positive!-powp


(c!:install 'reddom_zeros '(reddom_zeros) 14712597886441177874)
reddom_zeros


(c!:install 'red_prepare '(red_prepare bas_nr bas_dpoly bas_rep
dp_from_ei dp_sum bas_make1) 7814434015006136767)
red_prepare


(c!:install 'general!-difference!-mod!-p '(general!-difference!-mod!-p
general!-minus!-mod!-p general!-plus!-mod!-p) 14228395893305165229)
general!-difference!-mod!-p


(c!:install 'remainder!-mod!-p '(remainder!-mod!-p
"b=0 in remainder-mod-p" errorf xremainder!-mod!-p) 6513881754727781303)
remainder!-mod!-p


(c!:install 'ofsf_sippatl '(ofsf_sippatl true and false equal
!*rlsippsubst !*rlsiatadv !*rlsippsignchk cl_cflip ofsf_clnegrel
ofsf_exploitknowl ofsf_vareqnp ofsf_sippsubst ofsf_simplat1
sfto_varisnump ofsf_sippsignchk lto_insert) 15685455572427254218)
ofsf_sippatl


(c!:install 'constructinvolutivebasis '(constructinvolutivebasis
fluidbibasissetq fluidbibasisnonzeronormalforms fluidbibasissett
polynomlistautoreduce createtriple sortedtriplelistinsert setqget
normalform monomisdivisibleby setqdeletedescendants janettreedelete
createtriplewithancestor settinsert triplesetprolongset
settcollectnonmultiprolongations setqinsertlist sortedpolynomlistinsert)
 15826317613969295670)
constructinvolutivebasis



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u49.lsp"

Reading "$reduce/cslbuild/generated-c/u50.lsp"

% u50.lsp           Machine generated Lisp

(c!:install "u50" 111547 2521697 6761785)
nil


(c!:install 'ofsf_sminsert1 '(ofsf_sminsert1 false true negsq addsq
ofsf_smeqtable minusf ofsf_smordtable) 7042807841916849358)
ofsf_sminsert1


(c!:install 'opfchk!! '(opfchk!! integer !:rn!: !*numval dmode!* (!:rd!:
!:cr!:) !:rd!: simprn simparg simprd !*complex list expt !:cr!: alg
"is not defined as complex function" apply revlis simpcr rd!:minusp
rerror errorset2 errorp complexp intconv) 17814999030478090392)
opfchk!!


(c!:install 'get!*order '(get!*order get!*elements) 1961358405182470548)
get!*order


(c!:install 'talp_try2 '(talp_try2 cl_bvarl cl_fvarl talp_try3) 
2404501336677580567)
talp_try2


(c!:install 'reprod '(reprod multf) 1680435243969883784)
reprod


(c!:install 'groebmakepair '(groebmakepair !*gsugar vevlcm gsugar vevdif
vevtdeg max) 4704970316871433)
groebmakepair


(c!:install 'al1_defined_vertex '(al1_defined_vertex re_parents
defined_edge) 519817027080077876)
al1_defined_vertex


(c!:install 'coeffs!-to!-form1 '(coeffs!-to!-form1 to) 
17890572078723803509)
coeffs!-to!-form1


(c!:install 'freeoflist '(freeoflist freeof) 14086139525761355974)
freeoflist


(c!:install 'updkorder '(updkorder kord!* alglist!*) 7384907054091313147
)
updkorder


(c!:install 'ofsf_smwrmknowl '(ofsf_smwrmknowl !*rlsusi ofsf_susirmknowl
ofsf_smrmknowl) 4692894082393399308)
ofsf_smwrmknowl


(c!:install 'gd_simpl '(gd_simpl !*guardian !*rlnzden !*rladdcond
rl_simp rl_simpl rl_prepfof) 10364476088586607859)
gd_simpl


(c!:install '!*multsq '(!*multsq !*multf gcdf quotf!-fail minusf negf) 
9851859899492044261)
!*multsq


(c!:install 'talp_simplatfn '(talp_simplatfn equal neq and or talp_getl
talp_telp talp_simplt talp_mk2 talp_fop talp_fargl talp_simplat2) 
6220938308204958416)
talp_simplatfn


(c!:install 'qqe_length!-graph!-neighbors '(qqe_length!-graph!-neighbors
neighbors) 15934635560574021975)
qqe_length!-graph!-neighbors


(c!:install 'arprep!: '(arprep!: !*reexpress express!-in!-arvars prepf) 
11457261624739346880)
arprep!:


(c!:install 'make_wedge_pair '(make_wedge_pair !*twosided xtruncate!*
wedge_pair xval xlcm overall_factor mknwedge xdegreecheck) 
11385409692619205938)
make_wedge_pair


(c!:install 'coeff_sortl '(coeff_sortl coeff_ordn coeff_sortl1) 
15799877296695268259)
coeff_sortl


(c!:install 'rule!-list '(rule!-list frasc!* mcond!* list "rule list"
equal "Please use => instead of = in rules" replaceby "rule" when
algebraic typerr lprim remove!-free!-vars remove!-free!-vars!* formbool
rule!*) 14925885083637867660)
rule!-list


(c!:install 'df!-chain!-rule '(df!-chain!-rule df simp multsq addsq) 
5715389787073769380)
df!-chain!-rule


(c!:install 'cali_bc_power '(cali_bc_power exptf bc!=simp) 
2670688499088435073)
cali_bc_power


(c!:install 'test!-bool '(test!-bool boolean!-eval1 simp!-prop mk!*sq) 
8932349539925656937)
test!-bool


(c!:install 'pst_d1 '(pst_d1 sc_kern pa_coinc_split ordn) 
14917182381630739938)
pst_d1


(c!:install 'dnform '(dnform e dnform1) 6931039935746521334)
dnform


(c!:install 'count!-linear!-factors!-mod!-p '(
count!-linear!-factors!-mod!-p linear!-factors dpoly poly!-vector
current!-modulus make!-x!-to!-p copy!-vector gcd!-in!-vector
quotfail!-in!-vector) 13301651501611471653)
count!-linear!-factors!-mod!-p


(c!:install 'ofsf_smdbgetrel '(ofsf_smdbgetrel) 3992396472067234109)
ofsf_smdbgetrel


(c!:install 'qqe_length!-graph!-marked '(qqe_length!-graph!-marked
blockmark) 1172609336130959371)
qqe_length!-graph!-marked


(c!:install 'pasf_dnf '(pasf_dnf and dnf pasf_puregconp pasf_pnf
pasf_pbnf) 15208486177393031025)
pasf_dnf


(c!:install 'division!-test '(division!-test quotf) 7457882569290507332)
division!-test


(c!:install 'ldf!-spf!-var '(ldf!-spf!-var x u kernels makeset prlist
sacar appends) 2160313964912260152)
ldf!-spf!-var


(c!:install 'dipreplus '(dipreplus plus) 6843528938903311371)
dipreplus


(c!:install 'ratmean '(ratmean ratplusm) 13316605428599453302)
ratmean


(c!:install 'indordlp '(indordlp indordp) 10004274357578542948)
indordlp


(c!:install 'simp!-prop!-form '(simp!-prop!-form (nil) !'true not_prop!*
not !'and !'or) 3505596857183068138)
simp!-prop!-form


(c!:install 'can_rep_cell '(can_rep_cell) 15670187556956593219)
can_rep_cell


(c!:install 'even_action_pow '(even_action_pow to component_action
multsq find_active_components diffp addsq) 4093906823777950090)
even_action_pow


(c!:install 'quotf!* '(quotf!* "DIVISION FAILED" quotf rationalizesq
errach) 5639812097743456829)
quotf!*


(c!:install 'talp_cocc '(talp_cocc) 1370978426573660718)
talp_cocc


(c!:install 'sfto_deggcd1 '(sfto_deggcd1) 6311198043120278180)
sfto_deggcd1


(c!:install 'vdpfmon '(vdpfmon vdp !*gsugar vevtdeg gsetsugar) 
223532249635937953)
vdpfmon


(c!:install 'xexptpf '(xexptpf wedgepf) 11225990668432378292)
xexptpf


(c!:install 'latexprint '(latexprint prinlabegin latexprin prinlaend) 
1824421567986552037)
latexprint


(c!:install 'denlist '(denlist nreverse ev!-denom2 ev!-denom3) 
10869545544147735135)
denlist


(c!:install 'hdiff '(hdiff hdiffterm fs!:plus) 16897863673431883770)
hdiff


(c!:install 'eval!-yetunknowntypeexpr '(eval!-yetunknowntypeexpr !*sq
!:dn!: yetunknowntype getrtype) 16027293666846484104)
eval!-yetunknowntypeexpr


(c!:install 'gigcd!: '(gigcd!: gizerop!: fqa giremainder) 
7630160909363877681)
gigcd!:


(c!:install 'matrix_input_test '(matrix_input_test mat "ERROR: `"
"' is non matrix input." rederr) 4007855338312678546)
matrix_input_test



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u50.lsp"

Reading "$reduce/cslbuild/generated-c/u51.lsp"

% u51.lsp           Machine generated Lisp

(c!:install "u51" 10910 47199 2836573)
nil


(c!:install 'symmetrize!-inds '(symmetrize!-inds nth indordn indordln
flatindl pair) 2360766767333337586)
symmetrize!-inds


(c!:install 'combin '(combin) 6188018515752389102)
combin


(c!:install 'dv_skelsplit '(dv_skelsplit list !~dv !* symtree !+
antisymmetric !- !~dva idcons_ordp listp dummyp max st_sorttree
dv_skelsplit1 st_consolidate) 17835299216557388271)
dv_skelsplit


(c!:install 'simpdot '(simpdot dotord mkvarg) 13792885305380750406)
simpdot


(c!:install 'coeff_totder '(coeff_totder all_mind_table!* i2m_jetspace!*
i2m_jetspace_odd!* letop idtomind nth cde_lassoc2) 5042501430904969717)
coeff_totder


(c!:install 'ofsf_smmkatl!-or1 '(ofsf_smmkatl!-or1 (lessp greaterp equal
) or ofsf_smmkat!-or2 ofsf_entry2at lastpair) 3420829671504393222)
ofsf_smmkatl!-or1


(c!:install 'change!+sq!+to!+int '(change!+sq!+to!+int
"no integer in change!+sq!+to!+int" prepsq simp!* rederr) 
11238142442414323586)
change!+sq!+to!+int


(c!:install 'qqe_simplqequal '(qqe_simplqequal true qepsilon false
qequal qqe_arg2r qqe_arg2l qqe_qprefix!-var
qqe_number!-of!-adds!-in!-qterm qqe_number!-of!-tails!-in!-qterm
qqe_simplterm qqe_mk2) 2927715472686800828)
qqe_simplqequal


(c!:install 'acfsf_varlat '(acfsf_varlat acfsf_arg2l kernels) 
3942176160301289890)
acfsf_varlat


(c!:install 'gb_buchcrit4t '(gb_buchcrit4t ev_disjointp) 
16397767877925019400)
gb_buchcrit4t


(c!:install 'transferrow1 '(transferrow1 codmat maxvar) 
5971399830087691577)
transferrow1


(c!:install 'vdpmember '(vdpmember vdpequal) 8126623404930661228)
vdpmember


(c!:install 'exptbf '(exptbf csl_timbf lshift) 8829827129529104822)
exptbf


(c!:install 'preproc '(preproc preproc1) 2399640409246907490)
preproc


(c!:install 'coeff1_calc '(coeff1_calc nreverse calc_coeffmap_) 
15732296808858211155)
coeff1_calc


(c!:install 'subs2chkex '(subs2chkex subs2chk) 4517560909162540544)
subs2chkex


(c!:install 'red_redpol '(red_redpol !*red_total red_prepare
red_totalred red_topred red_extract) 9464429379661830263)
red_redpol


(c!:install 'ofsf_smmkatl!-or '(ofsf_smmkatl!-or or ofsf_ir2atl
ofsf_smmkatl!-or1 lastpair) 1775478292988938837)
ofsf_smmkatl!-or


(c!:install 'simp!-sign2 '(simp!-sign2 sign rd!-sign simpiden) 
17273752521537108984)
simp!-sign2


(c!:install 'talp_try1 '(talp_try1 true false or and talp_rnf talp_atfp
talp_op talp_argl cl_nnfnot talp_try2 cl_simpl) 18378002882174921029)
talp_try1


(c!:install 'tchscheme '(tchscheme rowmax codmat maxvar transferrow
chscheme) 8755550966450153547)
tchscheme


(c!:install 'cos!* '(cos!* !:bprec!: cos!:) 10648388374146150234)
cos!*


(c!:install 'requote1 '(requote1 (nil t) quote list) 1995016711071816972
)
requote1


(c!:install 'store_edges '(store_edges) 8426183693797107597)
store_edges


(c!:install 'normmat '(normmat lcm quotf multf) 1653959013059661494)
normmat


(c!:install 'extract_numid '(extract_numid !*id2num) 
17844419327560288190)
extract_numid


(c!:install 'eval_uni_poly '(eval_uni_poly) 6078601229241481536)
eval_uni_poly


(c!:install 'exports '(exports exportslist!* union) 10515641968720128232
)
exports


(c!:install 'smt_liter '(smt_liter (!~ !! !@ !$ !% !^ !& !* !_ !- !+ !=
!< !> !. !? !/ !:)) 4415757495831977008)
smt_liter


(c!:install 'giprim '(giprim i times) 8790229893788072726)
giprim


(c!:install 'qqe_prefix!-length '(qqe_prefix!-length (rtail ltail rhead
lhead)) 1891945703389096981)
qqe_prefix!-length


(c!:install 'rl_simplb '(rl_simplb rl_simplb!* apply) 
7197064830390758941)
rl_simplb


(c!:install 'intconv '(intconv dmode!* (!:rd!: !:cr!:)) 
12045065025164598034)
intconv


(c!:install 'splitrec '(splitrec list!-pq multf addf) 
14915310745069651795)
splitrec


(c!:install 'f2dip2 '(f2dip2 dipvars!* evinsert to multsq f2dip1) 
7346907586331285505)
f2dip2


(c!:install 'xpartitk '(xpartitk (wedge partdf) memqcar reval xpartitop)
 12829369561745651506)
xpartitk


(c!:install 'sqprla '(sqprla prepsq!* maprintla) 13712036929237112709)
sqprla


(c!:install 'physop!*sq '(physop!*sq physop !*q2a !*collectphysops) 
10075154655632502267)
physop!*sq


(c!:install 'precision1 '(precision1 !!rdprec !*roundbf minprec!#
!:prec!: !:print!-prec!: !:bprec!: !:rd!: epsqrt!* rd!-tolerance!*
cr!-tolerance!* !!flprec !*!*roundbf rmsubs max decprec2internal) 
14929182774852078873)
precision1


(c!:install 'merge_lists '(merge_lists reversip2) 10914131982876991318)
merge_lists


(c!:install 'update_components '(update_components) 7941079195352256761)
update_components


(c!:install 'ofsf_irl2atl '(ofsf_irl2atl ofsf_ir2atl lastpair) 
6610879085232105334)
ofsf_irl2atl


(c!:install 'ofsf_evalatp '(ofsf_evalatp equal neq leq geq lessp
greaterp "ofsf_evalatp: unknown operator " minusf rederr) 
6454550597136181537)
ofsf_evalatp



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u51.lsp"

Reading "$reduce/cslbuild/generated-c/u52.lsp"

% u52.lsp           Machine generated Lisp

(c!:install "u52" 129220 4952234 7549015)
nil


(c!:install 'mk_resimp_rep '(mk_resimp_rep get_group_in get!*elements
get_rep_matrix_in mk!+resimp!+mat) 8996840146166686658)
mk_resimp_rep


(c!:install 'bc_minus!? '(bc_minus!? minusf) 13892838142220692503)
bc_minus!?


(c!:install 'expttermp '(expttermp expt expttermp1) 18192048704841883576
)
expttermp


(c!:install 'expvec2a1 '(expvec2a1 expt nreverse) 3707321210302595183)
expvec2a1


(c!:install 'multsqpf '(multsqpf nreverse multsq) 10980860386620252559)
multsqpf


(c!:install 'rand!-mons!-sparse '(rand!-mons!-sparse binomial min
rand!-comb !*kp2f inttovec multf) 1302733689150682916)
rand!-mons!-sparse


(c!:install 'exp!* '(exp!* !:bprec!: exp!:) 18040129415916644653)
exp!*


(c!:install 'atlas_edges '(atlas_edges map__edges den__edges union_edges
coeff_edges) 8039082428745456416)
atlas_edges


(c!:install 'actual_arguments '(actual_arguments list generic_function) 
10022761296659648807)
actual_arguments


(c!:install 'dp!=comp '(dp!=comp nreverse dp_lmon mo_comp) 
14670774762518676824)
dp!=comp


(c!:install 'rl_identifyonoff '(rl_identifyonoff rl_identifyonoff!*
apply) 264122958181467562)
rl_identifyonoff


(c!:install 'addfactors '(addfactors times prepf aconc!* retimes) 
9069149108209877443)
addfactors


(c!:install 'rule!* '(rule!* frasc!* mcond!* old newrule!* rtype props!*
avalue expt asymplis!* updoldrules rule) 15917324397672373224)
rule!*


(c!:install 'constant_exprp '(constant_exprp constant i realvalued
alwaysrealvalued (plus minus difference times quotient) !:rd!: !*complex
!:cr!: constant_expr_listp) 18109207819067230144)
constant_exprp


(c!:install 'pasf_smordtable1 '(pasf_smordtable1 ((lessp (lessp 1) (leq
1) (equal false) (neq 1) (geq false) (greaterp false) (cong nil) (ncong
nil)) (leq (lessp 1) (leq 1) (equal false) (neq 1) (geq false) (greaterp
false) (cong nil) (ncong nil)) (equal (lessp 1) (leq 1) (equal false) (
neq 1) (geq false) (greaterp false) (cong nil) (ncong nil)) (neq (lessp
nil) (leq nil) (equal 2) (neq nil) (geq 2) (greaterp 2) (cong nil) (
ncong nil)) (geq (lessp nil) (leq nil) (equal 2) (neq nil) (geq 2) (
greaterp 2) (cong nil) (ncong nil)) (greaterp (lessp nil) (leq nil) (
equal 2) (neq nil) (geq 2) (greaterp 2) (cong nil) (ncong nil)))) 
7103508956278523470)
pasf_smordtable1


(c!:install 'ps!:difference!-erule '(ps!:difference!-erule ps!:evaluate
negsq addsq) 16135774197856350921)
ps!:difference!-erule


(c!:install 'getvariables '(getvariables varsinsf) 11726400517569850811)
getvariables


(c!:install 'gbftimes '(gbftimes csl_timbf difbf plubf) 
6762068369789808492)
gbftimes


(c!:install 'r2oreaction '(r2oreaction times expt difference plus aeval
reval) 13610110260629005727)
r2oreaction


(c!:install 'binc '(binc mk!-numr constimes factorial listquotient) 
14077582727497147310)
binc


(c!:install 'dp_2a '(dp_2a dp!=2a dp!=replus) 18083363694407178011)
dp_2a


(c!:install 'cde_list2id '(cde_list2id
"argument for cde_list2id must be a list" rederr lastpair) 
14000377831304568398)
cde_list2id


(c!:install 'subdf '(subdf subf subs2q !*multf plusdf) 
2743108251233153828)
subdf


(c!:install 'talp_mk!-invs '(talp_mk!-invs talp_mkinvop) 
5785843035114066455)
talp_mk!-invs


(c!:install 'qqe_dfs '(qqe_dfs) 5543017835140133068)
qqe_dfs


(c!:install 'i2ps '(i2ps) 5840660322852784483)
i2ps


(c!:install 'ldf!-pow!-var '(ldf!-pow!-var x u kernels makeset prlist) 
14977998401672650340)
ldf!-pow!-var


(c!:install 'fast!-augment!-columns '(fast!-augment!-columns
fast!-row!-dim sc_getmat sc_iputv sc_getrow nth sc_igetv) 
13224245610267281169)
fast!-augment!-columns


(c!:install 'decimal2internal '(decimal2internal !:rd!:
divide!-by!-power!-of!-ten) 14631323547991593864)
decimal2internal


(c!:install 'dvertex!-to!-projector '(dvertex!-to!-projector mktails
repeatsp prop!-simp mk!-contract!-coeff dpropagator) 6329309849721072789
)
dvertex!-to!-projector


(c!:install 'clogsq '(clogsq clogf) 12458012163820066603)
clogsq


(c!:install 'lf!=tovarlessp '(lf!=tovarlessp mo_compare) 
18012836837064206136)
lf!=tovarlessp


(c!:install 'dummy_nam '(dummy_nam symbolic g_dvnames ordn list2vect!*) 
13516216293254312689)
dummy_nam


(c!:install 'st_extract_symcells1 '(st_extract_symcells1 !* listp) 
9261528819786944218)
st_extract_symcells1


(c!:install 'mod!/ '(mod!/ current!-modulus general!-reciprocal!-by!-gcd
) 18103756201143973339)
mod!/


(c!:install 'cr2rderr '(cr2rderr
"complex to real type conversion requires zero imaginary part" error) 
11159384114148402351)
cr2rderr


(c!:install 'quotfexf!*1 '(quotfexf!*1 !*rationalize matrix
"Catastrophic division failure" quotf rationalizesq rerror) 
11249899643196219485)
quotfexf!*1


(c!:install 'texexplode '(texexplode texname !  texcollect strcollect
texexplist) 4644564349813911594)
texexplode


(c!:install 'dip_monp '(dip_monp) 602049357356881825)
dip_monp


(c!:install 'parseml '(parseml space count ch temp2 char (m a t h)
"<math>" (!/ m a t h) "</math>" list2string lex mathml errorml aeval) 
10857081456934169098)
parseml


(c!:install 'mkratnum '(mkratnum !:gi!: !:crn!: !:rn!: !*i2rn) 
4938996573169262951)
mkratnum


(c!:install 'poly!-remainder '(poly!-remainder remainder poly!-divide!*)
 6768570781226289743)
poly!-remainder


(c!:install 'xpartitsq '(xpartitsq sfp xexptpf cancel wedgepf xvarp
xpartitk multpfsq addpf) 3770491268411413216)
xpartitsq


(c!:install 'acmemb '(acmemb aceq) 13271867179498849625)
acmemb


(c!:install 'redassignp '(redassignp setq redassign1p) 
11307624572096717668)
redassignp


(c!:install 'adjp '(adjp unit adjoint comm anticomm) 7425062376879180506
)
adjp


(c!:install 'calc_world '(calc_world s_world_names actual_alst
calc_atlas reval) 6347126962586917981)
calc_world


(c!:install '!*sq2fourier '(!*sq2fourier cos fourier tag
fs!:make!-nullangle) 5891675253994263450)
!*sq2fourier


(c!:install '!*v2j '(!*v2j ordering lex varlist!* sub01) 
1976701608171549133)
!*v2j


(c!:install 'ic_taglist '(ic_taglist) 13395911804679478804)
ic_taglist


(c!:install 'initmonomials '(initmonomials fluidbibasisvariables
fluidbibasisnumberofvariables fluidbibasissinglevariablemonomialss
fluidbibasistripleid createsinglevariablemonom) 16303829755948409025)
initmonomials


(c!:install 'depend!-p '(depend!-p !*sq depend!-f depend!-sq depend!-l) 
8314922715292353285)
depend!-p


(c!:install 'ofsf_simpat '(ofsf_simpat !*rlnzden !*rlposden
"atomic formula" !*rladdcond (lessp leq greaterp geq) and greaterp neq
simp typerr negsq addsq multf) 16117239508109601768)
ofsf_simpat


(c!:install 'force!-lc '(force!-lc) 17754422174457067786)
force!-lc


(c!:install 'simpsqrt2 '(simpsqrt2 gaussiani minusf iequal negf
simpsqrt3 multf) 13180318253061721077)
simpsqrt2


(c!:install 'cr!:zerop '(cr!:zerop !:rd!:) 6552380167070519668)
cr!:zerop


(c!:install 'varsinsf '(varsinsf union) 15554101783376022867)
varsinsf


(c!:install 'row_dim '(row_dim !*fast_la
"Error in row_dim: input should be a matrix." matrixp rederr
size_of_matrix) 16864272506304451716)
row_dim


(c!:install 'xpndwedge '(xpndwedge partitop mkunarywedge wedgepf2) 
3250510587247370634)
xpndwedge


(c!:install 'find_bubles_coeff '(find_bubles_coeff find_bubles1_coeff) 
2751637220975430738)
find_bubles_coeff


(c!:install 'lf!=less '(lf!=less cali varlessp lf!=lvar) 
16141227712057728171)
lf!=less


(c!:install 'general!-negate!-term '(general!-negate!-term
general!-minus!-mod!-p) 16591824657730650749)
general!-negate!-term


(c!:install 'allbkern '(allbkern kernels basic!-kern union) 
514249563188008739)
allbkern



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u52.lsp"

Reading "$reduce/cslbuild/generated-c/u53.lsp"

% u53.lsp           Machine generated Lisp

(c!:install "u53" 92302 6804259 9274664)
nil


(c!:install 'ofsf_sminsert '(ofsf_sminsert false true ofsf_sminsert1
setcdr) 18000105277674831219)
ofsf_sminsert


(c!:install 'addinds '(addinds "Powrhs too long" "Powu too long"
nreverse interr) 8783814793223218724)
addinds


(c!:install 'multtaylorsq '(multtaylorsq taylor!* !*taylorkeeporiginal
multsq subs2!* resimp) 9919477787510602169)
multtaylorsq


(c!:install 'talp_nextt '(talp_nextt talp_getl talp_mk!-invs lastpair
talp_list2vec talp_invp talp_nextt1) 6462205596091280055)
talp_nextt


(c!:install 'qqe_length!-graph!-bterm '(qqe_length!-graph!-bterm (lhead
rhead) qqe_op qqe_length!-graph!-bterm!-update!-headmin) 
14798580470036677714)
qqe_length!-graph!-bterm


(c!:install '!*kp2q '(!*kp2q "Zero divisor" mksq rederr revpr) 
3599326762998707582)
!*kp2q


(c!:install 'physopplus '(physopplus "type mismatch in plus "
physopsim!* getphystype rederr2 physop2sq addsq mk!*sq) 
16067418966038295158)
physopplus


(c!:install 'mk!-strand!-vertex '(mk!-strand!-vertex incident
mk!-strand!-vertex2) 1642583444989583446)
mk!-strand!-vertex


(c!:install 'lchk '(lchk) 8834554188476547679)
lchk


(c!:install 'rationalizef '(rationalizef expt quotient i (quotient 1 2)
sqrt (quotient 1 3) (quotient 1 4) kernels lowertowerp mkmain
conjquadratic conjcubic conjquartic) 7151580781870530831)
rationalizef


(c!:install 'all_index_lst '(all_index_lst list listp) 
3654155541323541217)
all_index_lst


(c!:install 'bfprin0x '(bfprin0x bfexplode0x bfprin!:lst) 
18248937376260990662)
bfprin0x


(c!:install 'addcoeffs '(addcoeffs smallest!-increment common!-increment
makecoeffpairs multsq addsq) 15259186419355437484)
addcoeffs


(c!:install 'mrv_constantp '(mrv_constantp constant freeof) 
7453527344230814969)
mrv_constantp


(c!:install 'equal!+matrices!+p '(equal!+matrices!+p !*complex
same!+dim!+squared!+p mk!+scal!+mult!+mat mk!+mat!+plus!+mat
mk!+conjugate!+sq multsq addsq change!+sq!+to!+algnull) 
13192663332799596718)
equal!+matrices!+p


(c!:install 'bc_pmon '(bc_pmon to) 109842801484838358)
bc_pmon


(c!:install 'vevzero!?1 '(vevzero!?1) 10157384379837683846)
vevzero!?1


(c!:install 'remove_critical_pairs '(remove_critical_pairs remove_items)
 12426658889339854311)
remove_critical_pairs


(c!:install 'noncom1 '(noncom1 !*ncmp noncom) 11419460836052736216)
noncom1


(c!:install 'bassoc '(bassoc th_match) 16440937476530816831)
bassoc


(c!:install 'gak '(gak aconc) 12594716863303144844)
gak


(c!:install 'square!-free!-mod!-p '(square!-free!-mod!-p
derivative!-mod!-p gcd!-mod!-p) 11016584804240126921)
square!-free!-mod!-p


(c!:install 'sfto_b!:cquot '(sfto_b!:cquot nreverse quotf1) 
9581205324701258159)
sfto_b!:cquot


(c!:install 'operator '(operator mkop) 1409021900333175665)
operator


(c!:install 'tidysqrt '(tidysqrt tidysqrtf invsq multsq) 
17637639424542550931)
tidysqrt


(c!:install 'subscriptedvarp2 '(subscriptedvarp2 symtabget) 
2356643343232798268)
subscriptedvarp2


(c!:install 'expttermp1 '(expttermp1 expt) 16300050658521353563)
expttermp1


(c!:install 'dipcontenti1 '(dipcontenti1 vbcgcd dipcontevmin bcone!?) 
821378543249485162)
dipcontenti1


(c!:install 'evalsubset '(evalsubset subset evalsetbool evalsymsubset) 
18227868268543170902)
evalsubset


(c!:install 'all_defined '(all_defined map__edges defined_append
all_defined_map_) 6100698165411242067)
all_defined


(c!:install 'pa_vect2list '(pa_vect2list upbve ordn) 
17456351985825694030)
pa_vect2list


(c!:install 'lowestdeg '(lowestdeg expt "exponents must be integers"
simp!* !*q2f erase_pol_cst !*a2k setkorder reorder rederr) 
18356434283429461902)
lowestdeg


(c!:install 'rl_ex '(rl_ex rl_ex!* apply) 159967248458196071)
rl_ex


(c!:install 'ofsf_exploitknowl '(ofsf_exploitknowl equal !*rlsippsubst
greaterp geq lessp leq neq sfto_varp negsq lto_insertq) 
6407292417331235835)
ofsf_exploitknowl


(c!:install 'get!*nr!*real!*irred!*reps '(get!*nr!*real!*irred!*reps
realrepnumber) 6749148416422812882)
get!*nr!*real!*irred!*reps


(c!:install 'constant_expr_listp '(constant_expr_listp constant i
constant_exprp) 11204786086360299674)
constant_expr_listp


(c!:install 'qqe_simpat '(qqe_simpat) 9761063186935570134)
qqe_simpat


(c!:install 'ieval '(ieval reval !*s2i) 10970267165119146512)
ieval


(c!:install 'column_dim '(column_dim !*fast_la
"Error in column_dim: input should be a matrix." matrixp rederr
size_of_matrix) 9644095049462376249)
column_dim


(c!:install 'vdpappendmon '(vdpappendmon vdp vdpfmon vbczero!? dipsum) 
5462317633277046724)
vdpappendmon


(c!:install 'xriterion_2 '(xriterion_2 wedge_pair !*trxideal
"criterion 2 hit" last xdiv make_wedge_pair find_item writepri) 
5623418408247858791)
xriterion_2


(c!:install 'gffdot '(gffdot) 16874205848873527026)
gffdot


(c!:install 'r2speclist '(r2speclist plus r2speclist1) 
5879233124307570045)
r2speclist


(c!:install 'new_provev '(new_provev) 6302738449472206509)
new_provev


(c!:install 'dpmat_gbtag '(dpmat_gbtag nth) 7853934172546639414)
dpmat_gbtag


(c!:install 'general!-minus!-mod!-p '(general!-minus!-mod!-p nreverse
general!-modular!-minus) 12214029244195715542)
general!-minus!-mod!-p


(c!:install 'simprd '(simprd !:rd!: dmode!* simplist) 
15671832098548929442)
simprd


(c!:install 'cde_alglistp '(cde_alglistp list listp) 4533279857863766319
)
cde_alglistp


(c!:install 'find_active_components '(find_active_components depl!*
update_components) 15779492601999883025)
find_active_components


(c!:install '!*invsq '(!*invsq sqrtflag invsq sqrt2top) 
18396166173782830709)
!*invsq


(c!:install 'null!+vec!+p '(null!+vec!+p mk!+squared!+norm my!+nullsq!+p
) 9320904567712483426)
null!+vec!+p


(c!:install 'cl_strict!-gdnf '(cl_strict!-gdnf cl_strict!-gdnf1 rl_simpl
cl_mkstrict rl_bnfsimpl) 1349976826570922730)
cl_strict!-gdnf


(c!:install 'bc_abs '(bc_abs absf) 17823449427386136621)
bc_abs


(c!:install 'dip_comp1 '(dip_comp1 dip_evlmon ev_comp) 
15677524538554573974)
dip_comp1


(c!:install 'subsubf '(subsubf equal sub subsublis reversip!* aeval
aconc!* subeval mksp mk!*sq) 7039029750313157863)
subsubf


(c!:install 'deflate1 '(deflate1 ncoeffs times!: plus!:) 
4509771127112034283)
deflate1


(c!:install 'ev!-tades '(ev!-tades ndim!* nreverse binc) 
5470766975652506745)
ev!-tades


(c!:install 'restore_props '(restore_props props!*) 6152622342977608834)
restore_props


(c!:install 'sc_create '(sc_create symbolic list2vect!*) 
7753972097936331166)
sc_create



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u53.lsp"

Reading "$reduce/cslbuild/generated-c/u54.lsp"

% u54.lsp           Machine generated Lisp

(c!:install "u54" 80309 4310984 5630701)
nil


(c!:install 'rtrnda '(rtrnda rlval!# round!:dec1 decimal2internal) 
10001363363297517072)
rtrnda


(c!:install 'radd '(radd !*reduced i prepf nrootnn to multd) 
4883045765788106847)
radd


(c!:install 'coeffs!-to!-form '(coeffs!-to!-form coeffs!-to!-form1) 
4460287134275495432)
coeffs!-to!-form


(c!:install 'aex_psremseq '(aex_psremseq aex_mklcnt aex_divposcnt
aex_deg aex_psrem aex_neg aex_simplenullp) 1759062070613365367)
aex_psremseq


(c!:install 'rl_!*qe '(rl_!*qe rl_qe apply) 17173489639086840913)
rl_!*qe


(c!:install 'mkuniquewedge '(mkuniquewedge mkuniquewedge1 multpfsq addpf
) 6436937546738158185)
mkuniquewedge


(c!:install 'minprec '(minprec !*bftag !:prec!: !!nfpd) 
1602854570656589848)
minprec


(c!:install 'tvectorp '(tvectorp deg!*form) 2698767616585058183)
tvectorp


(c!:install 'ext_edges '(ext_edges !_0edge nreverse delete_edge) 
5784848160875481775)
ext_edges


(c!:install 'liendimcom '(liendimcom lie_dim difference lie_cc lie_p
lie_q plus quotient times lie_help lie_s lientrans lie_kk!* lie_tt aeval
setk aeval!* aminusp!: evalneq evalequal) 14036051703278256262)
liendimcom


(c!:install 'mo!=pair '(mo!=pair nreverse) 4859534959121366847)
mo!=pair


(c!:install 'gi '(gi gg!* class) 12570059923375073769)
gi


(c!:install '!*sf2exb '(!*sf2exb degr nreverse) 16721578175864221016)
!*sf2exb


(c!:install 'prepsqyy '(prepsqyy !*sq prepsqxx) 17138303528519497267)
prepsqyy


(c!:install 'ordexp '(ordexp ordop) 10875341827804411375)
ordexp


(c!:install 'cde_mkset '(cde_mkset nreverse) 13656224451752460396)
cde_mkset


(c!:install 'small!-random!-number '(small!-random!-number 1.0 1.5
1.0e+06 next!-random!-number exp) 11705891558564500348)
small!-random!-number


(c!:install 'ofsf_updsignpow '(ofsf_updsignpow (equal greaterp geq neq)
(lessp leq) unknown ofsf_canegrel) 12183535377953807471)
ofsf_updsignpow


(c!:install 'chrstrem '(chrstrem !*trwu !*trchrstrem
"--------------------------------------------------------"
"The new pol-set in ascending order is" "which is trivially trivial"
inconsistent "A basic set is" "The remainder of "
"wrt the basic set is " "which is a non-zero constant, and so"
"the equations are inconsistent." "The final characteristic set is:"
terpri!* prin2t!* wusort printsf wuconstantp pickbasicset setdiff
prin2!* findremainder prin2t absf union) 5892555042781459775)
chrstrem


(c!:install 'no_of_tm_sf '(no_of_tm_sf) 14650371380341364919)
no_of_tm_sf


(c!:install 'giminusp!: '(giminusp!:) 7111611823332749510)
giminusp!:


(c!:install 'qqe_qadd!-inside '(qqe_qadd!-inside a qqe_qadd!-location!*
d qqe_op qqe_qopaddp) 16452016970455392057)
qqe_qadd!-inside


(c!:install 'dip_reduceconti '(dip_reduceconti dip_lbc bc_quot
dip_evlmon dip_mred dip_moncomp) 12536364206078477054)
dip_reduceconti


(c!:install 'crprimp '(crprimp i minus times) 17061817778349731192)
crprimp


(c!:install 'rewrite2 '(rewrite2) 494596473675394549)
rewrite2


(c!:install 'weak_xreduce '(weak_xreduce !*trxmod " =" last "   " first
preppf writepri weak_xreduce1) 14660389791441603175)
weak_xreduce


(c!:install 'rand!-comb '(rand!-comb random) 9507653342872797240)
rand!-comb



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u54.lsp"

Reading "$reduce/cslbuild/generated-c/u55.lsp"

% u55.lsp           Machine generated Lisp

(c!:install "u55" 84207 3657721 4602479)
nil


(c!:install 'partitindexvar '(partitindexvar minus metricu!* covariant
indxsymmetries revalind !*num2id deg!*form getlower simp multpfsq addpf
getupper coposp mkupf mksq indexsymmetrize negsq) 15859767580377981061)
partitindexvar


(c!:install 'mk!-coeff1 '(mk!-coeff1 times getroad factorial eval) 
4284856049728081327)
mk!-coeff1


(c!:install 'modroots1 '(modroots1 g plus times modroots2 subf
reduce!-mod!-p!* modp) 12220486894174093238)
modroots1


(c!:install 'mkg1 '(mkg1 nospur g mksf) 10874375751637765688)
mkg1


(c!:install 'gd_newtype '(gd_newtype gec geg ger) 4854955074096824815)
gd_newtype


(c!:install 'dfmax '(dfmax dfrel) 5932994387667960604)
dfmax


(c!:install 'uterm '(uterm rhs!* addinds evaluatecoeffts plusdf) 
5304631242153271363)
uterm


(c!:install 'talp_try3 '(talp_try3 true false and equal talp_atfp
talp_argl talp_op talp_arg2l talp_arg2r talp_contains talp_td
talp_extlftrs talp_chsbstres talp_try1 talp_rnf) 5507210192899200995)
talp_try3


(c!:install 'simpsqrt3 '(simpsqrt3 listofallsqrts listofnewsqrts
knowntobeindep actualsimpsqrt) 4810146213398586859)
simpsqrt3


(c!:install 'ps!:value '(ps!:value !:ps!: ps!:getv) 8457495156308057488)
ps!:value


(c!:install 'setprev '(setprev codmat maxvar) 10823251145123251282)
setprev


(c!:install 'gvarlis '(gvarlis ordop gvarlis1 sort) 701878123664886157)
gvarlis


(c!:install 'xreduce1 '(xreduce1 weak_xreduce1 nreverse) 
11959619420246598109)
xreduce1


(c!:install 'calc_map_tar '(calc_map_tar ev!-poles constimes ev!-tades
strand!-alg!-top) 4380444771427007829)
calc_map_tar


(c!:install '!*ex2sf '(!*ex2sf nreverse subs2chk to) 
11567801212848725998)
!*ex2sf


(c!:install 'red_extract '(red_extract bas_rep dp_comp bas_nr bas_dpoly
dp_diff bas_make1) 18351211877572852818)
red_extract


(c!:install '!*hfac '(!*hfac avector "Invalid index" hfactors rerror
getavalue) 10654156801179525459)
!*hfac


(c!:install 'sep_tens_from_other '(sep_tens_from_other translate1 !*n2f
multf fullcopy setcar tensorp no_dum_varp) 13688086569006268499)
sep_tens_from_other


(c!:install 'sqlessp '(sqlessp negsq addsq !:minusp) 
17809746572932323716)
sqlessp


(c!:install 'generate_multiindex '(generate_multiindex n_indep_var nth
cde_replace_nth) 12093244824212738996)
generate_multiindex


(c!:install 'sfto_mindeg1 '(sfto_mindeg1) 14523690705715977540)
sfto_mindeg1


(c!:install 'cl_ex '(cl_ex ex cl_closure) 11384483825904126705)
cl_ex


(c!:install 'ofsf_canegrel '(ofsf_canegrel ofsf_anegrel) 
15037791649800802071)
ofsf_canegrel


(c!:install 'get_rep_of_generator '(get_rep_of_generator id
" error in get rep of generators" get!+row!+nr mk!+unit!+mat rederr) 
17062428417663879104)
get_rep_of_generator


(c!:install 'rl_reval '(rl_reval rl_simp1 rl_prepfof rl_mk!*fof) 
14443807258000341238)
rl_reval


(c!:install 'pasf_univnlp '(pasf_univnlp setkorder reorder) 
16237862166288005420)
pasf_univnlp


(c!:install 'remk '(remk degr multf negf to addf) 6335627113382538221)
remk


(c!:install 'irp_aex '(irp_aex nth) 9099467238542619998)
irp_aex


(c!:install 'mod!-domainvalchk '(mod!-domainvalchk expt failed
mod!-expt!-fract) 3596140922650879438)
mod!-domainvalchk


(c!:install 'remove_root_item '(remove_root_item setcar setcdr) 
10602874536531986244)
remove_root_item


(c!:install 'calc_map_2d '(calc_map_2d mk_names_map_2 mk_binding
coeff_calc) 4378061536774923404)
calc_map_2d


(c!:install 'depend1 '(depend1 depl!* "has no prior dependence on" !*a2k
union repasc lprim) 1640192312911088508)
depend1


(c!:install 'zfactor '(zfactor zfactor1) 2511242439935552506)
zfactor


(c!:install 'simprad '(simprad !*reduced !*rationalize quotient
!*precise radfa invsq multsq exptf multf radf minusf negf retimes simp
prepf mkrootsq negsq prepsq) 3068384987609076058)
simprad


(c!:install 'crn!:zerop '(crn!:zerop) 14471836097984589314)
crn!:zerop


(c!:install 'imports '(imports importslist!* union) 14856359103180957613
)
imports


(c!:install 'monomispommaretdivisibleby '(monomispommaretdivisibleby) 
15831018813323069051)
monomispommaretdivisibleby


(c!:install 'talp_raf '(talp_raf equal neq and or talp_op talp_arg2l
talp_tcfrp talp_arg2r talp_getinvfsym talp_mkinv talp_mk2 talp_simpat
talp_getl talp_fargl nth talp_rnf1 talp_mkn) 15957899528406532110)
talp_raf



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u55.lsp"

Reading "$reduce/cslbuild/generated-c/u56.lsp"

% u56.lsp           Machine generated Lisp

(c!:install "u56" 56422 5399638 6265814)
nil


(c!:install 'search_att '(search_att (stop) !  != !" !$ find2 errorml) 
44845976647922481)
search_att


(c!:install 'mo_from_ei '(mo_from_ei mo_zero mo!=deglist) 
602087789336090225)
mo_from_ei


(c!:install 'boolean!-eval2 '(boolean!-eval2 boolean and or not !*protfg
algebraic bool!-break!* erfg!* formbool errorset errorp) 
13535939763071878538)
boolean!-eval2


(c!:install 'distri_pol '(distri_pol addfd multf) 13109417853935887981)
distri_pol


(c!:install 'aex_xtothen '(aex_xtothen sfto_kexp ctx_new aex_mk) 
4843311709874545003)
aex_xtothen


(c!:install 'get!-min!-degreelist '(get!-min!-degreelist confusion
tayexp!-plus2 taymindegreel) 8744899286662908442)
get!-min!-degreelist


(c!:install 'available!*p '(available!*p "this is no group identifier"
available rederr) 3388754601504852178)
available!*p


(c!:install 'talp_get!-minfct '(talp_get!-minfct talp_invp talp_fop
talp_mktn) 10298220219146545044)
talp_get!-minfct


(c!:install 'mri_irsplit '(mri_irsplit floor to simp mri_simplfloor
mri_irsplit1 prepf !*a2k) 11148388974111862795)
mri_irsplit


(c!:install 'subsqnew '(subsqnew prepsq subf quotsq) 
12642540119680760180)
subsqnew


(c!:install 'implicitdec '(implicitdec !*decs!* symtabget isimplicit
firstmatch implicittype) 7614714412425999913)
implicitdec


(c!:install 'bccheckz '(bccheckz !*bcsubs2 bczerodivl!* subs2 qremf) 
5935526042975367298)
bccheckz


(c!:install 'xnormalise '(xnormalise invsq multpfsq) 
11085071778112155648)
xnormalise


(c!:install 'unshift '(unshift !*xo (0.0 . 0.0) gfplus gfadjust) 
18342691400931012398)
unshift


(c!:install 'simpabs '(simpabs abs revlis mksq sign!-abs simp!* simpabs1
quotsq) 3087722267708201599)
simpabs


(c!:install '!*sf2ex '(!*sf2ex nreverse) 12934913102930594307)
!*sf2ex


(c!:install 'compactf3 '(compactf3 mv!-vars!* sf2mv mv!-compact mv2sf) 
10919652603236884479)
compactf3


(c!:install 'extodd '(extodd ext
"the argument of extodd must be an ext variable" n_all_parametric_ext
all_principal_odd!* all_parametric_odd!* rederr nth) 5870015481548055222
)
extodd


(c!:install 'ofsf_facneq!* '(ofsf_facneq!* !*rlsifac !*rlsiexpla
!*rlsiexpl and neq ofsf_facneq) 9484445756966266993)
ofsf_facneq!*


(c!:install 'cl_subfof1 '(cl_subfof1 true false ex all bex ball or and
not impl repl equiv lastpair cl_newv cl_subvarsubstat rl_subat) 
13040601500932645714)
cl_subfof1


(c!:install 'applyml '(applyml char rdlist!* (i d e n t !/) (c o m p o s
e !/) (i n v e r s e !/) lex compress!* apply errorml) 
3404595783190816155)
applyml


(c!:install 'product!-set2 '(product!-set2) 5753609067411079214)
product!-set2


(c!:install 'dip!-nc!-m!*p!-distleft '(dip!-nc!-m!*p!-distleft
dip!-nc!-ev!-prod dipsum) 14884225942062731859)
dip!-nc!-m!*p!-distleft


(c!:install 'vdplsortin '(vdplsortin vdplsortin1) 7299351269199537602)
vdplsortin


(c!:install 'validrule '(validrule validrule1) 2742724852769084751)
validrule


(c!:install 'preproc1 '(preproc1 !:rd!: !:dn!: !*sq procedure !*params!*
!*getdecs (real integer) deftype!* declare (subroutine function)
!*type!* setq (cond progn) (plus times difference quotient minus) (
!:cr!: !:crn!: !:gi!:) quotient (!~for for) (integer) fl2bf read!:num
normbf decimal2internal prepsq symtabput lastpair preprocdec
migrate!-setqs simp!*) 6528805567621417354)
preproc1


(c!:install 'basisvectorp '(basisvectorp basisvectorl!*) 
18044454894974143165)
basisvectorp


(c!:install 'new_edge '(new_edge new_edge_list mk_edge_name) 
17926538594436632476)
new_edge


(c!:install 'solvevars '(solvevars allbkern constant_exprp ordad) 
15451545184830350089)
solvevars


(c!:install 'rlval '(rlval !:rd!: !:bprec!: r2flbf ncoeffs times!:
plus!: inorm) 7083699386214399275)
rlval


(c!:install 'ra_i2ra '(ra_i2ra ra_i2ra0 ra_wrapper) 12117492331715179625
)
ra_i2ra



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u56.lsp"

Reading "$reduce/cslbuild/generated-c/u57.lsp"

% u57.lsp           Machine generated Lisp

(c!:install "u57" 37636 8344457 1915989)
nil


(c!:install 'gcdlist1 '(gcdlist1 reduction!-count lesspcdr vunion
vintersection vdelete sort mapcarcar setkorder reorder gcdlist3 gcdlist2
split!-wrt!-variables total!-degree!-in!-powers) 10504323934466736076)
gcdlist1


(c!:install 'preptaylor!*!* '(preptaylor!*!* convert!-taylor!*
preptaylor!*) 2636884274083186405)
preptaylor!*!*


(c!:install 'ev_2f '(ev_2f iequal to multf) 17482014940251731800)
ev_2f


(c!:install 'redpar '(redpar) 16185300438157177557)
redpar


(c!:install 'cr!:minusp '(cr!:minusp) 1518570810801810726)
cr!:minusp


(c!:install 'vdpenumerate '(vdpenumerate number pcount!* vdpsave
vdpgetprop vdpputprop) 11111691383406042490)
vdpenumerate


(c!:install 'listofvarnames '(listofvarnames
"invalid argument to listofvarnames" free listp rederr domain!*p) 
14668539973731296408)
listofvarnames


(c!:install 'p_eq_vertex '(p_eq_vertex) 7973572559622386248)
p_eq_vertex


(c!:install 'intargfn '(intargfn integer list algebraic convertmode
form1 reversip!*) 11697267623635908172)
intargfn


(c!:install 'fillin '(fillin fillin1) 10080940669004967705)
fillin


(c!:install 'compactf1 '(compactf1 intersection compactf11) 
6316266038581973281)
compactf1


(c!:install 'tensor_has_dummy_idx '(tensor_has_dummy_idx smember) 
3965533702827161558)
tensor_has_dummy_idx


(c!:install 'cdr_signsort '(cdr_signsort copy apply) 
13787353986175638556)
cdr_signsort


(c!:install 'x!*!*p!-w '(x!*!*p!-w to general!-difference!-mod!-p) 
5260913038693974719)
x!*!*p!-w


(c!:install 'uniquifyf '(uniquifyf uniquifyk) 3625876549047266440)
uniquifyf


(c!:install 'add!-to!-sorted!-tree '(add!-to!-sorted!-tree nreverse) 
16019473893027424821)
add!-to!-sorted!-tree


(c!:install 'getsetvarlis '(getsetvarlis "getsetvarlis" (setel setk)
setq nreverse errach) 10814118241406422205)
getsetvarlis


(c!:install 'gd_applyscheme '(gd_applyscheme a mkid gd_getscheme) 
3715577770368755209)
gd_applyscheme


(c!:install 'absodeg '(absodeg plus eval) 15211225628975707552)
absodeg


(c!:install 'depend!-l '(depend!-l simp depend!-sq) 11705703878846753641
)
depend!-l


(c!:install 'rl_print!*fof '(rl_print!*fof reval maprin) 
8948476633242711435)
rl_print!*fof


(c!:install 'cl_susimkatl '(cl_susimkatl true false and inctheo or
lastpair rl_susipost cl_cflip rl_negateat rl_susitf) 
12591663934806987540)
cl_susimkatl


(c!:install 'ev_compless!? '(ev_compless!? ev_comp iequal) 
12235098990192970880)
ev_compless!?


(c!:install 'appends '(appends) 4527622923441649088)
appends


(c!:install 'groebsaveltermbc '(groebsaveltermbc glterms vbc2a
constant_exprp simp fctrf prepf) 2234765308638356198)
groebsaveltermbc


(c!:install 'simpintersection '(simpintersection intersection empty_set
applysetop ordn mksp) 18333976700864013619)
simpintersection


(c!:install 'rand!-mons!-dense '(rand!-mons!-dense mksq max multf
lastpair) 4000640762977857342)
rand!-mons!-dense


(c!:install 'lispcondp '(lispcondp cond) 15172181409483727939)
lispcondp


(c!:install 'actual_world '(actual_world exclude_edges union_edges) 
17227129322063686337)
actual_world


(c!:install 'groeb!=testb '(groeb!=testb mo_comp nth mo_divides!?
bas_dpoly dp_lmon mo_lcm mo_equal!?) 9387346251175807984)
groeb!=testb


(c!:install 'nrootnn '(nrootnn !*primelist!* mcfactor!* iroot) 
5942300179902464672)
nrootnn


(c!:install 'ofsf_qesubq '(ofsf_qesubq ofsf_qesubqat cl_apply2ats1) 
3485473431444974310)
ofsf_qesubq


(c!:install 'makecoeffpairs1 '(makecoeffpairs1 ((nil)) tayexp!-minus
makecoeffpairshom lastpair) 1976336402385581849)
makecoeffpairs1


(c!:install 'ev_lcm '(ev_lcm) 17226768181776415381)
ev_lcm


(c!:install 'cd_ordatp '(cd_ordatp neq equal ordp) 7200805220082662935)
cd_ordatp


(c!:install 'unary '(unary "<apply>" "<" "/>" indent "</apply>" printout
expression) 17628353546270141862)
unary


(c!:install 'tidysqrtf '(tidysqrtf i (sqrt -1) sqrt mksp simp exptsq
multsq tidysqrt addsq) 3822664086723673521)
tidysqrtf


(c!:install 'dm!-quotient '(dm!-quotient !*noequiv dm!-mkfloat
!:quotient) 6686076476757985430)
dm!-quotient


(c!:install 'rm_neg_pow '(rm_neg_pow to multsq addsq) 
2919842033772231034)
rm_neg_pow


(c!:install 'mkuniquewedge1 '(mkuniquewedge1 wedgemtch!* wedge mkupf
wedgemtch partitop) 17022987313366560229)
mkuniquewedge1


(c!:install '!:dmexpt '(!:dmexpt !*complex !:dm2fix !:expt force!-to!-dm
crexpt!* rdexpt!*) 16196288233956649776)
!:dmexpt


(c!:install 'rep_parents '(rep_parents) 10604531587366957043)
rep_parents


(c!:install 'dp_prod '(dp_prod dp!=prod) 12661104930869960654)
dp_prod



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u57.lsp"

Reading "$reduce/cslbuild/generated-c/u58.lsp"

% u58.lsp           Machine generated Lisp

(c!:install "u58" 167482 1588833 6511275)
nil


(c!:install 'sc_repkern '(sc_repkern !* lambda_1x539vlzlwg93
pa_list2vect sort) 8973480175038941953)
sc_repkern


(c!:install 'lambda_1x539vlzlwg93 '(lambda_1x539vlzlwg93) 
17810050070257344241)
lambda_1x539vlzlwg93


(c!:install 'super_product_sq '(super_product_sq (ext) split_ext multsq
ext_mult addsq) 17325628299063995866)
super_product_sq


(c!:install 'setqdeletedescendants '(setqdeletedescendants
fluidbibasissetq) 7347142229758694898)
setqdeletedescendants


(c!:install 'ofsf_ordrelp '(ofsf_ordrelp (equal neq leq lessp geq
greaterp)) 677969609291168617)
ofsf_ordrelp


(c!:install 'yetunknowntypeeval '(yetunknowntypeeval
eval!-yetunknowntypeexpr reval1) 16888849423757944204)
yetunknowntypeeval


(c!:install 'let0 '(let0 frasc!* let00) 7391967956783306752)
let0


(c!:install 'get_rep_matrix_entry '(get_rep_matrix_entry
get_rep_matrix_in get!+mat!+entry) 5359477799238910142)
get_rep_matrix_entry


(c!:install 'mri_dettype '(mri_dettype int real mri_arg2l kernels
mri_realvarp) 12589705886688684344)
mri_dettype


(c!:install 'qqe_length!-graph!-remove!-mark '(
qqe_length!-graph!-remove!-mark) 377600596588172727)
qqe_length!-graph!-remove!-mark


(c!:install 'aex_fromsf '(aex_fromsf aex ctx_new) 6306651090152265251)
aex_fromsf


(c!:install 'ps!:expansion!-point '(ps!:expansion!-point !:ps!: ps!:getv
) 16036982018896120238)
ps!:expansion!-point


(c!:install 'nestprep!: '(nestprep!: co simp prepsq) 
13873545229761536726)
nestprep!:


(c!:install 'bfdivide '(bfdivide !:bprec!: divide!: normbf) 
8889576880326804828)
bfdivide


(c!:install 'calc_map_ '(calc_map_ quotient actual_alst calc_map_tar
reval calc_den_tar) 13813670919727514222)
calc_map_


(c!:install 'rappend '(rappend "append has TWO arguments" "list or bag"
rederr reval baglistp typerr) 15804337383496172293)
rappend


(c!:install 'formclear '(formclear clear formclear1) 
11707879931340615398)
formclear


(c!:install 'partsym_zerop '(partsym_zerop !- repeats) 
5809084812164251243)
partsym_zerop


(c!:install 'modroots2 '(modroots2 (-1 0 1) modroots4 modroots3) 
1868084021990693538)
modroots2


(c!:install 'r2flbf '(r2flbf !*bftag r2bf r2fl) 11486658120533823622)
r2flbf


(c!:install 'order_of_der '(order_of_der i2o_jetspace!*
i2o_jetspace_odd!*) 13228324747429960556)
order_of_der


(c!:install 'talp_gaussand '(talp_gaussand failed ignore
talp_trygaussvar) 16419365261122652967)
talp_gaussand


(c!:install 'rl_b2atl '(rl_b2atl rl_b2atl!* apply) 2138926909353740864)
rl_b2atl


(c!:install 'rat_0 '(rat_0) 1405448541570817653)
rat_0


(c!:install 'ldt!-dep '(ldt!-dep depl!* ldt!-tvar) 507311575391496787)
ldt!-dep


(c!:install 'pm!:gensym '(pm!:gensym !? !_ pm!:gensym!-count!*) 
2925043532280623506)
pm!:gensym


(c!:install 'groebsimpcontnormalform '(groebsimpcontnormalform
!*groebprot quotient gsugar vdpsimpcont gsetsugar vbc2a reval
groebreductionprotocol2) 17945831652982038263)
groebsimpcontnormalform


(c!:install '!:quotient '(!:quotient poly "Zero divisor" dmode!* times
quotient rerror !:recip dcombine) 846785812012007106)
!:quotient


(c!:install 'matcheq '(matcheq !*exp (plus difference) diff eval
matchlinear) 11712912479545871603)
matcheq


(c!:install 'tot!-asym!-indp '(tot!-asym!-indp indordp indxchk indordlp)
 16378113130650151290)
tot!-asym!-indp


(c!:install '!*s2arg '(!*s2arg quote nochange mkarg) 4918202841384322310
)
!*s2arg


(c!:install 'com43 '(com43 liemat bb ff algebraic l_z cc minus det
quotient plus times comcom0 comcom1 comcom3 matrix aeval arrayfn aeval!*
setk evalneq evalequal clear) 15034922302418064058)
com43


(c!:install 'affinep '(affinep belong_to_space get_sign_space) 
17023873794737433173)
affinep


(c!:install 'deg '(deg gdmode!* dmode!* simp!* tstpolyarg numrdeg) 
11030504842515431628)
deg


(c!:install 'odd_action '(odd_action !*a2k negsq component_action addsq)
 1775369681381575803)
odd_action


(c!:install 'ra_onep '(ra_onep ra_onep0 ra_wrapper) 8756972081977403643)
ra_onep


(c!:install 'aex_diff '(aex_diff aex_ex diffsq kernels aex_ctx
ctx_filter aex_mk) 4163020938676067037)
aex_diff


(c!:install 'lto_hentry '(lto_hentry) 8213524916477710154)
lto_hentry


(c!:install 'put!-avalue '(put!-avalue scalar !*sq !*reduce4 generic
avalue sq_member recursiveerror putobject smember) 6185992911340267878)
put!-avalue


(c!:install 'talp_prepat '(talp_prepat talp_op talp_arg2l talp_prepterm
talp_arg2r) 4257837775421311319)
talp_prepat



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u58.lsp"

Reading "$reduce/cslbuild/generated-c/u59.lsp"

% u59.lsp           Machine generated Lisp

(c!:install "u59" 131655 2833294 5332876)
nil


(c!:install 'pasf_premf1 '(pasf_premf1 minusf addf to exptf multf) 
14196132484071525895)
pasf_premf1


(c!:install 'search4facf '(search4facf tryfactorf) 7022717262781964485)
search4facf


(c!:install 'frlp '(frlp frlis!*) 8131105772210933591)
frlp


(c!:install 'xvarp '(xvarp xvars!* (wedge d partdf hodge innerprod liedf
) xdegree) 10414475765977978179)
xvarp


(c!:install 'kernelp '(kernelp) 8367153360350514607)
kernelp


(c!:install 'mo_deletecomp '(mo_deletecomp mo!=deglist) 
12018199225992509237)
mo_deletecomp


(c!:install 'algebnp '(algebnp !:ar!:) 14842853218592494742)
algebnp


(c!:install 'ratleqp '(ratleqp ratdif) 9146806343219559736)
ratleqp


(c!:install 'gcdk '(gcdk !*heugcd !*ezgcd modular!-multicheck !*mcd
dmode!* degr quotf1 heu!-gcd getd remk addlc prim!-part) 
1808524218234108726)
gcdk


(c!:install 'interglue '(interglue !\co!  !+ !- ord clo !\cdot! ) 
4372386679573287132)
interglue


(c!:install 'pasf_qff2ivl '(pasf_qff2ivl
"pasf_qff2ivl : uniform Presburger arithmetic formula in input"
pasf_uprap rederr pasf_dnf pasf_qff2ivl1) 8801269133230318599)
pasf_qff2ivl


(c!:install 'cfrmconstant '(cfrmconstant cfrmcrd!* freeoffl) 
6322864059352167629)
cfrmconstant


(c!:install 'cflot '(cflot bf2flr) 7804044446289640211)
cflot


(c!:install 'partitpartdf '(partitpartdf !*a2k mknatvec simppartdf0) 
14341146793199646748)
partitpartdf


(c!:install 'propagator '(propagator plus repeatsp permutations propag) 
10586453555647518637)
propagator


(c!:install 'invbase!* '(invbase!* thirdway!* shortway!* !*trinvbase
maxord!* path gg!* varlist!* bv!* "---------- ORDER = " " ----------"
alglist!* list plus gv!* invtempbasis "Maximum degree bound exceeded."
ng!* redall newbasis ord !*di2q prepsq rederr max ljet class nonmult
pdmult nf stat dim) 9973221616266214468)
invbase!*


(c!:install 'st_flatten '(st_flatten copy lastpair) 5319316849813223378)
st_flatten


(c!:install 'dependsp '(dependsp !*sq taylorvariable depends involvesq
taylorp) 6918631214116765078)
dependsp


(c!:install 'bf2rn1 '(bf2rn1 !:rd!: !:bprec!: minus!: lshift normbf
difbf divide!: abs!: bfzerop!: greaterp!: invbf) 2108707566568556354)
bf2rn1


(c!:install 'anu_mk '(anu_mk anu) 3254050022557752615)
anu_mk


(c!:install 'conjgd '(conjgd cmpxfn realtype !:minus multf addf) 
13020833553470071081)
conjgd


(c!:install 'mk_character '(mk_character get_group_in get!*elements
get_rep_matrix_in mk!+trace) 18096703642181927895)
mk_character


(c!:install 'rl_cput '(rl_cput) 7354026563348624443)
rl_cput


(c!:install 'acfsf_smmkatl '(acfsf_smmkatl acfsf_irl2atl) 
11923196781002189479)
acfsf_smmkatl


(c!:install 'vp1 '(vp1 "Var not in z-list after all" interr nreverse vp2
) 10060692868592383623)
vp1


(c!:install 'ps!:depvar '(ps!:depvar !:ps!: ps!:getv) 
8317194183459206185)
ps!:depvar


(c!:install 'numberofoccs '(numberofoccs) 16872300168531133303)
numberofoccs


(c!:install '!:mod!:units '(!:mod!:units current!-modulus) 
13487510028733908380)
!:mod!:units


(c!:install 'idealp '(idealp i list) 2769528687974037603)
idealp


(c!:install 'lexorder '(lexorder gv!* !*g2lex gcdout ljet insert) 
1576949871607660531)
lexorder


(c!:install 'pst_partition '(pst_partition lambda_sorneshiwvd12 pst_d
sort) 17217556705073099669)
pst_partition


(c!:install 'lambda_sorneshiwvd12 '(lambda_sorneshiwvd12 numlist_ordp) 
9272889440585894424)
lambda_sorneshiwvd12


(c!:install 'bibasis '(bibasis list "is not a polynomial list"
"polynomial list is empty" "is not a variable list"
"variable list is empty" lex deglex degrevlex
" is unsupported monomial ordering" fluidbibasisvariables
fluidbibasismonomialorder fluidbibasisrunningtime fluidbibasisgctime
!*sq mathprint rederr init reval simp polynomread
sortedpolynomlistinsert constructinvolutivebasis polynomwrite) 
17894068981020192354)
bibasis


(c!:install 'evalleq '(evalleq evalgreaterp) 6043315464523647766)
evalleq


(c!:install 'taysimpsq!* '(taysimpsq!* !*taylorautoexpand taysimpsq) 
2248755144385674747)
taysimpsq!*


(c!:install 'repr_atfnew '(repr_atfnew (cong ncong) pasf_coeflst minusf
pasf_anegrel multf repr_new) 6288618993290193868)
repr_atfnew


(c!:install 'ev_disjointp '(ev_disjointp) 3858179724726596528)
ev_disjointp


(c!:install 'exdfp0 '(exdfp0 subfg!* sfp exformp exdff0 exdfk to
multpfsq) 17662055604185616268)
exdfp0


(c!:install 'rand_functionp '(rand_functionp lambda getd) 
14753800750502375528)
rand_functionp


(c!:install 'partdff '(partdff !*product!-rule partdft multsq partdfpow
addsq) 12896297760294010173)
partdff


(c!:install 'find_triangl_coeff '(find_triangl_coeff find_triangle_coeff
) 8985799429492222322)
find_triangl_coeff



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u59.lsp"

Reading "$reduce/cslbuild/generated-c/u60.lsp"

% u60.lsp           Machine generated Lisp

(c!:install "u60" 22407 1213094 3477608)
nil


(c!:install 'lie4 '(lie4 l_f algebraic ordv cc minus plus times
"not a Lie algebra" quotient det mat !*tr_lie
"Your Lie algebra is commutative" only lie_class list liealg comtab
liemat com43 com41 com42 matrix aeval arrayfn setk aeval!* evalneq clear
rederr evalequal revalx boolvalue!* assgnpri) 1845459913678695374)
lie4


(c!:install 'make!-image!-lc!-list1 '(make!-image!-lc!-list1 varlist
polyzero !*d2n horner!-rule!-for!-one!-var) 17533059322250563800)
make!-image!-lc!-list1


(c!:install 'rdzchk '(rdzchk 0.0 !!fleps1 rd!-tolerance!* bfz!* abs!:
times!: lessp!:) 5246679473715637252)
rdzchk


(c!:install 'memlis '(memlis) 18427748568451626524)
memlis


(c!:install 'modular!-factor!-count '(modular!-factor!-count
poly!-vector null!-space!-basis known!-factors poly!-mod!-p dpoly
poly!-to!-vector count!-linear!-factors!-mod!-p use!-berlekamp) 
14804056382089455950)
modular!-factor!-count


(c!:install 'ofsf_chsimpat1 '(ofsf_chsimpat1 (lessp leq equal neq geq
greaterp) lastcar) 13648608397240875860)
ofsf_chsimpat1


(c!:install 'clearrules '(clearrules !*sqrtrulep rule!-list) 
11581933298131554450)
clearrules


(c!:install 'negdf '(negdf nreverse negsq) 10195938657571290765)
negdf


(c!:install 'get!*generators '(get!*generators generators) 
16180433573324945269)
get!*generators


(c!:install 'formopr '(formopr symbolic flag opfn operator mkarg) 
9957583606918413146)
formopr


(c!:install 'rnfloor!* '(rnfloor!*) 5445137748960396329)
rnfloor!*


(c!:install 'codfac '(codfac rowmin codmat maxvar times samefar
commonfac) 12553701744991344560)
codfac


(c!:install 'qsimpcomb_standard_qexp_part_sf '(
qsimpcomb_standard_qexp_part_sf expt times simp addsq) 
546438383342275915)
qsimpcomb_standard_qexp_part_sf


(c!:install 'xreorder '(xreorder xpartitop reordsq multpfsq addpf) 
280604788576102600)
xreorder


(c!:install 'exdfpf '(exdfpf exdf0 exdfk multpfsq wedgepf2 mkuniquewedge
addpf) 2490051800327718576)
exdfpf


(c!:install 'texaeval1 '(texaeval1 !*latex tex texaeval) 
13851481172056204705)
texaeval1


(c!:install 'getphystypestate '(getphystypestate state statep!*) 
5587074674463140564)
getphystypestate



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u60.lsp"

nil


(rdf "$srcdir/fastgets.lsp")
Reading "$srcdir/fastgets.lsp"
% fastgets.lsp generated by profiling      Copyright (C) Codemist 2016-2017


% /**************************************************************************
%  * Copyright (C) 2017, Codemist.                         A C Norman       *
%  *                                                                        *
%  * Redistribution and use in source and binary forms, with or without     *
%  * modification, are permitted provided that the following conditions are *
%  * met:                                                                   *
%  *                                                                        *
%  *     * Redistributions of source code must retain the relevant          *
%  *       copyright notice, this list of conditions and the following      *
%  *       disclaimer.                                                      *
%  *     * Redistributions in binary form must reproduce the above          *
%  *       copyright notice, this list of conditions and the following      *
%  *       disclaimer in the documentation and/or other materials provided  *
%  *       with the distribution.                                           *
%  *                                                                        *
%  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    *
%  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      *
%  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS      *
%  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE         *
%  * COPYRIGHT OWNERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,   *
%  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,   *
%  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS  *
%  * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND *
%  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR  *
%  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF     *
%  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
%  * DAMAGE.                                                                *
%  *************************************************************************/



% $Id $

(progn
   (symbol!-make!-fastget 'noncom 0)
   (symbol!-make!-fastget 'lose 1)
   (symbol!-make!-fastget 'rtype 2)
   (symbol!-make!-fastget 'field 3)
   (symbol!-make!-fastget 'avalue 4)
   (symbol!-make!-fastget 'convert 5)
   (symbol!-make!-fastget 'optional 6)
   (symbol!-make!-fastget 'class 7)
   (symbol!-make!-fastget 'dname 8)
   (symbol!-make!-fastget 'opmtch 9)
   (symbol!-make!-fastget 'idtype 10)
   (symbol!-make!-fastget 'switch!* 11)
   (symbol!-make!-fastget 'oldnam 12)
   (symbol!-make!-fastget 'binding 13)
%  (symbol!-make!-fastget 'noncom 14) must not duplicate!
   (symbol!-make!-fastget 'zerop 15)
   (symbol!-make!-fastget 'indexvar 16)
   (symbol!-make!-fastget 'share 17)
   (symbol!-make!-fastget 'phystype 18)
   (symbol!-make!-fastget 'rtypefn 19)
   (symbol!-make!-fastget 'rules 20)
   (symbol!-make!-fastget 'rl_external 21)
   (symbol!-make!-fastget 'simpfn 22)
   (symbol!-make!-fastget 'infix 23)
   (symbol!-make!-fastget 'klist 24)
   (symbol!-make!-fastget 'ifdegree 25)
   (symbol!-make!-fastget 'onep 26)
   (symbol!-make!-fastget 'units 27)
   (symbol!-make!-fastget 'newnam 28)
   (symbol!-make!-fastget 'fdegree 29)
   (symbol!-make!-fastget 'minusp 30)
   (symbol!-make!-fastget 'trace 31)
   (symbol!-make!-fastget 'dummy 32)
   (symbol!-make!-fastget 'intequivfn 33)
   (symbol!-make!-fastget 'i2d 34)
   (symbol!-make!-fastget 'nary 35)
   (symbol!-make!-fastget 'stat 36)
   (symbol!-make!-fastget 'prtch 37)
   (symbol!-make!-fastget 'fkernfn 38)
   (symbol!-make!-fastget 'remember 39)
   (symbol!-make!-fastget 'delchar 40)
   (symbol!-make!-fastget 'polyfn 41)
   (symbol!-make!-fastget 'number!-of!-args 42)
   (symbol!-make!-fastget 'symmetric 43)
   (symbol!-make!-fastget 'prepfn2 44)
   (symbol!-make!-fastget 'psopfn 45)
   (symbol!-make!-fastget 'rvalue 46)
   (symbol!-make!-fastget 'initl 47)
   (symbol!-make!-fastget 'modefn 48)
   (symbol!-make!-fastget 'alt 49)
   (symbol!-make!-fastget 'kvalue 50)
   (symbol!-make!-fastget 'switch 51)
   (symbol!-make!-fastget 'plus 52)
   (symbol!-make!-fastget 'tracing 53)
   (symbol!-make!-fastget 'times 54)
   (symbol!-make!-fastget 'delim 55)
   (symbol!-make!-fastget 'idvalfn 56)
   (symbol!-make!-fastget 'prifn 57)
   (symbol!-make!-fastget '!*decs!* 58)
   (symbol!-make!-fastget 'opfn 59)
   (symbol!-make!-fastget 'pprifn 60)
   (symbol!-make!-fastget 'spaced 61)
   (symbol!-make!-fastget 'full 62)
   )
nil


% end of fastgets.lsp

Finished reading "$srcdir/fastgets.lsp"

nil

(rdf "$srcdir/compat.lsp")
Reading "$srcdir/compat.lsp"
% compat.lsp                               Copyright (C) Codemist 2016-2017

% This file defines functions and variables needed to make REDUCE
% and the underlying CSL system compatible. it should
% be loaded as the first file whenever REDUCE services are required.



% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions
% are met:
%
%    * Redistributions of source code must retain the relevant
%      copyright notice, this list of conditions and the following
%      disclaimer.
%    * Redistributions in binary form must reproduce the above
%      copyright notice, this list of conditions and the following
%      disclaimer in the documentation and/or other materials provided
%      with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
% "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
% LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
% A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
% OWNERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
% SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
% LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
% DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
% THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
% (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
% OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
% 

% Some of my trickery when bootstrap-building Reduce can load this
% file multiple times. But it has calls to setpchar and assignments to
% variables (the one to !!fleps1 bit me!) that ought not to be done
% more than once. 

% $Id $

(cond
  ((not (globalp '!!fleps1)) (progn

%%!!! csl

(symbol!-make!-fastget 'noncom 0)  % built into the kernel
(symbol!-make!-fastget 'lose   1)
(setpchar "> ")

(flag '(raise lower echo comp plap pgwd pwrds savedef) 'switch)

(make!-special '!*echo)
(setq !*echo nil)
(make!-special '!*raise)
(setq !*raise nil)
(make!-special '!*lower)
(setq !*lower t)
(make!-special '!*savedef)
% I only nil out !*savedef if it is not already present because of
% some bootstrapping delicacies when this file is re-loaded.
(if (not (boundp '!*savedef)) (setq !*savedef nil))
(make!-special '!*comp)
(setq !*comp nil)
(make!-special '!*plap)
(setq !*plap nil)
(make!-special '!*pgwd)
(setq !*pgwd nil)
(make!-special '!*pwrds)
(setq !*pwrds t)

% Until the following lines have been executed the
% bitwise operations listed here will not work. However there would be
% a disaster if the env cell of a symbol was unilaterally changed at a later
% stage (eg if the function had been defined) so I need to arrange that I
% only do this once

(cond
   ((or (null (symbol!-env 'logand))
        (eq (symbol!-env 'logand) 'logand))
     (symbol!-set!-env 'logand 1)
     (symbol!-set!-env 'logxor 6)
     (symbol!-set!-env 'logor 7)
     (symbol!-set!-env 'logeqv 9)
     (symbol!-set!-env 'land 1)      % PSL names as well
     (symbol!-set!-env 'lxor 6)
     (symbol!-set!-env 'lor 7)
     (symbol!-set!-env 'leqv 9))
)

(make!-global '!!fleps1)

%%! predef [!fleps] \item [{\ttfamily !!fleps1}] \index{{\ttfamily "!fleps}} ~\newline
%% There is a function safe!-fp!-plus that performs floating point
%% arithmetic but guarantees never to raise an exception. This value was
%% at one stage related to when small values created there got truncated to zero,
%% but the current code does not use the Lisp variable at all and instead does
%% things based on the bitwise representation of the numbers.

(make!-global '!!plumax)
(make!-global '!!plumin)
(make!-global '!!timmax)
(make!-global '!!timmin)
% The following values for !!fleps etc appear to be what Reduce expects
% when using IEEE double-precision arithmetic.
(setq !!fleps1 5.6843418860808e-14)
(setq !!plumax 2.24711641857789e+307)
(setq !!plumin 4.4501477170144e-296)
(setq !!timmax 4.74037595405459e+153)
(setq !!timmin 2.1095373229726e-154)

(cond ((null (flagp 'printprompt 'lose))
       (de printprompt (u) nil)))

(make!-global 'program!*)
(make!-global 'ttype!*)
(make!-global 'eof!*)

(make!-global 'crbuf!*)

(make!-global 'blank)              % blank, space
(make!-global '!$eol!$)            % end-of-line, linefeed
(make!-global '!$ff!$)             % form-feed
(make!-global 'tab)                % (horizontal) tab
(make!-global 'carriage!-return)   % carriage return
(make!-global '!$eof!$)            % end-of-file
(make!-global 'esc!*)              % escape character

(make!-special '!*notailcall)
(make!-special '!*carcheckflag)

(make!-special '!*terminal!-io!*)
(make!-special '!*standard!-input!*)
(make!-special '!*standard!-output!*)
(make!-special '!*error!-output!*)
(make!-special '!*trace!-output!*)
(make!-special '!*debug!-io!*)
(make!-special '!*query!-io!*)

(setq !*notailcall nil)
(setq !*carcheckflag t)

(progn
% The "special-char" numeric codes here are all very odd and are of no
% relevance beyond the initial build stages of this Lisp. In particular they
% have little or no resemblance to any widely used character code schemes.
   (setq blank   (compress (list '!! (special!-char 0))))
%%! predef [blank] \item [{\ttfamily blank}] \index{{\ttfamily blank}} ~\newline
%% The value of this variable is an space or blank character. This
%% might otherwise be written as {\ttfamily "! "}.

   (setq !$eol!$ (compress (list '!! (special!-char 1))))
%%! predef [$eol$] \item [{\ttfamily !\$eol!\$}] \index{{\ttfamily "!\$eol"!\$}}~\newline
%% The value of this variable is an end-of-line character.

   (setq tab     (compress (list '!! (special!-char 3))))
%%! predef [tab] \item [{\ttfamily tab}] \index{{\ttfamily tab}} ~\newline
%% The value of this variable is a tab character.

   (setq !$ff!$     (compress (list '!! (special!-char 5))))
%%! predef [$ff$] \item [{\ttfamily !\$ff!\$}] \index{{\ttfamily !\$ff!\$}} ~\newline
%% The value of this variable is a form-feed character.

%%! predef [carriage-return] \item [{\ttfamily carriage!-return}] \index{{\ttfamily carriage"!-return}} ~\newline
%% The value of this variable is a carriage-return character that could arise
%% in DOS-format files.

   (setq carriage!-return  (compress (list '!! (special!-char 6))))
   (setq esc!*   (compress (list '!! (special!-char 9))))
%%! predef [esc*] \item [{\ttfamily esc!*}] \index{{\ttfamily esc"!*}} ~\newline
%% The value of this variable is the character ``escape''. As a non-printing
%% character use of this is to be viewed as delicate.

% End of file is #10ffff which is "not a character" and is the highest
% codepoint in Unicode,
   (setq !$eof!$ (intern (list2string '(244 143 191 191))))
%%! predef [$eof$] \item [{\ttfamily !\$eof!\$}] \index{{\ttfamily "!\$eof"!\$}} ~\newline
%% The value of this variable is a pseudo-character returned from various
%% read functions to signal end-of-file.

   nil)

(setq crbuf!* (list !$eol!$))    % may not be necessary

(make!-global '!*full!-oblist)

(setq !*full!-oblist nil)

)))
nil

nil

rplacw

expand

mapcar

maplist

mapcan

mapcon

mapc

map

+++ copy redefined

copy

sassoc

+++ rassoc redefined

rassoc

+++ lastcar redefined

lastcar

+++ open redefined

open

binopen

pipe!-open

+++ putd redefined

putd

putc

nil

deflist

global

fluid

keyword

unglobal

unfluid

unkeyword

nil

carcheck

mapobl

s!:make!-psetq!-vars

s!:make!-psetq!-bindings

s!:make!-psetq!-assignments

psetq

s!:do!-bindings

s!:do!-endtest

s!:do!-result

s!:do!-updates

s!:expand!-do

do

do!*

s!:expand!-dolist

dolist

s!:expand!-dotimes

dotimes

nil

newbig

Finished reading "$srcdir/compat.lsp"

nil

Reading "$srcdir/extras.lsp"

df

oem!-supervisor

break!-loop

nil

0

s!:stamp

dated!-name

hashtagged!-name

nil

+++ sort redefined

sort

stable!-sort

sortip

+++ stable!-sortip redefined

stable!-sortip

nil

nil

#H(0 0 61 [~ ~ ~ ~ ~ ~ ~ ~] [~ ~ ~ ~ ~ ~ ~ ~])

s!:prinl0

s!:prinl1

s!:prinl2

printl

printcl

princl

+++ prinl redefined

prinl

s!:format

format

nil

nil

t

t

5

nil

prettyprint

tprettyprint

superprintm

superprinm

nil

s!:top

s!:depth

s!:indenting

s!:blankcount

s!:blanklist

s!:setindenting

s!:setblankcount

s!:setblanklist

s!:newframe

s!:blankp

s!:prindent

s!:explodes

s!:prvector

s!:putblank

s!:endlist

s!:finishpending

s!:quotep

prog

1

1

1

1

1

1

2

2

2

2

2

4

s!:putch

s!:overflow

!(

![

!)

!]

fetch!-url

bldmsg_temp_internal

bldmsg

nil

Finished reading "$srcdir/extras.lsp"

nil

Reading "$srcdir/compiler.lsp"

nil

(loadloc loadloc0 loadloc1 loadloc2 loadloc3 loadloc4 loadloc5 loadloc6 loadloc7
loadloc8 loadloc9 loadloc10 loadloc11 loc0loc1 loc1loc2 loc2loc3 loc1loc0
loc2loc1 loc3loc2 vnil loadlit loadlit1 loadlit2 loadlit3 loadlit4 loadlit5
loadlit6 loadlit7 loadfree loadfree1 loadfree2 loadfree3 loadfree4 storeloc
storeloc0 storeloc1 storeloc2 storeloc3 storeloc4 storeloc5 storeloc6 storeloc7
storefree storefree1 storefree2 storefree3 loadlex storelex closure carloc0
carloc1 carloc2 carloc3 carloc4 carloc5 carloc6 carloc7 carloc8 carloc9 carloc10
carloc11 cdrloc0 cdrloc1 cdrloc2 cdrloc3 cdrloc4 cdrloc5 caarloc0 caarloc1
caarloc2 caarloc3 call0 call1 call2 call2r call3 call4 call0_0 call0_1 call0_2
call0_3 call1_0 call1_1 call1_2 call1_3 call1_4 call1_5 call2_0 call2_1 call2_2
call2_3 call2_4 builtin0 builtin1 builtin2 builtin2r builtin3 apply1 apply2
apply3 apply4 jcall spare66 jump jump_b jump_l jump_bl jumpnil jumpnil_b
jumpnil_l jumpnil_bl jumpt jumpt_b jumpt_l jumpt_bl jumpatom jumpatom_b
jumpatom_l jumpatom_bl jumpnatom jumpnatom_b jumpnatom_l jumpnatom_bl jumpeq
jumpeq_b jumpeq_l jumpeq_bl jumpne jumpne_b jumpne_l jumpne_bl jumpequal
jumpequal_b jumpequal_l jumpequal_bl jumpnequal jumpnequal_b jumpnequal_l
jumpnequal_bl jumpl0nil jumpl0t jumpl1nil jumpl1t jumpl2nil jumpl2t jumpl3nil
jumpl3t jumpl4nil jumpl4t jumpst0nil jumpst0t jumpst1nil jumpst1t jumpst2nil
jumpst2t jumpl0atom jumpl0natom jumpl1atom jumpl1natom jumpl2atom jumpl2natom
jumpl3atom jumpl3natom jumpfree1nil jumpfree1t jumpfree2nil jumpfree2t
jumpfree3nil jumpfree3t jumpfree4nil jumpfree4t jumpfreenil jumpfreet jumplit1eq
jumplit1ne jumplit2eq jumplit2ne jumplit3eq jumplit3ne jumplit4eq jumplit4ne
jumpliteq jumplitne jumpb1nil jumpb1t jumpb2nil jumpb2t jumpflagp jumpnflagp
jumpeqcar jumpneqcar catch catch_b catch_l catch_bl uncatch throw protect
unprotect pvbind pvrestore freebind freerstr exit nilexit loc0exit loc1exit
loc2exit push pushnil pushnil2 pushnil3 pushnils pop lose lose2 lose3 loses swop
eq eqcar equal numberp car cdr caar cadr cdar cddr cons ncons xcons acons length
list2 list2star list3 plus2 add1 difference sub1 times2 greaterp lessp flagp get
litget getv qgetv qgetvn bigstack bigcall icase fastget onevalue spare)

(256 opcodes allocated)

nil

nil

s!:vecof

s!:vecof1

nil

s!:prinhex1

s!:prinhex2

s!:prinhex4

nil

nil

nil

nil

nil

nil

nil

t

nil

nil

t

nil

s!:start_procedure

s!:set_label

s!:outjump

s!:outexit

nil

s!:outopcode0

s!:outopcode1

(loadlit loadfree call0 call1 litget jumpliteq jumplitne jumpliteq!* jumplitne!*
jumpfreet jumpfreenil)

s!:record_literal

s!:record_literal_for_jump

s!:outopcode1lit

s!:outopcode2

s!:outlexref

((1 . 7) . [!- loadlit1 loadlit2 loadlit3 loadlit4 loadlit5 loadlit6 loadlit7])

((1 . 4) . [!- loadfree1 loadfree2 loadfree3 loadfree4])

((1 . 3) . [!- storefree1 storefree2 storefree3])

((0 . 3) . [call0_0 call0_1 call0_2 call0_3])

((0 . 5) . [call1_0 call1_1 call1_2 call1_3 call1_4 call1_5])

((0 . 4) . [call2_0 call2_1 call2_2 call2_3 call2_4])

((1 . 4) . [!- jumpfree1t jumpfree2t jumpfree3t jumpfree4t])

((1 . 4) . [!- jumpfree1nil jumpfree2nil jumpfree3nil jumpfree4nil])

((1 . 4) . [!- jumplit1eq jumplit2eq jumplit3eq jumplit4eq])

((1 . 4) . [!- jumplit1ne jumplit2ne jumplit3ne jumplit4ne])

((1 . 4) . [!- jumplit1eq jumplit2eq jumplit3eq jumplit4eq])

((1 . 4) . [!- jumplit1ne jumplit2ne jumplit3ne jumplit4ne])

0

16

32

48

64

80

96

112

128

144

160

176

192

208

224

240

s!:literal_order

s!:resolve_literals

s!:only_loadlit

s!:too_many_literals

nil

s!:endprocedure

s!:add_pending

s!:invent_exit

s!:destination_label

s!:remlose

(0 . 0)

(0 . 1)

(0 . 2)

(0 . 3)

(1 . 0)

(1 . 1)

(1 . 2)

(1 . 3)

(1 . 4)

(1 . 5)

(2 . 0)

(2 . 1)

(2 . 2)

(2 . 3)

(2 . 4)

s!:remcall

s!:is_lose_and_exit

s!:try_tail_1

s!:try_tailcall

s!:tidy_exits_1

s!:tidy_exits

s!:tidy_flowgraph

(jumpnil jumpt jumpatom jumpnatom jumpeq jumpne jumpequal jumpnequal jumpl0nil
jumpl0t jumpl1nil jumpl1t jumpl2nil jumpl2t jumpl3nil jumpl3t jumpl4nil jumpl4t
jumpl0atom jumpl0natom jumpl1atom jumpl1natom jumpl2atom jumpl2natom jumpl3atom
jumpl3natom jumpst0nil jumpst0t jumpst1nil jumpst1t jumpst2nil jumpst2t
jumpfree1nil jumpfree1t jumpfree2nil jumpfree2t jumpfree3nil jumpfree3t
jumpfree4nil jumpfree4t jumpfreenil jumpfreet jumplit1eq jumplit1ne jumplit2eq
jumplit2ne jumplit3eq jumplit3ne jumplit4eq jumplit4ne jumpliteq jumplitne
jumpliteq!* jumplitne!* jumpb1nil jumpb1t jumpb2nil jumpb2t jumpflagp jumpnflagp
jumpeqcar jumpneqcar)

s!:negate_jump

s!:resolve_labels

s!:plant_basic_block

s!:plant_bytes

s!:plant_exit_code

(jumpl0nil jumpl0t jumpl1nil jumpl1t jumpl2nil jumpl2t jumpl3nil jumpl3t
jumpl4nil jumpl4t jumpl0atom jumpl0natom jumpl1atom jumpl1natom jumpl2atom
jumpl2natom jumpl3atom jumpl3natom jumpst0nil jumpst0t jumpst1nil jumpst1t
jumpst2nil jumpst2t jumpfree1nil jumpfree1t jumpfree2nil jumpfree2t jumpfree3nil
jumpfree3t jumpfree4nil jumpfree4t jumpfreenil jumpfreet jumplit1eq jumplit1ne
jumplit2eq jumplit2ne jumplit3eq jumplit3ne jumplit4eq jumplit4ne jumpliteq
jumplitne jumpliteq!* jumplitne!* jumpb1nil jumpb1t jumpb2nil jumpb2t jumpflagp
jumpnflagp jumpeqcar jumpneqcar)

nil

nil

nil

s!:expand_jump

s!:comval

s!:comspecform

nil

s!:improve

s!:imp_minus

s!:imp_minus

s!:imp_minus

s!:imp_1!+

s!:imp_1!+

s!:imp_1!-

s!:imp_1!-

s!:imp_times

s!:imp_times

s!:imp_itimes

s!:imp_itimes

s!:imp_difference

s!:imp_difference

s!:imp_idifference

s!:imp_idifference

s!:boolean_jumpable

s!:boolean_jumpable_list

nil

s!:imp_or

s!:imp_or

s!:imp_and

s!:imp_and

s!:alwayseasy

s!:alwayseasy

s!:alwayseasy

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easyifarg

s!:easygetv

s!:easygetv

s!:easygetv

s!:easyqgetv

s!:easyqgetv

s!:easyqgetv

s!:iseasy

s!:instate_local_decs

s!:residual_local_decs

s!:cancel_local_decs

s!:find_local_decs

s!:comlambda

s!:loadliteral

s!:comquote

s!:comquote

nil

s!:comval_m

s!:comflet

s!:comflet

s!:comlabels

s!:comlabels

s!:commacrolet

s!:commacrolet

s!:local_macro

s!:comfunction

s!:comfunction

s!:should_be_fluid

s!:find_lexical

nil

[loadloc0 loadloc1 loadloc2 loadloc3 loadloc4 loadloc5 loadloc6 loadloc7
loadloc8 loadloc9 loadloc10 loadloc11]

s!:comatom

nil

s!:islocal

s!:load2

nil

[carloc0 carloc1 carloc2 carloc3 carloc4 carloc5 carloc6 carloc7 carloc8 carloc9
carloc10 carloc11]

[cdrloc0 cdrloc1 cdrloc2 cdrloc3 cdrloc4 cdrloc5]

[caarloc0 caarloc1 caarloc2 caarloc3]

nil

nil

nil

nil

s!:comcall

s!:ad_name

s!:comcarcdr3

s!:comcarcdr3

s!:comcarcdr3

s!:comcarcdr3

s!:comcarcdr3

s!:comcarcdr3

s!:comcarcdr3

s!:comcarcdr3

s!:comcarcdr3

s!:comcarcdr4

s!:comcarcdr4

s!:comcarcdr4

s!:comcarcdr4

s!:comcarcdr4

s!:comcarcdr4

s!:comcarcdr4

s!:comcarcdr4

s!:comcarcdr4

s!:comcarcdr4

s!:comcarcdr4

s!:comcarcdr4

s!:comcarcdr4

s!:comcarcdr4

s!:comcarcdr4

s!:comcarcdr4

s!:comcarcdr4

s!:comgetv

s!:comgetv

s!:comqgetv

s!:comqgetv

s!:comget

s!:comget

s!:comflagp

s!:comflagp

s!:complus

s!:complus

s!:complus

s!:comtimes

s!:comtimes

s!:comtimes

s!:comiplus

s!:comiplus

s!:comitimes

s!:comitimes

s!:complus2

s!:complus2

s!:comdifference

s!:comdifference

s!:comiplus2

s!:comiplus2

s!:comidifference

s!:comidifference

s!:comtimes2

s!:comtimes2

s!:comtimes2

s!:comminus

s!:comminus

s!:comminusp

s!:comminusp

s!:comlessp

s!:comlessp

s!:comiminusp

s!:comiminusp

s!:comilessp

s!:comilessp

s!:comprogn

s!:comprogn

s!:comprog1

s!:comprog1

s!:comprog2

s!:comprog2

s!:outstack

s!:outlose

s!:comprog

s!:comprog

s!:comtagbody

s!:comtagbody

s!:comprogv

s!:comprogv

s!:comprog!*

s!:comprog!*

+++ s!:comprog redefined

s!:comprog

s!:comprog

s!:comblock

s!:comblock

s!:comcatch

s!:comcatch

s!:comthrow

s!:comthrow

s!:comunwind!-protect

s!:comunwind!-protect

s!:comdeclare

s!:comdeclare

s!:expand_let

s!:comlet

s!:comlet

s!:expand_let!*

s!:comlet!*

s!:comlet!*

s!:restore_stack

s!:comgo

s!:comgo

s!:comreturn!-from

s!:comreturn!-from

s!:comreturn

s!:comreturn

nil

[jumpl0t jumpl1t jumpl2t jumpl3t jumpl4t]

[jumpl0nil jumpl1nil jumpl2nil jumpl3nil jumpl4nil]

[jumpl0atom jumpl1atom jumpl2atom jumpl3atom]

[jumpl0natom jumpl1natom jumpl2natom jumpl3natom]

s!:jumpif

s!:testnot

s!:testnot

s!:testnot

s!:testatom

s!:testatom

s!:testconsp

s!:testconsp

s!:comcond

s!:comcond

s!:comif

s!:comif

s!:comwhen

s!:comwhen

s!:comunless

s!:comunless

s!:comicase

s!:comicase

181

182

s!:jumpliteql

s!:casebranch

s!:comcase

s!:comcase

nil

s!:comeval!-when

s!:comeval!-when

s!:comthe

s!:comthe

s!:comand

s!:comand

s!:comor

s!:comor

s!:combool

s!:combool

s!:combool

s!:testeq

s!:testeq1

s!:testeq

s!:testeq1

s!:testequal

s!:testequal

s!:testneq

s!:testneq

s!:testeqcar

s!:testeqcar

s!:testflagp

s!:testflagp

nil

[storeloc0 storeloc1 storeloc2 storeloc3 storeloc4 storeloc5 storeloc6 storeloc7
]

s!:comsetq

s!:comsetq

s!:comsetq

s!:comlist

s!:comlonglist

s!:comlist

s!:comlist!*

s!:comlist!*

s!:comcons

s!:comcons

s!:commv!-call

s!:commv!-call

s!:commv!-prog1

s!:commv!-prog1

s!:comapply

s!:comapply

s!:imp_funcall

s!:imp_funcall

s!:eval_to_eq_safe

s!:eval_to_eq_unsafe

s!:list_all_eq_safe

s!:eval_to_list_all_eq_safe

s!:list_some_eq_unsafe

s!:eval_to_list_some_eq_unsafe

s!:eval_to_car_eq_safe

s!:eval_to_car_eq_unsafe

s!:alist_eq_safe

s!:eval_to_alist_eq_safe

s!:alist_eq_unsafe

s!:eval_to_alist_eq_unsafe

nil

nil

s!:comequal

s!:comequal

s!:comeq

s!:comeq

s!:comeqcar

s!:comeqcar

s!:comsublis

s!:comsublis

s!:comsubla

s!:comsubla

s!:comassoc

s!:comassoc

s!:comassoc

s!:comatsoc

s!:comatsoc

s!:commember

s!:commember

s!:commember

s!:commemq

s!:commemq

s!:comdelete

s!:comdelete

s!:comdeleq

s!:comdeleq

s!:commap

s!:commap

s!:commap

s!:commap

s!:commap

s!:commap

s!:commap

s!:nilargs

s!:subargs

nil

clear_source_database

load_source_database

save_source_database

display_source_database

nil

s!:r2i

s!:r2i1

s!:r2iand

s!:r2ior

s!:r2icond

s!:r2iif

s!:r2iwhen

s!:r2iprogn

s!:r2icons

s!:r2icons2

s!:r2isteps

s!:r2i_safestep

s!:r2i_dependson

nil

nil

s!:r2i_list_dependson

s!:r2i2

s!:r2i2cond

s!:r2i2if

s!:r2i2when

s!:r2i2progn

s!:r2i3

s!:any_fluid

s!:compile1

s!:compile2

compile!-all

nil

nil

nil

s!:fasl_supervisor

nil

s!:fslout0

s!:fslout1

s!:fslout2

nil

faslend

endstat

s!:file

s!:trim!.c

s!:dir

faslout

rlis

s!:c_supervisor

s!:cout0

s!:cout1

nil

c_end

endstat

c_out

rlis

s!:compile!-file!*

compile!-file!*

compd

s!:compile0

s!:fully_macroexpand_list

s!:fully_macroexpand

s!:expandfunction

s!:expandflet

s!:expandfletvars

s!:expandlabels

s!:expandmacrolet

s!:expandprog

s!:expandtagbody

s!:expandprogv

s!:expandblock

s!:expanddeclare

s!:expandlet

s!:expandlet!*

s!:expandgo

s!:expandreturn!-from

s!:expandcond

s!:expandcase

s!:expandeval!-when

s!:expandthe

s!:expandmv!-call

s!:expandfunction

s!:expandflet

s!:expandlabels

s!:expandmacrolet

s!:expandprog

s!:expandtagbody

s!:expandprogv

s!:expandblock

s!:expanddeclare

s!:expandlet

s!:expandlet!*

s!:expandgo

s!:expandreturn!-from

s!:expandcond

s!:expandcase

s!:expandeval!-when

s!:expandthe

s!:expandmv!-call

compile

nil

nil

nil

nil

nil

c!:printf

nil

c!:printf1

c!:safeprin

c!:valid_fndef

c!:valid_list

c!:valid_expr

c!:cspecform

c!:valid_specform

c!:valid_specform

nil

nil

nil

c!:alphanumeric

c!:reset_gensyms

nil

0

c!:my_gensym

c!:newreg

c!:startblock

c!:outop

c!:endblock

c!:cval_inner

c!:cval

nil

c!:start_nested_context

c!:end_nested_context

c!:clambda

c!:locally_bound

nil

nil

c!:find_literal

c!:catom

c!:cjumpif

nil

c!:ccall

nil

c!:has_calls

c!:has_calls_1

c!:can_reach

c!:any_can_reach

c!:evalargs

c!:ccall1

nil

c!:local_fluidp1

c!:local_fluidp

nil

c!:cfndef

nil

nil

nil

c!:ccompilesupervisor

nil

((!  . !A) (!! . !B) (!# . !C) (!$ . !D) (!% . !E) (!^ . !F) (!& . !G) (!* . !H)
(!( . !I) (!) . !J) (!- . !K) (!+ . !L) (!= . !M) (!\ . !N) (!| . !O) (!, . !P)
(!. . !Q) (!< . !R) (!> . !S) (!: . !T) (!; . !U) (!/ . !V) (!? . !W) (!~ . !X)
(!` . !Y))

nil

c!:inv_name

nil

c!:ccmpout1

c!:ccmpout1a

nil

c!:concat

c!:ccompilestart

c!-end

c!-end1

endstat

c!-compile

rlis

c!:print_opcode

c!:print_exit_condition1

c!:flag_exit_label

c!:pmovr

c!:pmovr

c!:pmovk

c!:pmovk

c!:pmovk1

c!:pmovk1

nil

c!:preloadenv

c!:preloadenv

c!:pldrglob

c!:pldrglob

c!:pstrglob

c!:pstrglob

c!:pnilglob

c!:pnilglob

nil

c!:pnull

c!:pnull

c!:pnull

nil

c!:pfastget

c!:pfastget

nil

c!:pfastflag

c!:pfastflag

nil

c!:pcar

c!:pcar

c!:pcdr

c!:pcdr

c!:pqcar

c!:pqcar

c!:pqcdr

c!:pqcdr

c!:patom

c!:patom

nil

c!:pnumberp

c!:pnumberp

nil

c!:pfixp

c!:pfixp

nil

c!:piminusp

c!:piminusp

nil

c!:pilessp

c!:pilessp

nil

c!:pigreaterp

c!:pigreaterp

nil

c!:piminus

c!:piminus

c!:piadd1

c!:piadd1

c!:pisub1

c!:pisub1

c!:piplus2

c!:piplus2

c!:pidifference

c!:pidifference

c!:pitimes2

c!:pitimes2

c!:pmodular_plus

c!:pmodular_plus

c!:pmodular_difference

c!:pmodular_difference

c!:pmodular_minus

c!:pmodular_minus

c!:passoc

c!:passoc

nil

c!:patsoc

c!:patsoc

nil

c!:pmember

c!:pmember

nil

c!:pmemq

c!:pmemq

nil

c!:pget

nil

c!:pget

c!:pqgetv

c!:pqgetv

c!:pqputv

c!:pqputv

c!:prplaca

c!:prplaca

c!:prplacd

c!:prplacd

c!:peq

c!:peq

nil

c!:pequal

c!:pequal

nil

nil

c!:pcall

c!:pcall

c!:pfluidbind

c!:pfluidbind

c!:pfluidunbind

c!:pfluidunbind

c!:pgoto

c!:pifnull

c!:pifnull

c!:pifatom

c!:pifatom

c!:pifsymbol

c!:pifsymbol

c!:pifnumber

c!:pifnumber

c!:pifizerop

c!:pifizerop

c!:pifeq

c!:pifeq

c!:pifequal

c!:pifequal

c!:pifilessp

c!:pifilessp

c!:pifigreaterp

c!:pifigreaterp

c!:display_flowgraph1

nil

c!:one_operand

c!:two_operands

nil

nil

nil

nil

nil

nil

nil

nil

c!:live_variable_analysis

c!:insert1

c!:clash

c!:build_clash_matrix

c!:allocate_registers

c!:remove_nops

c!:assign

c!:insert_tailcall

c!:does_return

c!:pushpop

showblock

showblocklist

c!:flatten

c!:optimise_flowgraph

c!:cand

c!:cand

c!:ccatch

c!:ccatch

c!:ccompile_let

c!:ccompiler_let

c!:ccond

c!:ccond

c!:valid_cond

c!:valid_cond

c!:cdeclare

c!:cdeclare

c!:cde

c!:cde

c!:cdefun

c!:cdefun

c!:ceval_when

c!:ceval_when

c!:cflet

c!:cflet

c!:cfunction

c!:valid_function

c!:cfunction

c!:valid_function

c!:cgo

c!:cgo

c!:valid_quote

c!:cif

c!:cif

c!:clabels

c!:clabels

c!:expand!-let

c!:clet

c!:valid_let

c!:clet

c!:valid_let

c!:expand!-let!*

c!:clet!*

c!:clet!*

c!:valid_let

c!:clist

c!:clist

c!:clist!*

c!:clist!*

c!:ccons

c!:ccons

c!:cget

c!:cget

c!:cflag

c!:cflag

c!:cgetv

c!:cgetv

c!:cputv

c!:cputv

c!:cqputv

c!:cqputv

c!:cmacrolet

c!:cmacrolet

c!:cmultiple_value_call

c!:cmultiple_value_call

c!:cmultiple_value_prog1

c!:cmultiple_value_prog1

c!:cor

c!:cor

c!:cprog

c!:cprog

c!:cprog

c!:valid_prog

c!:valid_prog

c!:valid_prog

c!:cprog!*

c!:cprog!*

c!:cprog1

c!:cprog1

c!:cprog2

c!:cprog2

c!:cprogn

c!:cprogn

c!:cprogv

c!:cprogv

c!:cquote

c!:valid_quote

c!:cquote

c!:valid_quote

c!:creturn

c!:creturn

c!:creturn_from

c!:csetq

c!:csetq

c!:csetq

c!:cprivate_tagbody

c!:cprivate_tagbody

c!:cthe

c!:cthe

c!:cthrow

c!:cthrow

c!:cunless

c!:cunless

c!:cunwind_protect

c!:cunwind_protect

c!:cwhen

c!:cwhen

c!:expand_map

c!:expand_map

c!:expand_map

c!:expand_map

c!:expand_map

c!:expand_map

c!:expand_map

c!:expand_carcdr

c!:expand_carcdr

c!:builtin_one

c!:builtin_two

c!:rplac

c!:rplac

c!:rplac

c!:narg

nil

c!:cplus2

c!:cplus2

c!:ciplus2

c!:ciplus2

c!:cdifference

c!:cdifference

c!:cidifference

c!:cidifference

c!:ctimes2

c!:ctimes2

c!:citimes2

c!:citimes2

c!:cminus

c!:cminus

c!:ceq

c!:ceq

c!:cequal

c!:cequal

c!:is_fixnum

c!:certainlyatom

c!:atomlist1

c!:atomlist

c!:atomcar

c!:atomkeys1

c!:atomkeys

c!:comsublis

c!:comsublis

c!:comassoc

c!:comassoc

c!:comassoc

c!:commember

c!:commember

c!:comdelete

c!:comdelete

c!:ctestif

c!:ctestif

c!:ctestnull

c!:ctestnull

c!:ctestnull

c!:ctestatom

c!:ctestatom

c!:ctestconsp

c!:ctestconsp

c!:ctestsymbol

c!:ctestsymbol

c!:ctestnumberp

c!:ctestnumberp

c!:ctestizerop

c!:ctestizerop

c!:ctesteq

c!:ctesteq

c!:ctesteqcar

c!:ctesteqcar

nil

-134217728

134217727

c!:small_number

c!:eqvalid

nil

c!:ctestequal

c!:ctestequal

c!:ctestneq

c!:ctestneq

c!:ctestilessp

c!:ctestilessp

c!:ctestigreaterp

c!:ctestigreaterp

c!:ctestand

c!:ctestand

c!:ctestor

c!:ctestor

nil

nil

nil

nil

nil

Finished reading "$srcdir/compiler.lsp"

nil

nil

nil

nil

### !*nocompile = nil

nil

t
+++ s!:improve compiled, 23 + 16 bytes
+++ s!:literal_order compiled, 17 + 8 bytes
+++ s!:comval compiled, 134 + 52 bytes
+++ s!:outopcode0 compiled, 29 + 36 bytes
+++ s!:plant_basic_block compiled, 134 + 64 bytes
+++ s!:remlose compiled, 60 + 36 bytes
+++ s!:islocal compiled, 37 + 20 bytes
+++ s!:is_lose_and_exit compiled, 53 + 24 bytes
+++ s!:comatom compiled, 205 + 136 bytes
+++ s!:destination_label compiled, 49 + 20 bytes
+++ s!:record_literal compiled, 50 + 36 bytes
+++ s!:resolve_labels compiled, 125 + 36 bytes
+++ s!:expand_jump compiled, 238 + 100 bytes
+++ s!:outopcode1lit compiled, 36 + 44 bytes
+++ stable!-sortip compiled, 133 + 8 bytes
+++ s!:iseasy compiled, 18 + 16 bytes
+++ s!:outjump compiled, 85 + 52 bytes
+++ s!:add_pending compiled, 34 + 16 bytes
+++ s!:comcall compiled, 670 + 284 bytes
+++ s!:resolve_literals compiled, 263 + 64 bytes
Compile: unkeyword
+++ unkeyword compiled, 9 + 12 bytes
Compile: unglobal
+++ unglobal compiled, 10 + 8 bytes
Compile: unfluid
+++ unfluid compiled, 10 + 8 bytes
Compile: tprettyprint
+++ tprettyprint compiled, 11 + 16 bytes
Compile: superprintm
+++ superprintm compiled, 15 + 20 bytes
Compile: superprinm
+++ superprinm compiled, 156 + 104 bytes
Compile: stable!-sort
+++ stable!-sort compiled, 7 + 12 bytes
Compile: sortip
+++ sortip compiled as link to stable-sortip
Compile: sort
+++ sort compiled, 7 + 12 bytes
Compile: showblocklist
+++ showblocklist compiled, 16 + 12 bytes
Compile: showblock
+++ showblock compiled, 49 + 36 bytes
Compile: save_source_database
+++ save_source_database compiled, 48 + 32 bytes
Compile: sassoc
+++ sassoc compiled, 16 + 8 bytes
Compile: s!:vecof1
+++ s!:vecof1 compiled, 35 + 12 bytes
Compile: s!:vecof
+++ s!:vecof compiled, 20 + 16 bytes
Compile: s!:try_tailcall
+++ s!:try_tailcall compiled, 23 + 12 bytes
Compile: s!:try_tail_1
+++ s!:try_tail_1 compiled, 162 + 80 bytes
Compile: s!:trim!.c
+++ s!:trim!.c compiled, 22 + 20 bytes
Compile: s!:too_many_literals
+++ s!:too_many_literals compiled, 215 + 60 bytes
Compile: s!:tidy_flowgraph
+++ s!:tidy_flowgraph compiled, 340 + 48 bytes
Compile: s!:tidy_exits_1
+++ s!:tidy_exits_1 compiled, 126 + 56 bytes
Compile: s!:tidy_exits
+++ s!:tidy_exits compiled, 23 + 12 bytes
Compile: s!:testnot
+++ s!:testnot compiled, 16 + 16 bytes
Compile: s!:testneq
+++ s!:testneq compiled, 17 + 20 bytes
Compile: s!:testflagp
+++ s!:testflagp compiled, 96 + 88 bytes
Compile: s!:testequal
+++ s!:testequal compiled, 124 + 52 bytes
Compile: s!:testeqcar
+++ s!:testeqcar compiled, 161 + 116 bytes
Compile: s!:testeq1
+++ s!:testeq1 compiled, 150 + 60 bytes
Compile: s!:testeq
+++ s!:testeq compiled, 202 + 92 bytes
Compile: s!:testconsp
+++ s!:testconsp compiled, 41 + 44 bytes
Compile: s!:testatom
+++ s!:testatom compiled, 41 + 44 bytes
Compile: s!:subargs
+++ s!:subargs compiled, 20 + 16 bytes
Compile: s!:start_procedure
+++ s!:start_procedure compiled, 59 + 64 bytes
Compile: s!:stamp
+++ s!:stamp compiled, 43 + 32 bytes
Compile: s!:should_be_fluid
+++ s!:should_be_fluid compiled, 40 + 40 bytes
Compile: s!:set_label
+++ s!:set_label compiled, 53 + 40 bytes
Compile: s!:restore_stack
+++ s!:restore_stack compiled, 151 + 96 bytes
Compile: s!:residual_local_decs
+++ s!:residual_local_decs compiled, 54 + 24 bytes
Compile: s!:remcall
+++ s!:remcall compiled, 180 + 88 bytes
Compile: s!:record_literal_for_jump
+++ s!:record_literal_for_jump compiled, 53 + 36 bytes
Compile: s!:r2iwhen
+++ s!:r2iwhen compiled, 20 + 12 bytes
Compile: s!:r2isteps
+++ s!:r2isteps compiled, 108 + 40 bytes
Compile: s!:r2iprogn
+++ s!:r2iprogn compiled, 33 + 12 bytes
Compile: s!:r2ior
+++ s!:r2ior compiled, 32 + 12 bytes
Compile: s!:r2iif
+++ s!:r2iif compiled, 62 + 12 bytes
Compile: s!:r2icons2
+++ s!:r2icons2 compiled, 93 + 44 bytes
Compile: s!:r2icons
+++ s!:r2icons compiled, 99 + 56 bytes
Compile: s!:r2icond
+++ s!:r2icond compiled, 121 + 32 bytes
Compile: s!:r2iand
+++ s!:r2iand compiled, 22 + 16 bytes
Compile: s!:r2i_safestep
+++ s!:r2i_safestep compiled, 18 + 16 bytes
Compile: s!:r2i_list_dependson
+++ s!:r2i_list_dependson compiled, 14 + 16 bytes
Compile: s!:r2i_dependson
+++ s!:r2i_dependson compiled, 53 + 36 bytes
Compile: s!:r2i3
+++ s!:r2i3 compiled, 340 + 84 bytes
Compile: s!:r2i2when
+++ s!:r2i2when compiled, 20 + 12 bytes
Compile: s!:r2i2progn
+++ s!:r2i2progn compiled, 33 + 12 bytes
Compile: s!:r2i2if
+++ s!:r2i2if compiled, 62 + 12 bytes
Compile: s!:r2i2cond
+++ s!:r2i2cond compiled, 109 + 28 bytes
Compile: s!:r2i2
+++ s!:r2i2 compiled, 166 + 76 bytes
Compile: s!:r2i1
+++ s!:r2i1 compiled, 203 + 96 bytes
Compile: s!:r2i
+++ s!:r2i compiled, 93 + 48 bytes
Compile: s!:quotep
+++ s!:quotep compiled, 20 + 16 bytes
Compile: s!:putch
+++ s!:putch compiled, 67 + 56 bytes
Compile: s!:putblank
+++ s!:putblank compiled, 35 + 24 bytes
Compile: s!:prvector
+++ s!:prvector compiled, 80 + 52 bytes
Compile: s!:prinl2
+++ s!:prinl2 compiled, 331 + 96 bytes
Compile: s!:prinl1
+++ s!:prinl1 compiled, 128 + 48 bytes
Compile: s!:prinl0
+++ s!:prinl0 compiled, 37 + 44 bytes
Compile: s!:prinhex4
+++ s!:prinhex4 compiled, 9 + 20 bytes
Compile: s!:prinhex2
+++ s!:prinhex2 compiled, 9 + 20 bytes
Compile: s!:prinhex1
+++ s!:prinhex1 compiled, 11 + 20 bytes
Compile: s!:prindent
+++ s!:prindent compiled, 343 + 148 bytes
Compile: s!:plant_exit_code
+++ s!:plant_exit_code compiled, 161 + 52 bytes
Compile: s!:plant_bytes
+++ s!:plant_bytes compiled, 156 + 68 bytes
Compile: s!:overflow
+++ s!:overflow compiled, 313 + 124 bytes
Compile: s!:outstack
+++ s!:outstack compiled, 136 + 68 bytes
Compile: s!:outopcode2
+++ s!:outopcode2 compiled, 40 + 40 bytes
Compile: s!:outopcode1
+++ s!:outopcode1 compiled, 34 + 40 bytes
Compile: s!:outlose
+++ s!:outlose compiled, 136 + 68 bytes
Compile: s!:outlexref
+++ s!:outlexref compiled, 145 + 92 bytes
Compile: s!:outexit
+++ s!:outexit compiled, 48 + 36 bytes
Compile: s!:only_loadlit
+++ s!:only_loadlit compiled, 18 + 16 bytes
Compile: s!:nilargs
+++ s!:nilargs compiled, 16 + 20 bytes
Compile: s!:negate_jump
+++ s!:negate_jump compiled, 15 + 12 bytes
Compile: s!:make!-psetq!-vars
+++ s!:make!-psetq!-vars compiled, 26 + 24 bytes
Compile: s!:make!-psetq!-bindings
+++ s!:make!-psetq!-bindings compiled, 20 + 12 bytes
Compile: s!:make!-psetq!-assignments
+++ s!:make!-psetq!-assignments compiled, 21 + 16 bytes
Compile: s!:local_macro
+++ s!:local_macro compiled, 33 + 24 bytes
Compile: s!:loadliteral
+++ s!:loadliteral compiled, 27 + 36 bytes
Compile: s!:load2
+++ s!:load2 compiled, 238 + 100 bytes
Compile: s!:list_some_eq_unsafe
+++ s!:list_some_eq_unsafe compiled, 12 + 12 bytes
Compile: s!:list_all_eq_safe
+++ s!:list_all_eq_safe compiled, 17 + 16 bytes
Compile: s!:jumpliteql
+++ s!:jumpliteql compiled, 55 + 72 bytes
Compile: s!:jumpif
+++ s!:jumpif compiled, 338 + 156 bytes
Compile: s!:invent_exit
+++ s!:invent_exit compiled, 36 + 16 bytes
Compile: s!:instate_local_decs
+++ s!:instate_local_decs compiled, 42 + 20 bytes
Compile: s!:imp_times
+++ s!:imp_times compiled, 77 + 32 bytes
Compile: s!:imp_or
+++ s!:imp_or compiled, 50 + 28 bytes
Compile: s!:imp_minus
+++ s!:imp_minus compiled, 53 + 28 bytes
Compile: s!:imp_itimes
+++ s!:imp_itimes compiled, 77 + 32 bytes
Compile: s!:imp_idifference
+++ s!:imp_idifference compiled, 26 + 24 bytes
Compile: s!:imp_funcall
+++ s!:imp_funcall compiled, 67 + 60 bytes
Compile: s!:imp_difference
+++ s!:imp_difference compiled, 26 + 24 bytes
Compile: s!:imp_and
+++ s!:imp_and compiled, 49 + 28 bytes
Compile: s!:imp_1!-
+++ s!:imp_1!- compiled, 5 + 16 bytes
Compile: s!:imp_1!+
+++ s!:imp_1!+ compiled, 5 + 16 bytes
Compile: s!:fully_macroexpand_list
+++ s!:fully_macroexpand_list compiled, 25 + 12 bytes
Compile: s!:fully_macroexpand
+++ s!:fully_macroexpand compiled, 65 + 28 bytes
Compile: s!:fslout2
+++ s!:fslout2 compiled, 58 + 36 bytes
Compile: s!:fslout1
+++ s!:fslout1 compiled, 647 + 236 bytes
Compile: s!:fslout0
+++ s!:fslout0 compiled, 4 + 12 bytes
Compile: s!:format
+++ s!:format compiled, 227 + 48 bytes
Compile: s!:finishpending
+++ s!:finishpending compiled, 50 + 28 bytes
Compile: s!:find_local_decs
+++ s!:find_local_decs compiled, 61 + 16 bytes
Compile: s!:find_lexical
+++ s!:find_lexical compiled, 38 + 12 bytes
Compile: s!:file
+++ s!:file compiled, 29 + 20 bytes
Compile: s!:fasl_supervisor
+++ s!:fasl_supervisor compiled, 106 + 64 bytes
Compile: s!:explodes
+++ s!:explodes compiled as link to explode
Compile: s!:expandthe
+++ s!:expandthe compiled, 12 + 12 bytes
Compile: s!:expandtagbody
+++ s!:expandtagbody compiled as link to s:fully_macroexpand_list
Compile: s!:expandreturn!-from
+++ s!:expandreturn!-from compiled, 12 + 12 bytes
Compile: s!:expandprogv
+++ s!:expandprogv compiled, 19 + 12 bytes
Compile: s!:expandprog
+++ s!:expandprog compiled, 12 + 12 bytes
Compile: s!:expandmv!-call
+++ s!:expandmv!-call compiled, 12 + 12 bytes
Compile: s!:expandmacrolet
+++ s!:expandmacrolet compiled as link to s:expandflet
Compile: s!:expandlet!*
+++ s!:expandlet!* compiled as link to s:expandlet
Compile: s!:expandlet
+++ s!:expandlet compiled, 33 + 12 bytes
Compile: s!:expandlabels
+++ s!:expandlabels compiled as link to s:expandflet
Compile: s!:expandgo
+++ s!:expandgo compiled, 1 + 8 bytes
Compile: s!:expandfunction
+++ s!:expandfunction compiled, 1 + 8 bytes
Compile: s!:expandfletvars
+++ s!:expandfletvars compiled, 12 + 12 bytes
Compile: s!:expandflet
+++ s!:expandflet compiled, 33 + 16 bytes
Compile: s!:expandeval!-when
+++ s!:expandeval!-when compiled, 12 + 12 bytes
Compile: s!:expanddeclare
+++ s!:expanddeclare compiled, 1 + 8 bytes
Compile: s!:expandcond
+++ s!:expandcond compiled, 28 + 12 bytes
Compile: s!:expandcase
+++ s!:expandcase compiled, 36 + 16 bytes
Compile: s!:expandblock
+++ s!:expandblock compiled, 12 + 12 bytes
Compile: s!:expand_let!*
+++ s!:expand_let!* compiled, 108 + 24 bytes
Compile: s!:expand_let
+++ s!:expand_let compiled, 59 + 12 bytes
Compile: s!:expand!-dotimes
+++ s!:expand!-dotimes compiled, 118 + 52 bytes
Compile: s!:expand!-dolist
+++ s!:expand!-dolist compiled, 111 + 48 bytes
Compile: s!:expand!-do
+++ s!:expand!-do compiled, 142 + 48 bytes
Compile: s!:eval_to_list_some_eq_unsafe
+++ s!:eval_to_list_some_eq_unsafe compiled, 45 + 28 bytes
Compile: s!:eval_to_list_all_eq_safe
+++ s!:eval_to_list_all_eq_safe compiled, 56 + 32 bytes
Compile: s!:eval_to_eq_unsafe
+++ s!:eval_to_eq_unsafe compiled, 49 + 28 bytes
Compile: s!:eval_to_eq_safe
+++ s!:eval_to_eq_safe compiled, 44 + 20 bytes
Compile: s!:eval_to_car_eq_unsafe
+++ s!:eval_to_car_eq_unsafe compiled, 19 + 20 bytes
Compile: s!:eval_to_car_eq_safe
+++ s!:eval_to_car_eq_safe compiled, 19 + 20 bytes
Compile: s!:eval_to_alist_eq_unsafe
+++ s!:eval_to_alist_eq_unsafe compiled, 45 + 32 bytes
Compile: s!:eval_to_alist_eq_safe
+++ s!:eval_to_alist_eq_safe compiled, 56 + 32 bytes
Compile: s!:endprocedure
+++ s!:endprocedure compiled, 228 + 112 bytes
Compile: s!:endlist
+++ s!:endlist compiled, 5 + 12 bytes
Compile: s!:easyqgetv
+++ s!:easyqgetv compiled, 22 + 20 bytes
Compile: s!:easyifarg
+++ s!:easyifarg compiled, 15 + 16 bytes
Compile: s!:easygetv
+++ s!:easygetv compiled, 25 + 24 bytes
Compile: s!:do!-updates
+++ s!:do!-updates compiled, 25 + 8 bytes
Compile: s!:do!-result
+++ s!:do!-result compiled, 5 + 8 bytes
Compile: s!:do!-endtest
+++ s!:do!-endtest compiled, 5 + 8 bytes
Compile: s!:do!-bindings
+++ s!:do!-bindings compiled, 42 + 12 bytes
Compile: s!:dir
+++ s!:dir compiled, 34 + 24 bytes
Compile: s!:cout1
+++ s!:cout1 compiled, 436 + 172 bytes
Compile: s!:cout0
+++ s!:cout0 compiled, 4 + 12 bytes
Compile: s!:comwhen
+++ s!:comwhen compiled, 44 + 44 bytes
Compile: s!:comval_m
+++ s!:comval_m compiled, 16 + 20 bytes
Compile: s!:comunwind!-protect
+++ s!:comunwind!-protect compiled, 72 + 68 bytes
Compile: s!:comunless
+++ s!:comunless compiled, 13 + 20 bytes
Compile: s!:comtimes2
+++ s!:comtimes2 compiled, 76 + 32 bytes
Compile: s!:comtimes
+++ s!:comtimes compiled, 8 + 20 bytes
Compile: s!:comthrow
+++ s!:comthrow compiled, 50 + 48 bytes
Compile: s!:comthe
+++ s!:comthe compiled, 6 + 12 bytes
Compile: s!:comtagbody
+++ s!:comtagbody compiled, 121 + 48 bytes
Compile: s!:comsublis
+++ s!:comsublis compiled, 21 + 24 bytes
Compile: s!:comsubla
+++ s!:comsubla compiled, 40 + 40 bytes
Compile: s!:comspecform
+++ s!:comspecform compiled, 9 + 20 bytes
Compile: s!:comsetq
+++ s!:comsetq compiled, 231 + 136 bytes
Compile: s!:comreturn!-from
+++ s!:comreturn!-from compiled, 62 + 48 bytes
Compile: s!:comreturn
+++ s!:comreturn compiled, 9 + 16 bytes
Compile: s!:comquote
+++ s!:comquote compiled, 23 + 36 bytes
Compile: s!:comqgetv
+++ s!:comqgetv compiled, 41 + 36 bytes
Compile: s!:comprogv
+++ s!:comprogv compiled, 48 + 56 bytes
Compile: s!:comprogn
+++ s!:comprogn compiled, 44 + 20 bytes
Compile: s!:comprog2
+++ s!:comprog2 compiled, 33 + 24 bytes
Compile: s!:comprog1
+++ s!:comprog1 compiled, 71 + 44 bytes
Compile: s!:comprog!*
+++ s!:comprog!* compiled, 38 + 44 bytes
Compile: s!:comprog
+++ s!:comprog compiled, 38 + 44 bytes
Compile: s!:complus2
+++ s!:complus2 compiled, 84 + 40 bytes
Compile: s!:complus
+++ s!:complus compiled, 8 + 20 bytes
Compile: s!:compile2
+++ s!:compile2 compiled, 533 + 164 bytes
Compile: s!:compile1
+++ s!:compile1 compiled, 985 + 284 bytes
Compile: s!:compile0
+++ s!:compile0 compiled, 247 + 96 bytes
Compile: s!:compile!-file!*
+++ s!:compile!-file!* compiled, 136 + 72 bytes
Compile: s!:comor
+++ s!:comor compiled, 31 + 32 bytes
Compile: s!:commv!-prog1
+++ s!:commv!-prog1 compiled, 94 + 72 bytes
Compile: s!:commv!-call
+++ s!:commv!-call compiled, 50 + 32 bytes
Compile: s!:comminusp
+++ s!:comminusp compiled, 20 + 28 bytes
Compile: s!:comminus
+++ s!:comminus compiled, 33 + 24 bytes
Compile: s!:commemq
+++ s!:commemq compiled, 53 + 48 bytes
Compile: s!:commember
+++ s!:commember compiled, 31 + 32 bytes
Compile: s!:commap
+++ s!:commap compiled, 309 + 140 bytes
Compile: s!:commacrolet
+++ s!:commacrolet compiled, 19 + 20 bytes
Compile: s!:comlonglist
+++ s!:comlonglist compiled, 122 + 84 bytes
Compile: s!:comlist!*
+++ s!:comlist!* compiled, 75 + 36 bytes
Compile: s!:comlist
+++ s!:comlist compiled, 66 + 40 bytes
Compile: s!:comlet!*
+++ s!:comlet!* compiled, 17 + 20 bytes
Compile: s!:comlet
+++ s!:comlet compiled, 15 + 20 bytes
Compile: s!:comlessp
+++ s!:comlessp compiled, 25 + 28 bytes
Compile: s!:comlambda
+++ s!:comlambda compiled, 289 + 124 bytes
Compile: s!:comlabels
+++ s!:comlabels compiled, 78 + 36 bytes
Compile: s!:comitimes
+++ s!:comitimes compiled, 8 + 20 bytes
Compile: s!:comiplus2
+++ s!:comiplus2 compiled, 66 + 36 bytes
Compile: s!:comiplus
+++ s!:comiplus compiled, 8 + 20 bytes
Compile: s!:comiminusp
+++ s!:comiminusp compiled, 20 + 28 bytes
Compile: s!:comilessp
+++ s!:comilessp compiled, 25 + 28 bytes
Compile: s!:comif
+++ s!:comif compiled, 58 + 40 bytes
Compile: s!:comidifference
+++ s!:comidifference compiled, 55 + 36 bytes
Compile: s!:comicase
+++ s!:comicase compiled, 90 + 36 bytes
Compile: s!:comgo
+++ s!:comgo compiled, 64 + 44 bytes
Compile: s!:comgetv
+++ s!:comgetv compiled, 16 + 24 bytes
Compile: s!:comget
+++ s!:comget compiled, 91 + 68 bytes
Compile: s!:comfunction
+++ s!:comfunction compiled, 216 + 156 bytes
Compile: s!:comflet
+++ s!:comflet compiled, 83 + 52 bytes
Compile: s!:comflagp
+++ s!:comflagp compiled, 52 + 44 bytes
Compile: s!:comeval!-when
+++ s!:comeval!-when compiled, 53 + 36 bytes
Compile: s!:comequal
+++ s!:comequal compiled, 26 + 20 bytes
Compile: s!:comeqcar
+++ s!:comeqcar compiled, 40 + 36 bytes
Compile: s!:comeq
+++ s!:comeq compiled, 53 + 40 bytes
Compile: s!:comdifference
+++ s!:comdifference compiled, 76 + 44 bytes
Compile: s!:comdelete
+++ s!:comdelete compiled, 31 + 32 bytes
Compile: s!:comdeleq
+++ s!:comdeleq compiled, 53 + 48 bytes
Compile: s!:comdeclare
+++ s!:comdeclare compiled, 14 + 20 bytes
Compile: s!:comcons
+++ s!:comcons compiled, 122 + 60 bytes
Compile: s!:comcond
+++ s!:comcond compiled, 92 + 52 bytes
Compile: s!:comcatch
+++ s!:comcatch compiled, 53 + 56 bytes
Compile: s!:comcase
+++ s!:comcase compiled, 375 + 104 bytes
Compile: s!:comcarcdr4
+++ s!:comcarcdr4 compiled, 25 + 16 bytes
Compile: s!:comcarcdr3
+++ s!:comcarcdr3 compiled, 30 + 28 bytes
Compile: s!:combool
+++ s!:combool compiled, 58 + 32 bytes
Compile: s!:comblock
+++ s!:comblock compiled, 25 + 28 bytes
Compile: s!:comatsoc
+++ s!:comatsoc compiled, 53 + 48 bytes
Compile: s!:comassoc
+++ s!:comassoc compiled, 44 + 36 bytes
Compile: s!:comapply
+++ s!:comapply compiled, 93 + 48 bytes
Compile: s!:comand
+++ s!:comand compiled, 31 + 32 bytes
Compile: s!:casebranch
+++ s!:casebranch compiled, 244 + 112 bytes
Compile: s!:cancel_local_decs
+++ s!:cancel_local_decs compiled as link to unfluid
Compile: s!:c_supervisor
+++ s!:c_supervisor compiled, 106 + 64 bytes
Compile: s!:boolean_jumpable_list
+++ s!:boolean_jumpable_list compiled, 12 + 16 bytes
Compile: s!:boolean_jumpable
+++ s!:boolean_jumpable compiled, 35 + 28 bytes
Compile: s!:any_fluid
+++ s!:any_fluid compiled, 13 + 16 bytes
Compile: s!:alwayseasy
+++ s!:alwayseasy compiled, 2 + 12 bytes
Compile: s!:alist_eq_unsafe
+++ s!:alist_eq_unsafe compiled, 30 + 16 bytes
Compile: s!:alist_eq_safe
+++ s!:alist_eq_safe compiled, 22 + 16 bytes
Compile: s!:ad_name
+++ s!:ad_name compiled, 19 + 28 bytes
Compile: rplacw
+++ rplacw compiled, 9 + 8 bytes
Compile: rassoc
+++ rassoc compiled, 14 + 8 bytes
Compile: putd
+++ putd compiled, 108 + 68 bytes
Compile: putc
+++ putc compiled as link to put
Compile: printprompt
+++ printprompt compiled, 1 + 8 bytes
Compile: printl
+++ printl compiled, 6 + 12 bytes
Compile: printcl
+++ printcl compiled, 6 + 12 bytes
Compile: prinl
+++ prinl compiled, 4 + 16 bytes
Compile: princl
+++ princl compiled, 4 + 16 bytes
Compile: prettyprint
+++ prettyprint compiled, 10 + 12 bytes
Compile: pipe!-open
+++ pipe!-open compiled, 24 + 36 bytes
Compile: open
+++ open compiled, 45 + 48 bytes
Compile: oem!-supervisor
+++ oem!-supervisor compiled, 7 + 8 bytes
Compile: oblist
+++ oblist compiled, 11 + 28 bytes
Compile: newbig
+++ newbig compiled, 24 + 20 bytes
Compile: mapobl
+++ mapobl compiled, 13 + 12 bytes
Compile: maplist
+++ maplist compiled, 16 + 8 bytes
Compile: mapcon
+++ mapcon compiled, 26 + 8 bytes
Compile: mapcar
+++ mapcar compiled, 17 + 8 bytes
Compile: mapcan
+++ mapcan compiled, 27 + 8 bytes
Compile: mapc
+++ mapc compiled, 10 + 8 bytes
Compile: map
+++ map compiled, 9 + 8 bytes
Compile: load_source_database
+++ load_source_database compiled, 32 + 28 bytes
Compile: lastcar
+++ lastcar compiled, 12 + 8 bytes
Compile: keyword
+++ keyword compiled, 17 + 12 bytes
Compile: hashtagged!-name
+++ hashtagged!-name compiled, 19 + 24 bytes
Compile: global
+++ global compiled, 18 + 8 bytes
Compile: fluid
+++ fluid compiled, 18 + 8 bytes
Compile: fetch!-url
+++ fetch!-url compiled, 68 + 40 bytes
Compile: faslout
+++ faslout compiled, 53 + 68 bytes
Compile: faslend
+++ faslend compiled, 67 + 64 bytes
Compile: expand
+++ expand compiled, 16 + 8 bytes
Compile: display_source_database
+++ display_source_database compiled, 41 + 28 bytes
Compile: df
+++ df_b54e1gthfxk93 compiled, 78 + 52 bytes
Compile: deflist
+++ deflist compiled, 22 + 12 bytes
Compile: dated!-name
+++ dated!-name compiled, 34 + 28 bytes
Compile: copy
+++ copy compiled, 16 + 8 bytes
Compile: compile!-file!*
+++ compile!-file!* compiled, 14 + 16 bytes
Compile: compile!-all
+++ compile!-all compiled, 59 + 44 bytes
Compile: compile
+++ compile compiled, 36 + 20 bytes
Compile: compd
+++ compd compiled, 31 + 36 bytes
Compile: clear_source_database
+++ clear_source_database compiled, 5 + 20 bytes
Compile: carcheck
+++ carcheck compiled, 12 + 12 bytes
Compile: c_out
+++ c_out compiled, 68 + 72 bytes
Compile: c_end
+++ c_end compiled, 17 + 32 bytes
Compile: c!:valid_specform
+++ c!:valid_specform compiled, 1 + 8 bytes
Compile: c!:valid_quote
+++ c!:valid_quote compiled, 2 + 12 bytes
Compile: c!:valid_prog
+++ c!:valid_prog compiled, 3 + 12 bytes
Compile: c!:valid_list
+++ c!:valid_list compiled, 16 + 16 bytes
Compile: c!:valid_let
+++ c!:valid_let compiled, 15 + 20 bytes
Compile: c!:valid_function
+++ c!:valid_function compiled, 39 + 24 bytes
Compile: c!:valid_fndef
+++ c!:valid_fndef compiled, 14 + 20 bytes
Compile: c!:valid_expr
+++ c!:valid_expr compiled, 61 + 36 bytes
Compile: c!:valid_cond
+++ c!:valid_cond compiled, 13 + 16 bytes
Compile: c!:two_operands
+++ c!:two_operands compiled, 21 + 32 bytes
Compile: c!:startblock
+++ c!:startblock compiled, 5 + 16 bytes
Compile: c!:start_nested_context
+++ c!:start_nested_context compiled, 15 + 32 bytes
Compile: c!:small_number
+++ c!:small_number compiled, 17 + 16 bytes
Compile: c!:safeprin
+++ c!:safeprin compiled, 93 + 56 bytes
Compile: c!:rplac
+++ c!:rplac compiled, 39 + 24 bytes
Compile: c!:reset_gensyms
+++ c!:reset_gensyms compiled, 100 + 68 bytes
Compile: c!:remove_nops
+++ c!:remove_nops compiled, 198 + 68 bytes
Compile: c!:pushpop
+++ c!:pushpop compiled, 82 + 44 bytes
Compile: c!:pstrglob
+++ c!:pstrglob compiled, 12 + 16 bytes
Compile: c!:prplacd
+++ c!:prplacd compiled, 17 + 20 bytes
Compile: c!:prplaca
+++ c!:prplaca compiled, 17 + 20 bytes
Compile: c!:printf1
+++ c!:printf1 compiled, 169 + 100 bytes
Compile: c!:printf
+++ c!:printf_m0mu8y9h0ul52 compiled, 15 + 16 bytes
Compile: c!:print_opcode
+++ c!:print_opcode compiled, 37 + 12 bytes
Compile: c!:print_exit_condition1
+++ c!:print_exit_condition1 compiled, 504 + 164 bytes
Compile: c!:preloadenv
+++ c!:preloadenv compiled, 11 + 20 bytes
Compile: c!:pqputv
+++ c!:pqputv compiled, 17 + 20 bytes
Compile: c!:pqgetv
+++ c!:pqgetv compiled, 16 + 20 bytes
Compile: c!:pqcdr
+++ c!:pqcdr compiled, 10 + 16 bytes
Compile: c!:pqcar
+++ c!:pqcar compiled, 10 + 16 bytes
Compile: c!:pnumberp
+++ c!:pnumberp compiled, 10 + 16 bytes
Compile: c!:pnull
+++ c!:pnull compiled, 10 + 16 bytes
Compile: c!:pnilglob
+++ c!:pnilglob compiled, 9 + 16 bytes
Compile: c!:pmovr
+++ c!:pmovr compiled, 10 + 16 bytes
Compile: c!:pmovk1
+++ c!:pmovk1 compiled, 35 + 32 bytes
Compile: c!:pmovk
+++ c!:pmovk compiled, 11 + 16 bytes
Compile: c!:pmodular_plus
+++ c!:pmodular_plus compiled, 28 + 28 bytes
Compile: c!:pmodular_minus
+++ c!:pmodular_minus compiled, 28 + 28 bytes
Compile: c!:pmodular_difference
+++ c!:pmodular_difference compiled, 28 + 28 bytes
Compile: c!:pmemq
+++ c!:pmemq compiled, 11 + 16 bytes
Compile: c!:pmember
+++ c!:pmember compiled, 11 + 16 bytes
Compile: c!:pldrglob
+++ c!:pldrglob compiled, 11 + 16 bytes
Compile: c!:pitimes2
+++ c!:pitimes2 compiled, 16 + 20 bytes
Compile: c!:pisub1
+++ c!:pisub1 compiled, 10 + 16 bytes
Compile: c!:piplus2
+++ c!:piplus2 compiled, 16 + 20 bytes
Compile: c!:piminusp
+++ c!:piminusp compiled, 10 + 16 bytes
Compile: c!:piminus
+++ c!:piminus compiled, 10 + 16 bytes
Compile: c!:pilessp
+++ c!:pilessp compiled, 11 + 16 bytes
Compile: c!:pigreaterp
+++ c!:pigreaterp compiled, 11 + 16 bytes
Compile: c!:pifsymbol
+++ c!:pifsymbol compiled, 8 + 16 bytes
Compile: c!:pifnumber
+++ c!:pifnumber compiled, 8 + 16 bytes
Compile: c!:pifnull
+++ c!:pifnull compiled, 8 + 16 bytes
Compile: c!:pifizerop
+++ c!:pifizerop compiled, 8 + 16 bytes
Compile: c!:pifilessp
+++ c!:pifilessp compiled, 10 + 16 bytes
Compile: c!:pifigreaterp
+++ c!:pifigreaterp compiled, 10 + 16 bytes
Compile: c!:pifequal
+++ c!:pifequal compiled, 18 + 24 bytes
Compile: c!:pifeq
+++ c!:pifeq compiled, 10 + 16 bytes
Compile: c!:pifatom
+++ c!:pifatom compiled, 8 + 16 bytes
Compile: c!:pidifference
+++ c!:pidifference compiled, 17 + 20 bytes
Compile: c!:piadd1
+++ c!:piadd1 compiled, 10 + 16 bytes
Compile: c!:pgoto
+++ c!:pgoto compiled, 22 + 24 bytes
Compile: c!:pget
+++ c!:pget compiled, 11 + 16 bytes
Compile: c!:pfluidunbind
+++ c!:pfluidunbind compiled, 8 + 16 bytes
Compile: c!:pfluidbind
+++ c!:pfluidbind compiled, 43 + 32 bytes
Compile: c!:pfixp
+++ c!:pfixp compiled, 10 + 16 bytes
Compile: c!:pfastget
+++ c!:pfastget compiled, 100 + 68 bytes
Compile: c!:pfastflag
+++ c!:pfastflag compiled, 110 + 72 bytes
Compile: c!:pequal
+++ c!:pequal compiled, 16 + 24 bytes
Compile: c!:peq
+++ c!:peq compiled, 11 + 16 bytes
Compile: c!:pcdr
+++ c!:pcdr compiled, 22 + 24 bytes
Compile: c!:pcar
+++ c!:pcar compiled, 22 + 24 bytes
Compile: c!:pcall
+++ c!:pcall compiled, 314 + 120 bytes
Compile: c!:patsoc
+++ c!:patsoc compiled, 11 + 16 bytes
Compile: c!:patom
+++ c!:patom compiled, 10 + 16 bytes
Compile: c!:passoc
+++ c!:passoc compiled, 11 + 16 bytes
Compile: c!:outop
+++ c!:outop compiled, 18 + 24 bytes
Compile: c!:optimise_flowgraph
+++ c!:optimise_flowgraph compiled, 634 + 296 bytes
Compile: c!:one_operand
+++ c!:one_operand compiled, 16 + 28 bytes
Compile: c!:newreg
+++ c!:newreg compiled, 7 + 16 bytes
Compile: c!:narg
+++ c!:narg compiled, 11 + 20 bytes
Compile: c!:my_gensym
+++ c!:my_gensym compiled, 39 + 36 bytes
Compile: c!:locally_bound
+++ c!:locally_bound compiled, 5 + 8 bytes
Compile: c!:local_fluidp1
+++ c!:local_fluidp1 compiled, 22 + 12 bytes
Compile: c!:local_fluidp
+++ c!:local_fluidp compiled, 13 + 12 bytes
Compile: c!:live_variable_analysis
+++ c!:live_variable_analysis compiled, 286 + 116 bytes
Compile: c!:is_fixnum
+++ c!:is_fixnum compiled, 17 + 16 bytes
Compile: c!:inv_name
+++ c!:inv_name compiled, 105 + 36 bytes
Compile: c!:install
+++ c!:install compiled, 62 + 28 bytes
Compile: c!:insert_tailcall
+++ c!:insert_tailcall compiled, 183 + 68 bytes
Compile: c!:insert1
+++ c!:insert1 compiled, 8 + 8 bytes
Compile: c!:has_calls_1
+++ c!:has_calls_1 compiled, 77 + 36 bytes
Compile: c!:has_calls
+++ c!:has_calls compiled, 10 + 20 bytes
Compile: c!:flatten
+++ c!:flatten compiled, 97 + 48 bytes
Compile: c!:flag_exit_label
+++ c!:flag_exit_label compiled, 51 + 16 bytes
Compile: c!:find_literal
+++ c!:find_literal compiled, 30 + 16 bytes
Compile: c!:expand_map
+++ c!:expand_map compiled, 263 + 132 bytes
Compile: c!:expand_carcdr
+++ c!:expand_carcdr compiled, 39 + 20 bytes
Compile: c!:expand!-let!*
+++ c!:expand!-let!* compiled, 32 + 16 bytes
Compile: c!:expand!-let
+++ c!:expand!-let compiled, 64 + 16 bytes
Compile: c!:evalargs
+++ c!:evalargs compiled, 25 + 12 bytes
Compile: c!:eqvalid
+++ c!:eqvalid compiled, 27 + 28 bytes
Compile: c!:endblock
+++ c!:endblock compiled, 32 + 36 bytes
Compile: c!:end_nested_context
+++ c!:end_nested_context compiled, 37 + 44 bytes
Compile: c!:does_return
+++ c!:does_return compiled, 68 + 32 bytes
Compile: c!:display_flowgraph1
+++ c!:display_flowgraph1 compiled, 112 + 48 bytes
Compile: c!:cwhen
+++ c!:cwhen compiled, 77 + 52 bytes
Compile: c!:cval_inner
+++ c!:cval_inner compiled, 71 + 44 bytes
Compile: c!:cval
+++ c!:cval compiled, 22 + 28 bytes
Compile: c!:cunwind_protect
+++ c!:cunwind_protect compiled, 4 + 20 bytes
Compile: c!:cunless
+++ c!:cunless compiled, 77 + 52 bytes
Compile: c!:ctimes2
+++ c!:ctimes2 compiled, 75 + 36 bytes
Compile: c!:cthrow
+++ c!:cthrow compiled, 4 + 20 bytes
Compile: c!:cthe
+++ c!:cthe compiled, 5 + 12 bytes
Compile: c!:ctestsymbol
+++ c!:ctestsymbol compiled, 16 + 20 bytes
Compile: c!:ctestor
+++ c!:ctestor compiled, 41 + 28 bytes
Compile: c!:ctestnumberp
+++ c!:ctestnumberp compiled, 16 + 20 bytes
Compile: c!:ctestnull
+++ c!:ctestnull compiled, 14 + 12 bytes
Compile: c!:ctestneq
+++ c!:ctestneq compiled, 67 + 36 bytes
Compile: c!:ctestizerop
+++ c!:ctestizerop compiled, 16 + 20 bytes
Compile: c!:ctestilessp
+++ c!:ctestilessp compiled, 20 + 20 bytes
Compile: c!:ctestigreaterp
+++ c!:ctestigreaterp compiled, 20 + 20 bytes
Compile: c!:ctestif
+++ c!:ctestif compiled, 33 + 20 bytes
Compile: c!:ctestequal
+++ c!:ctestequal compiled, 67 + 36 bytes
Compile: c!:ctesteqcar
+++ c!:ctesteqcar compiled, 53 + 40 bytes
Compile: c!:ctesteq
+++ c!:ctesteq compiled, 53 + 24 bytes
Compile: c!:ctestconsp
+++ c!:ctestconsp compiled, 16 + 20 bytes
Compile: c!:ctestatom
+++ c!:ctestatom compiled, 16 + 20 bytes
Compile: c!:ctestand
+++ c!:ctestand compiled, 41 + 28 bytes
Compile: c!:cspecform
+++ c!:cspecform compiled, 9 + 20 bytes
Compile: c!:csetq
+++ c!:csetq compiled, 72 + 56 bytes
Compile: c!:creturn
+++ c!:creturn compiled, 38 + 44 bytes
Compile: c!:cquote
+++ c!:cquote compiled, 44 + 36 bytes
Compile: c!:cqputv
+++ c!:cqputv compiled, 22 + 20 bytes
Compile: c!:cputv
+++ c!:cputv compiled, 16 + 24 bytes
Compile: c!:cprogv
+++ c!:cprogv compiled, 4 + 20 bytes
Compile: c!:cprogn
+++ c!:cprogn compiled, 27 + 16 bytes
Compile: c!:cprog2
+++ c!:cprog2 compiled, 43 + 40 bytes
Compile: c!:cprog1
+++ c!:cprog1 compiled, 35 + 40 bytes
Compile: c!:cprog!*
+++ c!:cprog!* compiled, 4 + 20 bytes
Compile: c!:cprog
+++ c!:cprog compiled, 428 + 140 bytes
Compile: c!:cprivate_tagbody
+++ c!:cprivate_tagbody compiled, 50 + 28 bytes
Compile: c!:cplus2
+++ c!:cplus2 compiled, 71 + 40 bytes
Compile: c!:cor
+++ c!:cor compiled, 70 + 44 bytes
Compile: c!:concat
+++ c!:concat compiled, 21 + 16 bytes
Compile: c!:comsublis
+++ c!:comsublis compiled, 12 + 16 bytes
Compile: c!:commember
+++ c!:commember compiled, 17 + 20 bytes
Compile: c!:comdelete
+++ c!:comdelete compiled, 17 + 20 bytes
Compile: c!:comassoc
+++ c!:comassoc compiled, 17 + 20 bytes
Compile: c!:cmultiple_value_prog1
+++ c!:cmultiple_value_prog1 compiled, 4 + 20 bytes
Compile: c!:cmultiple_value_call
+++ c!:cmultiple_value_call compiled, 4 + 20 bytes
Compile: c!:cminus
+++ c!:cminus compiled, 29 + 24 bytes
Compile: c!:cmacrolet
+++ c!:cmacrolet compiled, 4 + 20 bytes
Compile: c!:clist!*
+++ c!:clist!* compiled, 32 + 16 bytes
Compile: c!:clist
+++ c!:clist compiled, 116 + 52 bytes
Compile: c!:clet!*
+++ c!:clet!* compiled, 9 + 16 bytes
Compile: c!:clet
+++ c!:clet compiled, 9 + 16 bytes
Compile: c!:clash
+++ c!:clash compiled, 48 + 20 bytes
Compile: c!:clambda
+++ c!:clambda compiled, 303 + 108 bytes
Compile: c!:clabels
+++ c!:clabels compiled, 4 + 20 bytes
Compile: c!:cjumpif
+++ c!:cjumpif compiled, 69 + 44 bytes
Compile: c!:citimes2
+++ c!:citimes2 compiled, 72 + 36 bytes
Compile: c!:ciplus2
+++ c!:ciplus2 compiled, 68 + 40 bytes
Compile: c!:cif
+++ c!:cif compiled, 88 + 44 bytes
Compile: c!:cidifference
+++ c!:cidifference compiled, 63 + 44 bytes
Compile: c!:cgo
+++ c!:cgo compiled, 37 + 32 bytes
Compile: c!:cgetv
+++ c!:cgetv compiled, 16 + 24 bytes
Compile: c!:cget
+++ c!:cget compiled, 55 + 44 bytes
Compile: c!:cfunction
+++ c!:cfunction compiled, 51 + 52 bytes
Compile: c!:cfndef
+++ c!:cfndef compiled, 709 + 260 bytes
Compile: c!:cflet
+++ c!:cflet compiled, 4 + 20 bytes
Compile: c!:cflag
+++ c!:cflag compiled, 55 + 44 bytes
Compile: c!:ceval_when
+++ c!:ceval_when compiled, 4 + 20 bytes
Compile: c!:certainlyatom
+++ c!:certainlyatom compiled, 29 + 20 bytes
Compile: c!:cequal
+++ c!:cequal compiled, 59 + 44 bytes
Compile: c!:ceq
+++ c!:ceq compiled, 48 + 36 bytes
Compile: c!:cdifference
+++ c!:cdifference compiled, 66 + 44 bytes
Compile: c!:cdefun
+++ c!:cdefun compiled, 4 + 20 bytes
Compile: c!:cdeclare
+++ c!:cdeclare compiled, 4 + 20 bytes
Compile: c!:cde
+++ c!:cde compiled, 4 + 20 bytes
Compile: c!:ccons
+++ c!:ccons compiled, 101 + 56 bytes
Compile: c!:ccond
+++ c!:ccond compiled, 124 + 56 bytes
Compile: c!:ccompilesupervisor
+++ c!:ccompilesupervisor compiled, 84 + 56 bytes
Compile: c!:ccompilestart
+++ c!:ccompilestart compiled, 215 + 144 bytes
Compile: c!:ccompile_let
+++ c!:ccompile_let compiled, 4 + 20 bytes
Compile: c!:ccmpout1a
+++ c!:ccmpout1a compiled, 174 + 96 bytes
Compile: c!:ccmpout1
+++ c!:ccmpout1 compiled, 24 + 20 bytes
Compile: c!:ccatch
+++ c!:ccatch compiled, 4 + 20 bytes
Compile: c!:ccall1
+++ c!:ccall1 compiled, 110 + 52 bytes
Compile: c!:ccall
+++ c!:ccall compiled as link to c:ccall1
Compile: c!:catom
+++ c!:catom compiled, 126 + 68 bytes
Compile: c!:cand
+++ c!:cand compiled, 48 + 24 bytes
Compile: c!:can_reach
+++ c!:can_reach compiled, 23 + 24 bytes
Compile: c!:builtin_two
+++ c!:builtin_two compiled, 28 + 20 bytes
Compile: c!:builtin_one
+++ c!:builtin_one compiled, 20 + 20 bytes
Compile: c!:build_clash_matrix
+++ c!:build_clash_matrix compiled, 248 + 96 bytes
Compile: c!:atomlist1
+++ c!:atomlist1 compiled, 17 + 16 bytes
Compile: c!:atomlist
+++ c!:atomlist compiled, 56 + 32 bytes
Compile: c!:atomkeys1
+++ c!:atomkeys1 compiled, 22 + 20 bytes
Compile: c!:atomkeys
+++ c!:atomkeys compiled, 56 + 32 bytes
Compile: c!:atomcar
+++ c!:atomcar compiled, 19 + 20 bytes
Compile: c!:assign
+++ c!:assign compiled, 31 + 32 bytes
Compile: c!:any_can_reach
+++ c!:any_can_reach compiled, 14 + 16 bytes
Compile: c!:alphanumeric
+++ c!:alphanumeric compiled, 17 + 8 bytes
Compile: c!:allocate_registers
+++ c!:allocate_registers compiled, 145 + 28 bytes
Compile: c!-end1
+++ c!-end1 compiled, 648 + 344 bytes
Compile: c!-end
+++ c!-end compiled, 3 + 16 bytes
Compile: c!-compile
+++ c!-compile compiled, 44 + 56 bytes
Compile: break!-loop
+++ break!-loop compiled, 110 + 72 bytes
Compile: bldmsg_temp_internal
+++ bldmsg_temp_internal compiled, 70 + 24 bytes
Compile: bldmsg
+++ bldmsg_0yluunu13voy compiled, 15 + 16 bytes
Compile: binopen
+++ binopen compiled, 56 + 52 bytes

nil

nil
("*comp =" t)

("*comp =" t)

FASLOUT cslcompat: IN files;  or type in expressions
When all done, execute FASLEND;

Reading file "$srcdir/fastgets.lsp"
End of file "$srcdir/fastgets.lsp"

Reading file "$srcdir/compat.lsp"
+++ rplacw compiled, 9 + 8 bytes
+++ expand compiled, 16 + 8 bytes
+++ mapcar compiled, 17 + 8 bytes
+++ maplist compiled, 16 + 8 bytes
+++ mapcan compiled, 27 + 8 bytes
+++ mapcon compiled, 26 + 8 bytes
+++ mapc compiled, 10 + 8 bytes
+++ map compiled, 9 + 8 bytes
+++ copy not compiled (C++ version available)
+++ sassoc compiled, 16 + 8 bytes
+++ rassoc not compiled (C++ version available)
+++ lastcar not compiled (C++ version available)
+++ open not compiled (C++ version available)
+++ binopen compiled, 56 + 52 bytes
+++ pipe!-open compiled, 24 + 36 bytes
+++ putd not compiled (C++ version available)
+++ putc compiled as link to put
+++ deflist compiled, 22 + 12 bytes
+++ global compiled, 18 + 8 bytes
+++ fluid compiled, 18 + 8 bytes
+++ keyword compiled, 17 + 12 bytes
+++ unglobal compiled, 10 + 8 bytes
+++ unfluid compiled, 10 + 8 bytes
+++ unkeyword compiled, 9 + 12 bytes
+++ carcheck compiled, 12 + 12 bytes
+++ s!:make!-psetq!-vars compiled, 26 + 24 bytes
+++ s!:make!-psetq!-bindings compiled, 20 + 12 bytes
+++ s!:make!-psetq!-assignments compiled, 21 + 16 bytes
+++ psetq_n82s289159a6 compiled, 21 + 24 bytes
+++ s!:do!-bindings compiled, 42 + 12 bytes
+++ s!:do!-endtest compiled, 5 + 8 bytes
+++ s!:do!-result compiled, 5 + 8 bytes
+++ s!:do!-updates compiled, 25 + 8 bytes
+++ s!:expand!-do compiled, 142 + 48 bytes
+++ do_dinhmz70j74n3 compiled, 8 + 20 bytes
+++ do!*_azr03h9gz2y51 compiled, 8 + 20 bytes
+++ s!:expand!-dolist compiled, 111 + 48 bytes
+++ dolist_dqxxti25rbnh1 compiled, 8 + 12 bytes
+++ s!:expand!-dotimes compiled, 118 + 52 bytes
+++ dotimes_abbkmjh754cp1 compiled, 8 + 12 bytes
+++ newbig compiled, 24 + 20 bytes
End of file "$srcdir/compat.lsp"

Reading file "$srcdir/extras.lsp"
+++ df_n4fdfw1jhim7 compiled, 78 + 52 bytes
+++ oem!-supervisor compiled, 7 + 8 bytes
+++ break!-loop compiled, 110 + 72 bytes
+++ s!:stamp compiled, 43 + 32 bytes
+++ dated!-name compiled, 34 + 28 bytes
+++ hashtagged!-name compiled, 19 + 24 bytes
+++ sort not compiled (C++ version available)
+++ stable!-sort compiled, 7 + 12 bytes
+++ sortip compiled as link to stable-sortip
+++ stable!-sortip not compiled (C++ version available)
+++ s!:prinl0 compiled, 37 + 44 bytes
+++ s!:prinl1 compiled, 128 + 48 bytes
+++ s!:prinl2 compiled, 331 + 96 bytes
+++ printl compiled, 6 + 12 bytes
+++ printcl compiled, 6 + 12 bytes
+++ princl compiled, 4 + 16 bytes
+++ prinl compiled, 4 + 16 bytes
+++ s!:format compiled, 227 + 48 bytes
+++ format_356iboz8thgz1 compiled, 18 + 24 bytes
+++ prettyprint compiled, 10 + 12 bytes
+++ tprettyprint compiled, 11 + 16 bytes
+++ superprintm compiled, 15 + 20 bytes
+++ superprinm compiled, 156 + 104 bytes
+++ s!:top_yt23o7eyllf82 compiled, 4 + 12 bytes
+++ s!:depth_zj90vpmzsthz2 compiled, 7 + 12 bytes
+++ s!:indenting_mc9phwboxruv2 compiled, 7 + 12 bytes
+++ s!:blankcount_p3hfufbnmqv73 compiled, 7 + 12 bytes
+++ s!:blanklist_buz5bk0v89vc2 compiled, 7 + 12 bytes
+++ s!:setindenting_405246gkfs0z1 compiled, 12 + 16 bytes
+++ s!:setblankcount_wqtabtq2ayhf compiled, 12 + 16 bytes
+++ s!:setblanklist_qfx4kc6udsjn2 compiled, 12 + 16 bytes
+++ s!:newframe_f80lf00b4vuh3 compiled, 14 + 24 bytes
+++ s!:blankp_yiuratnb4rjb2 compiled, 12 + 16 bytes
+++ s!:prindent compiled, 343 + 148 bytes
+++ s!:explodes compiled as link to explode
+++ s!:prvector compiled, 80 + 52 bytes
+++ s!:putblank compiled, 35 + 24 bytes
+++ s!:endlist compiled, 5 + 12 bytes
+++ s!:finishpending compiled, 50 + 28 bytes
+++ s!:quotep compiled, 20 + 16 bytes
+++ s!:putch compiled, 67 + 56 bytes
+++ s!:overflow compiled, 313 + 124 bytes
+++ fetch!-url compiled, 68 + 40 bytes
+++ bldmsg_temp_internal compiled, 70 + 24 bytes
+++ bldmsg_s5n9pzn1jab13 compiled, 15 + 16 bytes
End of file "$srcdir/extras.lsp"
+++ FASLEND
Completed FASL files for cslcompat

nil

FASLOUT compiler: IN files;  or type in expressions
When all done, execute FASLEND;

Reading file "$srcdir/compiler.lsp"
+++ s!:vecof compiled, 20 + 16 bytes
+++ s!:vecof1 compiled, 35 + 12 bytes
+++ s!:prinhex1 compiled, 11 + 20 bytes
+++ s!:prinhex2 compiled, 9 + 20 bytes
+++ s!:prinhex4 compiled, 9 + 20 bytes
+++ s!:start_procedure compiled, 59 + 64 bytes
+++ s!:set_label compiled, 53 + 40 bytes
+++ s!:outjump compiled, 85 + 52 bytes
+++ s!:outexit compiled, 48 + 36 bytes
+++ s!:outopcode0 compiled, 29 + 36 bytes
+++ s!:outopcode1 compiled, 34 + 40 bytes
+++ s!:record_literal compiled, 50 + 36 bytes
+++ s!:record_literal_for_jump compiled, 53 + 36 bytes
+++ s!:outopcode1lit compiled, 36 + 44 bytes
+++ s!:outopcode2 compiled, 40 + 40 bytes
+++ s!:outlexref compiled, 145 + 92 bytes
+++ s!:literal_order compiled, 17 + 8 bytes
+++ s!:resolve_literals compiled, 263 + 64 bytes
+++ s!:only_loadlit compiled, 18 + 16 bytes
+++ s!:too_many_literals compiled, 215 + 60 bytes
+++ s!:endprocedure compiled, 228 + 112 bytes
+++ s!:add_pending compiled, 34 + 16 bytes
+++ s!:invent_exit compiled, 36 + 16 bytes
+++ s!:destination_label compiled, 49 + 20 bytes
+++ s!:remlose compiled, 60 + 36 bytes
+++ s!:remcall compiled, 180 + 88 bytes
+++ s!:is_lose_and_exit compiled, 53 + 24 bytes
+++ s!:try_tail_1 compiled, 162 + 80 bytes
+++ s!:try_tailcall compiled, 23 + 12 bytes
+++ s!:tidy_exits_1 compiled, 126 + 56 bytes
+++ s!:tidy_exits compiled, 23 + 12 bytes
+++ s!:tidy_flowgraph compiled, 340 + 48 bytes
+++ s!:negate_jump compiled, 15 + 12 bytes
+++ s!:resolve_labels compiled, 125 + 36 bytes
+++ s!:plant_basic_block compiled, 134 + 64 bytes
+++ s!:plant_bytes compiled, 156 + 68 bytes
+++ s!:plant_exit_code compiled, 161 + 52 bytes
+++ s!:expand_jump compiled, 238 + 100 bytes
+++ s!:comval compiled, 134 + 52 bytes
+++ s!:comspecform compiled, 9 + 20 bytes
+++ s!:improve compiled, 23 + 16 bytes
+++ s!:imp_minus compiled, 53 + 28 bytes
+++ s!:imp_1!+ compiled, 5 + 16 bytes
+++ s!:imp_1!- compiled, 5 + 16 bytes
+++ s!:imp_times compiled, 77 + 32 bytes
+++ s!:imp_itimes compiled, 77 + 32 bytes
+++ s!:imp_difference compiled, 26 + 24 bytes
+++ s!:imp_idifference compiled, 26 + 24 bytes
+++ s!:boolean_jumpable compiled, 35 + 28 bytes
+++ s!:boolean_jumpable_list compiled, 12 + 16 bytes
+++ s!:imp_or compiled, 50 + 28 bytes
+++ s!:imp_and compiled, 49 + 28 bytes
+++ s!:alwayseasy compiled, 2 + 12 bytes
+++ s!:easyifarg compiled, 15 + 16 bytes
+++ s!:easygetv compiled, 25 + 24 bytes
+++ s!:easyqgetv compiled, 22 + 20 bytes
+++ s!:iseasy compiled, 18 + 16 bytes
+++ s!:instate_local_decs compiled, 42 + 20 bytes
+++ s!:residual_local_decs compiled, 54 + 24 bytes
+++ s!:cancel_local_decs compiled as link to unfluid
+++ s!:find_local_decs compiled, 61 + 16 bytes
+++ s!:comlambda compiled, 289 + 124 bytes
+++ s!:loadliteral compiled, 27 + 36 bytes
+++ s!:comquote compiled, 23 + 36 bytes
+++ s!:comval_m compiled, 16 + 20 bytes
+++ s!:comflet compiled, 83 + 52 bytes
+++ s!:comlabels compiled, 78 + 36 bytes
+++ s!:commacrolet compiled, 19 + 20 bytes
+++ s!:local_macro compiled, 33 + 24 bytes
+++ s!:comfunction compiled, 216 + 156 bytes
+++ s!:should_be_fluid compiled, 40 + 40 bytes
+++ s!:find_lexical compiled, 38 + 12 bytes
+++ s!:comatom compiled, 205 + 136 bytes
+++ s!:islocal compiled, 37 + 20 bytes
+++ s!:load2 compiled, 238 + 100 bytes
+++ s!:comcall compiled, 670 + 284 bytes
+++ s!:ad_name compiled, 19 + 28 bytes
+++ s!:comcarcdr3 compiled, 30 + 28 bytes
+++ s!:comcarcdr4 compiled, 25 + 16 bytes
+++ s!:comgetv compiled, 16 + 24 bytes
+++ s!:comqgetv compiled, 41 + 36 bytes
+++ s!:comget compiled, 91 + 68 bytes
+++ s!:comflagp compiled, 52 + 44 bytes
+++ s!:complus compiled, 8 + 20 bytes
+++ s!:comtimes compiled, 8 + 20 bytes
+++ s!:comiplus compiled, 8 + 20 bytes
+++ s!:comitimes compiled, 8 + 20 bytes
+++ s!:complus2 compiled, 84 + 40 bytes
+++ s!:comdifference compiled, 76 + 44 bytes
+++ s!:comiplus2 compiled, 66 + 36 bytes
+++ s!:comidifference compiled, 55 + 36 bytes
+++ s!:comtimes2 compiled, 76 + 32 bytes
+++ s!:comminus compiled, 33 + 24 bytes
+++ s!:comminusp compiled, 20 + 28 bytes
+++ s!:comlessp compiled, 25 + 28 bytes
+++ s!:comiminusp compiled, 20 + 28 bytes
+++ s!:comilessp compiled, 25 + 28 bytes
+++ s!:comprogn compiled, 44 + 20 bytes
+++ s!:comprog1 compiled, 71 + 44 bytes
+++ s!:comprog2 compiled, 33 + 24 bytes
+++ s!:outstack compiled, 136 + 68 bytes
+++ s!:outlose compiled, 136 + 68 bytes
+++ s!:comprog compiled, 345 + 128 bytes
+++ s!:comtagbody compiled, 121 + 48 bytes
+++ s!:comprogv compiled, 48 + 56 bytes
+++ s!:comprog!* compiled, 38 + 44 bytes
+++ s!:comprog compiled, 38 + 44 bytes
+++ s!:comblock compiled, 25 + 28 bytes
+++ s!:comcatch compiled, 53 + 56 bytes
+++ s!:comthrow compiled, 50 + 48 bytes
+++ s!:comunwind!-protect compiled, 72 + 68 bytes
+++ s!:comdeclare compiled, 14 + 20 bytes
+++ s!:expand_let compiled, 59 + 12 bytes
+++ s!:comlet compiled, 15 + 20 bytes
+++ s!:expand_let!* compiled, 108 + 24 bytes
+++ s!:comlet!* compiled, 17 + 20 bytes
+++ s!:restore_stack compiled, 151 + 96 bytes
+++ s!:comgo compiled, 64 + 44 bytes
+++ s!:comreturn!-from compiled, 62 + 48 bytes
+++ s!:comreturn compiled, 9 + 16 bytes
+++ s!:jumpif compiled, 338 + 156 bytes
+++ s!:testnot compiled, 16 + 16 bytes
+++ s!:testatom compiled, 41 + 44 bytes
+++ s!:testconsp compiled, 41 + 44 bytes
+++ s!:comcond compiled, 92 + 52 bytes
+++ s!:comif compiled, 58 + 40 bytes
+++ s!:comwhen compiled, 44 + 44 bytes
+++ s!:comunless compiled, 13 + 20 bytes
+++ s!:comicase compiled, 90 + 36 bytes
+++ s!:jumpliteql compiled, 55 + 72 bytes
+++ s!:casebranch compiled, 244 + 112 bytes
+++ s!:comcase compiled, 375 + 104 bytes
+++ s!:comeval!-when compiled, 53 + 36 bytes
+++ s!:comthe compiled, 6 + 12 bytes
+++ s!:comand compiled, 31 + 32 bytes
+++ s!:comor compiled, 31 + 32 bytes
+++ s!:combool compiled, 58 + 32 bytes
+++ s!:testeq compiled, 202 + 92 bytes
+++ s!:testeq1 compiled, 150 + 60 bytes
+++ s!:testequal compiled, 124 + 52 bytes
+++ s!:testneq compiled, 17 + 20 bytes
+++ s!:testeqcar compiled, 161 + 116 bytes
+++ s!:testflagp compiled, 96 + 88 bytes
+++ s!:comsetq compiled, 231 + 136 bytes
+++ s!:comlist compiled, 66 + 40 bytes
+++ s!:comlonglist compiled, 122 + 84 bytes
+++ s!:comlist!* compiled, 75 + 36 bytes
+++ s!:comcons compiled, 122 + 60 bytes
+++ s!:commv!-call compiled, 50 + 32 bytes
+++ s!:commv!-prog1 compiled, 94 + 72 bytes
+++ s!:comapply compiled, 93 + 48 bytes
+++ s!:imp_funcall compiled, 67 + 60 bytes
+++ s!:eval_to_eq_safe compiled, 44 + 20 bytes
+++ s!:eval_to_eq_unsafe compiled, 49 + 28 bytes
+++ s!:list_all_eq_safe compiled, 17 + 16 bytes
+++ s!:eval_to_list_all_eq_safe compiled, 56 + 32 bytes
+++ s!:list_some_eq_unsafe compiled, 12 + 12 bytes
+++ s!:eval_to_list_some_eq_unsafe compiled, 45 + 28 bytes
+++ s!:eval_to_car_eq_safe compiled, 19 + 20 bytes
+++ s!:eval_to_car_eq_unsafe compiled, 19 + 20 bytes
+++ s!:alist_eq_safe compiled, 22 + 16 bytes
+++ s!:eval_to_alist_eq_safe compiled, 56 + 32 bytes
+++ s!:alist_eq_unsafe compiled, 30 + 16 bytes
+++ s!:eval_to_alist_eq_unsafe compiled, 45 + 32 bytes
+++ s!:comequal compiled, 26 + 20 bytes
+++ s!:comeq compiled, 53 + 40 bytes
+++ s!:comeqcar compiled, 40 + 36 bytes
+++ s!:comsublis compiled, 21 + 24 bytes
+++ s!:comsubla compiled, 40 + 40 bytes
+++ s!:comassoc compiled, 44 + 36 bytes
+++ s!:comatsoc compiled, 53 + 48 bytes
+++ s!:commember compiled, 31 + 32 bytes
+++ s!:commemq compiled, 53 + 48 bytes
+++ s!:comdelete compiled, 31 + 32 bytes
+++ s!:comdeleq compiled, 53 + 48 bytes
+++ s!:commap compiled, 309 + 140 bytes
+++ s!:nilargs compiled, 16 + 20 bytes
+++ s!:subargs compiled, 20 + 16 bytes
+++ clear_source_database compiled, 5 + 20 bytes
+++ load_source_database compiled, 32 + 28 bytes
+++ save_source_database compiled, 48 + 32 bytes
+++ display_source_database compiled, 41 + 28 bytes
+++ s!:r2i compiled, 93 + 48 bytes
+++ s!:r2i1 compiled, 203 + 96 bytes
+++ s!:r2iand compiled, 22 + 16 bytes
+++ s!:r2ior compiled, 32 + 12 bytes
+++ s!:r2icond compiled, 121 + 32 bytes
+++ s!:r2iif compiled, 62 + 12 bytes
+++ s!:r2iwhen compiled, 20 + 12 bytes
+++ s!:r2iprogn compiled, 33 + 12 bytes
+++ s!:r2icons compiled, 99 + 56 bytes
+++ s!:r2icons2 compiled, 93 + 44 bytes
+++ s!:r2isteps compiled, 108 + 40 bytes
+++ s!:r2i_safestep compiled, 18 + 16 bytes
+++ s!:r2i_dependson compiled, 53 + 36 bytes
+++ s!:r2i_list_dependson compiled, 14 + 16 bytes
+++ s!:r2i2 compiled, 166 + 76 bytes
+++ s!:r2i2cond compiled, 109 + 28 bytes
+++ s!:r2i2if compiled, 62 + 12 bytes
+++ s!:r2i2when compiled, 20 + 12 bytes
+++ s!:r2i2progn compiled, 33 + 12 bytes
+++ s!:r2i3 compiled, 340 + 84 bytes
+++ s!:any_fluid compiled, 13 + 16 bytes
+++ s!:compile1 compiled, 985 + 284 bytes
+++ s!:compile2 compiled, 533 + 164 bytes
+++ compile!-all compiled, 59 + 44 bytes
+++ s!:fasl_supervisor compiled, 106 + 64 bytes
+++ s!:fslout0 compiled, 4 + 12 bytes
+++ s!:fslout1 compiled, 647 + 236 bytes
+++ s!:fslout2 compiled, 58 + 36 bytes
+++ faslend compiled, 67 + 64 bytes
+++ s!:file compiled, 29 + 20 bytes
+++ s!:trim!.c compiled, 22 + 20 bytes
+++ s!:dir compiled, 34 + 24 bytes
+++ faslout compiled, 53 + 68 bytes
+++ s!:c_supervisor compiled, 106 + 64 bytes
+++ s!:cout0 compiled, 4 + 12 bytes
+++ s!:cout1 compiled, 436 + 172 bytes
+++ c_end compiled, 17 + 32 bytes
+++ c_out compiled, 68 + 72 bytes
+++ s!:compile!-file!* compiled, 136 + 72 bytes
+++ compile!-file!* compiled, 14 + 16 bytes
+++ compd compiled, 31 + 36 bytes
+++ s!:compile0 compiled, 247 + 96 bytes
+++ s!:fully_macroexpand_list compiled, 25 + 12 bytes
+++ s!:fully_macroexpand compiled, 65 + 28 bytes
+++ s!:expandfunction compiled, 1 + 8 bytes
+++ s!:expandflet compiled, 33 + 16 bytes
+++ s!:expandfletvars compiled, 12 + 12 bytes
+++ s!:expandlabels compiled as link to s:expandflet
+++ s!:expandmacrolet compiled as link to s:expandflet
+++ s!:expandprog compiled, 12 + 12 bytes
+++ s!:expandtagbody compiled as link to s:fully_macroexpand_list
+++ s!:expandprogv compiled, 19 + 12 bytes
+++ s!:expandblock compiled, 12 + 12 bytes
+++ s!:expanddeclare compiled, 1 + 8 bytes
+++ s!:expandlet compiled, 33 + 12 bytes
+++ s!:expandlet!* compiled as link to s:expandlet
+++ s!:expandgo compiled, 1 + 8 bytes
+++ s!:expandreturn!-from compiled, 12 + 12 bytes
+++ s!:expandcond compiled, 28 + 12 bytes
+++ s!:expandcase compiled, 36 + 16 bytes
+++ s!:expandeval!-when compiled, 12 + 12 bytes
+++ s!:expandthe compiled, 12 + 12 bytes
+++ s!:expandmv!-call compiled, 12 + 12 bytes
+++ compile compiled, 36 + 20 bytes
+++ c!:printf_oo1w6d8xai6t2 compiled, 15 + 16 bytes
+++ c!:printf1 compiled, 169 + 100 bytes
+++ c!:safeprin compiled, 93 + 56 bytes
+++ c!:valid_fndef compiled, 14 + 20 bytes
+++ c!:valid_list compiled, 16 + 16 bytes
+++ c!:valid_expr compiled, 61 + 36 bytes
+++ c!:cspecform compiled, 9 + 20 bytes
+++ c!:valid_specform compiled, 1 + 8 bytes
+++ c!:alphanumeric compiled, 17 + 8 bytes
+++ c!:reset_gensyms compiled, 100 + 68 bytes
+++ c!:my_gensym compiled, 39 + 36 bytes
+++ c!:newreg compiled, 7 + 16 bytes
+++ c!:startblock compiled, 5 + 16 bytes
+++ c!:outop compiled, 18 + 24 bytes
+++ c!:endblock compiled, 32 + 36 bytes
+++ c!:cval_inner compiled, 71 + 44 bytes
+++ c!:cval compiled, 22 + 28 bytes
+++ c!:start_nested_context compiled, 15 + 32 bytes
+++ c!:end_nested_context compiled, 37 + 44 bytes
+++ c!:clambda compiled, 303 + 108 bytes
+++ c!:locally_bound compiled, 5 + 8 bytes
+++ c!:find_literal compiled, 30 + 16 bytes
+++ c!:catom compiled, 126 + 68 bytes
+++ c!:cjumpif compiled, 69 + 44 bytes
+++ c!:ccall compiled as link to c:ccall1
+++ c!:has_calls compiled, 10 + 20 bytes
+++ c!:has_calls_1 compiled, 77 + 36 bytes
+++ c!:can_reach compiled, 23 + 24 bytes
+++ c!:any_can_reach compiled, 14 + 16 bytes
+++ c!:evalargs compiled, 25 + 12 bytes
+++ c!:ccall1 compiled, 110 + 52 bytes
+++ c!:local_fluidp1 compiled, 22 + 12 bytes
+++ c!:local_fluidp compiled, 13 + 12 bytes
+++ c!:cfndef compiled, 709 + 260 bytes
+++ c!:ccompilesupervisor compiled, 84 + 56 bytes
+++ c!:inv_name compiled, 105 + 36 bytes
+++ c!:ccmpout1 compiled, 24 + 20 bytes
+++ c!:ccmpout1a compiled, 174 + 96 bytes
+++ c!:concat compiled, 21 + 16 bytes
+++ c!:ccompilestart compiled, 215 + 144 bytes
+++ c!-end compiled, 3 + 16 bytes
+++ c!-end1 compiled, 648 + 344 bytes
+++ c!-compile compiled, 44 + 56 bytes
+++ c!:print_opcode compiled, 37 + 12 bytes
+++ c!:print_exit_condition1 compiled, 504 + 164 bytes
+++ c!:flag_exit_label compiled, 51 + 16 bytes
+++ c!:pmovr compiled, 10 + 16 bytes
+++ c!:pmovk compiled, 11 + 16 bytes
+++ c!:pmovk1 compiled, 35 + 32 bytes
+++ c!:preloadenv compiled, 11 + 20 bytes
+++ c!:pldrglob compiled, 11 + 16 bytes
+++ c!:pstrglob compiled, 12 + 16 bytes
+++ c!:pnilglob compiled, 9 + 16 bytes
+++ c!:pnull compiled, 10 + 16 bytes
+++ c!:pfastget compiled, 100 + 68 bytes
+++ c!:pfastflag compiled, 110 + 72 bytes
+++ c!:pcar compiled, 22 + 24 bytes
+++ c!:pcdr compiled, 22 + 24 bytes
+++ c!:pqcar compiled, 10 + 16 bytes
+++ c!:pqcdr compiled, 10 + 16 bytes
+++ c!:patom compiled, 10 + 16 bytes
+++ c!:pnumberp compiled, 10 + 16 bytes
+++ c!:pfixp compiled, 10 + 16 bytes
+++ c!:piminusp compiled, 10 + 16 bytes
+++ c!:pilessp compiled, 11 + 16 bytes
+++ c!:pigreaterp compiled, 11 + 16 bytes
+++ c!:piminus compiled, 10 + 16 bytes
+++ c!:piadd1 compiled, 10 + 16 bytes
+++ c!:pisub1 compiled, 10 + 16 bytes
+++ c!:piplus2 compiled, 16 + 20 bytes
+++ c!:pidifference compiled, 17 + 20 bytes
+++ c!:pitimes2 compiled, 16 + 20 bytes
+++ c!:pmodular_plus compiled, 28 + 28 bytes
+++ c!:pmodular_difference compiled, 28 + 28 bytes
+++ c!:pmodular_minus compiled, 28 + 28 bytes
+++ c!:passoc compiled, 11 + 16 bytes
+++ c!:patsoc compiled, 11 + 16 bytes
+++ c!:pmember compiled, 11 + 16 bytes
+++ c!:pmemq compiled, 11 + 16 bytes
+++ c!:pget compiled, 11 + 16 bytes
+++ c!:pqgetv compiled, 16 + 20 bytes
+++ c!:pqputv compiled, 17 + 20 bytes
+++ c!:prplaca compiled, 17 + 20 bytes
+++ c!:prplacd compiled, 17 + 20 bytes
+++ c!:peq compiled, 11 + 16 bytes
+++ c!:pequal compiled, 16 + 24 bytes
+++ c!:pcall compiled, 314 + 120 bytes
+++ c!:pfluidbind compiled, 43 + 32 bytes
+++ c!:pfluidunbind compiled, 8 + 16 bytes
+++ c!:pgoto compiled, 22 + 24 bytes
+++ c!:pifnull compiled, 8 + 16 bytes
+++ c!:pifatom compiled, 8 + 16 bytes
+++ c!:pifsymbol compiled, 8 + 16 bytes
+++ c!:pifnumber compiled, 8 + 16 bytes
+++ c!:pifizerop compiled, 8 + 16 bytes
+++ c!:pifeq compiled, 10 + 16 bytes
+++ c!:pifequal compiled, 18 + 24 bytes
+++ c!:pifilessp compiled, 10 + 16 bytes
+++ c!:pifigreaterp compiled, 10 + 16 bytes
+++ c!:display_flowgraph1 compiled, 112 + 48 bytes
+++ c!:one_operand compiled, 16 + 28 bytes
+++ c!:two_operands compiled, 21 + 32 bytes
+++ c!:live_variable_analysis compiled, 286 + 116 bytes
+++ c!:insert1 compiled, 8 + 8 bytes
+++ c!:clash compiled, 48 + 20 bytes
+++ c!:build_clash_matrix compiled, 248 + 96 bytes
+++ c!:allocate_registers compiled, 145 + 28 bytes
+++ c!:remove_nops compiled, 198 + 68 bytes
+++ c!:assign compiled, 31 + 32 bytes
+++ c!:insert_tailcall compiled, 183 + 68 bytes
+++ c!:does_return compiled, 68 + 32 bytes
+++ c!:pushpop compiled, 82 + 44 bytes
+++ showblock compiled, 49 + 36 bytes
+++ showblocklist compiled, 16 + 12 bytes
+++ c!:flatten compiled, 97 + 48 bytes
+++ c!:optimise_flowgraph compiled, 634 + 296 bytes
+++ c!:cand compiled, 48 + 24 bytes
+++ c!:ccatch compiled, 4 + 20 bytes
+++ c!:ccompile_let compiled, 4 + 20 bytes
+++ c!:ccond compiled, 124 + 56 bytes
+++ c!:valid_cond compiled, 13 + 16 bytes
+++ c!:cdeclare compiled, 4 + 20 bytes
+++ c!:cde compiled, 4 + 20 bytes
+++ c!:cdefun compiled, 4 + 20 bytes
+++ c!:ceval_when compiled, 4 + 20 bytes
+++ c!:cflet compiled, 4 + 20 bytes
+++ c!:cfunction compiled, 51 + 52 bytes
+++ c!:valid_function compiled, 39 + 24 bytes
+++ c!:cgo compiled, 37 + 32 bytes
+++ c!:cif compiled, 88 + 44 bytes
+++ c!:clabels compiled, 4 + 20 bytes
+++ c!:expand!-let compiled, 64 + 16 bytes
+++ c!:clet compiled, 9 + 16 bytes
+++ c!:valid_let compiled, 15 + 20 bytes
+++ c!:expand!-let!* compiled, 32 + 16 bytes
+++ c!:clet!* compiled, 9 + 16 bytes
+++ c!:clist compiled, 116 + 52 bytes
+++ c!:clist!* compiled, 32 + 16 bytes
+++ c!:ccons compiled, 101 + 56 bytes
+++ c!:cget compiled, 55 + 44 bytes
+++ c!:cflag compiled, 55 + 44 bytes
+++ c!:cgetv compiled, 16 + 24 bytes
+++ c!:cputv compiled, 16 + 24 bytes
+++ c!:cqputv compiled, 22 + 20 bytes
+++ c!:cmacrolet compiled, 4 + 20 bytes
+++ c!:cmultiple_value_call compiled, 4 + 20 bytes
+++ c!:cmultiple_value_prog1 compiled, 4 + 20 bytes
+++ c!:cor compiled, 70 + 44 bytes
+++ c!:cprog compiled, 428 + 140 bytes
+++ c!:valid_prog compiled, 3 + 12 bytes
+++ c!:cprog!* compiled, 4 + 20 bytes
+++ c!:cprog1 compiled, 35 + 40 bytes
+++ c!:cprog2 compiled, 43 + 40 bytes
+++ c!:cprogn compiled, 27 + 16 bytes
+++ c!:cprogv compiled, 4 + 20 bytes
+++ c!:cquote compiled, 44 + 36 bytes
+++ c!:valid_quote compiled, 2 + 12 bytes
+++ c!:creturn compiled, 38 + 44 bytes
+++ c!:csetq compiled, 72 + 56 bytes
+++ c!:cprivate_tagbody compiled, 50 + 28 bytes
+++ c!:cthe compiled, 5 + 12 bytes
+++ c!:cthrow compiled, 4 + 20 bytes
+++ c!:cunless compiled, 77 + 52 bytes
+++ c!:cunwind_protect compiled, 4 + 20 bytes
+++ c!:cwhen compiled, 77 + 52 bytes
+++ c!:expand_map compiled, 263 + 132 bytes
+++ c!:expand_carcdr compiled, 39 + 20 bytes
+++ c!:builtin_one compiled, 20 + 20 bytes
+++ c!:builtin_two compiled, 28 + 20 bytes
+++ c!:rplac compiled, 39 + 24 bytes
+++ c!:narg compiled, 11 + 20 bytes
+++ c!:cplus2 compiled, 71 + 40 bytes
+++ c!:ciplus2 compiled, 68 + 40 bytes
+++ c!:cdifference compiled, 66 + 44 bytes
+++ c!:cidifference compiled, 63 + 44 bytes
+++ c!:ctimes2 compiled, 75 + 36 bytes
+++ c!:citimes2 compiled, 72 + 36 bytes
+++ c!:cminus compiled, 29 + 24 bytes
+++ c!:ceq compiled, 48 + 36 bytes
+++ c!:cequal compiled, 59 + 44 bytes
+++ c!:is_fixnum compiled, 17 + 16 bytes
+++ c!:certainlyatom compiled, 29 + 20 bytes
+++ c!:atomlist1 compiled, 17 + 16 bytes
+++ c!:atomlist compiled, 56 + 32 bytes
+++ c!:atomcar compiled, 19 + 20 bytes
+++ c!:atomkeys1 compiled, 22 + 20 bytes
+++ c!:atomkeys compiled, 56 + 32 bytes
+++ c!:comsublis compiled, 12 + 16 bytes
+++ c!:comassoc compiled, 17 + 20 bytes
+++ c!:commember compiled, 17 + 20 bytes
+++ c!:comdelete compiled, 17 + 20 bytes
+++ c!:ctestif compiled, 33 + 20 bytes
+++ c!:ctestnull compiled, 14 + 12 bytes
+++ c!:ctestatom compiled, 16 + 20 bytes
+++ c!:ctestconsp compiled, 16 + 20 bytes
+++ c!:ctestsymbol compiled, 16 + 20 bytes
+++ c!:ctestnumberp compiled, 16 + 20 bytes
+++ c!:ctestizerop compiled, 16 + 20 bytes
+++ c!:ctesteq compiled, 53 + 24 bytes
+++ c!:ctesteqcar compiled, 53 + 40 bytes
+++ c!:small_number compiled, 17 + 16 bytes
+++ c!:eqvalid compiled, 27 + 28 bytes
+++ c!:ctestequal compiled, 67 + 36 bytes
+++ c!:ctestneq compiled, 67 + 36 bytes
+++ c!:ctestilessp compiled, 20 + 20 bytes
+++ c!:ctestigreaterp compiled, 20 + 20 bytes
+++ c!:ctestand compiled, 41 + 28 bytes
+++ c!:ctestor compiled, 41 + 28 bytes
End of file "$srcdir/compiler.lsp"
+++ FASLEND
Completed FASL files for compiler

nil

t
+++ concat compiled, 24 + 12 bytes

concat

nil

cslprolo

cslrend

t

nil

nil

nil

nil

nil

nil

nil

(nil !*semicol!*)

(nil !*lpar!*)

(nil !*rpar!*)

(nil !*comma!*)

(nil cons)

(nil equal)

(((!= nil setq)) !*colon!*)

(((!= nil leq) (!< nil !*lsqbkt!*)) lessp)

(((!= nil geq) (!> nil !*rsqbkt!*)) greaterp)

1

2

3

4

5

nil

nil

blockstat

ifstat

procstat
+++ begin2 compiled, 18 + 36 bytes

begin2

+++ form redefined
+++ form compiled, 1 + 8 bytes

form

+++ xread redefined
+++ xread compiled, 6 + 16 bytes

xread

+++ xread1 redefined
+++ xread1 compiled, 179 + 36 bytes

xread1

+++ eqcar not defined because of LOSE flag

nil

+++ mksetq redefined
+++ mksetq compiled, 5 + 12 bytes

mksetq

+++ rread redefined
+++ rread compiled, 13 + 28 bytes

rread

+++ rrdls redefined
+++ rrdls compiled, 35 + 32 bytes

rrdls
+++ token compiled, 208 + 92 bytes

token

! 

+++ delcp redefined
+++ delcp compiled, 9 + 20 bytes

delcp
+++ mkstrng compiled, 1 + 8 bytes

mkstrng

+++ seprp not defined because of LOSE flag

nil

+++ scan redefined
+++ scan compiled, 101 + 56 bytes

scan

+++ ifstat redefined
+++ ifstat compiled, 49 + 40 bytes

ifstat

+++ procstat redefined
+++ procstat compiled, 60 + 56 bytes

procstat
+++ blockstat compiled, 59 + 56 bytes

blockstat
+++ mkprog compiled, 5 + 12 bytes

mkprog
+++ gostat compiled, 9 + 16 bytes

gostat

gostat

+++ rlis redefined
+++ rlis compiled, 17 + 24 bytes

rlis
+++ endstat compiled, 7 + 16 bytes

endstat

+++ readprogn redefined
+++ readprogn compiled, 20 + 32 bytes

readprogn

readprogn

nil

nil

nil
+++ whilstat compiled, 48 + 48 bytes

whilstat
+++ while_yxxjw0ff0crr compiled, 38 + 44 bytes

while

whilstat

nil
+++ repeatstat compiled, 48 + 48 bytes

repeatstat
+++ repeat_p0eqbt3rfj3u1 compiled, 45 + 36 bytes

repeat

repeatstat

nil
(#F[synonym-stream nil *terminal-io* 00000000 0000064e 0000064f 00000050
00000000 00000000 0000025a 000006b3 40000000 00000000])(nil)(nil)
+++ mkfil compiled, 20 + 24 bytes
(mkfil)
+++ string!-downcase compiled, 22 + 16 bytes
(string-downcase)(nil)
+++ red!-char!-downcase redefined
+++ red!-char!-downcase compiled, 11 + 12 bytes
(red-char-downcase)(((A . a) (B . b) (C . c) (D . d) (E . e) (F . f) (G . g) (H
. h) (I . i) (J . j) (K . k) (L . l) (M . m) (N . n) (O . o) (P . p) (Q . q) (R
. r) (S . s) (T . t) (U . u) (V . v) (W . w) (X . x) (Y . y) (Z . z)))
+++ concat redefined
+++ concat compiled, 11 + 16 bytes
(concat)
+++ module2!-to!-file compiled, 50 + 40 bytes
(module2-to-file)
+++ inmodule compiled, 31 + 44 bytes
(inmodule)
+++ load!-package!-sources compiled, 49 + 48 bytes
(load-package-sources)(nil)
nil

nil
% module cslprolo;   % CSL dependent code for REDUCE.

% Author: Anthony C. Hearn.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% This file defines functions, variables and declarations needed to
% make REDUCE and the underlying CSL system compatible, and which need
% to be input before the system independent REDUCE source is loaded.

% Support for package creation.

symbolic procedure create!-package(u,v);
   % Make module list u into a package with path v.
   % Second argument is no longer used.
   if null idp car u then typerr(car u,"package name")
   else <<
% If building the bootstrap version report the name of each package.
      if member('cold!-start, lispsystem!*) then <<
          if !*backtrace then << !*echo := t; enable!-errorset(3,3) >>;
          terpri(); princ "+++ Creating a package: "; print car u >>;
      put(car u,'package,u);
      car u >>;
+++ create!-package compiled, 43 + 60 bytes
create-package

% create!-package('(cslprolo),nil);

symbolic procedure evload l;
  begin
     while l do <<
        load!-module car l;
        l := cdr l >>
  end;
+++ evload redefined
+++ evload compiled, 11 + 8 bytes
evload

% The following are built into CSL and so any definition found within
% the REDUCE sources should be viewed as "portability" but should be ignored.

% note that the elementary functions within CSL are (almost always)
% implemented using "crlibm" the "correctly rounded mathematical library"
% which is certainly higher quality than the portable code within Reduce
% and often gets more accurate answers that the elementary functions provided
% by vendors. Its use should also ensure that CSL delivers bit-identical
% results on any platform it runs on.

if memq('vsl, lispsystem!*) then
   flag('(atsoc copy eqcar gcdn geq lastpair leq mkquote neq reversip
       rplacw iplus itimes iplus2 itimes2 iadd1 isub1 iminus iminusp
       idifference iquotient iremainder ilessp igreaterp ileq igeq
       izerop ionep apply1 apply2 apply3
% modular!-difference
% modular!-minus modular!-number modular!-plus modular!-quotient
% modular!-reciprocal modular!-times modular!-expt set!-small!-modulus
% acos acosd acosh acot acotd acoth acsc acscd acsch asec asecd
% asech asin asind asinh atan atand atan2 atan2d atanh cbrt
       cos
% cosd cosh cot cotd coth csc cscd csch
       exp expt
% hypot ln
       log
% logb log10 sec secd sech
       sin
% sind sinh
       sqrt
% tan tand tanh
       fix
       ceiling floor round clrhash puthash gethash remhash
% princ!-upcase princ!-downcase
       union intersection
       threevectorp
       sort
% stable!-sort stable!-sortip
       lengthc prin2 princ substq),'lose)
else
   flag('(atsoc copy eqcar gcdn geq lastpair leq mkquote neq reversip
       rplacw iplus itimes iplus2 itimes2 iadd1 isub1 iminus iminusp
       idifference iquotient iremainder ilessp igreaterp ileq igeq
       izerop ionep apply1 apply2 apply3 modular!-difference
       modular!-minus modular!-number modular!-plus modular!-quotient
       modular!-reciprocal modular!-times modular!-expt set!-small!-modulus
       acos acosd acosh acot acotd acoth acsc acscd acsch asec asecd
       asech asin asind asinh atan atand atan2 atan2d atanh cbrt cos
       cosd cosh cot cotd coth csc cscd csch exp expt hypot ln log
       logb log10 sec secd sech sin sind sinh sqrt tan tand tanh fix
       ceiling floor round clrhash puthash gethash remhash
       princ!-upcase princ!-downcase union intersection
       threevectorp
       sort stable!-sort stable!-sortip lengthc prin2 princ substq
       string!-store1 string!-store2 string!-store3 string!-store4), 'lose);nil


!*argnochk := t;t

% At some early stages in the bootstrapping the variable lispsystem!*
% is not available but I want to be able to tell that I am building on
% PSL as distinct from any other Lisp. This global value will help!

global '(!*psl !*csl);nil
!*psl := nil;nil
!*csl := t;t

% endmodule;

end;nil
nil

% Authors: Arthur Norman

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%

% $Id: revision.red 5411 2020-09-27 20:03:06Z arthurcnorman $

% This file will be automatically updated by the code in scripts/commit.sh
% to show the latest subversion revision number.

fluid '(revision!*);nil

revision!* := 5411;5411

end;nil
nil

t


(load!-package!-sources 'rlisp 'rlisp)% module rlisp;  % Header module for rlisp package.

% Author: Anthony C. Hearn.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


global '(date!* patch!-date!* version!*);nil

create!-package('(rlisp module newtok rsupport slfns superv tok xread
                  lpri parser block form proc forstat loops statmisc
                  smacro io infix switch where list array inter charname
                  rprintf),
                 nil);
+++ Creating a package: rlisp
rlisp

flag('(rlisp), 'core!_package);nil

date!* := date();28-Oct-20

fluid '(revision!*);nil
if null version!* then <<
  if null revision!* then version!* := "REDUCE"
  else version!* :=
    compress ('!" . append (explode2 "REDUCE (",
      append(explode2 revision!*, '(!) !")))) >>;REDUCE (5411)

% Hook to Rlisp88.

put('rlisp88, 'simpfg, '((t (load!-package 'rlisp88) (rlisp88!_on))));((t (
load-package (quote rlisp88)) (rlisp88_on)))

flag('(rlisp88), 'switch);nil

% endmodule;

end;nil% module module; % Support for module and package use.

% Author: Anthony C. Hearn.

% Copyright (c) 1990 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% The code here is loaded rather early in the bootstrap process, and so
% is processed by a provisional rather than the final version of the
% rlisp parser. Most features of the language are available, but do careful
% testing after any edits in case you faul foul of any of the restrictions!

fluid '(!*backtrace !*mode !*faslp);nil

global '(exportslist!* importslist!* loaded!-packages!* loaded!-modules!*
         mode!-list!*);nil

!*mode := 'symbolic;symbolic   % initial value.

remprop('exports,'stat);nil

remprop('imports,'stat);nil

remprop('module,'stat);nil

symbolic procedure exports u;
   begin exportslist!* := union(u,exportslist!*) end;
+++ exports redefined
+++ exports compiled, 5 + 16 bytes
exports

symbolic procedure imports u;
   begin importslist!* := union(u,importslist!*) end;
+++ imports redefined
+++ imports compiled, 5 + 16 bytes
imports

symbolic procedure module u;
   % Sets up a module definition.
   begin
      mode!-list!* := !*mode . mode!-list!*;
      !*mode := 'symbolic
   end;
+++ module redefined
+++ module compiled, 7 + 20 bytes
module

symbolic procedure endmodule;
   begin
      if null mode!-list!*
        then rederr  "ENDMODULE called outside module";
      exportslist!* := nil;
      importslist!* := nil;
      !*mode := car mode!-list!*;
      mode!-list!* := cdr mode!-list!*
   end;
+++ endmodule redefined
+++ endmodule compiled, 18 + 32 bytes
endmodule

deflist('((exports rlis) (imports rlis) (module rlis)),'stat);(exports imports
module)

put('endmodule,'stat,'endstat);endstat

flag('(endmodule),'go);nil

flag('(module endmodule),'eval);nil

put('xmodule,'newnam,'module);module   % Hook for module extensions.

% Support for package loading.

put('load,'stat,'rlis);rlis

put('load,'formfn,'formload);formload


symbolic procedure formload(u,vars,mode);
   if mode = 'symbolic then
      list('progn,
% Adapted to maintain loaded!-modules!*
           list('setq, 'loaded!-modules!*,
              list('union, 'loaded!-modules!*, mkquote cdr u)),
           list('evload, mkquote cdr u))
   else list('load!_package, mkquote cdr u);
+++ formload compiled, 44 + 40 bytes
formload

symbolic procedure load!-package u;
   begin scalar x,y;
      if stringp u then return load!-package intern u
% And earlier comment said 'intern intern is needed for, e.g., "../huhu".'
% but when I try both PSL and CSL the string "../huhu" when passed to intern
% yields the symbol !.!.!/huhu as expected...
       else if null idp u then rederr list(u,"is not a package name")
       else if memq(u,loaded!-packages!*)
%       then << lprim list("Package",u,"already loaded"); return u >>
        then return u
       else if or(atom(x:= errorset(list('evload,list('quote,list u)),
                               nil,!*backtrace)),
                  cdr x)
        then rederr
           list("error in loading package",u,"or package not found");
       loaded!-packages!* := u . loaded!-packages!*;
       loaded!-modules!* := union(loaded!-modules!*, list u);
       x := get(u,'package);
       if x then x := cdr x;
       while x do <<
          if null atom get(car x,'package) then load!-package car x
          else if or(atom(y := errorset(list('evload,
                                            list('quote,list car x)),
                                       nil,!*backtrace)),
                     cdr y)
           then rederr list("module",car x,"of package",u,
                            "cannot be loaded");
         loaded!-modules!* := union(loaded!-modules!*, list car x);
         x := cdr x >>;
      return install!-patches u
   end;
+++ load!-package compiled, 144 + 80 bytes
load-package

% Now a more user-friendly version.

remprop('load!_package,'stat);nil

remprop('packages!_to!_load,'stat);nil

symbolic procedure load!_package u;
   begin
      while u do <<
         load!-package car u;
         u := cdr u >>
   end;
+++ load_package compiled, 10 + 12 bytes
load_package

symbolic procedure packages!_to!_load u;
   %% FJW: Load other packages at package load time only, i.e. do not
   %% load during building (hence not to be flagged eval).
   if null !*faslp then load!_package u;
+++ packages_to_load compiled, 7 + 16 bytes
packages_to_load

put('load!_package,'stat,'rlis);rlis

put('packages!_to!_load,'stat,'rlis);rlis

flag('(load!-package load!_package),'eval);nil


% Support for patching REDUCE sources. The whole mechanism set up here is
% now no longer used. In the past when distribution was on CD (or magnetic
% tape, or on large piles of floppy disc) users received a base version
% of the system and then relativly small patch files could be distributed
% to update the system or correct errors. Now with the faster networks
% this whole idea is not so necessary.

symbolic procedure patchstat;
   % Read a patch for a given package.
   begin scalar !*mode,u,v,x,y,z,z2;
      x := scan();   % Package name.
      scan();        % Remove semicolon.
 a:   !*mode := 'symbolic;
      y := xread nil;
      if eqcar(y,'symbolic) then y := cadr y
       else if flagpcar(y,'modefn)
        then << !*mode := car y; y := cadr y >>;
      if eq(y,'endpatch) then <<
         u := name!-for!-patched!-version(x, z);
         z2 := list('de,u,nil,'progn . reversip z) . z2;
         z2 := list('patches!-load!-check,mkquote x,mkquote u) . z2;
         return ('patch . reversip z2) >>
      else if eqcar(y,'procedure) then <<
         v := cadr y;
         u := name!-for!-patched!-version(v, y);
         z := list('instate!-patches,mkquote v,mkquote u,mkquote x) . z;
         z2  := convertmode(('procedure . u . cddr y),nil,
                             'symbolic,!*mode) . z2 >>
      else z := convertmode(y,nil,'symbolic,!*mode) . z;
      go to a;
   end;
+++ patchstat compiled, 168 + 80 bytes
patchstat

symbolic procedure name!-for!-patched!-version(name, extra);
   % hashtagged!-name (in CSL) constructs a name that starts with NAME but
   % then continues with a hash value based on EXTRA. The improbability of
   % hash collisions then makes it reasonable to use an interned symbol.
   if member('psl, lispsystem!*) then gensym()
    else hashtagged!-name(name,extra);
+++ name!-for!-patched!-version compiled, 12 + 24 bytes
name-for-patched-version

symbolic procedure instate!-patches(new,old,pkg);
  begin scalar x;
     x := getd old;
     if x then putd(new,car x,cdr x)
     else rerror('module,1,list(new,"has a badly set-up patch"));
     return nil
  end;
+++ instate!-patches compiled, 26 + 32 bytes
instate-patches

symbolic procedure install!-patches u;
   if u = 'patches then nil
   else if (u := get(u,'patchfn)) then
   begin scalar !*usermode,!*redefmsg;
      eval list u
   end;
+++ install!-patches compiled, 23 + 24 bytes
install-patches

symbolic procedure patches!-load!-check(u,v);
   begin
      put(u,'patchfn,v);
      if memq(u,loaded!-packages!*) then install!-patches u
   end;
+++ patches!-load!-check compiled, 14 + 24 bytes
patches-load-check

put('patch,'stat,'patchstat);patchstat

symbolic procedure formpatch(u,vars,mode);
   'progn . cdr u;
+++ formpatch compiled, 4 + 12 bytes
formpatch

put('patch,'formfn,'formpatch);formpatch

% endmodule;

end;nilmodule newtok;nil  % Functions for introducing infix tokens to the system.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*msg !*redeflg!*);nil

global '(preclis!* fixedpreclis!*);nil

% Several operators in REDUCE are used in an infix form (e.g., +,- ).
% The internal alphanumeric names associated with these operators are
% introduced by the function NEWTOK defined below.  This association,
% and the precedence of each infix operator, is initialized in this
% section.  We also associate printing characters with each internal
% alphanumeric name as well.

fixedpreclis!* := '(where !*comma!* setq);(where *comma* setq)

preclis!*:= '(or and member memq equal neq eq geq greaterp leq   % not
              lessp freeof plus difference times quotient expt cons);(or and
member memq equal neq eq geq greaterp leq lessp freeof plus difference times
quotient expt cons)

deflist ('(
%  (not not)
   (plus plus)
   (difference minus)
   (minus minus)
   (times times)
   (quotient recip)
   (recip recip)
 ), 'unary);(plus difference minus times quotient recip)

flag ('(and or !*comma!* plus times),'nary);nil

flag ('(cons setq plus times),'right);nil

deflist ('((minus plus) (recip times)),'alt);(minus recip)

symbolic procedure mkprec;
   begin scalar x,y,z;
        x := append(fixedpreclis!*,preclis!*);
        y := 1;
    a:  if null x then return nil;
        put(car x,'infix,y);
        put(car x,'op,list list(y,y));   % for RPRINT.
        if z := get(car x,'unary) then put(z,'infix,y);
        if and(z,null flagp(z,'nary)) then put(z,'op,list(nil,y));
        x := cdr x;
        y := add1 y;
        go to a
   end;
+++ mkprec compiled, 66 + 36 bytes
mkprec

mkprec();nil
% From here onwards the precedences of infix operators are established.

symbolic procedure newtok u;
   begin scalar !*redeflg!*,x,y;
      if atom u or atom car u or null idp caar u
        then typerr(u,"NEWTOK argument");
      % set up SWITCH* property.
      put(caar u,'switch!*,
          cdr newtok1(car u,cadr u,get(caar u,'switch!*)));
      % set up PRTCH property.
      y := intern list2string car u;
      if !*redeflg!* then lprim list(y,"redefined");
      put(cadr u,'prtch,y);
      if x := get(cadr u,'unary) then put(x,'prtch,y)
   end;
+++ newtok compiled, 82 + 60 bytes
newtok

symbolic procedure newtok1(charlist,name,propy);
      if null propy then lstchr(charlist,name)
       else if null cdr charlist
        then begin
                if cdr propy and !*msg then !*redeflg!* := t;
                return list(car charlist,car propy,name)
             end
       else car charlist . newtok2(cdr charlist,name,car propy)
                         . cdr propy;
+++ newtok1 compiled, 34 + 28 bytes
newtok1

symbolic procedure newtok2(charlist,name,assoclist);
   if null assoclist then list lstchr(charlist,name)
    else if car charlist eq caar assoclist
     then newtok1(charlist,name,cdar assoclist) . cdr assoclist
    else car assoclist . newtok2(charlist,name,cdr assoclist);
+++ newtok2 compiled, 40 + 16 bytes
newtok2

symbolic procedure consescc u;
   if null u then nil else '!! . car u . consescc cdr u;
+++ consescc compiled, 18 + 16 bytes
consescc

symbolic procedure lstchr(u,v);
   if null cdr u then list(car u,nil,v)
    else list(car u,list lstchr(cdr u,v));
+++ lstchr compiled, 19 + 8 bytes
lstchr

newtok '((!$) !*semicol!*);nil
newtok '((!;) !*semicol!*);nil
newtok '((!+) plus);nil
newtok '((!-) difference);nil
newtok '((!*) times);nil
newtok '((!^) expt);nil
newtok '((!* !*) expt);nil
newtok '((!/) quotient);nil
newtok '((!=) equal);nil
newtok '((!,) !*comma!*);nil
newtok '((!() !*lpar!*);nil
newtok '((!)) !*rpar!*);nil
newtok '((!:) !*colon!*);nil
newtok '((!: !=) setq);nil
newtok '((!.) cons);nil
newtok '((!<) lessp);nil
newtok '((!< !=) leq);nil
newtok '((![) !*lsqbkt!*);nil
newtok '((!< !<) !*lsqbkt!*);nil
newtok '((!>) greaterp);nil
newtok '((!> !=) geq);nil
newtok '((!]) !*rsqbkt!*);nil
newtok '((!> !>) !*rsqbkt!*);nil
newtok '((!/ !*) !*comment!*);nil

% ... and from here on the full set of infix operators may be used with
% their standard notation. So the ONLY files where (eg) "+" may not be used
% will be support/build.red, support/XXXprolo.red, rlisp/rlisp.red
% rlisp/module.red and this file.

put('expt,'prtch,'!*!*);**   % To ensure that FORTRAN output is correct.

flag('(difference minus plus setq),'spaced);nil

flag('(newtok),'eval);nil

endmodule;nil

end;nilmodule rsupport;nil   % Basic functions needed to support RLISP and REDUCE.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*backtrace !*comp);nil

symbolic procedure aconc(u,v);
   % Adds element v to the tail of u. u is destroyed in process.
   nconc(u,list v);
+++ aconc redefined
+++ aconc compiled, 8 + 8 bytes
aconc

symbolic procedure arrayp u; get(u,'rtype) = 'array;
+++ arrayp redefined
+++ arrayp compiled, 6 + 12 bytes
arrayp

symbolic procedure atsoc(u,v);
   % This definition allows for a search of a general list.
   % The definition given here is recursive, and for long searches the
   % stack use issues rely on either a built-in atsoc being available and
   % used or on tail-recursion optimistaion in the compiler.
   if null v then nil
    else if eqcar(car v,u) then car v
    else atsoc(u,cdr v);nil

symbolic procedure copyd(new,old);
   % Copy the function definition from old id to new.
   begin
      scalar x;
      x := getd old;
      if null x then
         rerror('rlisp, 1, list(old, "has no definition in copyd"));
      putd(new, car x, cdr x);
      return new
   end;
+++ copyd redefined
+++ copyd compiled, 24 + 32 bytes
copyd

symbolic procedure eqcar(u,v); null atom u and car u eq v;nil

symbolic procedure errorset!*(!~u!~,!~v!~); errorset(!~u!~,!~v!~,!*backtrace);
+++ errorset!* redefined
+++ errorset!* compiled, 7 + 12 bytes
errorset*

symbolic procedure errorset2 !~u!~;
   begin
      scalar !*protfg;
      !*protfg := t;
      return errorset(!~u!~, nil, nil)
   end;
+++ errorset2 redefined
+++ errorset2 compiled, 10 + 12 bytes
errorset2

symbolic procedure flagpcar(u,v);
   null atom u and idp car u and flagp(car u,v);nil

symbolic procedure idlistp u;
   % True if u is a list of id's.
   null u or null atom u and idp car u and idlistp cdr u;
+++ idlistp redefined
+++ idlistp compiled, 16 + 16 bytes
idlistp

symbolic procedure listp u;
   % Returns T if U is a top level list.
   null u or null atom u and listp cdr u;
+++ listp redefined
+++ listp compiled, 10 + 12 bytes
listp

symbolic procedure mkprog(u,v); 'prog . (u . v);
+++ mkprog redefined
+++ mkprog compiled, 5 + 12 bytes
mkprog

symbolic procedure mkquote u; list('quote,u);nil

symbolic procedure mksetq(u,v);
   if atom u then list('setq,u,v)
    else begin
       scalar x;
       if (x := get(car u,'setfn)) then return apply2(x,u,v)
        else typerr(u,"assignment argument")
    end;
+++ mksetq redefined
+++ mksetq compiled, 22 + 24 bytes
mksetq

symbolic procedure pairvars(u, vars, mode);
   % Sets up pairings of parameters and modes.
   begin
      scalar x;
      while u do <<
         if null idp car u or get(car u, 'infix) or get(car u, 'stat) then
            symerr(list("Invalid parameter:", car u), nil);
         x := (car u . mode) . x;
         u := cdr u >>;
      return append(reversip!* x, vars)
   end;
+++ pairvars compiled, 40 + 24 bytes
pairvars

symbolic procedure prin2t u; << prin2 u; terpri(); u >>;
+++ prin2t redefined
+++ prin2t compiled, 6 + 12 bytes
prin2t

symbolic procedure princ u; prin2 u;nil

symbolic procedure putc(name, type, body);
   % Defines a non-standard function, such as an inline. Returns NAME.
   begin
      if !*comp and flagp(type, 'compile) and getd 'compd then
         compd(name, type, body)
      else put(name, type, body);
      return name
   end;nil

% flag('(putc),'eval);

symbolic procedure reversip u;
   begin
      scalar x, y;
      while u do <<
         x := cdr u;
         y := rplacd(u,y);
         u := x >>;
      return y
   end;nil

symbolic procedure smemq(u,v);
   % True if id U is a member of V at any level (excluding quoted
   % expressions).
   if atom v then u eq v
   else if car v = 'quote then nil
   else smemq(u,car v) or smemq(u,cdr v);nil

symbolic procedure ssubst(a, b, c);
   % Substitute a in place of b in c, excluding within quoted expressions.
   if b = c then a
   else if atom c or eqcar(c, 'quote) then c
   else ssubst(a, b, car c) . ssubst(a, b, cdr c);
+++ ssubst compiled, 32 + 12 bytes
ssubst

symbolic procedure subsetp(u,v);
   % True if u is a subset of v.
   null u or car u member v and subsetp(cdr u,v);
+++ subsetp redefined
+++ subsetp compiled, 15 + 12 bytes
subsetp

symbolic procedure union(x,y);
   if null x then y
   else union(cdr x, if car x member y then y else car x . y);nil

symbolic procedure intersection(u,v);
   % This definition is consistent with PSL.
   if null u then nil
   else if car u member v then
      car u . intersection(cdr u,delete(car u,v))
   else intersection(cdr u,v);nil

% The following definition have been coded to be NaN-safe even though that
% may hurt speed.
% I rather hope that these definitions are ones where Lisp-provided
% versions are used instead.

symbolic procedure u>=v; u>v or u=v;nil

symbolic procedure u<=v; u<v or u=v;nil

symbolic procedure u neq v; null(u=v);nil

symbolic procedure setdiff(u,v);
   if null v then u
   else if null u then nil
   else setdiff(delete(car v, u), cdr v);
+++ setdiff redefined
+++ setdiff compiled, 15 + 8 bytes
setdiff

% List changing alternates (may also be defined as copying functions).

symbolic procedure aconc!*(u,v); nconc(u,list v);
+++ aconc!* redefined
+++ aconc!* compiled, 8 + 8 bytes
aconc*  % append(u,list v);

symbolic procedure nconc!*(u,v); nconc(u,v);
+++ nconc!* compiled as link to nconc
nconc*       % append(u,v);

symbolic procedure reversip!* u; reversip u;
+++ reversip!* compiled as link to reversip
reversip*       % reverse u;

symbolic procedure rplaca!*(u,v); rplaca(u,v);
+++ rplaca!* compiled as link to rplaca
rplaca*     % v . cdr u;

symbolic procedure rplacd!*(u,v); rplacd(u,v);
+++ rplacd!* compiled as link to rplacd
rplacd*     % car u . v;

% The following functions should be provided in the compiler for
% efficient coding.

symbolic procedure lispapply(u,v);
   % I'd like to use idp in the following test, but the TPS package
   % stores code pointers on property lists which then get used here.
   if null atom u then
      rerror('rlisp,2,list("Apply called with non-id arg",u))
   else apply(u,v);
+++ lispapply redefined
+++ lispapply compiled, 18 + 28 bytes
lispapply

symbolic procedure lispeval u; eval u;
+++ lispeval compiled as link to eval
lispeval

symbolic procedure apply1(u,v); apply(u,list v);nil

symbolic procedure apply2(u,v,w); apply(u,list(v,w));nil

symbolic procedure apply3(u,v,w,x); apply(u,list(v,w,x));nil

% The following function is needed by several modules. It is more
% REDUCE-specific than other functions in this module, but since it
% needs to be defined early on, it might as well go here.

symbolic procedure gettype u;
   % Returns a REDUCE-related type for the expression U.
   % It needs to be more table driven than the current definition.
   if numberp u then 'number
   else if null atom u or null u or null idp u then 'form
   else if get(u,'simpfn) then 'operator
   % opfn property indicates an algebraic procedure
   else if flagp(u,'opfn) then 'algebraic!_procedure
   %taken out again as it messes up assist XXX For the moment, treat psopfn like simpfn
   %else if get(u,'psopfn) then 'operator
   % what should be done about evfn?
   %% else if get(u,'evfn) then xxxxxx
   else if get(u,'avalue) then car get(u,'avalue)
   else if getd u then 'procedure
   else if globalp u then 'global
   else if fluidp u then 'fluid
   else if flagp(u,'parm) then 'parameter
   else get(u,'rtype);
+++ gettype compiled, 81 + 60 bytes
gettype

% The following function maps reserved identifiers to internal names.
% This is needed for t and nil, and possibly others.

symbolic procedure map!-reserved!-id u;
   get(u,'map!-reserved) or u;
+++ map!-reserved!-id compiled, 7 + 12 bytes
map-reserved-id

% The same for a list of variables

symbolic procedure map!-reserved!-ids l;
   begin
      scalar v;
      while l do <<
         v := map!-reserved!-id car l . v;
         l := cdr l >>;
      return reversip v
   end;
+++ map!-reserved!-ids compiled, 17 + 12 bytes
map-reserved-ids    

symbolic procedure get!-print!-name u;
   idp u and get(u,'oldnam) or u;
+++ get!-print!-name redefined
+++ get!-print!-name compiled, 11 + 12 bytes
get-print-name

% If there is an error while a bootstrap version of Reduce is being built
% the disgnostics associated with it can be unhelpful. Providing a dummy
% print function here may help...

symbolic procedure assgnpri(u, v, w);
 << terpri();
    prin2t "Bootstrap version of assgnpri:";
    print u;
    print v;
    print w;
    nil >>;
+++ assgnpri compiled, 15 + 16 bytes
assgnpri

% It looks to me as if this name-mapping was an idea that was being looked
% at but never ended up activated...

%put('t,'map!-reserved,'t!-reserved);
%put('t!-reserved,'oldnam,'t);

%% nil will be done later, needs more modifications to the parser
%put('nil,'map!-reserved,'nil!-reserved);
% The following doesn work, as get('reserved!-nil,'oldnam) returns nil
%put('nil!-reserved,'oldnam,'nil);

endmodule;nil

end;nilmodule slfns;nil  % Complete list of Standard LISP functions.

% Author: Anthony C. Hearn.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*argnochk);nil
global '(slfns!*);nil

slfns!* := '(
        (abs 1)
        (add1 1)
        (append 2)
        (apply 2)
        (assoc 2)
        (atom 1)
        (car 1)
        (cdr 1)
        (caar 1)
        (cadr 1)
        (cdar 1)
        (cddr 1)
        (caaar 1)
        (caadr 1)
        (cadar 1)
        (caddr 1)
        (cdaar 1)
        (cdadr 1)
        (cddar 1)
        (cdddr 1)
        (caaaar 1)
        (caaadr 1)
        (caadar 1)
        (caaddr 1)
        (cadaar 1)
        (cadadr 1)
        (caddar 1)
        (cadddr 1)
        (cdaaar 1)
        (cdaadr 1)
        (cdadar 1)
        (cdaddr 1)
        (cddaar 1)
        (cddadr 1)
        (cdddar 1)
        (cddddr 1)
        (close 1)
        (codep 1)
        (compress 1)
        (cons 2)
        (constantp 1)
        (de 3)
        (deflist 2)
        (delete 2)
%       (df 3)                     conflicts with algebraic operator DF
        (difference 2)
        (digit 1)
        (divide 2)
        (dm 3)
%       (dn 3)
%       (ds 3)
        (eject 0)
        (eq 2)
        (eqn 2)
        (equal 2)
        (error 2)
        (errorset 3)
        (eval 1)
        (evlis 1)
        (expand 2)
        (explode 1)
        (expt 2)
        (fix 1)
        (fixp 1)
        (flag 2)
        (flagp 2)
        (float 1)
        (floatp 1)
        (fluid 1)
        (fluidp 1)
        (function 1)
        (gensym 0)
        (get 2)
        (getd 1)
        (getv 2)
        (global 1)
        (globalp 1)
        (go 1)
        (greaterp 2)
        (idp 1)
        (intern 1)
        (length 1)
        (lessp 2)
        (linelength 1)
        (liter 1)
        (lposn 0)
        (map 2)
        (mapc 2)
        (mapcan 2)
        (mapcar 2)
        (mapcon 2)
        (maplist 2)
        (max2 2)
        (member 2)
        (memq 2)
        (minus 1)
        (minusp 1)
        (min2 2)
        (mkvect 1)
        (nconc 2)
        (not 1)
        (null 1)
        (numberp 1)
        (onep 1)
        (open 2)
        (pagelength 1)
        (pair 2)
        (pairp 1)
        (plus2 2)
        (posn 0)
        (print 1)
        (prin1 1)
        (prin2 1)
        (prog2 2)
        (put 3)
        (putd 3)
        (putv 3)
        (quote 1)
        (quotient 2)
        (rds 1)
        (read 0)
        (readch 0)
        (remainder 2)
        (remd 1)
        (remflag 2)
        (remob 1)
        (remprop 2)
        (return 1)
        (reverse 1)
        (rplaca 2)
        (rplacd 2)
        (sassoc 3)
        (set 2)
        (setq 2)
        (stringp 1)
        (sublis 2)
        (subst 3)
        (sub1 1)
        (terpri 0)
        (times2 2)
        (unfluid 1)
        (upbv 1)
        (vectorp 1)
        (wrs 1)
        (zerop 1)
        );((abs 1) (add1 1) (append 2) (apply 2) (assoc 2) (atom 1) (car 1) (cdr
1) (caar 1) (cadr 1) (cdar 1) (cddr 1) (caaar 1) (caadr 1) (cadar 1) (caddr 1) (
cdaar 1) (cdadr 1) (cddar 1) (cdddr 1) (caaaar 1) (caaadr 1) (caadar 1) (caaddr
1) (cadaar 1) (cadadr 1) (caddar 1) (cadddr 1) (cdaaar 1) (cdaadr 1) (cdadar 1)
(cdaddr 1) (cddaar 1) (cddadr 1) (cdddar 1) (cddddr 1) (close 1) (codep 1) (
compress 1) (cons 2) (constantp 1) (de 3) (deflist 2) (delete 2) (difference 2)
(digit 1) (divide 2) (dm 3) (eject 0) (eq 2) (eqn 2) (equal 2) (error 2) (
errorset 3) (eval 1) (evlis 1) (expand 2) (explode 1) (expt 2) (fix 1) (fixp 1)
(flag 2) (flagp 2) (float 1) (floatp 1) (fluid 1) (fluidp 1) (function 1) (
gensym 0) (get 2) (getd 1) (getv 2) (global 1) (globalp 1) (go 1) (greaterp 2) (
idp 1) (intern 1) (length 1) (lessp 2) (linelength 1) (liter 1) (lposn 0) (map 2
) (mapc 2) (mapcan 2) (mapcar 2) (mapcon 2) (maplist 2) (max2 2) (member 2) (
memq 2) (minus 1) (minusp 1) (min2 2) (mkvect 1) (nconc 2) (not 1) (null 1) (
numberp 1) (onep 1) (open 2) (pagelength 1) (pair 2) (pairp 1) (plus2 2) (posn 0
) (print 1) (prin1 1) (prin2 1) (prog2 2) (put 3) (putd 3) (putv 3) (quote 1) (
quotient 2) (rds 1) (read 0) (readch 0) (remainder 2) (remd 1) (remflag 2) (
remob 1) (remprop 2) (return 1) (reverse 1) (rplaca 2) (rplacd 2) (sassoc 3) (
set 2) (setq 2) (stringp 1) (sublis 2) (subst 3) (sub1 1) (terpri 0) (times2 2)
(unfluid 1) (upbv 1) (vectorp 1) (wrs 1) (zerop 1))

if !*argnochk then deflist(slfns!*,'number!-of!-args);(abs add1 append apply
assoc atom car cdr caar cadr cdar cddr caaar caadr cadar caddr cdaar cdadr cddar
cdddr caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr cdaaar cdaadr
cdadar cdaddr cddaar cddadr cdddar cddddr close codep compress cons constantp de
deflist delete difference digit divide dm eject eq eqn equal error errorset eval
evlis expand explode expt fix fixp flag flagp float floatp fluid fluidp function
gensym get getd getv global globalp go greaterp idp intern length lessp
linelength liter lposn map mapc mapcan mapcar mapcon maplist max2 member memq
minus minusp min2 mkvect nconc not null numberp onep open pagelength pair pairp
plus2 posn print prin1 prin2 prog2 put putd putv quote quotient rds read readch
remainder remd remflag remob remprop return reverse rplaca rplacd sassoc set
setq stringp sublis subst sub1 terpri times2 unfluid upbv vectorp wrs zerop)

endmodule;nil

end;nilmodule superv;nil % REDUCE supervisory functions.

% Author: Anthony C. Hearn.

% Modified by: Jed B. Marti, Francis J. Wright.

% Copyright (c) 1998 Anthony C. Hearn.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*debug
        !*defn
        !*demo
        !*echo
        !*errcont
        !*int
        !*lisp!_hook
        !*mode
        !*output
        !*pret
        !*reduce4
        !*slin
        !*time
        !*rlisp88
        ifl!*
        curline!*
        dfprint!*
        peekchar!*
        errmsg!*
        lispsystem!*
        loopdelimslist!*
        lreadfn!*
        newrule!*
        semic!*
        tslin!*
        !*libreduce!_active);nil

global '(!$eof!$
         !*byeflag!*
         !*extraecho
         !*lessspace
         !*micro!-version
         !*nosave!*
         !*strind
         !*struct
         cloc!*
         cmsg!*
         crbuf!*
         crbuflis!*
         crbuf1!*
         cursym!*
         curescaped!*
         eof!*
         erfg!*
         forkeywords!*
         ipl!*
         initl!*
         inputbuflis!*
         key!*
         ofl!*
         opl!*
         ogctime!*
         otime!*
         ogctime1!*
         otime1!*
         ogctime2!*
         otime2!*
         ogctime3!*
         otime3!*
         program!*
         programl!*
         promptexp!*
         repeatkeywords!*
         resultbuflis!*
         st!*
         statcounter
         symchar!*
         tok!*
         ttype!*
         whilekeywords!*
         ws);nil

!*output := t;t
eof!* := 0;0
initl!* := '(fname!* outl!*);(fname* outl*)
statcounter := 0;0

% The true REDUCE supervisory function is BEGIN, again defined in the
% system dependent part of this program.  However, most of the work is
% done by BEGIN1, which is called by BEGIN for every file encountered
% on input;

symbolic procedure errorp u;
   %returns true if U is an ERRORSET error format;
   atom u or cdr u;
+++ errorp redefined
+++ errorp compiled, 6 + 12 bytes
errorp

symbolic procedure printprompt u;
   %Prints the prompt expression for input;
   << ofl!* and wrs nil; prin2 u; ofl!* and wrs cdr ofl!* >>;nil

symbolic procedure setcloc!*;
   % Used to set for file input a global variable CLOC!* to dotted pair
   % of file name and dotted pair of line and page being read.
   % Currently a place holder for system specific function, since not
   % supported in Standard LISP.  CLOC!* is used in the INTER and RCREF
   % modules.
   cloc!* := if null ifl!* then nil else car ifl!* . (1 . curline!*);
+++ setcloc!* redefined
+++ setcloc!* compiled, 14 + 24 bytes
setcloc*

symbolic procedure commdemo;
   begin scalar echo,x,y,z,!*demo;
      echo := !*echo;
      !*echo := nil;
      x := ifl!*;
      terpri();
      rds nil;
      y:=readch();
      if null seprp y then
             % Read command line from terminal.
          begin scalar crbuf,crbuf1,crchar,ifl;
                crbuf := crbuf!*;
                crbuf!* := nil;
                crbuf1 := crbuf1!*;
                crbuf1!* := list y;
                crchar := crchar!*;
                crchar!* := '! ;
                ifl := ifl!*;
                ifl!* := nil;
                z := errorset!*('(command),t);
                z := if errorp z then '(algebraic(aeval 0))
                     else car z;
                     % eat rest of line quietly.
                while (y := readch() neq !$eol!$ and
                       y neq !$eof!$) do nil;
                rds cadr x;
                crbuf!* := crbuf;
                crbuf1!* := crbuf1;
                crchar!* := crchar;
                ifl!* := ifl;
                !*echo := echo;
          end
       else<<
             % Read command from current input.
          rds cadr x; !*echo := echo; z := command() >>;
       return z
   end;
+++ commdemo compiled, 118 + 72 bytes
commdemo

symbolic procedure command1;
   % Innermost part of COMMAND. Can be used as hook to editor if needed.
   begin
      scan();
      setcloc!*();
      key!* := cursym!*;
      return xread1 nil
   end;
+++ command1 redefined
+++ command1 compiled, 8 + 28 bytes
command1

symbolic procedure command;
   begin scalar errmsg!*,loopdelimslist!*,mode,x,y;
      if !*demo and ifl!* then return commdemo()
       else if null !*slin or !*reduce4 then go to a;
      % Note key!* not set in this case.
      setcloc!*();
      y := if lreadfn!* then lispapply(lreadfn!*,nil) else read();
      go to b;
   a: crchar!* := readch1();  % Initialize crchar!*.
      if crchar!* = !$eol!$ then go to a;
      % Parse input.
      y := command1();
   b: if !*reduce4 then go to c
       else if !*struct then y := structchk y;
      if !*pret and (atom y or null (car y memq '(in out shut)))
        then if null y and cursym!* = 'end then rprint 'end
              else << rprint y; terpri() >>;
      if !*slin then return list('symbolic,y);
      x := form y;
      % Determine target mode.
      if flagp(key!*,'modefn) then mode := key!*
       else if null atom x % and null !*micro!-version
         and null(car x = 'quote)
         and (null(idp car x
                 and (flagp(car x,'nochange)
                       or flagp(car x,'intfn)
                       or car x = 'list))
           or car x memq '(setq setel setf)
                   and eqcar(caddr x,'quote))
        then mode := 'symbolic
       else mode := !*mode;
      return list(mode,convertmode1(x,nil,'symbolic,mode));
   c: if !*debug then << prin2 "Parse: "; prettyprint y >>;
    % Mode analyze input.
      if key!* = '!*semicol!* then go to a;  % Should be a comment.
      if null !*reduce4 then y := form y else y := n!_form y;
%     y := n!_form y;
      if !*debug then << terpri(); prin2 "Form: "; prettyprint y >>;
      return y
   end;
+++ command redefined
+++ command compiled, 225 + 168 bytes
command

symbolic procedure update!_prompt;
   begin
      statcounter := statcounter + 1;
      promptexp!* :=
         intern list2string append(explode statcounter,
                     if null symchar!* or !*mode = 'algebraic
                     then '(!: ! ) else '(!* ! ));
      setpchar promptexp!*
   end;
+++ update_prompt compiled, 30 + 44 bytes
update_prompt

symbolic procedure begin1;
   begin1a nil;
+++ begin1 compiled, 3 + 12 bytes
begin1

% In the code here is the variable now called !~x!~ was just called x
% then there could be a conflict between the binding here and use of x
% as a top-level variable in symbolic mode code in the case where all
% of Reduce is interpreted and where "local" variables are in fact implemented
% using shallow binding and hence behave rather like fluids. In such a
% situation the input
%     symbolic; x := 5; list(x, x);
% used to return an unexpected ((list x x) (list x x)) rather than (5 5).
% I have renamed the delicate variables as (eg) !~x!~ believing that altough
% casual users might well use x as a variable name few will use that.
% Variables such as errmsg!* already have "unusual" names to reduce the
% chances of conflict. The changes here do not provider a technical resolution
% of the underlying issue, but probably make it a lot less liable to bit in
% the real world.

symbolic procedure begin1a !~prefixchars!~;
   begin scalar !~parserr!~,!~result!~,!~x!~;
      otime!* := time();
      % The next line is that way for bootstrapping purposes.
      if getd 'gctime then ogctime!* := gctime() else ogctime!* := 0;
      otime1!* := otime2!* := otime3!* := otime!*;
      ogctime1!* := ogctime2!* := ogctime3!* := ogctime!*;
      peekchar!* := !~prefixchars!~;
      cursym!* := '!*semicol!*;
      curescaped!* := nil;
  a:  if terminalp()
        then <<(if !*nosave!* or statcounter=0 then nil
                     else add2buflis());
                   update!_prompt()>> ;
      !*nosave!* := nil;
      !*strind := 0;     % Used by some versions of input editor.
      !~parserr!~ := nil;
      if !*time then lispeval '(showtime nil);   % Since a STAT.
      if !*output and null ofl!* and terminalp() and null !*defn
         and null !*lessspace
        then terpri();
      if tslin!*
        then << !*slin := car tslin!*;
                lreadfn!* := cdr tslin!*;
                tslin!* := nil >>;
      !~x!~ := initl!*;
 b:   if !~x!~ then << sinitl car !~x!~; !~x!~ := cdr !~x!~; go to b >>;
      remflag(forkeywords!*,'delim);
      remflag(repeatkeywords!*,'delim);
      remflag( whilekeywords!*,'delim);
      if !*int then erfg!* := nil;   % To make editing work properly.
      if cursym!* = 'end then << comm1 'end; return nil >>
       % Note that key* was set from *previous* command in following.
       else if terminalp() and null(key!* = 'ed)
        then printprompt promptexp!*;
      !~x!~ := errorset!*('(command),t);
      condterpri();
      if errorp !~x!~ then go to err1;
      !~x!~ := car !~x!~;
      if car !~x!~ = 'symbolic and eqcar(cadr !~x!~,'xmodule)
        then !~result!~ := xmodloop eval cadr !~x!~
       else !~result!~ := begin11 !~x!~;
      if null !~result!~ then go to a
       else if !~result!~ = 'end then return nil
       else if !~result!~ = 'err2 then go to err2
       else if !~result!~ = 'err3 then go to err3;
  c:  if crbuf1!* then <<
         lprim "Closing object improperly removed. Redo edit.";
         crbuf1!* := nil;
         return nil >>
        else if eof!*>4
         then << lprim "End-of-file read"; return lispeval '(bye) >>
       else if terminalp()
        then << crbuf!* := nil; !*nosave!* := t; go to a >>
       else return nil;
  err1:
      if eofcheck() or eof!*>0 then go to c
       else if !~x!~="BEGIN invalid" then go to a;
      !~parserr!~ := t;
  err2:
      resetparser();  % In case parser needs to be modified.
  err3:
      erfg!* := t;
      if null !*int and null !*errcont
        then << !*defn := t;
                   !*echo := t;
                   (if null cmsg!*
                      then lprie "Continuing with parsing only ...");
                   cmsg!* := t >>
       else if null !*errcont
        then << !~result!~ := pause1 !~parserr!~;
                   (if !~result!~ then return null lispeval !~result!~);
                   erfg!* := nil >>
       else erfg!* := nil;
      go to a
   end;
+++ begin1a redefined
+++ begin1a compiled, 330 + 300 bytes
begin1a

% Newrule!* is initialized in the following function, since it is not
% always reinitialized by the rule code.

fluid '(ulimit!* trap!-time!*);nil
ulimit!* := nil;nil

symbolic procedure begin11 !~x!~;
   begin scalar errmsg!*,!~mode!~,!~result!~,newrule!*;
      if cursym!* = 'end
         then if terminalp() and null !*lisp!_hook
                then << cursym!* := '!*semicol!*;
                           curescaped!* := nil;
                           !*nosave!* := t;
                           return nil >>
               else << comm1 'end; return 'end >>
       else if eqcar((if !*reduce4 then !~x!~ else cadr !~x!~),'retry)
        then if programl!* then !~x!~ := programl!*
              else << lprim "No previous expression"; return nil >>;
      if null !*reduce4 then << !~mode!~ := car !~x!~; !~x!~ := cadr !~x!~ >>;
      program!* := !~x!~;    % Keep it around for debugging purposes.
      if eofcheck() then return 'c else eof!* := 0;
      add2inputbuf(!~x!~,if !*reduce4 then nil else !~mode!~);
      if null atom !~x!~
          and car !~x!~ memq '(bye quit)
        then if getd 'bye
               then << lispeval !~x!~; !*nosave!* := t; return nil >>
              else << !*byeflag!* := t; return nil >>
       else if null !*reduce4 and eqcar(!~x!~,'ed)
        then <<(if getd 'cedit and terminalp()
                      then cedit cdr !~x!~
                     else lprim "ED not supported");
                   !*nosave!* := t;
                    return nil >>
       else if !*defn
        then if erfg!* then return nil
              else if null flagp(key!*,'ignore)
                and null eqcar(!~x!~,'quote)
               then << (if !~x!~ then dfprint !~x!~ else nil);
                          if null flagp(key!*,'eval) then return nil >>;
      if !*output and ifl!* and !*echo and null !*lessspace
        then terpri();
% If the (Lisp) variable ulimit!* is set to an integer value than that
% represents a resource limit measured in milliseconds of CPU time to
% be allowed for any step of a calculation. This time is not measured
% precisely - what happens is that a timeout is checked for each time
% there is a garbage collection. However because of bootstrapping I do not
% yet have the macro "with-timeout" and so I need to use a forward
% reference to an ordinary function.
      if fixp ulimit!* then <<
        !~result!~ := errorset!_with!_timeout(ulimit!*, !~x!~);
        if not atom !~result!~ then !~result!~ := car !~result!~ >>
      else !~result!~ := errorset!*(!~x!~,t);
      if errorp !~result!~ or erfg!*
        then << programl!* := list(!~mode!~,!~x!~); return 'err2 >>
       else if !*defn then return nil;
      if null !*reduce4
        then if null(!~mode!~ = 'symbolic) then !~x!~ := getsetvars !~x!~ else nil
       else << !~result!~ := car !~result!~;
                  (if null !~result!~ then !~result!~ := mkobject(nil,'noval));
                  !~mode!~ := type !~result!~;
                  !~result!~ := value !~result!~ >>;
      add2resultbuf((if null !*reduce4 then car !~result!~ else !~result!~),
                    !~mode!~);
      if null !*output then return nil
       else if null(semic!* = '!$)
        then if !*reduce4 then (begin
                   terpri();
                   if !~mode!~ = 'noval then return nil
                    else if !*debug then prin2t "Value:";
                   rapply1('print,list list(!~mode!~,!~result!~))
                 end)
       else if !~mode!~ = 'symbolic
              then if null car !~result!~ and null(!*mode = 'symbolic)
                     then nil
              else begin
                  terpri();
                  !~result!~:=
                       errorset!*(list('print,mkquote car !~result!~),t)
                    end
       else if car !~result!~
        then !~result!~ := errorset!*(list('assgnpri,mkquote car !~result!~,
                                       (if !~x!~ then 'list . !~x!~ else nil),
                                       mkquote 'only),
                                  t);
      if null !*reduce4
        then return if errorp !~result!~ then 'err3 else nil
       else if null(!*mode = 'noval) % and !*debug
        then << terpri(); prin2 "of type: "; print !~mode!~ >>;
      return nil
   end;
+++ begin11 redefined
+++ begin11 compiled, 432 + 292 bytes
begin11

symbolic procedure getsetvarlis u;
   if null u then nil
    else if atom u then errach list("getsetvarlis",u)
    else if atom car u then car u . getsetvarlis cdr u
    else if caar u memq '(setel setk)   % setk0.
     then getsetvarlis cadar u . getsetvarlis cdr u
    else if caar u = 'setq then mkquote cadar u . getsetvarlis cdr u
    else car u . getsetvarlis cdr u;
+++ getsetvarlis redefined
+++ getsetvarlis compiled, 65 + 32 bytes
getsetvarlis

symbolic procedure getsetvars u;
   if atom u then nil
    else if car u memq '(setel setk)   % setk0.
     then getsetvarlis cadr u . getsetvars caddr u
    else if car u = 'setq then mkquote cadr u . getsetvars caddr u
    else nil;
+++ getsetvars redefined
+++ getsetvars compiled, 39 + 28 bytes
getsetvars

flag ('(deflist flag fluid global remflag remprop unfluid),'eval);nil

symbolic procedure close!-input!-files;
   % Close all input files currently open;
   begin
      if ifl!* then << rds nil; ifl!* := nil >>;
      while ipl!* do <<
         close cadar ipl!*;
         ipl!* := cdr ipl!* >>;
   end;
+++ close!-input!-files compiled, 21 + 16 bytes
close-input-files

symbolic procedure close!-output!-files;
   % Close all output files currently open;
   begin
      if ofl!* then << wrs nil; ofl!* := nil >>;
      while opl!* do <<
         close cdar opl!*;
         opl!* := cdr opl!* >>;
   end;
+++ close!-output!-files compiled, 20 + 16 bytes
close-output-files

symbolic procedure add2buflis;
   begin
      if null crbuf!* then return nil;
      crbuf!* := reversip crbuf!*;   %put in right order;
      while crbuf!* and seprp car crbuf!* do crbuf!* := cdr crbuf!*;
      crbuflis!* := (statcounter . crbuf!*) . crbuflis!*;
      crbuf!* := nil
   end;
+++ add2buflis compiled, 29 + 20 bytes
add2buflis

symbolic procedure add2inputbuf(u,mode);
   begin
      if null terminalp() or !*nosave!* then return nil;
      inputbuflis!* := list(statcounter,mode,u) . inputbuflis!*
   end;
+++ add2inputbuf redefined
+++ add2inputbuf compiled, 15 + 24 bytes
add2inputbuf

symbolic procedure add2resultbuf(u,mode);
   begin
% The extra treatment here when libreduce is in use is included in this
% main definition of add2resultbuf so that at the cost of a small extra test
% here there will not be a need for copying and replacing the main definition.
% Note that functions like lr_results etc are ones in the libreduce package.
      if !*libreduce!_active then <<
         lr!_result();
         if null(semic!* = '!$) then lr!_printer(u,mode);
         lr!_statcounter();
         prin2 statcounter;
         lr!_mode();
         prin2 (if !*mode = 'symbolic then 1 else 0);
         lr!_posttext();
         terpri() >>;
      if mode = 'symbolic
       or (null u and (null !*reduce4 or null(mode = 'empty!_list)))
       or !*nosave!* then return nil;
      if !*reduce4 then putobject('ws,u,mode) else ws := u;
      if terminalp()
        then resultbuflis!* := (statcounter . u) . resultbuflis!*
   end;
+++ add2resultbuf redefined
+++ add2resultbuf compiled, 74 + 92 bytes
add2resultbuf

symbolic procedure condterpri;
   !*output and !*echo and !*extraecho and (null !*int or ifl!*)
        and null !*defn and null !*demo and terpri();
+++ condterpri redefined
+++ condterpri compiled, 31 + 40 bytes
condterpri

symbolic procedure eofcheck;
   % true if an end-of-file has been read in current input sequence;
   program!* eq !$eof!$ and ttype!*=3 and (eof!* := eof!*+1);
+++ eofcheck redefined
+++ eofcheck compiled, 13 + 28 bytes
eofcheck

symbolic procedure resetparser;
   %resets the parser after an error;
   if null !*slin then comm1 t;
+++ resetparser compiled, 7 + 20 bytes
resetparser

symbolic procedure terminalp;
   %true if input is coming from an interactive terminal;
   !*int and null ifl!*;
+++ terminalp redefined
+++ terminalp compiled, 8 + 16 bytes
terminalp

symbolic procedure dfprint u;
   % Looks for special action on a form, otherwise prettyprints it.
   if dfprint!* then lispapply(dfprint!*,list u)
    else if cmsg!* then nil
    else if null eqcar(u,'progn) then prettyprint u
    else while (u := cdr u) do dfprint car u;
+++ dfprint redefined
+++ dfprint compiled, 29 + 28 bytes
dfprint


symbolic procedure showtime optarg;
   begin scalar x,y;
      x := otime!*;
      otime!* := time();
      x := otime!* - x;
      y := ogctime!*;
      ogctime!* := gctime();
      y := ogctime!* - y;
      if 'psl memq lispsystem!* then x := x - y;
      terpri();
      if optarg then prin2 optarg;
      prin2 "Time: "; prin2 x; prin2 " ms";
      if null(y=0)
        then << prin2 "  plus GC time: "; prin2 y; prin2 " ms" >>;
      terpri();
      return if !*reduce4 then mknovalobj() else nil
   end;
+++ showtime compiled, 61 + 52 bytes
showtime

% OK so what is this all about...
% Well for benchmarking I would like to record the time spent in
% a test script. However some test scripts use "showtime" and that
% then interferes. So I introduce a variant on showtime specifically
% for my use that does just the same but that will be independent of
% the original version. I call this "showtime1". And then in a spirit
% of future-proofing I provide two further versions for other people
% to use too. So
%   showtime1;
%   showtime;
%   part A
%   showtime;    % time just for part A
%   part B
%   showtime;    % time just for part B
%   showtime1;   % total time.
% Because the counters used differ (obviously) I found this easiest to
% do my replicating code rather than having a single parameterised
% function.

symbolic procedure showtime1 optarg;
   begin scalar x,y;
      x := otime1!*;
      otime1!* := time();
      x := otime1!* - x;
      y := ogctime1!*;
      ogctime1!* := gctime();
      y := ogctime1!* - y;
      if 'psl memq lispsystem!* then x := x - y;
      terpri();
      if optarg then prin2 optarg;
      prin2 "Time (counter 1): "; prin2 x; prin2 " ms";
      if null(y=0)
        then << prin2 "  plus GC time: "; prin2 y; prin2 " ms" >>;
      terpri();
      return if !*reduce4 then mknovalobj() else nil
   end;
+++ showtime1 compiled, 61 + 52 bytes
showtime1

symbolic procedure showtime2 optarg;
   begin scalar x,y;
      x := otime2!*;
      otime2!* := time();
      x := otime2!* - x;
      y := ogctime2!*;
      ogctime2!* := gctime();
      y := ogctime2!* - y;
      if 'psl memq lispsystem!* then x := x - y;
      terpri();
      if optarg then prin2 optarg;
      prin2 "Time (counter 2): "; prin2 x; prin2 " ms";
      if null(y=0)
        then << prin2 "  plus GC time: "; prin2 y; prin2 " ms" >>;
      terpri();
      return if !*reduce4 then mknovalobj() else nil
   end;
+++ showtime2 compiled, 61 + 52 bytes
showtime2

symbolic procedure showtime3 optarg;
   begin scalar x,y;
      x := otime3!*;
      otime3!* := time();
      x := otime3!* - x;
      y := ogctime3!*;
      ogctime3!* := gctime();
      y := ogctime3!* - y;
      if 'psl memq lispsystem!* then x := x - y;
      terpri();
      if optarg then prin2 optarg;
      prin2 "Time (counter 3): "; prin2 x; prin2 " ms";
      if null(y=0)
        then << prin2 "  plus GC time: "; prin2 y; prin2 " ms" >>;
      terpri();
      return if !*reduce4 then mknovalobj() else nil
   end;
+++ showtime3 compiled, 61 + 52 bytes
showtime3

symbolic procedure resettime;
  << otime!* := time();
     ogctime!* := gctime();
     if !*reduce4 then mknovalobj() else nil >>;
+++ resettime compiled, 13 + 24 bytes
resettime

symbolic procedure resettime1;
  << otime1!* := time();
     ogctime1!* := gctime();
     if !*reduce4 then mknovalobj() else nil >>;
+++ resettime1 compiled, 13 + 24 bytes
resettime1

symbolic procedure resettime2;
  << otime2!* := time();
     ogctime2!* := gctime();
     if !*reduce4 then mknovalobj() else nil >>;
+++ resettime2 compiled, 13 + 24 bytes
resettime2

symbolic procedure resettime3;
  << otime3!* := time();
     ogctime3!* := gctime();
     if !*reduce4 then mknovalobj() else nil >>;
+++ resettime3 compiled, 13 + 24 bytes
resettime3


symbolic procedure sinitl u;
   set(u, eval get(u, 'initl));
+++ sinitl redefined
+++ sinitl compiled, 11 + 8 bytes
sinitl

% Beware - at least under PSL at this stage if you use "_" within a name
% you need to escape it.

symbolic procedure getenv!_if!_not!_empty name;
  begin
    name := getenv name;
    if name = "" then name := nil;
    return name
  end;
+++ getenv_if_not_empty compiled, 10 + 12 bytes
getenv_if_not_empty

symbolic procedure read!-init!-file name;
  % Read a resource file in REDUCE syntax. Quiet input.
  % Algebraic mode is used unless rlisp88 is on.
  % Look for file in home directory. If no home directory
  % is defined, use the current directory.
  begin scalar !*errcont,!*int,base,fname,oldmode,x,y;
   base := getenv!_if!_not!_empty "HOME" or
%          getenv!_if!_not!_empty "home" or
           ((x := getenv "HOMEDRIVE") and
             (y := getenv "HOMEPATH") and
             concat2(x,y)) or
           ".";
% PSL does not have LAST defined at this stage, so I use "car reversip"
% on the list that was newly created by explode2...
   if base neq "" and car reversip explode2 base neq '!/ then
     base := concat2(base,"/");
   fname := if filep(x := concat2(base,concat2(".", % FJW
                                                concat2(name,"rc"))))
               then x
             else if filep(x := concat2(base,concat2(name,".rc"))) % FJW
              then x
             else if filep
                     (x := concat2(base,concat2(name,".INI")))
               then x; % for (Open) VMS
   if null fname then return nil
    else if !*mode neq 'algebraic and null !*rlisp88
     then << oldmode := !*mode; !*mode := 'algebraic >>;
   x := errorset(list('in!_list1,fname,nil),nil,nil);
   if errorp x or erfg!* then <<
      terpri();
      prin2 "***** Error processing resource file ";
      prin2t fname >>;
   close!-input!-files();
   erfg!*:= cmsg!* := !*defn := nil;
   if oldmode then !*mode := oldmode;
   terpri();
   statcounter := 0
  end;
+++ read!-init!-file compiled, 187 + 128 bytes
read-init-file

endmodule;nil

end;nilmodule tok;nil % Identifier and reserved character reading.

% Author: Anthony C. Hearn.
% Modifications by: Arthur Norman.

% Copyright (c) 2001 Anthony C. Hearn.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%

% Parts of the coding style here look antique and ugly with lots of
% goto statements. The notations for  "for" and "while" loops are not
% used here.
% This is not because we do not care about style, but because in the
% process of bootstrapping Reduce this file is first read by a somewhat
% minimalist cut-down version of the parser that does not support the
% full language syntax.

% Substantial changes in March 2014 to put in support for wide characters
% generally packed in the underlying Lisp string type using utf-8 encoding.

fluid '(!*adjprec !*comment !*defn !*eoldelimp !*lower !*minusliter
        peekchar!* !*quotenewnam !*raise semic!* !*report!_colons
        ifl!* curline!*);nil

!*report!_colons := t;t

% Note *raise is global in the SL Report, but treated as fluid here.

global '(!$eof!$
         !$eol!$
         !*micro!-version
         !*savecomments!*
         comment!*
         crbuf!*
         crbuf1!*
         crchar!*
         cursym!*
         curescaped!*
         eof!*
         nxtsym!*
         outl!*
% Values in ttype!*:
%     0  symbol                   a,b,c,word,!+
%     1  string                   "something"
%     2  number                   1,2, 1.0, 2.0
%     3  operator-like character  +,-,...
%     4  result of quotation      '(something)
         ttype!*
         escaped!*
         !*csl
         !*psl

         named!-character!*);nil

flag('(adjprec),'switch);nil

!*quotenewnam := t;t

crchar!* := '! ; 
peekchar!* := nil;nil

curline!* := 1;1

% The next few are so I have clear names for functions that will
% support strings that have utf-8 sequences packed within them. They
% just rely on Lisp support for strings made up of 8-bit characters.

% I will want to check that Jlisp and VSL also support the things that
% are essential here... mainly allocate-string, string2list, list2string
% and int2id.

% This takes a list of integers (each in the range 0-255) and make a
% string. BEWARE that although PSL can print such strings at present
% if you try passing one to explode or explode2 that can crash the
% system. It should be consided improper to pass a list of integers
% here if they do not represent a valid encoding in utf-8.
%
symbolic procedure bytelist2string u;
  list2string u;
+++ bytelist2string compiled as link to list2string
bytelist2string

% Given a string (that may contain bytes that are over 127) return a list
% of positive small integers out of the raw byte data.
%
symbolic procedure string2bytelist u;
% I do not want to use explode here in case at some stage I want to
% re-work that to behave in character units not in bytes. So here I
% will do things by hand...
  begin
    scalar r, w;
    w := string2list u;
    while w do <<
       if minusp car w then r := (256+car w) . r
       else r := car w . r;
       w := cdr w >>;
    return reversip r;
  end;
+++ string2bytelist redefined
+++ string2bytelist compiled, 31 + 16 bytes
string2bytelist

% Make a symbol from the given list of bytes that are each on 0-255
%
symbolic procedure bytelist2id u;
  intern list2string u;
+++ bytelist2id redefined
+++ bytelist2id compiled, 5 + 12 bytes
bytelist2id

% Make a character (ie a symbol whose name is one character long)
% out of the integer in the range 0-127. Note that this function
% might cope also with arguments in the range 129-255 but PSL specifies
% that if it is given 128 it will return nil.
% In CSL this will also do the same job for the range 128-255.
%
% symbolic procedure int2id u; % built in / defined in csl.red

% Here I will want the strings that I work with to be treated as if
% they are sequences of octets forming an UTF-8 encoded string. I update
% these sequences, and if I do so in a non-atomic manner I can have
% intermediate states that are not valid UTF-8 sequences. That does not
% hurt too much on CSL or PSL where the native string representations are
% as sequences of octets. However for any Lisp that stores strings in a way
% that can only support valud Unicode that is an issue. So I have an
% abstraction here that writes the sequences of octets that make up the
% UTF-8 representation of a single codepoint, and in the simple case I
% just write byte at a time but for Jlisp (in particular) I need to
% ensure that these are treated atomically. So Jlisp has functions
% to write 2, 3 and 4 bytes into a string and the intent is that these are
% used when those bytes form part of a single UTF-8 group. For PSL
% I make writing 2, 3 or 4 bytes into procedures. I had wanted to make
% these inline procedures or smacros but it is too early in the bootstrapping
% for that. But the extra procedure call will only happen if an character
% outside the basic Latin set (U+0000 to U+007f) is being processed, so I
% am not too worried.

symbolic procedure string!-store1(s, n, c);
  string!-store(s, n, c);nil

symbolic procedure string!-store2(s, n, c1, c2);
  << string!-store(s, n, c1);
     string!-store(s, n+1, c2) >>;nil

symbolic procedure string!-store3(s, n, c1, c2, c3);
 << string!-store(s, n, c1);
    string!-store(s, n+1, c2);
    string!-store(s, n+2, c3) >>;nil

symbolic procedure string!-store4(s, n, c1, c2, c3, c4);
 << string!-store(s, n, c1);
    string!-store(s, n+1, c2);
    string!-store(s, n+2, c3);
    string!-store(s, n+3, c4) >>;nil

% Take a list of integers (now each in the range 0-0x0010ffff) and
% turn it into a string encoding those using utf-8
%
% It will also support use of identifiers or strings as well as integers,
% and will use the first character (n.b. not octet) as the code concerned.
%

% Look at the GOTOs in this...

symbolic procedure list2widestring u;
  begin
    scalar u1, n, s, len;
    len := 0;
    u1 := u;
 a: if null u1 then go to b;
    n := car u1;
    u1 := cdr u1;
    if idp n then n := car widestring2list symbol!-name n
    else if stringp n and n neq "" then n := car widestring2list n
    else if not fixp n then rederr "Invalid item in arg to list2widestring";
    if n < 0 then error(1, "Negative integer in list2widestring")
% I put the constants in decimal because hex reading may not be
% available yet.
    else if n < 128 then len := len + 1
    else if n < 2048 then len := len + 2
    else if n < 65536 then len := len + 3
    else if n < 1114112 then len := len + 4
    else error(1, "Integer too large in list2widestring");
    go to a;
 b: s := allocate!-string len;
    len := 0;
 c: while u do <<
       n := car u;
       if idp n then n := car widestring2list symbol!-name n
       else if stringp n and n neq "" then n := car widestring2list n;
       u := cdr u;
       if n < 128 then <<
% I use string!-store rather than the more proper name string!-store1 here
% since I believe that string!-store will be the version built into the Lisp
% I am using.
         string!-store(s, len, n);
         len := len + 1 >>
       else if n < 2048 then <<
         string!-store2(s, len, 192 + lshift(n, (iminus 6)),
                                128 + land(n, 63));
         len := len + 2 >>
       else if n < 65536 then <<
         string!-store3(s, len, 224 + lshift(n, (iminus 12)),
                                128 + land(lshift(n, (iminus 6)), 63),
                                128 + land(n, 63));
         len := len + 3 >>
       else <<
         string!-store4(s, len, 240 + lshift(n, (iminus 18)),
                                128 + land(lshift(n, (iminus 12)), 63),
                                128 + land(lshift(n, (iminus 6)), 63),
                                128 + land(n, 63));
         len := len + 4 >> >>;
    return s
  end;
+++ list2widestring redefined
+++ list2widestring compiled, 324 + 132 bytes
list2widestring

% Ditto but make a symbol;
%
symbolic procedure list2wideid u;
  intern list2widestring u;
+++ list2wideid redefined
+++ list2wideid compiled, 5 + 12 bytes
list2wideid

% Ditto but starting with a single integer
%
symbolic procedure int2wideid n;
  if n < 128 then int2id n
  else intern list2widestring list n;
+++ int2wideid compiled, 15 + 20 bytes
int2wideid

% Given a string that may contain bytes that are over 127 return a list
% of positive integers corresponding to the characters in it if it
% is interpreted as being encoded in utf-8. The behaviour if the bytes
% are not valid utf-8 is to be considered undefined.
%
symbolic procedure moan!-if!-not!-follower n;
  if not (land(n, 192) = 128) then
    error(0, "Bad follow-on in utf-8 string")
  else n;
+++ moan!-if!-not!-follower compiled, 14 + 32 bytes
moan-if-not-follower

symbolic procedure moan!-if!-truncated u;
  if null u then error(0, "Truncated data in utf-8 string")
  else moan!-if!-not!-follower car u;
+++ moan!-if!-truncated compiled, 11 + 24 bytes
moan-if-truncated

symbolic procedure widestring2list u;
  begin
    scalar w, r, n, c;
% The next line turns the string into a list of bytes. On PSL the
% bytes may be extracted as signed values. With CSL they are all
% positive.
    w := string2list u;
% Now I need to decode any utf-8 specials...
    while w do <<
       n := car w;
       w := cdr w;
% I am going to rely on the fact that bytes from the string that were
% at least 0x80 in value come back looking negative here. Thus any values
% that are positive are simple ASCII.
       if not (land(n, 128) = 0) then <<
         if land(n, 224) = 192 then << % Start of 2 byte code
           c := moan!-if!-truncated w;
           w := cdr w;
           n := lshift(land(n, 31), 6) + land(c, 63) >>
         else if land(n, 240) = 224 then << % Start of 3 byte code
           c := moan!-if!-truncated w;
           w := cdr w;
           n := lshift(land(n, 15), 12) + lshift(land(c, 63), 6);
           c := moan!-if!-truncated w;
           w := cdr w;
           n := n + land(c, 63) >>
         else if land(n, 248) = 240 then << % Start of 4 byte code
           c := moan!-if!-truncated w;
           w := cdr w;
           n := lshift(land(n, 7), 18) + lshift(land(c, 63), 12);
           c := moan!-if!-truncated w;
           w := cdr w;
           n := n + lshift(land(c, 63), 6);
           c := moan!-if!-truncated w;
           w := cdr w;
           n := n + land(c, 63) >>
         else error(0, "Improper byte in utf-8 string") >>;
       r := n . r >>;
    return reversip r;
  end;
+++ widestring2list redefined
+++ widestring2list compiled, 162 + 84 bytes
widestring2list

% Return a list of bytes corresponding to the representation of the
% name of the symbol u. Each byte will be in the range 0 to 255.
%
symbolic procedure id2bytelist u;
  string2bytelist id2string u;
+++ id2bytelist redefined
+++ id2bytelist compiled, 5 + 16 bytes
id2bytelist

% Return a list of integers corresponding to the characters that make
% up the name of the symbol u assuming it is encoded using utf-8.
%
symbolic procedure wideid2list u;
  widestring2list id2string u;
+++ wideid2list redefined
+++ wideid2list compiled, 5 + 16 bytes
wideid2list

% The argument should be an identifier denoting a single character. It
% mey neverthless use multiple bytes. Return the integer code for the
% character.
%
symbolic procedure wideid2int u;
  car wideid2list u;
+++ wideid2int compiled, 4 + 12 bytes
wideid2int


% Find the number of bytes that would be printed if the argument
% was. The argument ought to be an identifier, string or number
%
symbolic procedure lengthc u;
  if idp u then length string2list id2string u
  else if stringp u then length string2list u
  else length explode2 u;nil

% Find the number of (wide) characters  that would arise from printing
% the atom. This just ignores bytes that are utf-8 follow-on bytes (ie
% those that are 10xxxxxx in binary).
%
symbolic procedure widelengthc u;
   if idp u then length!-without!-followers string2list id2string u
   else if stringp u then length!-without!-followers string2list u
   else length explode2 u;
+++ widelengthc redefined
+++ widelengthc compiled, 27 + 24 bytes
widelengthc

symbolic procedure length!-without!-followers l;
  begin
    scalar n;
    n := 0;
    while l do <<
       if not (land(car l, 192) = 128) then n := n + 1;
       l := cdr l >>;
    return n
  end;
+++ length!-without!-followers compiled, 19 + 24 bytes
length-without-followers

%==========================================================================

% The function TOKEN defined below is used for reading identifiers
% and reserved characters (such as parentheses and infix operators).
% It is called by the function SCAN, which translates reserved
% characters into their internal name, and sets up the output of the
% input line.  The following definitions of TOKEN and SCAN are quite
% general, but also inefficient.  The reading process can often be
% speeded up considerably if these functions (especially token) are
% written in terms of the explicit LISP used.

symbolic procedure prin2x u;
   outl!* := u . outl!*;
+++ prin2x redefined
+++ prin2x compiled, 5 + 12 bytes
prin2x

% This character look-ahead is used when parsing names that
% have colons within them, as in abc:def. In particular it is active when
% input text such as "... abc::? ...". If the character written as "?" there
% is a letter, digit or underscore then it continues the symbol that
% started with "abc". Otherwise the symbol will stop as just "abc" with
% the first ":" left in crchar!* and peekchar!* set to '(!: ?).
% I will not preserve peekchar!* across file-selection (I note that
% curchr!* is not preserved either). This is OK provided that the Reduce
% directive to read in a file (ie 'in "filename";') can not properly end in
% a symbol that has colons at the end of it. And also that the "in" command
% can not end with something that messed with backslashes. This is UGLY and
% delicate but probably OK at present.
%
% Furthermore I will cause this to do special things with "#" so that at
% this very low level a sequence
%          #word;
%    or    #number;
% gets treated as if it was a single character. Numbers must be given in
% hexadecimal, and the words will be (by and large) following the usage
% in HTML. Thus "#amp;" and "&" will be equivalent. Many forms of usage
% here will describe characters outside the safe 7-bit ASCII range,
% so "#pound;" will be the Sterling pounds sign that is otherwise "#a3"
% and "#Sigma;" will be the same as "#3a3;". This conversion will take
% place everywhere, even within strings. However if the material after
% a "#" is not a recognised word or a valid hexadecimal number (with a
% maximum of 6 digits and a value at most 0x0010ffff) or the ";" is missing
% then the conversion described here will not be made. It looks as if the
% standard HTML 4 entity names are all at most 8 characters long (eg thetasym
% is maximal). Codes in the range #00; to #ff; may be useful even in the
% short term. Some others are looking forward to a Unicode world. In
% particular the character items created will be made using int2id passing
% arguments in the range 0 to 0x0010ffff not just 0 to 0xff.
%
% Note that an extension to try to use HTML5 entity names would lead to
% ambiguity with #ac;, #ace; and several others. To cope with that the
% symbolic name will take priority over a numeric interpretation, but
% a form #Xddd; or #Uddd; can be available where X introduces hex digits and
% U a decimal version. At present at least there are no name conflicts that
% arise if those versions are used!
%
% I will note (although it is not dealt with here) that later on in
% token1 I will make "#if", "#else", "#elif", "#endif", "#eval" and
% "#define" special cases of tokens that can be written without needing
% the initial "#" to be escaped. Thus I want the words involved there
% to be disjoint from the ones I use for character entities.
%
% To back this up it will be good if the Lisp system lets prin2 just print
% items (in UTF8 encoding), but print will need altering. Given a symbol
% or a string that contains a non-ASCII character it should display it
% using "#NNN;" (and if it is a symbol that will be preceeded by an
% exclamation mark escape). If the name or string contains a "#" character
% that should be rendered as "#23;" so that e.g. the string that displays
% using prin2 as #amp; will come out via prin1 as "#23;amp;". Note that the
% translation of funny characters is only done once, also that HTML does not
% provide a special name for the character "#". Perhaps I ought to then the
% output could become "#hash;amp;" which may be clearer.
%
% I might note that #apos; is ('), #quot; is ("), #grave is (`),
% #dollar; is ($).  #Tab; and #NewLine ; provide layout. There are
% a couple of very special bits of treatment in these areas implemented
% because I believe that they will help.
% Within a string #quot; expands to a (") but it does not terminate the
% string. Thus a string with an embedded quote mark can be written
% as "This string has an embedded #quot; in it". For now the previous
% notation where the (") needs to be doubled is still available.
% In a similar sort of way the end-of-line denoted by #NewLine ; does not
% terminate a "%" comment, and the dollar that results from #dollar;
% does not end one that is introduced with the word "comment". These
% three cases are handled by having a flag "named!-character!*" that
% can identify when a character has arisen as an expansion of a sequence
% starting with "#". This flag must be cleared before a call to readch1
% if it is to be tested afterwards.
%
% The idiom (string!-length id2string x = 1) tests if x is a symbol whose
% internal representation is just one byte long. This can identify things
% in the range 0 to 127 that may safely be be tested using liter, digit etc.
% In the code here I try to protect calls to liter, digit etc and as
% a result all characters whose code exceeds 127 will be neither letters
% not digits nor whitespace.

% Check GOTO here


symbolic procedure readch1;
  begin
    scalar x, y, w, n, save;
% First cope with anything that had been read ahead...
    if peekchar!* then <<
      x := car peekchar!*;
% In general when I peek ahead I will not do case-folding as I go:
% that has to be done now when I retrieve the character for final use.
% The PSL rule is that if !*raise is set then characters are all converted
% to the standard case (ie lower case). CSL has two variables !*raise and
% !*lower and folds case as directed by them.
      peekchar!* := cdr peekchar!*;
% I had at first tried "memq('psl, lispsystem!*)" here to detect PSL but that
% fails for two reasons in bootstrapping. First MEMQ may only be used as an
% infix, secondly lispsystem!* is not set early enough. So I have a new
% variable !*psl that I use to detect the relevant situation!
      <<
        if x eq !$eof!$ then nil % Do not mess with EOF
        else if !*psl then << if !*raise then x := red!-char!-downcase x >>
        else if !*lower then x := char!-downcase x
        else if !*raise then x := char!-upcase x >>;
      return x >>;
% Now it is necessary to do a "real" read.
a:  if null terminalp() then <<
% In a fully Unicode world readch() might return a symbol whose name
% is several bytes long but that represents a single Unicode character.
% Doing things that way risks repeatedly packing and unpacking utf-8
% and Unicode data but may feel most consistent.
      x := readch();
      if x eq !$eol!$ then curline!* := curline!*+1 >>
% crbuf1!* is a close relative of peekchar!* but is mainly used as
% an interface for "cedit" to use so that it can have an edited
% bit of stuff appear visible as if it was keyboard input.
    else if crbuf1!* then <<
      x := car crbuf1!*;
      crbuf1!* := cdr crbuf1!* >>
    else x := readch();
    crbuf!* := x . crbuf!*;
% One might worry that adding support for "#" escapes has made this code
% a lot longer than before and that this might slow critical things down.
% In fact about the only extra work done here in normal circumstances is
% a fairly cheap test to see if "#" is present.
    if null peekchar!* then <<
      if not (x = '!#) then return x;
      save := (!*raise . !*lower);
% I switch off !*raise and !*lower while reading. That is (for instance)
% so that #Sigma; and #sigma; can yield an upper and a lower case
% Greek sigma character.
      !*raise := (!*lower := nil);
      peekchar!* := x . peekchar!*;
      go to a >>
% Here I am accumulating a bit of stuff where I look ahead following
% a "#" character.
    else if (not (x eq !$eof!$)) and
       (string!-length id2string x = 1) and
       (liter x or digit x) then <<
% I accumulate the initial "#" followed by any number of letters and
% digits. Well I will only consider letters with codes in the range
% U+0000 to u+007f here and that keeps things simpler - eg when it comes
% to case folding things later on.
      peekchar!* := x . peekchar!*;
      go to a >>;
    !*raise := car save;
    !*lower := cdr save;
% If what I find at the end is not a semicolon then I will
% do nothing... ie I will leave the peeked characters to be read one
% by one in the usual way. Note that while the very final peeked character
% could be a second "#" none of the others can be.
    if not (x = '!;) or null cdr peekchar!* then <<
      peekchar!* := cdr reversip (x . peekchar!*);
      return '!# >>;
% Now I have a potential character name object. It could be one of
%        #name;
%        #hexdigits;
%        #Xhexdigits;     (upper or lower case "x")
% (also  #0hexdigits;     will have the same effect)
%        #Udecimaldigits; (upper or lower case "u")
% but if the name is not recognised or the numeric value is out of
% range the sequence will just be treated as raw characters and all
% this special treatment will have been merely a diversion.
    y := intern list2string (x := cdr reverse peekchar!*);
% For bootstrapping there has to be a "!" before the "_" on the next line.
    if (y := get(y, 'unicode!_character)) then <<
       peekchar!* := nil;
       named!-character!* := t;
       return int2wideid y >>;
% Now it was not a known name. Next check if it was #Udddd
    n := 0;
% I uprated the very initial bootstrap version of the parser so that
% letters after "!" were not case folded.
    if eqcar(x, '!u) or eqcar(x, '!U) then go to dec1;
% Check for explicit hex marker, as in #Xdddd
    if eqcar(x, '!x) or eqcar(x, '!X) then x := cdr x;
hex:if null x then go to ok;
    w := get(car x, 'hexdigit);
    if null w then go to fail;
    n := 16*n + w;
    x := cdr x;
    go to hex;
dec1:
    x := cdr x;
dec:if null x then go to ok;
    if null digit car x then go to fail;
    n := 10*n + get(car x, 'hexdigit);
    x := cdr x;
    go to dec;
ok: peekchar!* := nil;
    named!-character!* := t;
    return int2wideid n;
fail:
    peekchar!* := cdr reverse ('!; . peekchar!*);
    return '!#
  end;
+++ readch1 redefined
+++ readch1 compiled, 261 + 132 bytes
readch1

symbolic procedure tokquote;
   begin
      crchar!* := readch1();
      nxtsym!* := mkquote rread();
      curescaped!* := nil;
      ttype!* := 4;
      return nxtsym!*
   end;
+++ tokquote redefined
+++ tokquote compiled, 15 + 40 bytes
tokquote

put('!','tokprop,'tokquote);tokquote

% Check GOTO here

if !*csl then <<
% I will accept input such as 1.23S0. I preserve the fact that it named
% a short float by using ":dn!-s!:" to tag it rather than just ":dn:", but
% then in algebraic mode form() will map that back onto just !:dn!: so that
% the short nature of the float is only used in symbolic mode.
  put('!s, 'exponent!-mark, '!:dn!-s!:);
  put('!S, 'exponent!-mark, '!:dn!-s!:);
  put('!f, 'exponent!-mark, '!:dn!-f!:);
  put('!F, 'exponent!-mark, '!:dn!-f!:);
  put('!e, 'exponent!-mark, '!:dn!:);
  put('!E, 'exponent!-mark, '!:dn!:);
  put('!d, 'exponent!-mark, '!:dn!:);
  put('!D, 'exponent!-mark, '!:dn!:);
  put('!l, 'exponent!-mark, '!:dn!-l!:);
  put('!L, 'exponent!-mark, '!:dn!-l!:) >>
else <<
  put('!e, 'exponent!-mark, '!:dn!:);
  put('!E, 'exponent!-mark, '!:dn!:) >>;:dn-l:

symbolic procedure token!-number x;
   % Read and return a valid number from input.
   % Adjusted by A.C. Norman to be less sensitive to input case and to
   % support hex numbers.
   begin scalar dotp,power,sign,y,z,xmark;
      power := 0;
      ttype!* := 2;
    num1:
      if y or null(x = '!)) then y := x . y;
      if dotp then power := power - 1;
    num2:
      x := readch1();
      if (x eq !$eof!$) or
         (not (string!-length id2string x = 1)) then go to ret
% The code here used to generate a diagnostic on input like "1.2.3" but
% now it should accept 1.2 as a number and just stop reading at the second
% dot. That seems more friendly and generally consistent with what lexical
% processing should do.
       else if x = '!. and not dotp then <<
         dotp := t;
         go to num2 >>
       else if digit x then go to num1
       else if y = '(!0) and (x = '!x or x = '!X) then go to hexnum
% The next line is a HACK so that 0zNNNNN will let ACN read in a potentially
% big integer explicitly using an experimental version of the CSL bignum
% arithmetic. The syntax will only be available if a function called "newplus"
% is defined, which I take to be a signature of the testing code. When (and
% I should probably say "if") CSL has fully adopted its new code I can get
% rid of this!
       else if y = '(!0) and
               (x = '!z or x = '!Z) and
               getd 'newplus then go to znum
% For whatever original reason this ignores backslashes within numbers. This
% I guess lets one write 12\34567\89000 and group digits in fives if you like.
% I can not see this mentioned in the manual and wonder if anybody uses it.
       else if x = '!\ then << readch1(); go to num2 >>
       else if null(xmark := get(x, 'exponent!-mark)) then go to ret;
% I want to let exponent markers S, F, E, D and L be available for
% writing floating point literals with some specified width. However there
% is a problem of backwards compatibility. Old-style Reduce lets a number end
% when there is a character other than "E". And it does not require spaces
% between tokens. A concrete example of how this hurts is that there are
% places that read "... 2sqrt x ..." where I might have liked it better if
% the code read "2*sqrt x" or at a minimum "2 sqrt x" with a space. But I
% should not break TOO much existing code. So I will allow letters other than
% "e" to instroduce exponents only when there has been an explicit "." before.
% That means that the input "... 2.0sqrt x ..." will now parse with a short
% float 2.0s0 and then "qrt x" and that is a change. But that case "2sqrt x"
% will behave the way it used to. Similarly for cases with other letters at the
% end of of numbers.
%
% To show part of why I believe that the status quo was wrong, note the
% different behaviour of
%    2sqrt x;       (times 2 (list 'sqrt 'x))
%    2exp x;        (times '(!:rd!: 2 . 0) (list 'xp 'x))
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% I rather view that as broken behaviour.
      if not dotp and (x neq '!e and x neq '!E) then go to ret;
      % Case of number with embedded or trailing E.
      dotp := t;
      if (x := readch1()) = '!- then sign := t
       else if x = '!+ then nil
       else if (x eq !$eof!$) or
               (null (string!-length id2string x = 1)) then go to ret
       else if null digit x then go to ret
       else z := list x;
   nume1:
% Even though characters are now extended I want the digit test to pick out
% just those decimal digits that can be handled by compress. So characters
% such as U+1D7E6 (mathematical sans serif digit four) probably does not want
% to pass the test...
      x := readch1();
      if null (string!-length id2string x = 1) then go to nume2
       else if null digit x then go to nume2;
      z := x . z;
      go to nume1;
   hexnum:
      y := 0;
   hexnum1:
      if not (z := get(x := readch1(), 'hexdigit)) then go to ret1;
      y := 16*y + z;
      go to hexnum1;
   znum:
      y := 0;
   znum1:
      if not digit (x := readch1()) then go to ret1;
% This uses functions newplus and newtimes that are only available in
% non-standard testing builds of the CSL version...
      y := newplus(newtimes(10, y), get(x, 'hexdigit));
      go to znum1;
   nume2:
      if null z then rerror('rlisp,4,
         concat("Syntax error: improper number ",
                list2string (x . append(z, 'e . y))));
% This use of compress is for a number...
      z := compress reversip!* z;
      if sign then power := power - z else power := power + z;
   ret:
% This use of compress is for a number...
      y := compress reversip!* y;
   ret1:
      nxtsym!* := if dotp then (if null xmark then '!:dn!: else xmark) .
                               (y . power)
                   else if !*adjprec then '!:int!: . (y . nil)
                   else y;
      crchar!* := x;
      return nxtsym!*
   end;
+++ token!-number compiled, 299 + 168 bytes
token-number

% Note that the arrangements here only support numbers written using
% characters from the Basic Latin Block (U+0000 to U+007f).
deflist(
 '((!0 0)  (!1 1)  (!2 2)  (!3 3)  (!4 4)
   (!5 5)  (!6 6)  (!7 7)  (!8 8)  (!9 9)
   (!a 10) (!b 11) (!c 12) (!d 13) (!e 14) (!f 15)
   (!A 10) (!B 11) (!C 12) (!D 13) (!E 14) (!F 15)), 'hexdigit);(0 1 2 3 4 5 6 7
8 9 a b c d e f A B C D E F)

% The special marker !_line!_ will be replaced in the input stream of
% tokens by the current line number. Note that if terminalp() returns
% true that input lines are not counted - ie if !*int is on (to signal
% interactive use) and input is direct from whatever is standard when
% reduce starts then !_line!_ will always expand to 1. Go "off int;" or
% put your material in a file that you read using "in" if this matters
% to you. Similarly, the special marker !_file!_ will be replaced by the
% name of the file currently read in, or the string "Terminal" if not
% reading from a file.

fluid '(!*line!-marker !*file!-marker);nil
% Note I can NOT just go "!*line!-marker := '__line__;" here since that
% would end up mapped to the line number in this file rather than the
% desired literal symbol - hence the use of intern on a string!
!*line!-marker := intern "__line__";__line__
!*file!-marker := intern "__file__";__file__

% This is a big ugly procedure with a lot of GOTO statements. It is overdue
% for re-work.

symbolic procedure token1;
%
% The current syntax for an identifier is that it starts with a letter (or
% an escaped character) and can continue with letters, digits or underscores.
% I wish to support identifiers that contain an internal unescaped "::"
% (but just one such).
% When I started considering this I had wondered about also allowing
% an embedded single ":" too. However it became clear that that would cause
% trouble in common occuring cases such in
%         label:x:=y;
% and     for i:=m:n dp ...
%
% I believe that little existing code will be troubled if double colons are
% treated specially. The only use of them that I can see in the current source
% is where gentran enables :: to indicate a range in a declaration. If both
% ends of the range have alpabetic names then extra whitespace would be
% required.
%
% When (and if) this is ever activated the case of a single colon
% will merely be treated as it used to be (so avoiding incompatibility),
% while perhaps the usage
%   package::name
% can be used for something interesting. But initially package::name will
% merely denote a name that has embedded colons.
%
% I suspect that the flag "!*minusliter" (which I hope is not made a flag
% that can be toggled using on/off, since it is a dodgy thing for ordinary
% users to mess with) causes "-" to be accepted as a "letter" within but
% not at the start of a name. Thus "-a-b+c" ends up parsing as
%      (plus (minus a!-b) c)
%
   begin scalar x,y,z;
        x := crchar!*;
    a:  if (x eq !$eof!$) or
           (not (string!-length id2string x = 1)) then go to unicode;
        if seprp x and null(x eq !$eol!$ and !*eoldelimp)
          then << x := readch1(); go to a >>
         else if digit x then return token!-number x
% Letters in the Basic Latin Block can be used without needing an escape
% character. The status of things such as U+00c1 (latin capital A with acute)
% and all the other supplemental characters (to say nothing of Greek letters)
% will be a matter for the underlying Lisp to worry about.
         else if liter x then go to letter
         else if (y := get(x,'tokprop)) then return lispapply(y,nil)
         else if x = '!% and null !*savecomments!* then go to coment
         else if x = '!! and null(!*micro!-version and null !*defn)
          then go to escape
         else if x = '!" then go to string
         else if x = '!\ then go to backslash;
    unicode:
        ttype!* := 3;
        if x eq !$eof!$ then prog2(crchar!* := '! ,filenderr());
        nxtsym!* := x;
        if not (x eq !$eof!$) then <<
           if (string!-length id2string x = 1) and (delcp x) then
             crchar!*:= '!  else crchar!*:= readch1() >>;
        if null(x = '!- and
                (not (crchar!* eq !$eof!$)) and
                (string!-length id2string crchar!*  = 1) and
                digit crchar!* and
                !*minusliter)
          then go to c;
        x := token!-number crchar!*;
        if numberp x then return apply1('minus,x);  % For bootstrapping.
        rplaca(cdr x,apply1('minus,cadr x));        % Also for booting.
        return x;
    escape:
        begin scalar !*raise,!*lower;
           escaped!* := t;
           x := readch1();
% If a token is read such that a letter is preceeded by an exclamation mark
% I will set the variable escaped!*. The purpose of this is to support a
% tool that will report on cases where names are used in Reduce such that they
% are identical other than in case. So if both "symbolic" and "sYmBoLiC" are
% used that is a clash. However I do not want "!Alpha" and "alpha" to count
% as a clash, or "!X" and "!x" and "x". So the presence of a letter whose
% case is explicitly preserved by the escape character will be taken as a mark
% that the word was meant to be just as written. This can leave bad cases
% such as "!Alpha" vs "!AlphA" but it covers enough to be useful for now.
% I do not set escaped!* to nil here - if you wish to inspect it please set
% it to nil before calling token(). The arrangement like that is perhaps
% ugly but minimises overhead in all the common cases where this is not
% actually being used.
           if liter x then escaped!* := t;
        end;
    letter:
        ttype!* := 0;
    let1:
        x := wideid2list x;
    let2:
        if null x then go to let3;
        y := car x . y;
        x := cdr x;
        go to let2;
    let3:
        x := readch1();
        if (x eq !$eof!$) or
            (not (string!-length id2string crchar!*  = 1)) then go to ordinarysym
         else if digit x or liter x then go to let1
         else if x = '!! then go to escape
         else if x = '!- and !*minusliter
          then go to let1
         else if x = '!_ then go to let1     % Allow _ as letter.
%% The following change led to problems with CSL, and perhaps it is not
%% even needed.
%%         else if x = '!% then go to let1     % Allow % as letter.
         else if x = '!: then go to maybepackage;
    ordinarysym:
        y := list2wideid reversip!* y;
% If I implement a package system I might want to check if the name
% y here should map onto ppp:y for some package ppp.
        if y = !*line!-marker then nxtsym!* := curline!*
        else if y = !*file!-marker
          then nxtsym!* := if null ifl!* then "Terminal" else car ifl!*
        else nxtsym!* := y;
        crchar!* := x;
    c:  return nxtsym!*;
    backslash:
        y := '(!\ e n d !{ r e d u c e !});
        z := nil;
    bsloop:
        z := x . z;
        x := readch1();
        y := cdr y;
        if null y then go to bsfound
        else if x eq car y then go to bsloop;
% Here I need to set things back so that all the peeked-ahead stuff is
% put ready for re-scanning and I can merely return the "\".
        peekchar!* := cdr reverse (x . z);
        ttype!* := 3;
        crchar!* := readch1();
        nxtsym!* := '!\;
        return nxtsym!*;
    bsfound:
% At this stage I have just found the text "\end{reduce}" and what I will do
% is to discard all stuff until I find either end of file of "\begin{reduce}".
% However note that at this stage I am expecting to be scanning TeX code and
% so if there are any TeX comments (introduced by "%") I do not want to
% detect the magic within them.
        y := '(!\ b e g i n !{ r e d u c e !});
        ttype!* := 3;
    bssrch:
        if x = '!% then go to bscomm
        else if x eq !$eof!$ then <<
           crchar!* := '! ;
           filenderr();
           nxtsym!* := x;
           return x >>;
% If I have found \begin{reduce} go back to scanning input normally.
        if null y then go to a;
        z := x;
        x := readch1();
        if not (z eq car y) then go to bsfound;
        y := cdr y;
        go to bssrch;
    bscomm:
        x := readch1();
        if x eq !$eof!$ then go to bssrch
        else if x eq !$eol!$ then go to bsfound
        else go to bscomm;
    maybepackage:                               % Seen abc:
        x := readch1();
        if x = '!: then go to maybeextpackage;
        peekchar!* := list x;
        x := '!:;
        go to ordinarysym;
    maybeextpackage:                            % Seen abc::
        x := readch1();
        if (not (x eq !$eof!$)) and
           (string!-length id2string crchar!*  = 1) and
           liter x then go to isextpackage;
        peekchar!* := list('!:, x);
        x := '!:;
        go to ordinarysym;
    isextpackage:
% What follows lexes a name of the form ppp::xxx
        z := list2wideid reverse y;
% In case it is useful I set z to the name of the "package" part ppp
        y := (id2int '!:) . (id2int '!:) .  y;
    extpackmore:
        x := wideid2list x;
    ext1:
        if null x then go to ext2;
        y := car x . y;
        x := cdr x;
        go to ext1;
    ext2:
        x := readch1();
        if (x eq !$eof!$) or
           (not (string!-length id2string crchar!*  = 1)) then go to extdone
         else if digit x or liter x then go to extpackmore
         else if x = '!! then go to extpackescape
         else if x = '!- and !*minusliter
          then go to extpackmore
         else if x = '!_ then go to extpackmore;    % Allow _ as letter.
    extdone:
        y := list2wideid reversip!* y;
% At this stage I will always display a message reporting what I have seen.
        lprim list("Name with double colon in detected:", y);
        nxtsym!* := y;
        crchar!* := x;
% This is where I merely return the symbol with an embedded "::". If I
% ever implement a genuine package system this should be where I put a
% major hook that manages extra symbol tables.
        return nxtsym!*;
    extpackescape:
        begin scalar !*raise,!*lower;
           escaped!* := t;
           x := readch1()
        end;
        go to extpackmore;
    string:
        begin scalar !*raise,!*lower;
       strinx:
           x := wideid2list x; % extract character from the symbol.
       dumpx:
           if null x then go to dumped;
           y := car x . y;
           x := cdr x;
           go to dumpx;
       dumped:
           named!-character!* := nil;
           if (x := readch1()) eq !$eof!$
             then << crchar!* := '! ;
                     lpriw("***** End-of-file in string",nil);
                     filenderr() >>
            else if (null(x = '!")) or named!-character!* then go to strinx;
           % Now check for embedded string character.
           named!-character!* := nil;
           x := readch1();
           if (x = '!") and (null named!-character!*) then go to strinx;
           nxtsym!* := list2widestring cdr reversip!* y
         end;
        ttype!* := 1;
        crchar!* := x;
        go to c;
    coment:
        begin scalar !*raise,!*lower;
    comm1:
        named!-character!* := nil;
        if (null((x := readch1()) eq !$eol!$ or
                  x eq !$eof!$)) or named!-character!* then go to comm1
        end;
        x := readch1();
        go to a
   end;
+++ token1 redefined
+++ token1 compiled, 675 + 220 bytes
token1

symbolic procedure tokbquote;
   begin
     crchar!* := readch1();
      nxtsym!* := list('backquote,rread());
      curescaped!* := nil;
      ttype!* := 3;
      return nxtsym!*
   end;
+++ tokbquote compiled, 18 + 40 bytes
tokbquote

put('!`,'tokprop,'tokbquote);tokbquote

symbolic procedure token;
   %This provides a hook for a faster TOKEN;
   token1();
+++ token redefined
+++ token compiled as link to token1
token

symbolic procedure filenderr;
   begin
      curescaped!* := nil;
      cursym!* := '!*semicol!*;
      eof!* := eof!*+1;
      if terminalp() then error1()
       else error(99,if ifl!*
                       then list("End-of-file read in file",car ifl!*)
                      else "End-of-file read")
   end;
+++ filenderr compiled, 31 + 48 bytes
filenderr

symbolic procedure ptoken;
   begin scalar x;
        x := token();
        if x = '!) and eqcar(outl!*,'! ) then outl!*:= cdr outl!*;
           %an explicit reference to OUTL!* used here;
        prin2x x;
        if null ((x = '!() or (x = '!))) then prin2x '! ;
        return x
   end;
+++ ptoken redefined
+++ ptoken compiled, 25 + 32 bytes
ptoken

symbolic procedure rread1;
   % Modified to use QUOTENEWNAM's for ids.
   % Note that handling of reals uses symbolic mode, regardless of
   % actual mode.
   begin scalar x,y;
        x := ptoken();
        if null (ttype!*=3)
          then return if idp x
                        then if !*quotenewnam
                                and (y := get(x,'quotenewnam))
                               then y
                              else x
                       else if eqcar(x,'!:dn!:)
                        then dnform(x,nil,'symbolic)
                       else x
         else if x = '!( then return rrdls()
         else if null (x = '!+ or x = '!-) then return x;
        y := ptoken();
        if eqcar(y,'!:dn!:) then y := dnform(y,nil,'symbolic);
        if null numberp y
          then << nxtsym!* := " ";
                  symerr("Syntax error: improper number",nil) >>
         else if x = '!- then y := apply1('minus,y);
           % We need this construct for bootstrapping purposes.
%@@@@@@@@ Check if this is still the case @@@@@@@@@@@
        return y
   end;
+++ rread1 redefined
+++ rread1 compiled, 85 + 80 bytes
rread1

symbolic procedure rrdls;
   begin scalar x,y,z;
    a:  x := rread1();
        if null (ttype!*=3) then go to b
         else if x = '!) then return z
         else if null (x = '!.) then go to b;
        x := rread1();
        y := ptoken();
        if null (ttype!*=3) or null (y = '!))
          then << nxtsym!* := " "; symerr("Invalid S-expression",nil) >>
         else return nconc(z,x);
    b: z := nconc(z,list x);
       go to a
   end;
+++ rrdls redefined
+++ rrdls compiled, 51 + 48 bytes
rrdls

symbolic procedure rread;
   << prin2x " '"; rread1() >>;
+++ rread redefined
+++ rread compiled, 5 + 20 bytes
rread

symbolic procedure delcp u;
   % Returns true if U is a semicolon, dollar sign, or other delimiter.
   % This definition replaces the one in the BOOT file.
   flagp(u,'delchar);
+++ delcp redefined
+++ delcp compiled, 4 + 8 bytes
delcp

flag('(!; !$),'delchar);
nil
symbolic procedure toknump x;
   numberp x or eqcar(x,'!:dn!:) or eqcar(x,'!:int!:);
+++ toknump redefined
+++ toknump compiled, 15 + 20 bytes
toknump

% The following version of SCAN provides RLISP with a facility for
% conditional compilation.  The protocol is that text is included or
% excluded at the level of tokens.  Control by use of new reserved
% tokens #if, #else, #elif and #endif.  These are used in the form:
%    #if (some Lisp expression for use as a condition)
%    ... RLISP input ...
%    #else
%    ... alternative RLISP input ...
%    #endif
%
% The form
%    #if C1 ... #elif C2 ... #elif C3 ... #else ... #endif
% is also supported.
%
% This formation will not be recognised within quoted exressions, so
%       a := '(one
%       #if sometimes
%              two
%       #endif
%              three);
% will not be useful. The tokens "#if" etc do not need an initial (!)
% when they might be directives. Again this means that within quoted
% material they will.
%
% Conditional compilation can be nested.  If the Lisp expression used
% to guard a condition causes an error it is taken to be a FALSE
% condition. It is not necessary to have an #else before #endif if no
% alternative text is needed.  Although the examples here put #if etc
% at the start of lines this is not necessary (though it may count as
% good style?).  Since the condition will be read using RLISPs own
% list-reader there could be conditional compilation guarding parts of
% it - the exploitation of that possibility is to be discouraged!

% Making the condition a raw Lisp expression makes sure that parsing it
% is easy. It makes it possible to express arbitrary conditions, but it
% is hoped that most conditions will not be very elaborate - things like
%    #if (member 'psl lispsystem!*)
%         magic();
%    #else
%         error();
%    #endif
% or
%    #if debugging!-mode  % NB if variable is unset that counts as nil
%    print "message";      % so care should be taken to select the most
%    #endif               % useful default sense for such tests
% should be about as complicated as reasonable people need.
%
% Two further facilities are provided:
%    #eval (any lisp expression)
% causes that expression to be evaluated at parse time.  Apart from any
% side-effects in the evaluation the text involved is all ignored. It is
% expected that this will only be needed in rather curious cases, for
% instance to set system-specific options for a compiler.

%    #define symbol value
% where the value should be another symbol, a string or a number,
% causes the first symbol to be mapped onto the second value wherever
% it occurs in subsequent input.  This uses exactly the same mechanism
% as the existing REDUCE "define" statement and so has the same
% limitations.  The use of a hook in SCAN to support this ensures that
% the #define can be written anywhere in REDUCE source code (eg within
% a procedure definition) and will still apply while the program
% involved is parsed.  No special facility for undoing the effect of a
% #define is provided, but the general-purpose #eval could be used to
% remove the 'newnam property that is involved.

symbolic procedure addcomment u;
 %  if commentlist!*
 %    then cursym!* := 'comment . aconc(reversip commentlist!*,u)
 %   else
     cursym!* := u;
+++ addcomment redefined
+++ addcomment compiled, 3 + 12 bytes
addcomment

symbolic procedure scan;
   begin scalar bool,x,y;
        if null (cursym!* = '!*semicol!*) then go to b;
    a:  escaped!* := nil;
        nxtsym!* := token();
    b:  if null atom nxtsym!* and null toknump nxtsym!*
          then go to q1
         else if nxtsym!* = 'else or cursym!* = '!*semicol!*
         then outl!* := nil;
        prin2x nxtsym!*;
    c:  if null idp nxtsym!* then go to l
         else if (x:=get(nxtsym!*,'newnam)) and
                        (null (x=nxtsym!*)) then go to new
% Here I will allow "comment" to be spent in either upper or lower case
% so that if "off raise;" (or "off lower;") is active things that may be
% intended to be comments remain treated as such. The various capitalisations
% detected here actually arise within the Reduce sources (at least until at
% some stage they are tidied away...)
         else if nxtsym!* = '!c!o!m!m!e!n!t or
                 nxtsym!* = '!C!O!M!M!E!N!T or
                 nxtsym!* = '!C!o!m!m!e!n!t
          then << x := read!-comment1 'comment;
                  if !*comment then return x else go to a >>
         else if nxtsym!* = '!% and ttype!*=3
          then << x := read!-comment1 'percent!_comment;
                  if !*comment then return x else go to a >>
% I might comment that the material within a quoted form is not
% processed by SCAN and so the text "!#if" here both NEED the initial
% escape mark and it will not be treated as introducing a conditional
% section.
         else if nxtsym!* = '!#if then go to conditional
         else if nxtsym!* = '!#else or
                 nxtsym!* = '!#elif then <<
                     nxtsym!* := x := bool := nil;
                     go to skipping >>
         else if nxtsym!* = '!#endif then go to a
         else if nxtsym!* = '!#eval then <<
                     errorset(rread(), !*backtrace, nil);
                     curescaped!* := (escaped!* := nil);
                     go to a >>
         else if nxtsym!* = '!#define then <<
                     x := errorset('(rread), !*backtrace, nil);
                     curescaped!* := (escaped!* := nil);
                     if errorp x then go to a;
                     y := errorset('(rread), !*backtrace, nil);
                     curescaped!* := (escaped!* := nil);
                     if errorp y then go to a;
                     put(car x, 'newnam, car y);
% Print a message to show that the "#define" has been seen.
                     princ "*** "; prin car x; princ " => "; print car y;
                     go to a >>
         else if null(ttype!* = 3) then go to l
         else if nxtsym!* eq !$eof!$ then return filenderr()
         else if nxtsym!* = '!' then rederr "Invalid QUOTE"
         else if !*eoldelimp and nxtsym!* eq !$eol!$ then go to delim
         else if nxtsym!* = '!# and not seprp crchar!* then go to hh
         else if null (x:= get(nxtsym!*,'switch!*)) then go to l
         else if eqcar(cdr x,'!*semicol!*) then go to delim;
        bool := seprp crchar!*;
   sw1: nxtsym!* := token();
        if null(ttype!* = 3) then go to sw2
         else if nxtsym!* eq !$eof!$ then return filenderr()
         else if car x then go to sw3;
   sw2: cursym!*:=cadr x;
        curescaped!*:=nil;
        bool := nil;
        if cursym!* = '!*rpar!* then go to l2
         else return addcomment cursym!*;
   sw3: if bool or null (y:= atsoc(nxtsym!*,car x)) then go to sw2;
        prin2x nxtsym!*;
        x := cdr y;
% The next line is a hook for RLISP88 where input of the form
%    /* .... */ reads in as (!*comment!* "....") so that the comment
% text can be preserved.
        if null car x and cadr x = '!*comment!*
          then << comment!* := read!-comment(); go to a >>;
        go to sw1;
  hh:
% Here I have a "#" not preceeded by an escape marker (!) and followed
% by something that is not a separator. I will handle that at first rather
% as if it was the "switch" case but with extra support for some special
% cases like "#if".
        bool := nil;
        x := get(nxtsym!*,'switch!*);
        nxtsym!* := token();
        if nxtsym!* = 'if or
           nxtsym!* = 'else or
           nxtsym!* = 'elif or
           nxtsym!* = 'endif or
           nxtsym!* = 'eval or
           nxtsym!* = 'define then go to preprocessor;
        if null(ttype!* = 3) then go to sw2
         else if nxtsym!* eq !$eof!$ then return filenderr()
         else if car x then go to sw3;
        go to sw2;
  preprocessor:
        prin2x nxtsym!*;
        nxtsym!* := intern list2string ('!# . explode2 nxtsym!*);
        go to c;
  conditional:
% The conditional expression used here must be written in Lisp form
        x := errorset(rread(), !*backtrace, nil);
        curescaped!* := (escaped!* := nil);
% errors in evaluation count as NIL
        if null errorp x and car x then go to a;
        x := nil;
        bool := t;
  skipping:
% I support nesting of conditional inclusion. However one new joy
% here is that a "#" followed (immediately) by one "if, "else", "elif"
% or "endif" must be noticed here... The way I do that here has the
% effect that (eg) ##endif is treated as ## endif not as # #endif so will
% not terminate a conditional block.
        if nxtsym!* = '!# and ttype!*=3 and not seprp crchar!* then <<
          nxtsym!* := token();
          if ttype!* = 0 then
            nxtsym!* := intern list2string ('!# . explode2 nxtsym!*) >>;
        if nxtsym!* = '!#endif then
           if null x then go to a else x := cdr x
        else if nxtsym!* = '!#if then x := nil . x
        else if (nxtsym!* = '!#else) and null x and bool then go to a
        else if (nxtsym!* = '!#elif) and null x and bool then go to conditional;
        nxtsym!* := token();
        if (ttype!*=3) and (nxtsym!* eq !$eof!$)
          then return filenderr()
         else go to skipping;
  delim:
        semic!*:=nxtsym!*;
        curescaped!* := nil;
        return addcomment '!*semicol!*;
  new:  nxtsym!* := x;
        if stringp x then go to l
        else if atom x then go to c
        else go to l;
  q1:   if null (car nxtsym!* = 'string) then go to l;
        prin2x " ";
        prin2x cadr(nxtsym!* := mkquote cadr nxtsym!*);
  l:    cursym!*:=nxtsym!*;
        curescaped!* := escaped!*;
        escaped!* := nil;
        nxtsym!* := token();
        if (nxtsym!* eq !$eof!$) and (ttype!* = 3) then return filenderr();
  l2:   if numberp nxtsym!*
           or (atom nxtsym!* and null get(nxtsym!*,'switch!*))
          then prin2x " ";
        return addcomment cursym!*
   end;
+++ scan redefined
+++ scan compiled, 600 + 248 bytes
scan

symbolic procedure read!-comment1 u;
   begin scalar !*lower,!*raise;
      named!-character!* := nil;
 comm1:
      if named!-character!* or
         (null (string!-length id2string crchar!* = 1)) or
         (null (delcp crchar!*)) or
         (crchar!* eq !$eol!$) then <<
             named!-character!* := nil;
             crchar!* := readch1();
             go to comm1 >>;
      crchar!* := '! ;
      condterpri()
   end;
+++ read!-comment1 redefined
+++ read!-comment1 compiled, 43 + 60 bytes
read-comment1

% The next procedure is adapted from code in RLISP88 for a comment
% opened with "/*". These leave material in the source.

symbolic procedure read!-comment;
   begin
      scalar x,y,z;
      begin
         scalar !*raise, !*lower;
         z := list crchar!*;
      a: named!-character!* := nil;
         if (x := readch()) = '!* and not named!-character!* then
            if (y := readch()) = '!/ and not named!-character!* then return nil
            else z := y . x . z
         else if x = !$eof!$ then rederr "EOF encountered in comment"
         else z := x . z;
         go to a;
      end;
      crchar!* := readch();
      return list('!*comment!*, list2string reversip z)
   end;
+++ read!-comment compiled, 73 + 56 bytes
read-comment


endmodule;nil

end;nilmodule xread;nil % Routines for parsing RLISP input.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% NOTE: For bootstrapping purposes, this file should not have any tab
%       characters in it.

fluid '(!*blockp !*eoldelimp !*reduce4 commentlist!*);nil   % !*ignoreeol

global '(cursym!* curescaped!* nxtsym!*);nil

% The conversion of an RLISP expression to LISP prefix form is carried
% out by the function XREAD.  This function initiates the scanning
% process, and then calls the auxiliary function XREAD1 to perform the
% actual parsing.  Both XREAD and XREAD1 are used by many functions
% whenever an expression must be read;

flag ('(end !*colon!* !*semicol!*),'delim);nil

symbolic procedure chknewnam u;
   % Check to see if U has a newnam, and return it else return U.
   begin scalar x;
      return if null(x := get(u,'newnam)) or x eq u then u
              else if idp x then chknewnam x
              else x
   end;
+++ chknewnam redefined
+++ chknewnam compiled, 18 + 12 bytes
chknewnam

symbolic procedure mkvar(u,v); u;
+++ mkvar redefined
+++ mkvar compiled, 1 + 8 bytes
mkvar

symbolic procedure remcomma u;
   if eqcar(u,'!*comma!*) then cdr u else list u;
+++ remcomma redefined
+++ remcomma compiled, 9 + 12 bytes
remcomma

symbolic procedure eolcheck;
   if null !*eoldelimp then nil
   else while nxtsym!* eq !$eol!$ do
           nxtsym!* := (if cursym!* = 'end then '!;
                        else token());
+++ eolcheck redefined
+++ eolcheck compiled, 19 + 36 bytes
eolcheck

symbolic procedure xcomment(u,commentlist);
   if commentlist then 'COMMENT . aconc(reversip commentlist,u)
   else u;
+++ xcomment redefined
+++ xcomment compiled, 15 + 16 bytes
xcomment

% The code here has MANY labels and goto statements and may be in need
% or re-writing to make it clearer... If I get to work on this it will
% need to be re-worked in phases I suspect...

symbolic procedure xread1 u;
   begin scalar v,w,x,y,z,z1,z2,commentlist;
        % This is the basic function for parsing RLISP input, once
        % tokens have been read by TOKEN and SCAN.  Its one argument
        % U can take a number of values:
        %   FOR:     Parsing of FOR statements
        %   GROUP:   Parsing of group statements after keyword <<
        %   LAMBDA:  Parsing of lambda expressions after keyword lambda
        %   NIL:     Parsing of expressions which can have a comma at
        %            the end for example.
        %   PROC:    Parsing of procedures after keyword PROCEDURE
        %   T:       Default case with standard parsing.
        % Also, if U is flagged STRUCT, it is assumed that the arguments
        % are lists of lists, and so commas are removed.  At present,
        % only MAT is tagged in this manner.
        % The local variables are used as follows:
        % v: expression being built
        % w: prefix operator stack
        % x: infix operator stack
        % y: infix value or stat property
        % z: current symbol
        % z1: next symbol
        % z2: temporary storage;
        % commentlist: association list of read comments.
        if commentlist!* then <<
           commentlist := commentlist!*;
           commentlist!* := nil >>;
  a:    z := cursym!*;
  a1:   if null idp z then nil
         else if z = '!*lpar!* then go to lparen
         else if z = '!*rpar!* then go to rparen
         else if y := get(z,'infix) then go to infx
         % The next line now commented out was intended to allow a STAT
         % to be used as a label. However, it prevents the definition of
         % a diphthong whose first character is a colon.
%        else if nxtsym!* = '!: then nil
         else if flagp(z,'delim) then go to delimit
         else if y := get(z,'stat) then go to stat
         else if null !*reduce4 and flagp(z,'type) then <<
            w := lispapply('decstat,nil) . w; go to a >>;
  a2:   y := nil;
  a3:   w := z . w;
        % allow for implicit * after a number.
        if toknump z
           and null(z1 eq !$eol!$)
           and idp (z1 := chknewnam nxtsym!*)
           and null flagp(z1,'delim)
           and null(get(z1,'switch!*) and null(z1 = '!())
           and null get(z1,'infix)
           and null (!*eoldelimp and z1 eq !$eol!$)
          then << cursym!* := 'times; curescaped!* := nil; go to a >>
         else if u = 'proc and length w > 2
          then symerr("Syntax error in procedure header",nil);
  next: z := scan();
        go to a1;
  lparen:
        eolcheck();
        y := nil;
        if scan() = '!*rpar!* then go to lp1    % no args
         else if flagpcar(w,'struct) then z := xread1 car w
         else z := xread1 'paren;
        if flagp(u,'struct) then << z := remcomma z; go to a3 >>
         else if null eqcar(z,'!*comma!*) then go to a3
         else if null w         % then go to a3
           then (if u = 'lambda then go to a3
                 else symerr("Improper delimiter",nil))
         else w := (car w . cdr z) . cdr w;
        go to next;
  lp1:  if w then w := list car w . cdr w;  % Function of no args.
        go to next;
  rparen:
        if null u or u = 'group
           or u = 'proc % and null !*reduce4
          then symerr("Too many right parentheses",nil)
         else go to end1;
  infx: eolcheck();
        if z = '!*comma!* or null atom (z1 := scan())
                or toknump z1 then go to in1
         else if z1 = '!*rpar!* % Infix operator used as variable.
                or z1 = '!*comma!*
                or flagp(z1,'delim)
          then go to in2
         else if z1 = '!*lpar!* % Infix operator in prefix position.
                    and null eolcheck()     % Side effect important
                    and null atom(z1 := xread 'paren)
                    and car z1 = '!*comma!*
                    and (z := z . cdr z1)
          then go to a1;
  in1:  if w then go to unwind
         else if null(z := get(z,'unary))
          then symerr("Redundant operator",nil);
        v := '!*!*un!*!* . v;
        go to pr1;
% in2:  if y then if !*ignoreeol then y := nil
%                  else symerr("Redundant operator",nil);
  in2:  if y then y := nil;
        w := z . w;
  in3:  z := z1;
        go to a1;
  unwind:
        % Null w implies a delimiter was found, say, after a comma.
        if null w then symerr("Improper delimiter",nil);
        z2 := mkvar(car w,z);
  un1:  w:= cdr w;
        if null w then go to un2
         else if atom car w and null idp car w
          then symerr("Missing operator",nil);
        z2 := list(car w,z2);
        go to un1;
  un2:  v:= z2 . v;
  preced:
        if null x then if y=0 then go to end2 else nil
%        else if z = 'setq then nil
% The next line is intended to generate a diagnostic in cases such as
%       a ^ - b * c
% and   a / - b / c
% where the precedence of the prefix operator is lower than that of the
% two infix operators surrounding it. In general it is intended to encourage
% people to write something like
%       a ^ ( - b ) * c
% with explicit parentheses. It tries to avoid raising complaints in
% cases such as
%       a ^ - b + c
% where the precedent rules seem to manage to lead to results that more
% people would view as "expected". Note that in Reduce parsers certainly from
% version 3.3 onwards and probably for ever the following parses applied
%      - a * b       => - (a * b)
%      a / - b / c   => a / (- (b / c))      !!!!!
%      a ^ - b * c   => a ^ (- (b * c))      !!!!!
%      a ^ (- b) * c => (a ^ (-b)^ * c
% and because of the very long-standing nature of this behaviour a silent
% change seems dangerous. I hope that the test here detects and flags as
% problematic a minimal set of cases that deserve explicit brackets for
% avoidance of ambiguity, and so it will not hurt existing safe code.
         else if v and eqcar(cdr v, '!*!*un!*!*) and
                 cdr x and y >= caar x and y <= caadr x then
            symerr("Please use parentheses around use of the unary operator", nil)
        % Makes parsing a + b := c more natural.
         else if y<caar x
           or (y=caar x
               and ((z eq cdar x and null flagp(z,'nary)
                                 and null flagp(z,'right))
                             or get(cdar x,'alt)))
          then go to pr2;
  pr1:  %if v and eqcar(cdr v,'!*!*un!*!*) and not (car v = '!*!*un!*!*)
        %  then symerr("Invalid combination of prefix and infix operator",nil);
        x:= (y . z) . x;
        if null(z = '!*comma!*) then go to in3
         else if cdr x or null u or u memq '(lambda paren)
            or flagp(u,'struct)
          then go to next
         else go to end2;
  pr2:  %if cdar x = 'setq then go to assign else;
        % Check for NOT used as infix operator.
        if eqcar(cadr v,'not) and caar x >= get('member,'infix)
          then typerr("NOT","infix operator");
        if cadr v = '!*!*un!*!*
          then (if car v = '!*!*un!*!* then go to pr1
                else z2 := list(cdar x,car v))
         else z2 := cdar x .
                     if eqcar(car v,cdar x) and flagp(cdar x,'nary)
                       then (cadr v . cdar v)
                      else list(cadr v,car v);
        x:= cdr x;
        v := z2 . cddr v;
        go to preced;
  stat: if null(y = 'endstat) then eolcheck();
        if null (flagp(z,'go) or
                 (null(u = 'proc) and
                  (flagp(y,'endstatfn) or
                   (null delcp nxtsym!* and null (nxtsym!* = '!,)))))
          then go to a2;
        if z = 'procedure and !*reduce4
          then if w then if cdr w or !*reduce4
                           then symerr("proc form",nil)
                          else w := list procstat1 car w
                else w := list procstat1 nil
         else w := lispapply(y,nil) . w;
        y := nil;
        go to a;
  delimit:
        if null(cursym!* = '!*semicol!*) then eolcheck();
        if z = '!*colon!* and null(u = 'for)
              and (null !*blockp or null w or null atom car w or cdr w)
           or flagp(z,'nodel)
              and (null u
                      or u = 'group
                        and null(z memq
                                   '(!*rsqbkt!* !*rcbkt!* !*rsqb!*)))
          then symerr("Improper delimiter",nil)
         else if idp u and (u = 'paren or flagp(u,'struct))
          then symerr("Too few right parentheses",nil);
  end1:
        if y then symerr("Improper delimiter",nil) % Probably ,).
         else if null v and null w and null x
          then return xcomment(nil,commentlist);
        y := 0;
        go to unwind;
  end2: if null cdr v then return xcomment(car v,commentlist)
         else print "Please send hearn@rand.org your program!!";
        symerr("Improper delimiter",nil)
   end;
+++ xread1 redefined
+++ xread1 compiled, 706 + 260 bytes
xread1

%symbolic procedure getels u;
%   getel(car u . !*evlis cdr u);

%symbolic procedure !*evlis u;
%   mapcar(u,function lispeval);

flag ('(endstat endstat1 retstat),'endstatfn);nil

flag ('(else then until),'nodel);nil

flag ('(begin),'go);nil

symbolic procedure xread u;
   begin
      while << scan();
               !*eoldelimp and cursym!* = '!*semicol!* >> do nil;
      return xread1 u
   end;
+++ xread redefined
+++ xread compiled, 13 + 28 bytes
xread

symbolic procedure expread;  xread t;
+++ expread compiled, 3 + 16 bytes
expread

flag('(expread xread),'opfn);nil   % To make them operators.

endmodule;nil

end;nilmodule lpri;nil % Functions for printing diagnostic and error messages.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*defn !*echo !*fort !*int !*msg !*nat !*protfg errmsg!* curline!*);nil

global '(cursym!* erfg!* ofl!* outl!*);nil

symbolic procedure lpri u;
   while u do <<
      prin2 car u;
      prin2 " ";
      u := cdr u >>;
+++ lpri redefined
+++ lpri compiled, 11 + 16 bytes
lpri

symbolic procedure lpriw(u, v);
   begin
      u := u . if v and atom v then list v else v;
      if null ofl!* then <<
% In the simple case where no "out" commands have been used this
% just calls lpri to display a message.
         terpri();
         lpri u;
         terpri() >>
      else <<
         if not (!*fort or not !*nat or !*defn) then <<
% Write the message to the current output unless current output satisfies
% various special conditions.
            terpri();
            lpri u;
            terpri() >>;
% Also write it to the standard output.
         wrs nil;
         lpri u;
         terpri();
         wrs cdr ofl!* >>
   end;
+++ lpriw redefined
+++ lpriw compiled, 50 + 28 bytes
lpriw


symbolic procedure lprim u;
   !*msg and lpriw("***",u);
+++ lprim redefined
+++ lprim compiled, 8 + 20 bytes
lprim

symbolic procedure lprie u;
   begin
      scalar x;
     if not !*int then <<
        x := !*defn;
        !*defn := nil>>;
     erfg!* := t;
     lpriw("*****", u);
     if null !*int then !*defn := x
   end;
+++ lprie compiled, 19 + 32 bytes
lprie

symbolic procedure printty u;
   begin
      scalar ofl;
      if null !*fort and !*nat then print u;
      if null ofl!* then return nil;
      ofl := ofl!*;
      wrs nil;
      print u;
      wrs cdr ofl
   end;
+++ printty compiled, 23 + 20 bytes
printty

symbolic procedure rerror(packagename, number, message);
   << errmsg!* := message; rederr message >>;
+++ rerror compiled, 5 + 16 bytes
rerror

symbolic procedure rederr u;
   begin if not !*protfg then lprie u; error1() end;
+++ rederr compiled, 7 + 16 bytes
rederr

symbolic procedure symerr(u,v);
   begin
      scalar x;
      erfg!* := t;
      if numberp cursym!* or not(x := get(cursym!*,'prtch)) then
         x := cursym!*;
      terpri();
      if !*echo then terpri();
      outl!* := car outl!* . '!$!$!$ . cdr outl!*;
      comm1 t;
      outl!* := reversip!* outl!*;
      while outl!* do <<
         prin2 car outl!*;
         outl!* := cdr outl!* >>;
      terpri();
      prin2 "at line "; prin2 curline!*;
      if ifl!* then << prin2 " of file "; prin2 car ifl!* >>;
      terpri();
      if null v then rerror('rlisp,5,u)
      else rerror('rlisp, 6,
         if u then list(x, "invalid", "in", u, "statement")
         else list(x, "invalid"))
   end;
+++ symerr compiled, 110 + 96 bytes
symerr

symbolic procedure typerr(u, v);
   rerror('rlisp, 6, list(u, "invalid as", v));
+++ typerr compiled, 13 + 24 bytes
typerr

endmodule;nil

end;nilmodule parser;nil  % Functions for parsing RLISP expressions.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*backtrace);nil

global '(cursym!*);nil

% With the exception of assignment statements, which are handled by
% XREAD, statements in REDUCE are introduced by a key-word, which
% initiates a reading process peculiar to that statement.  The key-word
% is recognized (in XREAD1) by the indicator STAT on its property list.
% The corresponding property is the name of the function (of no
% arguments) which carries out the reading sequence.

% ***** COMMENTS *****

symbolic procedure comm1 u;
   begin scalar bool;
      if u = 'end then scan();
      while not
         (cursym!* = '!*semicol!* or
          (u = 'end and
           cursym!* memq '(end else then until !*rpar!* !*rsqbkt!*))) do <<
         if u = 'end and null bool then <<
            lprim list("END-COMMENT NO LONGER SUPPORTED");
            bool := t >>;
         scan() >>
   end;
+++ comm1 redefined
+++ comm1 compiled, 32 + 40 bytes
comm1


% ***** CONDITIONAL STATEMENT *****

symbolic procedure ifstat;
   begin scalar condx,condit;
    a:  condx := xread t;
        if not(cursym!* = 'then) then symerr('if,t);
        condit := aconc!*(condit,list(condx,xread t));
        if not(cursym!* = 'else) then nil
         else if scan() = 'if then go to a
         else condit := aconc!*(condit,list(t,xread1 t));
        return ('cond . condit)
   end;
+++ ifstat redefined
+++ ifstat compiled, 55 + 52 bytes
ifstat

put('if,'stat,'ifstat);ifstat

flag ('(then else),'delim);nil


% ***** FUNCTION STATEMENT *****

symbolic procedure functionstat;
   begin scalar x;
      x := scan();
      return list('function,
                  if x = '!*lpar!* then xread1 t
                  else if idp x and null(x = 'lambda) then << scan(); x >>
                  else symerr("Function", t))
   end;
+++ functionstat compiled, 34 + 44 bytes
functionstat

put('function,'stat,'functionstat);functionstat


% ***** LAMBDA STATEMENT *****

symbolic procedure lamstat;
   begin scalar x,y;
        x:= xread 'lambda;
        if x then x := remcomma x;
        y := list('lambda,x,xread t);
        return y
   end;
+++ lamstat compiled, 20 + 24 bytes
lamstat

put ('lambda,'stat,'lamstat);lamstat


% ***** GROUP STATEMENT *****

symbolic procedure readprogn;
   %Expects a list of statements terminated by a >>;
   begin scalar lst;
      lst := list xread 'group;
      while not (cursym!* = '!*rsqbkt!*) do
         lst := aconc!*(lst,xread 'group);
      scan();
      return ('progn . lst)
   end;
+++ readprogn redefined
+++ readprogn compiled, 25 + 36 bytes
readprogn

put('!*lsqbkt!*,'stat,'readprogn);readprogn

flag ('(!*lsqbkt!*),'go);nil

flag('(!*rsqbkt!*),'delim);nil

flag('(!*rsqbkt!*),'nodel);nil

% ***** END STATEMENT *****

symbolic procedure endstat;
  %This procedure can also be used for any key-words  which  take  no
  %arguments;
  begin
    scalar x;
    x := cursym!*;
    comm1 'end;
    return list x
  end;
+++ endstat redefined
+++ endstat compiled, 8 + 20 bytes
endstat

put('end,'stat,'endstat);endstat

put('endmodule,'stat,'endstat);endstat

put('bye,'stat,'endstat);endstat

put('quit,'stat,'endstat);endstat

flag('(bye quit),'eval);nil

symbolic procedure endstat1;
  % A keyword that can optionally be followed with a string.
  begin
    scalar x, optarg;
    x := cursym!*;
    scan();
    if stringp cursym!* then optarg := cursym!*;
    while not (cursym!* = '!*semicol!*) and
% The next line is to allow for an ENDSTAT1 to omit the semicolon that
% would normally come after it if what happens next is a word like
% ">>" or "else"...
          not (idp cursym!* and flagp(cursym!*, 'delim)) do scan();
    return list(x, optarg)
   end;
+++ endstat1 compiled, 29 + 24 bytes
endstat1

put('showtime,'stat,'endstat1);endstat1
% showtime, showtime1, showtime2 and showtime3 will just be independent
% timing statements so that one can be used without interfering with
% any of the others.
put('showtime1,'stat,'endstat1);endstat1
put('showtime2,'stat,'endstat1);endstat1
put('showtime3,'stat,'endstat1);endstat1

% "resettime" re-bases the counter but does not print anything.
put('resettime,'stat,'endstat);endstat
put('resettime1,'stat,'endstat);endstat
put('resettime2,'stat,'endstat);endstat
put('resettime3,'stat,'endstat);endstat

endmodule;nil

end;nilmodule block;nil   % Block statement and related operators.

% Author: Anthony C. Hearn.

% Copyright (c) 1993 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*blockp !*novarmsg !*rlisp88);nil

global '(!*vars!* cursym!* nxtsym!*);nil

flag('(novarmsg),'switch);nil

% ***** GO statement *****

symbolic procedure gostat;
   begin scalar var;
        var := if eq(scan(),'to) then scan() else cursym!*;
        scan();
        return list('go,var)
   end;
+++ gostat redefined
+++ gostat compiled, 14 + 24 bytes
gostat

put('go,'stat,'gostat);gostat

put('goto,'newnam,'go);go


% ***** Declaration Statement *****

% This is called from two locations. It is called with argument "t"
% at the head of a block, so there it deals with things like
% "begin scalar v1,v2,v3; ...". Then decstat could call it with argument nil
% and that arises when the xread encounters INTEGER, REAL or SCALAR.

symbolic procedure read_parameter_list();
% This version should only be used for declaring local variables. It
% allows types and intialization, so the syntax will allow for things like
%    scalar a,          % original style
%           b:typeb,    % with type specifier
%           c:=initc,   % initialize as you go
%           d:td:=id,   % type and initializer
%           e;
%
% It returns a list of items each of which is (name type initial_value).
%
   begin scalar x,xt,xv,y,z;
      repeat <<
        if cursym!* = '!*comma!* then scan();
        x := cursym!*;
        if not idp x then typerr(x,"variable name");
        y := scan();
        if y = '!*colon!* then <<
          scan();
          xt := read_type();
          y := cursym!* >>
        else xt := 'general;
        if y = 'setq then <<
          scan();
          xv := xread1 t;
          y := cursym!* >>
        else xv := nil;
        z := list(x, xt, xv) . z
      >> until not (y = '!*comma!*);
      return reversip z
   end;
(prog nil repeatlabel (progn (cond ((equal cursym!* (quote !*comma!*)) (scan)))
(setq x cursym!*) (cond ((not (idp x)) (typerr x "variable name"))) (setq y (
scan)) (cond ((equal y (quote !*colon!*)) (progn (scan) (setq xt (read_type)) (
setq y cursym!*))) (t (setq xt (quote general)))) (cond ((equal y (quote setq))
(progn (scan) (setq xv (xread1 t)) (setq y cursym!*))) (t (setq xv nil))) (setq
z (cons (list x xt xv) z))) (cond ((not (not (equal y (quote !*comma!*)))) (go
repeatlabel))))
+++ read_parameter_list compiled, 63 + 56 bytes
read_parameter_list

% This now returns a list of variables and a list of declaration
% information.

symbolic procedure collect_decls(u, w);
  if null u then nil
  else (caar u . w) . collect_decls(cdr u, w);
+++ collect_decls compiled, 15 + 12 bytes
collect_decls

symbolic procedure decl();
   begin scalar varlis,w,pl,typelist;
   a: while cursym!* = '!*semicol!* do scan();
      if cursym!* = 'local and !*reduce4 then nil
      else if not flagp(cursym!*,'type) then return (varlis . typelist)
      else if !*reduce4 then typerr(cursym!*,"local declaration");
      w := cursym!*;
      scan();
      if !*reduce4 then varlis := append(varlis,read_param_list nil)
      else if cursym!* = '!*semicol!* then <<
        lprim list("Empty variable list in",w,"declaration");
        return (nil . nil) >>
      else <<
        pl := read_parameter_list();
        typelist := append(typelist, pl);
        varlis := append(varlis, collect_decls(pl, w)) >>;
      if not(cursym!* = '!*semicol!*) then symerr(nil,t);
      scan();
      go to a
   end;
+++ decl compiled, 94 + 72 bytes
decl

put('integer,'initvalue!*,0);0

symbolic procedure decstat;
% Called following a word like "scalar" or "integer" or "real"
% other than at the start of a block. The only valid case is when the
% next word is "procedure" and even this is an archaic thow-back to
% "mode Reduce".
  begin scalar x;
     if !*blockp then symerr('block,t);
     x := cursym!*;
     if nxtsym!* neq 'procedure
       then rerror('rlisp,7,list(x,"invalid outside block"));
     scan();
     return procstat1 x
  end;
+++ decstat compiled, 32 + 60 bytes
decstat

flag('(integer real scalar),'type);nil

symbolic procedure blocktyperr u;
   % Type declaration found at wrong position.
   rerror('rlisp,8,list(u,"invalid except at head of block"));
+++ blocktyperr compiled, 11 + 24 bytes
blocktyperr


% ***** Block Statement *****

symbolic procedure mapovercar u;
   begin scalar x;
   while u do <<
      x := caar u . x;
      u := cdr u >>;
   return reversip!* x
   end;
+++ mapovercar compiled, 15 + 12 bytes
mapovercar

% If you annotate the declaration of local variable (at a block-head)
% with type information then the block will end up starting with
% a quoted expression of the types...
%
%     begin scalar a:type1:=val1, b:type2, c:=val3; ...
% =>  (prog (a b) (quote ((a type1 val1) (b type2 nil) (c general val3))) ...
%
% I will want to migrate the initialization material into executable
% code soon.

% The information I have on the local variable is in a list structured
% as ((name type initial_value) ...)

% At the head of the block I will put a quoted expression that has just
% ((name . type) ...) info in it, and that omits any cases where the type
% is given as just 'general.

symbolic procedure extract_types vl;
  if null vl then nil
  else if cadar vl = 'general then extract_types cdr vl
  else (caar vl . cadar vl) . extract_types cdr vl;
+++ extract_types compiled, 25 + 16 bytes
extract_types

% Where there are non-nil initializers stick them on the front of the
% body code.

symbolic procedure add_initializers(vl, b);
  if null vl then b
  else if null caddar vl then add_initializers(cdr vl, b)
  else list('setq, caar vl, caddar vl) . add_initializers(cdr vl, b);
+++ add_initializers compiled, 30 + 12 bytes
add_initializers

symbolic procedure add_varinfo(vl, b);
  begin
    scalar tt;
    tt := extract_types vl;
    b := add_initializers(vl, b);
% Only put the (quote (name . type) ...) info if there is some present.
    if tt then b := mkquote tt . b;
    return b
  end;
+++ add_varinfo compiled, 15 + 20 bytes
add_varinfo

symbolic procedure blockstat;
   begin scalar hold,varlis,x,!*blockp;
        !*blockp := t;
        scan();
        if cursym!* memq '(nil !*rpar!*)
          then rerror('rlisp, 9, "BEGIN invalid");
        varlis := decl();
    a:  if cursym!* = 'end and not(nxtsym!* = '!:) then <<
           comm1 'end;
           return mkblock(car varlis, add_varinfo(cdr varlis, hold)) >>;
        x := xread1 nil;
        if eqcar(x, 'end) then
           return mkblock(car varlis, add_varinfo(cdr varlis, hold));
        if not(cursym!* = 'end) then scan();
        if x then <<
           (if eqcar(x, 'equal) then
               lprim list("top level", cadr x, "= ... in block"));
           hold := aconc!*(hold, x) >>;
        go to a;
   end;
+++ blockstat redefined
+++ blockstat compiled, 97 + 100 bytes
blockstat

symbolic procedure mkblock(u,v); 'rblock . (u . v);
+++ mkblock compiled, 5 + 12 bytes
mkblock

putd('rblock,'macro,
   '(lambda (u) (cons 'prog (cons (mapovercar (cadr u)) (cddr u)))));
+++ rblock_f6m8t0grzrv compiled, 11 + 16 bytes
rblock

symbolic procedure symbvarlst(vars,body,mode);
   begin scalar x,y;
      if not (mode = 'symbolic) then return nil;
      y := vars;
      while y do <<
         x := if pairp car y then caar y else car y;
         if not fluidp x and
            not globalp x and
            not smemq(x,body) and
            not !*novarmsg then
            lprim list("local variable",x,"in procedure", fname!*,"not used");
         y := cdr y >>;
   end;
+++ symbvarlst redefined
+++ symbvarlst compiled, 53 + 52 bytes
symbvarlst

symbolic procedure make_prog_declares(v, b);
   begin
#if (getd 'declare)
% This detects any bound variables that are fluid (or global) at the
% time I process this code and adds in a DECLARE to remind us about
% that fact. I should put in an explanation for the benefit of those who
% do not expect this. In CSL some definitions are extracted from the body
% of the source for compilation into C (and similar issues could potentially
% arise with in-lining of function definitions). The consequence of this is
% that the code concerned is compiled at a stage that is NOT when it has
% just been read from its source file. If the function binds and fluid
% variables then the fluid declaration MUST be visible at the time it is
% compiled, and the only way to achieve this is for the declaration to be
% included as part of the code. I use the Common Lisp notation for this
% with "declare special" stuck in as a first item in the procedure body.
% This is not actually very CSL specific... if one built a system using any
% Lisp with everything initially interpreted then there is no good guarantee
% that fluid declarations for eveything will be in force at run-time - and so
% attempts to compile parts of the code incrementally at that late stage
% could cause disaster. Well there would be further issues in that case
% depending on whether the interpreter treated variable bindings as lexical
% or fluid in the absence of declarations.
     scalar w, r;
     w := v;
     while w do <<
        if fluidp car w or globalp car w then r := car w . r;
        w := cdr w >>;
     if r then b := list('declare, 'special . r) . b;
#endif
     return ('prog . v . b)
   end;
+++ make_prog_declares compiled, 43 + 28 bytes
make_prog_declares

symbolic procedure formblock(u,vars,mode);
   begin scalar w;
     symbvarlst(cadr u,cddr u,mode); % Merely report on any unused vars
     w := initprogvars cadr u;
     return make_prog_declares(car w,
                      append(cdr w,
                             formprog1(cddr u,append(cadr u,vars),mode)));
   end;
+++ formblock compiled, 35 + 24 bytes
formblock

symbolic procedure initprogvars u;
   begin scalar x,y,z;
      while u do <<
         if null caar u or caar u = 't then rsverr caar u
         else if (z := get(caar u,'initvalue!*)) or
                 (z := get(cdar u,'initvalue!*)) then
            y := mksetq(caar u,z) . y;
         x := caar u . x;
         u := cdr u >>;
      return (reversip!* x . reversip!* y)
   end;
+++ initprogvars compiled, 51 + 28 bytes
initprogvars

symbolic procedure formprog(u,vars,mode);
   make_prog_declares(cadr u,
                      formprog1(cddr u,pairvars(cadr u,vars,mode),mode));
+++ formprog compiled, 20 + 20 bytes
formprog


symbolic procedure formprog1(u,vars,mode);
   if null u then nil
    else if null car u then formprog1(cdr u,vars,mode)
        % remove spurious NILs, probably generated by FOR statements.
    else if atom car u then car u . formprog1(cdr u,vars,mode)
    else if eqcar(car u, 'quote) and not (mode = 'symbolic) then
       formprog1(cdr u,vars,mode)
    else if idp caar u and flagp(caar u,'modefn)
           then if !*rlisp88 and null(caar u = 'symbolic)
                  then typerr("algebraic expression","Rlisp88 form")
          else formc(cadar u,vars,caar u) . formprog1(cdr u,vars,mode)
    else formc(car u,vars,mode) . formprog1(cdr u,vars,mode);
+++ formprog1 compiled, 86 + 44 bytes
formprog1

put('rblock,'formfn,'formblock);formblock

put('prog,'formfn,'formprog);formprog

put('begin,'stat,'blockstat);blockstat

flag('(declare), 'noform);nil

% ***** Return Statement *****

symbolic procedure retstat;
   if not !*blockp then symerr(nil,t)
    else begin scalar !*blockp;  % To prevent RETURN within a RETURN.
            return list('return,
                if flagp(scan(),'delim) then nil else xread1 t)
      end;
+++ retstat compiled, 29 + 36 bytes
retstat

put('return,'stat,'retstat);retstat

endmodule;nil

end;nilmodule form;nil  % Performs a mode analysis of parsed forms.

% Author: Anthony C. Hearn.

% Modifications by: Jed Marti, Arthur C. Norman.

% Copyright (c) 1993 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%

fluid '(!*!*a2sfn !*comp !*cref !*defn !*mode !*reduce4 !*rlisp88
        current!-modulus fname!* ftype!* !*strict_argcount
        !*argnochk);nil

global '(!*composites !*force !*micro!-version !*vars!* cursym!*);nil

!*!*a2sfn := 'aeval;aeval

flag('(algebraic symbolic),'modefn);nil

symbolic procedure formcond(u,vars,mode);
   'cond . formcond1(cdr u,vars,mode);
+++ formcond redefined
+++ formcond compiled, 11 + 16 bytes
formcond

symbolic procedure formcond1(u,vars,mode);
   if null u then nil
    else list(formbool(caar u,vars,mode),formc(cadar u,vars,mode))
       % FORM1 here leaves out top level REVAL.
              . formcond1(cdr u,vars,mode);
+++ formcond1 redefined
+++ formcond1 compiled, 29 + 20 bytes
formcond1

put('cond,'formfn,'formcond);formcond

% See formprog for commentary.
% NOTE that this can create a LAMBDA with a PROGN, as
% in (lambda (q) (progn 
%                  (declare (special q))
%                  original_body)
% which hides the DECLARE within a PROGN. This is so that there
% remains just one item in the body.

symbolic procedure formlamb(u,vars,mode);
   begin scalar v, b, fl;
      v := cadr u;
      while v do <<
% Trying to rebind NIL or T as a lambda-variable would be an error.
         if null car v or car v = 't then rsverr car v;
         v := cdr v >>;
      v := cadr u;
      b := list form1(caddr u, pairvars(v, vars, mode), mode);
#if (getd 'declare)
% See comments elsewhere in the source about why DECLARE is important here.
      while v do <<
         if fluidp car v or globalp car v then fl := car v . fl;
         v := cdr v >>;
      if fl then b := list('declare, 'special . fl) . b;
      v := cadr u;
#endif
      return 'lambda . v . b;
   end;
+++ formlamb compiled, 80 + 44 bytes
formlamb

put('lambda,'formfn,'formlamb);formlamb

symbolic procedure formprogn(u,vars,mode);
   'progn . formclis(cdr u,vars,mode);
+++ formprogn redefined
+++ formprogn compiled, 11 + 16 bytes
formprogn

put('progn,'formfn,'formprogn);formprogn

symbolic procedure expdrmacro u;
   % Returns the macro form for U if expansion is permitted.
   begin scalar x;
      if null(x := getrmacro u) or flagp(u,'noexpand) then return nil
       else if !*cref and null flagp(u,'expand) and null !*force
        then return nil
       else return x
   end;
+++ expdrmacro redefined
+++ expdrmacro compiled, 20 + 28 bytes
expdrmacro

symbolic procedure getrmacro u;
   %returns a Reduce macro definition for U, if one exists,
   %in GETD format;
   begin scalar x;
      return if not idp u then nil
       else if (x := getd u) and car x = 'macro then x
       else if (x := get(u,'inline)) then 'inline . x
       else if (x := get(u,'smacro)) then 'smacro . x
       else nil
   end;
+++ getrmacro redefined
+++ getrmacro compiled, 34 + 28 bytes
getrmacro

symbolic procedure applmacro(u,v,w); apply1(u,w . v);
+++ applmacro compiled, 8 + 8 bytes
applmacro

put('macro,'macrofn,'applmacro);applmacro

flag('(ed go quote),'noform);nil

symbolic procedure all!-vars!-in(x, l);
  if atom x then
     if atsoc(x, l) then l
     else (x . t) . l
  else all!-vars!-in(cdr x, all!-vars!-in(car x, l));
+++ all!-vars!-in compiled, 24 + 12 bytes
all-vars-in

% The next bit arranges that
%     quotecode <any rlisp expression>
% turns into (quote <the lisp version of that code>)
% but that (a) any "form" actions needed have bene performed on the
% code and (b) there will never be moans about use of undeclared name
% in the code. The latter is achieved using all!-vars!-in that makes
% an association list naming all atoms present in the code so that it
% appears that all are in scope.

symbolic procedure formquotecode(u, vars, mode);
  mkquote form1(cadr u, all!-vars!-in(cadr u, nil), mode);
+++ formquotecode compiled, 13 + 20 bytes
formquotecode

put('quotecode, 'formfn, 'formquotecode);formquotecode

symbolic procedure set!-global!-mode u;
   begin
      !*mode := u;
      return list('null,list('setq,'!*mode,mkquote u))
   end;
+++ set!-global!-mode redefined
+++ set!-global!-mode compiled, 17 + 24 bytes
set-global-mode

symbolic procedure form1(u,vars,mode);
   begin scalar x,y;
      if atom u
        then return if not idp u then u
                     else if u = 'ed then list u
                     else if flagp(u,'modefn) then set!-global!-mode u
                     else if x:= get(mode,'idfn)
                      then apply2(x,u,vars)
                     else u
       else if not atom car u then return form2(u,vars,mode)
       else if not idp car u then typerr(car u,"operator")
       else if car u = 'comment
        then return form1(car lastpair u,vars,mode)
       else if flagp(car u,'noform) then return u
       else if arrayp car u
          and mode = 'symbolic
        then return list('getel,intargfn(u,vars,mode))
       else if pairp cdr u and (get(car u,'rtype) = 'vector
             or vectorp cadr u or flagpcar(cadr u,'vecfn))
        then return getvect(u,vars,mode)
       else if flagp(car u,'modefn)
        then return convertmode(cadr u,vars,mode,car u)
       else if (x := get(car u,'formfn))
        then return macrochk(apply3(x,u,vars,mode),mode)
       else if get(car u,'stat) = 'rlis
        then return macrochk(formrlis(u,vars,mode),mode)
       else if car u = '!*comma!*
        then if not atom cadr u and atom caddr u
                 and flagp(caadr u,'type)
               then blocktyperr caadr u
              else rerror('rlisp,10,
                          list("Syntax error: , invalid after",cadr u));
      % Exclude algebraic operator with same name as symbolic function.
      if mode = 'symbolic or flagp(car u,'opfn)
        then argnochk u;
      x := formlis(cdr u,vars,mode);
      y := if x=cdr u then u else car u . x;
      return if mode = 'symbolic
              or get(car u,'stat)
              or cdr u and eqcar(cadr u,'quote)
                       and null(!*micro!-version and null !*defn)
              or intexprnp(y,vars) and null !*composites
                 and current!-modulus=1
               then macrochk(y,mode)
              else if not(mode = 'algebraic)
               then convertmode(y,vars,mode,'algebraic)
              else ('list . algid(car u,vars) . x)
   end;
+++ form1 redefined
+++ form1 compiled, 307 + 172 bytes
form1

symbolic procedure form2(u,vars,mode);
   begin scalar x;
      if x := get(caar u,'form2fn) then return apply3(x,u,vars,mode)
        else typerr(car u,"operator")
   end;
+++ form2 compiled, 18 + 20 bytes
form2

put('lambda,'form2fn,'formlis);formlis

symbolic procedure argnochk u;
   begin scalar x;
      if null !*argnochk then return u
       else if (x := argsofopr car u) then <<
          if x neq length cdr u
          %% and null get(car u,'simpfn)
          and null (get(car u,'simpfn) or get(car u,'psopfn) or
                    flagp(car u, 'variadic)) % FJW ?????
        then <<
           if !*strict_argcount then <<
              prin2 "+++++ "; print u;
              rerror('rlisp,11,list(car u,"called with",
                                   length cdr u,
                                   if length cdr u=1 then "argument"
                                    else "arguments",
                                   "instead of",x)) >>
           else <<
              lprim list(car u, "called with", length cdr u,
                                "instead of", x, "arguments");
              return u >>>>
 
        else return u >>
      else <<
        put(car u, 'number!-of!-args, length cdr u);
        return u >>
   end;
+++ argnochk redefined
+++ argnochk compiled, 117 + 88 bytes
argnochk

flag('(cond and or list list!* plus times logand logor
       iplus itimes ilogand ilogor defautoload gethash
       restart!-csl preserve checkpoint filestatus
       bldmsg plotdriver fdeclare !& !| lpdotimes
       ), 'variadic);nil

symbolic procedure argsofopr u;
   % This function may be optimizable in various implementations.
   get(u,'number!-of!-args);
+++ argsofopr redefined
+++ argsofopr compiled, 4 + 8 bytes
argsofopr

fluid '(!*revalp);nil
!*revalp := t;t

symbolic procedure intexprnp(u,vars);
   %determines if U is an integer expression. Note that with "off revalp;"
   % nothing is considered to be an integer!
    if not !*revalp then nil
    else if atom u then if numberp u then fixp u
                   else if (u := atsoc(u,vars)) then cdr u = 'integer
                   else nil
     else idp car u and flagp(car u,'intfn) and intexprlisp(cdr u,vars);
+++ intexprnp redefined
+++ intexprnp compiled, 37 + 28 bytes
intexprnp

symbolic procedure intexprlisp(u,vars);
   null u or intexprnp(car u,vars) and intexprlisp(cdr u,vars);
+++ intexprlisp redefined
+++ intexprlisp compiled, 14 + 16 bytes
intexprlisp

flag('(difference minus plus times),'intfn);nil
   % EXPT is not included in this list, because a negative exponent can
   % cause problems (i.e., result can be rational);

symbolic procedure formlis(u,vars,mode);
   begin
      scalar x;
% Note that I do not have the "FOR EACH x IN ..." syntax available yet...
      while u do <<
         x := form1(car u, vars, mode) . x;
         u := cdr u >>;
      return reversip!* x;
   end;
+++ formlis redefined
+++ formlis compiled, 19 + 16 bytes
formlis

symbolic procedure formclis(u,vars,mode);
   begin
      scalar x;
      while u do <<
         x := formc(car u,vars,mode) . x;
         u := cdr u >>;
      return reversip!* x;
   end;
+++ formclis redefined
+++ formclis compiled, 19 + 16 bytes
formclis

symbolic procedure form u;
   if null atom u and flagp(car u,'always_nform)
     then n_form u   % REDUCE 4.
    else if null !*rlisp88 then form1(u,!*vars!*,!*mode)
    else if null(!*mode = 'symbolic)
        or flagp(u,'modefn) and null(u = 'symbolic)
        or flagpcar(u,'modefn) and null(car u = 'symbolic)
     then typerr("algebraic expression","Rlisp88 form")
    else form1(u,!*vars!*,!*mode);
+++ form redefined
+++ form compiled, 56 + 52 bytes
form

symbolic procedure macrochk(u,mode);
   begin scalar y;
      % Expands U if CAR U is a macro and expansion allowed.
      % This model has the problem that nested macros are not expanded
      % at this point (but they will be in the compiler).
      if atom u then return u
       else if (y := expdrmacro car u)
        and (mode = 'symbolic or idp car u and flagp(car u,'opfn))
        then return apply3(get(car y,'macrofn),cdr y,cdr u,car u)
       else return u
   end;
+++ macrochk redefined
+++ macrochk compiled, 31 + 24 bytes
macrochk

put('symbolic,'idfn,'symbid);symbid

symbolic procedure symbid(u,vars);
   <<if fname!* and null(ftype!* memq '(macro smacro inline))
       and not(atsoc(u,vars) or fluidp u or globalp u
        or null u or u eq t or flagp(u,'share) or !*comp or !*cref
        or get(u,'constant!?))
       then lprim list("nonlocal use of undeclared variable",u,
                       "in procedure",fname!*);
     u>>;
+++ symbid redefined
+++ symbid compiled, 60 + 64 bytes
symbid

put('algebraic,'idfn,'algid);algid

symbolic procedure algid(u,vars);
   if atsoc(u,vars) or flagp(u,'share) then u else mkquote u;
+++ algid redefined
+++ algid compiled, 13 + 12 bytes
algid

put('integer,'idfn,'intid);intid

symbolic procedure intid(u,vars);
   begin scalar x,y;
      return if (x := atsoc(u,vars))
        then if cdr x = 'integer then u
               else if y := get(cdr x,'integer)
                then apply2(y,u,vars)
               else if cdr x = 'scalar then !*!*a2i(u,vars)
               else rerror('rlisp,12,
                           list(cdr x,"not convertable to INTEGER"))
      else !*!*a2i(mkquote u,vars)
   end;
+++ intid compiled, 44 + 40 bytes
intid

symbolic procedure convertmode(exprn,vars,target,source);
   convertmode1(form1(exprn,vars,source),vars,target,source);
+++ convertmode redefined
+++ convertmode compiled, 19 + 16 bytes
convertmode

symbolic procedure convertmode1(exprn,vars,target,source);
   begin scalar x;
      if source = 'real then source := 'algebraic;
      if target = 'real then target := 'algebraic;
      if target eq source then return exprn
       else if idp exprn and (x := atsoc(exprn,vars))
          and not(cdr x memq '(integer scalar real))
          and not(cdr x eq source)
        then return convertmode(exprn,vars,target,cdr x)
       else if not (x := get(source,target))
        then typerr(source,target)
       else return apply2(x,exprn,vars)
   end;
+++ convertmode1 redefined
+++ convertmode1 compiled, 62 + 32 bytes
convertmode1

put('algebraic,'symbolic,'!*!*a2s);**a2s

put('symbolic,'algebraic,'!*!*s2a);**s2a

symbolic procedure !*!*a2s(u,vars);
   % It would be nice if we could include the ATSOC(U,VARS) line,
   % since in many cases that would save recomputation. However,
   % in any sequential process, assignments or substitution rules
   % can change the value of a variable, so we have to check its
   % value again.  More comprehensive analysis could certainly
   % optimize this.  We could also avoid wrapping an integer, thus
   % making a mode change only occur within an expression.
   if null u then rederr "tell Hearn!!"
%   else if constantp u and null fixp u
%     or intexprnp(u,vars) and null !*composites
%                and null current!-modulus
    else if flagpcar(u,'nochange) and not(car u = 'getel)
     then u
    % Expressions involving "random" cannot be cached.
    % We need smember rather than smemq in case the "random" is
    % in a quoted expression.
#if (getd 'declare)
    else if smember('random,u) then
     list(list('lambda,'(!*uncached),
       list('progn, '(declare (special !*uncached)), list(!*!*a2sfn,u))),t)
#else
    else if smember('random,u) then
     list(list('lambda,'(!*uncached),list(!*!*a2sfn,u)),t)
#endif
    else list(!*!*a2sfn,u);
+++ !*!*a2s redefined
+++ !*!*a2s compiled, 51 + 56 bytes
**a2s

symbolic procedure !*!*s2a(u,vars); u;
+++ !*!*s2a redefined
+++ !*!*s2a compiled, 1 + 8 bytes
**s2a

symbolic procedure formc(u, vars, mode);
   %this needs to be generalized;
   if !*rlisp88 and flagpcar(u, 'modefn) and null(car u = 'symbolic) then
      typerr("algebraic expression", "Rlisp88 form")
   else if mode = 'algebraic and intexprnp(u, vars) then u
   else convertmode(u, vars, 'symbolic, mode);
+++ formc redefined
+++ formc compiled, 38 + 44 bytes
formc

symbolic procedure intargfn(u,vars,mode);
   % transforms array element U into expression with integer arguments.
   % Array name is treated as an algebraic variable;
   begin scalar x,y;
      y := cdr u;
      while y do <<
         x := convertmode(car y, vars, 'integer, mode) . x;
         y := cdr y >>;
      return 'list . form1(car u, vars, 'algebraic) . reversip!* x
   end;
+++ intargfn redefined
+++ intargfn compiled, 40 + 32 bytes
intargfn

put('algebraic,'integer,'!*!*a2i);**a2i

symbolic procedure !*!*a2i(u,vars);
   if intexprnp(u,vars) then u else list('ieval,u);
+++ !*!*a2i redefined
+++ !*!*a2i compiled, 11 + 16 bytes
**a2i

symbolic procedure ieval u; !*s2i reval u;
+++ ieval redefined
+++ ieval compiled, 5 + 16 bytes
ieval

flag('(ieval),'opfn);nil   % To make it a symbolic operator.

flag('(ieval),'nochange);nil

put('symbolic,'integer,'!*!*s2i);**s2i

symbolic procedure !*!*s2i(u,vars);
   if fixp u then u else list('!*s2i,u);
+++ !*!*s2i compiled, 9 + 12 bytes
**s2i

symbolic procedure !*s2i u;
   if fixp u then u else typerr(u,"integer");
+++ !*s2i compiled, 9 + 16 bytes
*s2i

put('integer,'symbolic,'identity);identity

symbolic procedure identity(u,vars); u;
+++ identity redefined
+++ identity compiled, 1 + 8 bytes
identity

symbolic procedure formbool(u,vars,mode);
   if mode = 'symbolic then formc(u,vars,mode)
    else if atom u then if u = 't then u
           else if not idp u or atsoc(u,vars)
           then list('boolvalue!*,u)
          else list('boolvalue!*,formc!*(u,vars,mode))
    else if intexprlisp(cdr u,vars) and get(car u,'boolfn) then u
    else if idp car u and get(car u,'boolfn)
     then get(car u,'boolfn) . formclis(cdr u,vars,mode)
    else if idp car u and flagp(car u,'boolean)
        then car u . formboollis(cdr u,vars,mode,flagp(car u,'boolargs))
    else if car u = 'boolvalue!* then rederr("Too many formbools")
    else if car u = 'where
     then list('boolvalue!*,
           formc!*(list('where,
                   mkquote list('bool!-eval,formbool(cadr u,vars,mode)),
                   caddr u),
                   vars,mode))
    else list('boolvalue!*,formc!*(u,vars,mode));
+++ formbool redefined
+++ formbool compiled, 165 + 76 bytes
formbool

symbolic procedure formboollis(u, vars, mode, bool);
   begin scalar x;
      while u do <<
         if bool then x := formbool(car u, vars, mode) . x
         else x := formc!*(car u, vars, mode) . x;
         u := cdr u >>;
      return reversip!* x;
   end;
+++ formboollis redefined
+++ formboollis compiled, 34 + 20 bytes
formboollis

symbolic procedure bool!-eval u; lispeval u;
+++ bool!-eval compiled as link to lispeval
bool-eval

flag('(bool!-eval),'noform);nil

flag('(bool!-eval),'opfn);nil  % symbolic operator bool!-eval.

flag('(bool!-eval),'noval);nil

symbolic procedure boolvalue!* u; u and null(u = 0);
+++ boolvalue!* redefined
+++ boolvalue!* compiled, 9 + 12 bytes
boolvalue*

symbolic procedure formc!*(u,vars,mode);
   begin scalar !*!*a2sfn;
      !*!*a2sfn := 'revalx;
      return formc(u,vars,mode)
   end;
+++ formc!* redefined
+++ formc!* compiled, 15 + 24 bytes
formc*

symbolic procedure revalx u;
   % Defined this way to handle standard form kernels in pattern
   % matching.
   reval if not atom u and not atom car u then prepf u else u;
+++ revalx redefined
+++ revalx compiled, 13 + 16 bytes
revalx

% Functions with side effects must be handled carefully in this model,
% otherwise they are not always evaluated within blocks.

symbolic procedure formrerror(u,vars,mode);
   begin scalar x;
      argnochk u;
      if not fixp caddr u then typerr(caddr u,"RERROR argument");
      x := formc!*(cadddr u,vars,mode);
      if idp cadr u then return list('rerror,mkquote cadr u,caddr u,x)
       else if eqcar(cadr u,'quote) and idp cadadr u
        then return list('rerror,cadr u,caddr u,x)
       else typerr(cadr u,"RERROR argument")
   end;
+++ formrerror compiled, 72 + 48 bytes
formrerror

deflist('((rerror formrerror)),'formfn);(rerror)   % For bootstrapping.

symbolic procedure formrederr(u,vars,mode);
   list('rederr,formc!*(cadr u,vars,mode));
+++ formrederr compiled, 12 + 16 bytes
formrederr

put('rederr,'formfn,'formrederr);formrederr

symbolic procedure formreturn(u,vars,mode);
%  begin scalar x;
%     x := form1(cadr u,vars,mode);  % FORMC here would add REVAL
%     if not(mode memq '(symbolic integer real))
%        and eqcar(x,'setq)             % Should this be more general?
%       then x := list(!*!*a2sfn,x);
%     return list('return,x)
%  end;
   list('return,formc(cadr u,vars,mode));
+++ formreturn compiled, 12 + 16 bytes
formreturn

put('return,'formfn,'formreturn);formreturn

symbolic procedure rsverr x;
   rerror('rlisp,13,list (x,"is a reserved identifier"));
+++ rsverr compiled, 11 + 24 bytes
rsverr

symbolic procedure mksetshare(u,v);
   mksetq(u,list('progn,'(setq alglist!* (cons nil nil)),v));
+++ mksetshare compiled, 11 + 20 bytes
mksetshare

symbolic procedure formsetq(u,vars,mode);
   % formsetq1 and formsetq2 are for handling assignments to lists and
   % pairs of identifiers, resp., in symbolic mode. The original
   % formsetq has been renamed to formsetq0 but remained unchanged.
   if mode neq 'symbolic then
      formsetq0 (u,vars,mode)
   else if eqcar(cadr u,'list) then
      formsetq1 (u,vars,mode)
   else if eqcar(cadr u,'cons) then
      formsetq2 (u,vars,mode)
   else
      formsetq0 (u,vars,mode);
+++ formsetq redefined
+++ formsetq compiled, 39 + 32 bytes
formsetq

symbolic procedure formsetq0(u,vars,mode);
   % u is a form starting with "setq"; vars is an alist, where the keys
   % are variables, and the values are bindings types for these like,
   % e.g., "scalar"; mode is either "algebraic" or "symbolic".
   begin scalar x,y,z;
     if idp(z := car(u := cdr u)) then y := atsoc(z,vars);
     if eqcar(cadr u,'quote) then mode := 'symbolic;
      % Make target always SYMBOLIC so that algebraic expressions
      % are evaluated before being stored.
      x := convertmode(cadr u,vars,'symbolic,mode);
      return if not atom z and <<
% If I am building on CSL and am doing a bootstrap build then !*savedef will
% be true: in that case I will display an alert every time there is an
% assignment to something non-atomic that is defined using either an
% smacro or an inline. This is done because if an smacro is changed into an
% inline then assignment via it may change behaviour.
          if !*savedef and (get(car z, 'inline) or
                            get(car z, 'smacro)) then <<
            if not zerop posn() then terpri();
            princ "+++ Assign via inline or smacro: "; print z >>; t >>
        then if not idp car z then typerr(z,"assignment")
          else if null atom(z := macrochk(z,mode)) and arrayp car z
           then list('setel,intargfn(z,vars,mode),x)
          else if null atom z
               and cdr z and (get(car z,'rtype) = 'vector
                              or vectorp cadr z
                              or flagpcar(cadr z,'vecfn))
           then putvect(u,vars,mode)
          else if eqcar(z,'part)
           then aconc('list .
                      mkquote 'setpart!* . formlis(cdr z,vars,mode),x)
          else if null atom z and (y := get(car z,'setqfn))
           then form1(applsmacro(y,append(cdr z,cdr u),nil),vars,mode)
          else if mode = 'symbolic
             and (!*rlisp88 or eqcar(z,'structfetch))
          % Allow for Rlisp '88 records in general Rlisp.
           then list('rsetf,form1(z,vars,mode),x)
          else list('setk,form1(z,vars,'algebraic),x)
             % algebraic needed above, since SETK expects it.
    else if not idp z then typerr(z,"assignment")
    else if flagp(z,'reserved) and null atsoc(z,vars) then rsverr z
    else if flagp(z,'share) then mksetshare(symbid(z,vars),x)
    else if mode = 'symbolic or y or eqcar(x,'quote)
     then mksetq(symbid(z,vars),x)
    else if vectorp cadr u or flagpcar(cadr u,'vecfn)
     then list('setv,mkquote z,cadr u)
    else list('setk,mkquote z,x)
   end;
+++ formsetq0 redefined
+++ formsetq0 compiled, 285 + 160 bytes
formsetq0

symbolic procedure formsetq1(u,vars,mode);
   begin scalar gens,resu,li,coll;
      gens := gensym();
      resu := gensym();
      vars := (gens . 'scalar) . vars;
      li := cdr cadr u;
      while li do <<
         coll := formsetq0(list('setq, car li, list('car, gens)), vars, mode) .
                 coll;
         coll := list('setq, gens, list('cdr, gens)) . coll;
         li := cdr li >>;
      coll := list('return, resu) . coll;
      return('prog . list(gens, resu) .
             formsetq0(list('setq, gens, caddr u), vars, mode) .
             list('setq, resu, gens) .
             reversip coll)
   end;
+++ formsetq1 compiled, 95 + 40 bytes
formsetq1

symbolic procedure formsetq2(u,vars,mode);
   begin scalar gens,li,coll;
      gens := gensym();
      vars := (gens . 'scalar) . vars;
      li := cdr cadr u;
      coll := formsetq0(list('setq, car li, list('car, gens)), vars, mode)
         . coll;
      coll := formsetq0(list('setq, cadr li, list('cdr, gens)),vars, mode)
         . coll;
      coll := list('return, gens) . coll;
      return('prog . list gens .
             formsetq0(list('setq, gens, caddr u), vars, mode) .
             reversip coll)
   end;
+++ formsetq2 compiled, 84 + 40 bytes
formsetq2

put('setq,'formfn,'formsetq);formsetq

% Table of SETQFNs.

symbolic procedure setcar(a,b); << rplaca(a,b); b >>;
+++ setcar redefined
+++ setcar compiled, 4 + 8 bytes
setcar

symbolic procedure setcdr(a,b); << rplacd(a,b); b >>;
+++ setcdr redefined
+++ setcdr compiled, 4 + 8 bytes
setcdr

put('car,'setqfn,'(lambda (u v) (setcar u v)));(lambda (u v) (setcar u v))

put('cdr,'setqfn,'(lambda (u v) (setcdr u v)));(lambda (u v) (setcdr u v))

put('caar,'setqfn,'(lambda (u v) (setcar (car u) v)));(lambda (u v) (setcar (car
u) v))

put('cadr,'setqfn,'(lambda (u v) (setcar (cdr u) v)));(lambda (u v) (setcar (cdr
u) v))

put('cdar,'setqfn,'(lambda (u v) (setcdr (car u) v)));(lambda (u v) (setcdr (car
u) v))

put('cddr,'setqfn,'(lambda (u v) (setcdr (cdr u) v)));(lambda (u v) (setcdr (cdr
u) v))

put('caaar,'setqfn,'(lambda (u v) (setcar (caar u) v)));(lambda (u v) (setcar (
caar u) v))

put('caadr,'setqfn,'(lambda (u v) (setcar (cadr u) v)));(lambda (u v) (setcar (
cadr u) v))

put('cadar,'setqfn,'(lambda (u v) (setcar (cdar u) v)));(lambda (u v) (setcar (
cdar u) v))

put('caddr,'setqfn,'(lambda (u v) (setcar (cddr u) v)));(lambda (u v) (setcar (
cddr u) v))

put('cdaar,'setqfn,'(lambda (u v) (setcdr (caar u) v)));(lambda (u v) (setcdr (
caar u) v))

put('cdadr,'setqfn,'(lambda (u v) (setcdr (cadr u) v)));(lambda (u v) (setcdr (
cadr u) v))

put('cddar,'setqfn,'(lambda (u v) (setcdr (cdar u) v)));(lambda (u v) (setcdr (
cdar u) v))

put('cdddr,'setqfn,'(lambda (u v) (setcdr (cddr u) v)));(lambda (u v) (setcdr (
cddr u) v))

put('caaaar,'setqfn,'(lambda (u v) (setcar (caaar u) v)));(lambda (u v) (setcar
(caaar u) v))

put('caaadr,'setqfn,'(lambda (u v) (setcar (caadr u) v)));(lambda (u v) (setcar
(caadr u) v))

put('caadar,'setqfn,'(lambda (u v) (setcar (cadar u) v)));(lambda (u v) (setcar
(cadar u) v))

put('caaddr,'setqfn,'(lambda (u v) (setcar (caddr u) v)));(lambda (u v) (setcar
(caddr u) v))

put('cadaar,'setqfn,'(lambda (u v) (setcar (cdaar u) v)));(lambda (u v) (setcar
(cdaar u) v))

put('cadadr,'setqfn,'(lambda (u v) (setcar (cdadr u) v)));(lambda (u v) (setcar
(cdadr u) v))

put('caddar,'setqfn,'(lambda (u v) (setcar (cddar u) v)));(lambda (u v) (setcar
(cddar u) v))

put('cadddr,'setqfn,'(lambda (u v) (setcar (cdddr u) v)));(lambda (u v) (setcar
(cdddr u) v))

put('cdaaar,'setqfn,'(lambda (u v) (setcdr (caaar u) v)));(lambda (u v) (setcdr
(caaar u) v))

put('cdaadr,'setqfn,'(lambda (u v) (setcdr (caadr u) v)));(lambda (u v) (setcdr
(caadr u) v))

put('cdadar,'setqfn,'(lambda (u v) (setcdr (cadar u) v)));(lambda (u v) (setcdr
(cadar u) v))

put('cdaddr,'setqfn,'(lambda (u v) (setcdr (caddr u) v)));(lambda (u v) (setcdr
(caddr u) v))

put('cddaar,'setqfn,'(lambda (u v) (setcdr (cdaar u) v)));(lambda (u v) (setcdr
(cdaar u) v))

put('cddadr,'setqfn,'(lambda (u v) (setcdr (cdadr u) v)));(lambda (u v) (setcdr
(cdadr u) v))

put('cdddar,'setqfn,'(lambda (u v) (setcdr (cddar u) v)));(lambda (u v) (setcdr
(cddar u) v))

put('cddddr,'setqfn,'(lambda (u v) (setcdr (cdddr u) v)));(lambda (u v) (setcdr
(cdddr u) v))

put('nth,'setqfn,'(lambda (l i x) (setcar (pnth l i) x)));(lambda (l i x) (
setcar (pnth l i) x))

symbolic procedure set_nth(l, i, x); setcar(pnth(l, i), x);
+++ set_nth compiled, 6 + 16 bytes
set_nth

put('getv,'setqfn,'(lambda (v i x) (putv v i x)));(lambda (v i x) (putv v i x))

put('igetv,'setqfn,'(lambda (v i x) (iputv v i x)));(lambda (v i x) (iputv v i x
))

symbolic procedure formfunc(u,vars,mode);
% ACN has changed this so that it only moans if the thing used with
% FUNCTION is a real macro. If it is an SMACRO that is now allowed. This
% is because I want to have functions that are defined BOTH as regular
% functions (eg for use as envisaged here) and ALSO as SMACROs so that
% direct use of them is expanded in-line.
   if idp cadr u then
     if eqcar(getd cadr u, 'macro) then
        rerror('rlisp,14,list("Macro",cadr u,"Used as Function"))
     else list('function,cadr u)
    else list('function,form1(cadr u,vars,mode));
+++ formfunc compiled, 46 + 48 bytes
formfunc

put('function,'formfn,'formfunc);formfunc

% RLIS is a parser function that reads a list of arguments and returns
% this list as one argument.  It needs to be defined in this module for
% bootstrapping purposes since this definition only works with its form
% function.

symbolic procedure rlis;
   begin scalar x;
        x := cursym!*;
        return if flagp(scan(),'delim) then list(x,nil)
                else if !*reduce4
                 then list(x,'list . remcomma xread1 'lambda)
                else x . remcomma xread1 'lambda
   end;
+++ rlis redefined
+++ rlis compiled, 39 + 36 bytes
rlis

symbolic procedure flagop u; begin flag(u,'flagop); rlistat u end;
+++ flagop compiled, 8 + 12 bytes
flagop

symbolic procedure rlistat u;
   while u do <<
      put(car u,'stat,'rlis);
      u := cdr u >>;
+++ rlistat compiled, 13 + 20 bytes
rlistat

rlistat '(flagop);nil

symbolic procedure formrlis(u,vars,mode);
   if not flagp(car u,'flagop)
     then list(car u,'list .
                  if car u = 'share
                    then (begin scalar x,y;
                             y := cdr u;
                             while y do <<
                                x := mkquote car y . x;
                                y := cdr y >>;
                             return reversip!* x
                         end)
                   else formlis(cdr u,vars,'algebraic))
    else if not idlistp cdr u
     then typerr('!*comma!* . cdr u,"identifier list")
    else list('flag,
              'list . formlis(cdr u,vars,'algebraic),mkquote car u);
+++ formrlis redefined
+++ formrlis compiled, 83 + 56 bytes
formrlis

symbolic procedure mkarg(u,vars);
   % Returns the "unevaled" form of U.
   if null u or constantp u then u
    else if atom u then if atsoc(u,vars) then u else mkquote u
    else if car u memq '(quote !:dn!: !:int!:) then mkquote u
    else if car u memq '(!:dn!-s!: !:dn!-f!: !:dn!-l!:) then
       mkquote '!:dn!: . cdr u 
    else begin scalar x;
            while u do <<
               x := mkarg(car u,vars) . x;
               u := cdr u >>;
            return 'list . reversip!* x;
         end;
+++ mkarg compiled, 61 + 32 bytes
mkarg

% Form functions needed for number input.

put('!:dn!:,'formfn,'dnform);dnform
put('!:dn!-s!:,'formfn,'dnform!-s);dnform-s
put('!:dn!-f!:,'formfn,'dnform!-f);dnform-f
put('!:dn!-l!:,'formfn,'dnform!-l);dnform-l

symbolic procedure dnform1(u,vars,mode,xmark);
   if mode = 'symbolic then  % Format as nnn.Emmm then is in FP format
      compress nconc!*(explode cadr u,'!. . xmark . explode cddr u)
   else << if !*adjprec then precmsg length explode abs cadr u;
           mkquote (if cddr u >= 0 then decimal2internal(cadr u,cddr u)
                    else ('!:dn!: . cdr u)) >>;
+++ dnform1 compiled, 57 + 44 bytes
dnform1

symbolic procedure dnform(u,vars,mode);
  dnform1(u,vars,mode,'e);
+++ dnform redefined
+++ dnform compiled, 12 + 16 bytes
dnform

symbolic procedure dnform!-s(u,vars,mode);
  dnform1(u,vars,mode,'s);
+++ dnform!-s compiled, 12 + 16 bytes
dnform-s

symbolic procedure dnform!-f(u,vars,mode);
  dnform1(u,vars,mode,'f);
+++ dnform!-f compiled, 12 + 16 bytes
dnform-f

symbolic procedure dnform!-l(u,vars,mode);
  dnform1(u,vars,mode,'l);
+++ dnform!-l compiled, 12 + 16 bytes
dnform-l

put('!:int!:,'formfn,'intform);intform

symbolic procedure intform(u,vars,mode);
   if mode = 'symbolic then mkquote cadr u
   else << precmsg length explode abs cadr u; mkquote cadr u >>;
+++ intform compiled, 21 + 20 bytes
intform

endmodule;nil

end;nilmodule proc;nil   % Procedure statement.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*argnochk !*noinlines !*loginlines !*redeflg!* fname!* ftype!*
        !*strict_argcount !*comp ifl!* curline!*);nil

% !*loginlines will cause a compile-time report of patterns of inline usage.
!*loginlines := t;t

global '(!*lose !*micro!-version cursym!* curescaped!* erfg!*
         ftypes!*);nil

fluid '(!*defn new_inline_definitions);nil

new_inline_definitions := nil;nil

!*lose := t;t

ftypes!* := '(expr fexpr macro);(expr fexpr macro)

% If foo(a,b) is already a defined function than when you go
%    symbolic emb procedure foo(u,v);
%      <new body ... foo(u', v') ... >;
% the function is redefined, but the inner call within it refers to the
% existing definition. So this can wrap new stuff around an existing
% procedure body. It is ONLY intended for debugging and I suggest that
% functions that have been embedded should not be written out in
% fasl files or saved on heap images (for instance it is not always going
% to be certain that the proper identity of the gensym used here will
% survive serialization). This may however be useful for debugging as
% a more flexible alternative to use of "tr foo;". In reduce4 mode this was
% wired into the parser, aned there is a commented out autoload directive
% for the "embfn" function in PSL, so I avoided clashing with that name
% here.

put('emb, 'procfn, 'portable!-embfn);portable-embfn

symbolic procedure portable!-embfn(name, args, body);
  begin
    scalar g;
    if not eqcar(getd name, 'expr) then
      rederr "Trying to embed around undefined function, or a fexpr or macro";
    g := gensym();
    return list('progn,
      list('copyd, mkquote g, mkquote name),
      list('de, name, args, ssubst(g, name, body)))
% I replace name by the gensym except within quotes. This will have
% untoward effects if name is also the the name of a fluid variable...
% but since this is JUST for debugging I will ignore that issue just
% for now. Another case where this scheme will fail is if there is a
% use of (eg) apply('name, ...) or an errorset that wants to call the
% function and so creates a structure with its name in it. So you
% see that overall this is a marginal and dodgy bit of code - but it can
% still be really useful when used in SIMPLE ways.
  end;
+++ portable!-embfn compiled, 44 + 56 bytes
portable-embfn

symbolic procedure mkprogn(u,v);
   if eqcar(v,'progn) then 'progn . u . cdr v else list('progn,u,v);
+++ mkprogn redefined
+++ mkprogn compiled, 15 + 12 bytes
mkprogn

symbolic procedure proc!-add!-info(name,info,body);
   if null info then body
    else proc!-add!-info(name,
      cdr info,
      mkprogn(list('put,mkquote name,mkquote caar info,mkquote cdar info),body));
+++ proc!-add!-info compiled, 32 + 28 bytes
proc-add-info

symbolic procedure formproc(u,vars,mode);
   begin scalar obody,body,fname!*,name,type,varlis,x,y,fl,n,info;
        u := cdr u;
        name := fname!* := car u;
        if cadr u then mode := cadr u;   % overwrite previous mode
        u := cddr u;
        type := ftype!* := car u;
        if flagp(name,'lose) and (!*lose or null !*defn)
          then return << lprim list(name,
                            "not defined (LOSE flag)");
                        '(quote nil) >>
         else if !*redeflg!* and getd name
          then lprim list(name,"redefined");
        varlis := cadr u;
        while varlis do <<
           if null car varlis or car varlis = 't then rsverr car varlis;
           varlis := cdr varlis >>;
        varlis := cadr u;
% For the benefit of CSL - and also perhaps for source analysis tools - if
% a fluid variable is bound I will insert a (DECLARE...) form at the
% head of the function. The justification for this is that the status of
% the variable as fluid is being checked at parse time. With CSL I capture
% the Lisp versions of function definitions and translate them into C++
% at a later stage, and when I do that the fluid declarations are in general
% not still around. But with the adjustment that is made here I have a local
% fluid declaration to guide me. I test for DECLARE being defined (it should
% be a special form not a regular function) rather than looking at the
% identity of the Lisp system.
#if (getd 'declare)
        while varlis do <<
           if fluidp car varlis or globalp car varlis then
              fl := car varlis . fl;
           varlis := cdr varlis >>;
        varlis := cadr u;
#endif
        body := caddr u;
      	if pairp cdddr u then info := cadddr u; 
        x := if eqcar(body,'rblock) then cadr body else nil;
        y := pairxvars(varlis,x,vars,mode);
        if x then body := car body . rplaca!*(cdr body,cdr y);
%        body:= form1(body,car y,mode);   % FORMC here would add REVAL.
        body := if flagp(name,'formc) then formc(body,car y,mode)
                 else form1(body,car y,mode);
% !*noinlines being set causes every inline that is defined to be downgraded
% to a regular procedure.
        if !*noinlines and type = 'inline then type := 'expr;
#if (getd 'declare)
% Note the non-Common way in which the DECLARE sits within a PROGN here.
% Furthermore I only insert DECLARE for sort-of ordinary functions.
% Specifically this will not include "inline procedure"... but a consequence
% of this will be that it will be a mistake to introduce an inline function
% that attempts to bind a fluid... because the variable concerned might not be
% declared fluid at the point where the inline definition is used.
        if fl and type memq '(expr fexpr macro) then
         body:=list('progn,
                    list('declare, 'special . fl),
                    body);
#endif
        obody:=body;
        if type = 'inline then begin
           scalar dd;
           dd := list('lambda,varlis,body);
           if not (dd = get(name, 'inline)) then <<
              if not zerop posn() then terpri();
              prin2 "+++ Record new inline definition:";
              terpri();
% I had been minded to use prettyprint here, however with PSL the file that
% contains the code for prettyprint sets up some inline definitions and it
% appears that an attempt to use prettyprint will fail there. What is worse
% is that I tried "if getd 'prettyprint then prettyprint else print" but that
% also crashed when PSL tried to build the prettyprint module.
              print list('de,name,varlis,body);
              new_inline_definitions := (name . dd) . new_inline_definitions >>
           end;
        if (not(type = 'inline) and get(name,'inline)) or
           (not(type = 'smacro) and get(name,'smacro))
          then lprim list("SMACRO/INLINE",name,"redefined");
% the next line generates warnings if any arguments are not used (in symbolic
% mode, and not counting arguments that are fluid).
        symbvarlst(varlis,body,mode);
        if type = 'expr then body := list('de,name,varlis,body)
         else if type = 'fexpr then body := list('df,name,varlis,body)
         else if type = 'macro then body := list('dm,name,varlis,body)
         else if (x := get(type,'procfn))
          then return apply3(x,name,varlis,body)
         else << body := list('putc,
                              mkquote name,
                              mkquote type,
                              mkquote list('lambda,varlis,body));
                 if !*defn then lispeval body >>;
	body := proc!-add!-info(name,info,body);
        if not(mode = 'symbolic)
          then body :=
              mkprogn(list('flag,mkquote list name,mkquote 'opfn),body);
        if !*argnochk and type memq '(expr inline smacro)
          then <<
              if (n:=get(name, 'number!-of!-args)) and
                 not flagp(name, 'variadic) and
                 n neq length varlis then <<
                if !*strict_argcount then
                  lprie list ("Definition of", name,
                      "different count from args previously called with")
                else lprim list(name, "defined with", length varlis,
                    "but previously called with",n,"arguments") >>;
           body := mkprogn(list('put,mkquote name,
                                    mkquote 'number!-of!-args,
                                    length varlis),
                               body) >>;
        if !*defn and type memq '(fexpr macro inline smacro)
          then lispeval body;
% "inline" procedures define a regular procedure as well as saving the
% definition so it can be expanded in place elsewhere.
        if type = 'inline then
           body := print mkprogn(list('de,name,varlis,obody), body);
        return if !*micro!-version and type memq '(fexpr macro smacro)
                 then nil
                else body
   end;
+++ formproc compiled, 621 + 272 bytes
formproc

put('procedure,'formfn,'formproc);formproc

symbolic procedure formde(u, vars, mode);
  formproc(
     list('procedure, cadr u, 'symbolic, 'expr, caddr u,
                      if null cddddr u then cadddr u else 'progn . cdddr u),
     vars,
     mode);
+++ formde redefined
+++ formde compiled, 36 + 40 bytes
formde

put('de,'formfn,'formde);formde

symbolic procedure pairxvars(u,v,vars,mode);
   %Pairs procedure variables and their modes, taking into account
   %the convention which allows a top level prog to change the mode
   %of such a variable;
   begin scalar x,y;
      while u do <<
         if (y := atsoc(car u,v)) then <<
            v := delete(y,v);
            if not(cdr y = 'scalar) then x := (car u . cdr y) . x
            else x := (car u . mode) . x >>
         else if null idp car u or get(car u,'infix) or get(car u,'stat) then
            symerr(list("Invalid parameter:",car u),nil)
         else x := (car u . mode) . x;
         u := cdr u >>;
      return append(reversip!* x,vars) . v
   end;
+++ pairxvars redefined
+++ pairxvars compiled, 76 + 28 bytes
pairxvars

symbolic procedure starts!-with(a, b);
  if null b then t
  else if null a then nil
  else if eqcar(a, car b) or
     (eqcar(a,'!\) and eqcar(b, '!/)) then starts!-with(cdr a, cdr b)
  else nil;
+++ starts!-with redefined
+++ starts!-with compiled, 27 + 20 bytes
starts-with

symbolic procedure simplify!-filename s;
  begin
    scalar a, b;
% The issue that I am concerned with here is that the full version of
% a file-name may be very long, and including all of it in messages can be
% unhelpful. To cope with files-names that are within the Reduce source
% tree I will apply what is perhaps a hack, and I will remove any initial
% part of a path that ends in "/packages/". Thus (for instance) one of the
% more basic test files will end up just names as "alg/alg.tst" rather than
% anything longer.
    a := explode2 s;
    b := explode2 "/packages/";
    while a and not starts!-with(a, b) do a := cdr a;
    if null a then return s;
    a := cddddr cddddr cddr a;
    return list2string a;
  end;
+++ simplify!-filename redefined
+++ simplify!-filename compiled, 32 + 20 bytes
simplify-filename

!#if (or (null (getd 'mkhash)) (flagp 'mkhash 'rlisp))

% I need to simulate hash tables, which PSL does not appear to provide.
% Well I will provide a minimal functional (but not performance)
% replacement here for use in any Lisp that does not heva a function
% called "mkhash" defined.

% The type is 0 for EQ hashes and all other cases are treated as EQUAL
% ones here. Since I am simulating "hash" tables in PSL using just simple
% association lists I do not have any use for a concept of initial size or
% the factor by which tables expand once they become full.

% I think a nicer implementation would be to use genuine hashed tables with
% PSL providing a function that hashed items. For EQ hashing that could be
% based on the machine representation of the (reference to) an item, while
% for equal it could traverse lists but use the address for symbols. The key
% issue there is that garbage collection moves things around! The neatest idea
% I have about that is to have each hash table record in its header the
% sequence number of garbage collection with respect to which it is valid.
% puthash and gethash would then check that on entry and perform a rehash
% operation if out of date. If one can be confident that garbage collection
% will not be triggered while performing gethash, and if puthash and rehash
% record the garbage collection number when they start and check if items are
% already present first using gethash (and if rehash re0runs itself if it
% finds that a GC happened while it was active). I think all is not too
% messy. But because hash tables are not very heavily used this is not a high
% priority!

symbolic procedure mkhash(size, type, expansion);
  type . nil;

symbolic procedure clrhash u;
  rplacd(u, nil);

symbolic procedure gethash(key, table);
  begin
% Of course use of assoc/atsoc here is not good for performance if you
% end up with many items stored...
    table := (if car table = 0 then atsoc(key, cdr table)
            else assoc(key, cdr table));
    if null table then return nil
    else return cdr table
  end;

symbolic procedure puthash(key, table, val);
  begin
    scalar w;
    w := (if car table = 0 then atsoc(key, cdr table)
          else assoc(key, cdr table));
    if w then <<
      rplacd(w, val);
      return val >>;
    rplacd(table, (key . val) . cdr table);
    return val
  end;

symbolic procedure hashcontents table;
  cdr table;

flag('(mkhash), 'rlisp);

!#endif

% At present this code only allows single token type specifiers. This is
% far from enough, but may still do as a placeholder while I implement
% more of the infrastructure.

% read_type() reads a description of a type.

symbolic procedure read_type();
  begin
    scalar x;
    x := cursym!*;
    scan();
    return x;
  end;
+++ read_type compiled, 5 + 16 bytes
read_type

% read_typed_name will read either "name" or "name : type", and if the
% explicit type is not given it defaults to "general".

symbolic procedure read_typed_name();
  begin
    scalar a;
    a := cursym!*;
    scan();
    if not (cursym!* = '!*colon!*) then return (a . 'general);
    scan();
    return (a . read_type())
  end;
+++ read_typed_name redefined
+++ read_typed_name compiled, 20 + 28 bytes
read_typed_name

% read_namelist knows that there is at least one name - so it reads
% a sequence of typed names connected to "," tokens. It stops as soon
% as the tyken following a typed name is not a comma.

symbolic procedure read_namelist();
  begin
    scalar a;
    if not valid_as_variable cursym!* then return nil;
    a := read_typed_name();
    if not (cursym!* = '!*comma!*) then return list a;
    scan();
    return a . read_namelist()
  end;
+++ read_namelist redefined
+++ read_namelist compiled, 23 + 28 bytes
read_namelist

% valid_as_variable is a function that exists because the Rlisp tokenization
% code does not make a clear distinction between reserved words and ordinary
% identifiers.

symbolic procedure valid_as_variable u;
  idp u and
  not flagp(u, 'invalid_as_variable);
+++ valid_as_variable redefined
+++ valid_as_variable compiled, 10 + 20 bytes
valid_as_variable

flag('(nil t !*comma!* !*lpar!* !*rpar!* !*colon!* !*semicol!*),
     'invalid_as_variable);nil

% read_signature is used for procedure headers. The syntax it accepts
% should be as shown here (where the final ";" tells parsing when to stop).
%     name ;                           No arguments, no type info
%     name : type ;                    No arguments, resuly type specified
%     name arg ;                       A single argument
%     name arg1 : type1 ;              One arg with arg type specified
%     name arg1 : type1 : type ;       Both arg and result type specified
%     name() ;                         No arguments, but () to stress that!
%     name() : type ;
%     name( arg1, ...) ;               Argument or arguments without types
%     name( arg1, ...) : type ;        Ditto but with result type
%     name( arg1:type1, ...) ;         Arguments may have type specifiers
%     name( arg1:type1, ...) : type ;
% Note that "name arg:type;" is treated as "name(arg:type);" rather
% then "name(arg):type;".
%
% For compatibility I also need
%    arg1[:type1] infix-operator arg1[:type2] [:result_type]
% and this is used in a situation
%    infix .*; inline procedure u .* v; u + v;
% where I can even imagine wanting to put in type decorations. Oh bother -
% I had thought I could get away with not supporting that case!


symbolic procedure read_signature();
  begin
    scalar x, y;
    x := cursym!*;
    if not valid_as_variable x then
      rerror('rlisp, 7, list(x, "invalid as formal parameter name"));
    scan();
    if cursym!* = '!*semicol!* then return list(list x, 'general);
    if cursym!* = '!*colon!* then <<
% The signature started off as "x : type". There are two wanys this
% can end up. One is just as
%       x : type ;
% which introduces a procedure with no arguments but with a declared
% return type. The other is
%       x : type infix_op y [: type] [: type] ;
% where the procedure is specified using infix notation but with a type
% for at least its left operand.
       scan();
       y := read_type();
       if cursym!* = '!*semicol!* then return list(list x, y)
       else if not idp cursym!* or
          not get(cursym!*, 'infix) then symerr(nil, cursym!*);
       x := x . y;
       y := cursym!*;
       scan();
       x := list(y, x, read_typed_name()) >>
    else if cursym!* = '!*lpar!* then <<
      scan();
      if cursym!* = '!*rpar!* then x := list x
      else <<
        x := x . read_namelist();
        if not (cursym!* = '!*rpar!*) then rerror('rlisp, 8,
          list(cursym!*, "found where right parenthesis expected")) >>;
      scan() >>
    else if idp cursym!* and get(cursym!*, 'infix) then <<
% This is the case
%        u infix_op v [: type] [: type]
      y := cursym!*;
      scan();
      x := list(y, x . 'general, read_typed_name()) >>
    else x := list(x, read_typed_name());
    if cursym!* = '!*colon!* then <<
      scan();
      return list(x, read_type()) >>
    else return list(x, 'general)
  end;
+++ read_signature redefined
+++ read_signature compiled, 175 + 84 bytes
read_signature

symbolic procedure make_tuple_type x;
  if null x then 'unit
  else if null cdr x then cdar x
  else 'times . collect_cdrs x;
+++ make_tuple_type redefined
+++ make_tuple_type compiled, 18 + 20 bytes
make_tuple_type

% At this stage in the bootstrap process I can not use a "for each"
% statement, so I write this out as a separate function

symbolic procedure collect_cars u;
  if null u then nil
  else caar u . collect_cars cdr u;
+++ collect_cars redefined
+++ collect_cars compiled, 14 + 12 bytes
collect_cars

symbolic procedure collect_cdrs u;
  if null u then nil
  else cdar u . collect_cdrs cdr u;
+++ collect_cdrs redefined
+++ collect_cdrs compiled, 15 + 12 bytes
collect_cdrs

symbolic procedure procstat1 mode;
   begin scalar bool, u, type, x, y, z, file, line, info;
% Note the file and line that this procedure is in. This will be the
% location that the procedure statement starts on.
% I can tag it with the file name and line where it was defined, and that
% may be really helpful in some debugging context.
      if ifl!* then << file := car ifl!*;
% By using intern I turn the string that is the file-name into a symbol.
% That arranges that when the file-name is used multiple times only one
% copy is kept in memory.
	 info := list('defined!-in!-file . intern simplify!-filename file,                                                                                                                                    'defined!-on!-line . line) >>
       else file = "-";
% I think that erfg!* will be set if we have already suffered an error, so
% we may be parsing in a sort of recovery mode.
      bool := erfg!*;
% fname!* is set to the name of a procedure while we are parsing the body
% of that procedure, so if it is set here then we have an illegal attempt at
% a procedure definition nested within another. This will most typically
% occur if a previous procedure fails to have enough ">>" or "end" tokens.
      if fname!* then <<
         bool := t;
         errorset!*('(symerr (quote procedure) t),nil) >>
      else <<
% Here we allow for "procedure", "symbolic procedure", "algebraic procedure"
% or "maud procedure" with (in that case) "maud" ending up in the variable
% "type". If the word "procedure" is not found we will complain.
         if cursym!* = 'procedure then type := 'expr
         else << type := cursym!*; scan() >>;
         if not(cursym!* = 'procedure) then <<
            errorset!*('(symerr (quote procedure) t),nil) >>
         else <<
% Reduce 4 differs from previous versions... it allows type specifiers.
            if !*reduce4 then <<
% Name of the procedure comes next
               fname!* := scan();
               if not idp fname!* then typerr(fname!*,"procedure name")
               else <<
                  scan();
% Move past the procedure name and read the list of parameters.
                  y := errorset!*(list('read_param_list,mkquote mode),nil);
                  if not errorp y then <<
% If parameters were read happily and the next token is a colon then there
% will be a type given after it.
                     y := car y;
                     if cursym!* = '!*colon!* then mode := read_type() >> >> >>
            else <<
               scan();
               x := read_signature();
% The result of read_signature is
%    ((fname (arg1 . type1) ...) result_type)
% I will edit that to make something that looks a bit more like the style
% of type signature I have used before... Examples could be
%    (arrow unit general)
%    (arrow integer integer)
%    (arrow (times general integer general) general)
% where "unit" denotes nothing (ie not having any arguments), "general" is
% where the type had not been specified, and otherwise at present types
% are merely symbols.
	       info := ('procedure_type . 'arrow . make_tuple_type cdar x . cdr x) . info;
               x := car x;
               fname!* := car x;
               x := fname!* . collect_cars cdr x;
               y := cdr x >> >> >>;
% Recover a bit of there was an end of file encountered while reading the
% procedure heading.
      if eof!*>0 then <<
         cursym!* := '!*semicol!*;
         curescaped!* := nil >>
      else <<
% Now read the procedure body. It is quite reasonable to use xread here.
         z := errorset!*('(xread t),nil);
         if not errorp z then z := car z;
         if null erfg!* then
            z := list('procedure,
                      if null !*reduce4 then car x else fname!*,
                      mode,type,y,z,info) >>;
% Parsing is complete. So now just tidy up.
      remflag(list fname!*,'fnc);
      fname!* := nil;
      if erfg!* then <<
         z := nil;
% What seems to be going on here is that most errors spotted during parsing
% get deferred to here. I rather believe that this is so that the state of
% Reduce is not messed up too much by a parse failure, and so that lines
% of input beyond an error get skipped past in a reasonable way.
         if not bool then error1() >>;
% In sensible cases the value of z here will be something like
%  (de maud (arg1 ... argn) body)
      return z
   end;
+++ procstat1 compiled, 226 + 156 bytes
procstat1

symbolic procedure procstat;
  procstat1 nil;
+++ procstat redefined
+++ procstat compiled, 3 + 12 bytes
procstat

deflist ('((procedure procstat) (expr procstat) (fexpr procstat)
           (emb procstat) (macro procstat) (inline procstat)
           (smacro procstat)),
        'stat);(procedure expr fexpr emb macro inline smacro)

% Next line refers to bootstrapping process.

if get('symbolic,'stat) = 'procstat then remprop('symbolic,'stat);nil

deflist('((lisp symbolic)),'newnam);(lisp)

endmodule;nil

end;nilmodule forstat;nil   % Definition of REDUCE FOR loops.

% Author: Anthony C. Hearn.

% Copyright (c) 1993 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*blockp !*fastfor !*modular);nil

global '(cursym!* foractions!*);nil

COMMENT the syntax of the FOR statement is as follows:

                 {step i3 until}
        {i := i1 {             } i2 }
        {        {      :      }    }
   for  {                           } <action> <expr>
        {        { in }             }
        { each i {    }  <list>     }
                 { on }

In all cases, the <expr> is evaluated algebraically within the scope of
the current value of i.  If <action> is DO, then nothing else happens.
In other cases, <action> is a binary operator that causes a result to be
built up and returned by FOR.  In each case, the loop is initialized to
a default value.  The test for the end condition is made before any
action is taken.

The effect of the definition here is to replace all for loops by
semantically equivalent blocks.  As a result, none of the mapping
functions are needed in REDUCE.

To declare a set of actions, one says;

foractions!* := '(do collect conc product sum);(do collect conc product sum)

remflag(foractions!*,'delim);nil    % For bootstrapping purposes.

% To associate a binary function with an action, one says:

deflist('((product times) (sum plus)),'bin);(product sum)

% And to give these an initial value in a loop:

deflist('((product 1) (sum 0)),'initval);(product sum)

% NB:  We need to reset for and let delims if an error occurs.  It's
% probably best to do this in the begin1 loop.

% flag('(for),'nochange);

symbolic procedure forstat;
   begin scalar !*blockp;
      return if scan() = 'all then forallstat()
              else if cursym!* = 'each then foreachstat()
              else forloop()
   end;
+++ forstat compiled, 25 + 44 bytes
forstat

put('for,'stat,'forstat);forstat

symbolic procedure forloop;
   begin scalar action,bool,incr,var,x;
      if flagp('step,'delim) then bool := t else flag('(step),'delim);
      x := errorset!*('(xread1 'for),t);
      if null bool then remflag('(step),'delim) else bool := nil;
      if errorp x then error1() else x := car x;
      if not eqcar(x,'setq) or not idp(var := cadr x)
        then symerr('for,t);
      x := caddr x;
      if cursym!* = 'step
        then <<if flagp('until,'delim) then bool := t
                else flag('(until),'delim);
               incr := xread t;
               if null bool then remflag('(until),'delim)
                else bool := nil;
               if not(cursym!* = 'until) then symerr('for,t)>>
       else if cursym!* = '!*colon!* then incr := 1
       else symerr('for,t);
      if flagp(car foractions!*,'delim) then bool := t % nested loop
       else flag(foractions!*,'delim);
      incr := list(x,incr,xread t);
      if null bool then remflag(foractions!*,'delim);
      if not((action := cursym!*) memq foractions!*)
        then symerr('for,t);
      return list('for,var,incr,action,xread t)
   end;
+++ forloop compiled, 183 + 88 bytes
forloop

symbolic procedure formfor(u,vars,mode);
   begin scalar action,algp,body,endval,incr,initval,var,x;
         scalar !*!*a2sfn;
        % ALGP is used to determine if the loop calculation must be
        % done algebraically or not.
      !*!*a2sfn := 'aeval!*;
      var := cadr u;
      incr := caddr u;
      incr := list(formc(car incr,vars,mode),
                   formc(cadr incr,vars,mode),
                   formc(caddr incr,vars,mode));
      if not atsoc(var,vars)
        then if intexprnp(car incr,vars) and intexprnp(cadr incr,vars)
               then vars := (var . 'integer) . vars
              else vars := (var . mode) . vars;
      action := cadddr u;
      body := formc(car cddddr u,vars,mode);
      initval := car incr;
      endval := caddr incr;
      incr := cadr incr;
      algp := algmodep initval or algmodep incr or algmodep endval;
      if algp then <<endval := unreval endval; incr := unreval incr>>;
      x := if algp then list('list,''difference,endval,var)
            else list(if !*fastfor then 'idifference else 'difference,
                      endval,var);
      if incr neq 1
        then x := if algp then list('list,''times,incr,x)
                   else list('times,incr,x);
      % We could consider simplifying X here (via reval).
      x := if algp then list('aminusp!:,x)
            else list(if !*fastfor then 'iminusp else 'minusp,x);
      return forformat(action,body,initval,x,
                       if algp
                          then list('aeval!*,list('list,''plus,incr))
                        else list(if !*fastfor then 'iplus2 else 'plus2,
                                  incr),
                       var,vars,mode)
   end;
+++ formfor compiled, 276 + 108 bytes
formfor

put('for,'formfn,'formfor);formfor

symbolic procedure algmodep u;
   not atom u and car u memq '(aeval aeval!*);
+++ algmodep redefined
+++ algmodep compiled, 8 + 12 bytes
algmodep

symbolic procedure aminusp!: u;
   % This is only used in loop tests. We must make sure we are not in a
   % modular domain (where the difference will always be positive!).
   begin scalar oldmode,v;
      if !*modular then oldmode := setdmode('modular,nil);
      v := errorset2 list('aminusp!:1,mkquote u);
      if oldmode then setdmode('modular,t);
      if errorp v then typerr(u,"arithmetic expression")
       else return car v
   end;
+++ aminusp!: redefined
+++ aminusp!: compiled, 35 + 48 bytes
aminusp:

symbolic procedure aminusp!:1 u;
   begin scalar x;
      u := aeval!* u;
      x := u;
      if fixp x then return minusp x
       else if not eqcar(x,'!*sq)
        then msgpri(nil,reval u,"invalid in FOR statement",nil,t);
      x := cadr x;
      if fixp car x and fixp cdr x then return minusp car x
       else if not(cdr x = 1)
             or not (atom(x := car x) or atom car x)
         % Should be DOMAINP, but SMACROs not yet defined.
        then msgpri(nil,reval u,"invalid in FOR statement",nil,t)
       else return apply1('!:minusp,x)
   end;
+++ aminusp!:1 redefined
+++ aminusp!:1 compiled, 73 + 40 bytes
aminusp:1

symbolic procedure foreachstat;
   begin scalar w,x,y,z;
        if not idp(x := scan()) or not((y := scan()) memq '(in on))
          then symerr("FOR EACH",t)
         else if flagp(car foractions!*,'delim) then w := t
         else flag(foractions!*,'delim);
        z := xread t;
        if null w then remflag(foractions!*,'delim);
        w := cursym!*;
        if not(w memq foractions!*) then symerr("FOR EACH",t);
        return list('foreach,x,y,z,w,xread t)
   end;
+++ foreachstat compiled, 72 + 64 bytes
foreachstat

put('foreach,'stat,'foreachstat);foreachstat

symbolic procedure formforeach(u,vars,mode);
   begin scalar action,body,lst,mod1,var;
        var := cadr u; u := cddr u;
        mod1 := car u; u := cdr u;
        lst := formc(car u,vars,mode); u := cdr u;
        if not(mode = 'symbolic) then lst := list('getrlist,lst);
        action := car u; u := cdr u;
        body := formc(car u,(var . mode) . vars,mode); % was FORMC
        if mod1 = 'in
          then body := list(list('lambda,list var,body),list('car,var))
         else if not(mode = 'symbolic) then typerr(mod1,'action);
        return forformat(action,body,lst,
                         list('null,var),list 'cdr,var,vars,mode)
   end;
+++ formforeach compiled, 99 + 60 bytes
formforeach

put('foreach,'formfn,'formforeach);formforeach

symbolic procedure forformat(action,body,initval,
                             testexp,updform,var,vars,mode);
   begin scalar result;
       % Next test is to correct structure generated by formfor.
% The expansion here can introduce new local variables named
% forall!-result and forall!-endprt. Until recently the first of
% these had been created as a gensym to avoid any prospect of name
% clashing. However that results in code parsing onto different stuff
% each time it is read, and that causes some confusion in the CSL world
% where I want to match source code to compiled code. The messy use
% of a "sort of obscure" name should in practise be OK. Especially since
% I observe that "endptr" had been polluting the name-space for some years.
      if algmodep updform and length cadr updform > 2
         then <<result:='forall!-result; % gensym();
                updform:= list list('lambda,
                                    list result,
                                    list('aeval!*,
                                         caadr updform .
                                              cadadr updform .
                                              result .
                                              cddadr updform))>>;
      result := 'forall!-result; % gensym();
      return
         sublis(list('body2 .
                if mode = 'symbolic or intexprnp(body,vars)
                  then list(get(action,'bin),body,result)
                 else list('aeval!*,list('list,mkquote get(action,'bin),
                            unreval body,result)),
               'body3 .
                   if mode = 'symbolic then body
                      else list('getrlist,body),
               'body . body,
               'initval . initval,
               'nillist .
                   if mode = 'symbolic then nil else '(makelist nil),
               'result . result,
               'initresult . get(action,'initval),
               'resultlist . if mode = 'symbolic then result
                              else list('cons,''list,result),
               'testexp . testexp,
               'updfn . car updform,
               'updval . cdr updform,
               'var . var),
          if action = 'do
            then '(prog (var)
                  (setq var initval)
              lab (cond (testexp (return nil)))
                  body
                  (setq var (updfn var . updval))
                  (go lab))
           else if action = 'collect
            then '(prog (var result forall!-endptr)
                  (setq var initval)
                  (cond (testexp (return nillist)))
                  (setq result (setq forall!-endptr (cons body nil)))
                looplabel
                  (setq var (updfn var . updval))
                  (cond (testexp (return resultlist)))
                  (rplacd forall!-endptr (cons body nil))
                  (setq forall!-endptr (cdr forall!-endptr))
                  (go looplabel))
           else if action = 'conc
            then '(prog (var result forall!-endptr)
                  (setq var initval)
               startover
                  (cond (testexp (return nillist)))
                  (setq result body)
                  (setq forall!-endptr (lastpair resultlist))
                  (setq var (updfn var . updval))
                  (cond ((atom forall!-endptr) (go startover)))
                looplabel
                  (cond (testexp (return result)))
                  (rplacd forall!-endptr body3)
                  (setq forall!-endptr (lastpair forall!-endptr))
                  (setq var (updfn var . updval))
                  (go looplabel))
           else '(prog (var result)
                 (setq var initval)
                 (setq result initresult)
              lab1
                 (cond (testexp (return result)))
                 (setq result body2)
                 (setq var (updfn var . updval))
                 (go lab1)))
   end;
+++ forformat compiled, 252 + 156 bytes
forformat

symbolic procedure lastpair u;
   % Return the last pair of the list u.
   if atom u or atom cdr u then u else lastpair cdr u;nil

symbolic procedure unreval u;
   % Remove spurious aeval or reval in inner expression.
   if atom u or null(car u memq '(aeval reval)) then u else cadr u;
+++ unreval compiled, 11 + 12 bytes
unreval

remprop('conc,'newnam);nil

put('join,'newnam,'conc);conc   % alternative for CONC

endmodule;nil

end;nilmodule loops;nil  % Looping forms other than the FOR statement.

% Author: Anthony C. Hearn

% Copyright (c) 1987 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*blockp);nil

global '(cursym!*);nil


% ***** REPEAT STATEMENT *****

symbolic procedure repeatstat;
  begin scalar !*blockp,body,bool;
        if flagp('until,'delim) then bool := t
         else flag('(until),'delim);
        body:= xread t;
        if not bool then remflag('(until),'delim);
        if not(cursym!* = 'until) then symerr('repeat,t);
        return list('repeat,body,xread t);
   end;
+++ repeatstat redefined
+++ repeatstat compiled, 48 + 48 bytes
repeatstat

symbolic macro procedure repeat u;
   begin scalar body,bool,lab;
        body := cadr u; bool := caddr u;
        lab := 'repeatlabel;
        return mkprog(nil,list(lab,body,
                list('cond,list(list('not,bool),list('go,lab)))))
   end;
+++ repeat_z8lmmn3ezz56 compiled, 39 + 28 bytes
repeat

put('repeat,'stat,'repeatstat);repeatstat

flag('(repeat),'nochange);nil

symbolic procedure formrepeat(u,vars,mode);
   begin scalar !*!*a2sfn;
      !*!*a2sfn := 'aeval!*;
      return list('repeat,formc(cadr u,vars,mode),
                  formbool(caddr u,vars,mode))
   end;
+++ formrepeat compiled, 30 + 32 bytes
formrepeat

put('repeat,'formfn,'formrepeat);formrepeat


% ***** WHILE STATEMENT *****

symbolic procedure whilstat;
   begin scalar !*blockp,bool,bool2;
        if flagp('do,'delim) then bool2 := t else flag('(do),'delim);
        bool := xread t;
        if not bool2 then remflag('(do),'delim);
        if not(cursym!* = 'do) then symerr('while,t);
        return list('while,bool,xread t)
   end;
+++ whilstat redefined
+++ whilstat compiled, 48 + 48 bytes
whilstat

% The version of WHILE does more than Reduce per se requires, in that
% it allows (WHILE pred b1 b2 ... ) with a sequence ot body components.
% The previous version only supported a single body, so that one needed
% to put in PROGN if several actions were involved. This more generous one
% should be upwards compatible, and also it agrees better with a WHILE
% macro used in raw PSL.

symbolic macro procedure while u;
   begin scalar body,bool,lab;
        bool := cadr u; body := cddr u;
        lab := 'whilelabel;
        return mkprog(nil,
                lab .
                list('cond,list(list('not,bool), list('return,nil))) .
                append(body,
                list list('go,lab)))
   end;
+++ while_lm0fhkicguod compiled, 47 + 32 bytes
while

put('while,'stat,'whilstat);whilstat

flag('(while),'nochange);nil

symbolic procedure formwhile(u,vars,mode);
   begin scalar !*!*a2sfn;
      !*!*a2sfn := 'aeval!*;
      return list('while,formbool(cadr u,vars,mode),
                  formc(caddr u,vars,mode))
   end;
+++ formwhile compiled, 30 + 32 bytes
formwhile

put('while,'formfn,'formwhile);formwhile

endmodule;nil

end;nilmodule write;nil  % Miscellaneous statement definitions.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%

% ***** DEFINE STATEMENT *****

remprop('define,'stat);nil

symbolic procedure define u;
   for each x in u do
      if not eqcar(x,'equal) or not idp cadr x
        then typerr(x,"DEFINE declaration")
       else put(cadr x,'newnam,caddr x);
+++ define compiled, 36 + 32 bytes
define

deflist('((define rlis)),'stat);(define)

flag('(define),'eval);nil

% ***** WRITE STATEMENT *****

symbolic procedure formwrite(u,vars,mode);
   begin scalar bool1,bool2,x,y,z;
      u := cdr u;
      bool1 := mode = 'symbolic;
      while u do
        <<x := formc(car u,vars,mode);
          y := getsetvars x;
          z := (if bool1 then list('prin2,x)
                 else list('assgnpri,x,if y then 'list . y else nil,
          if not cdr u then if not bool2 then ''only else ''last
           else if not bool2 then ''first else nil)) .
                             z;
          bool2 := t;
          u := cdr u>>;
        if bool1 then z := nil . z;  % Since PRIN2 returns its value.
        return if null z then nil
                else if null cdr z then car z
                else 'progn . reversip!* z
   end;
+++ formwrite compiled, 104 + 64 bytes
formwrite

put('write,'stat,'rlis);rlis

put('write,'formfn,'formwrite);formwrite


% ECHOPR is similar to WRITE but, if switch TESTECHO is on, it echos an
% offline print onto the screen, in either algebraic or symbolic mode.

% Switch is not yet defined.

flag('(testecho),'switch);nil

put('echopr,'stat,'rlis);rlis

put('echopr,'formfn,'formechopr);formechopr

symbolic procedure formechopr(u,vars,mode);
   (lambda x; list ('progn,x,
      list ('cond,list ('(and !*testecho ofl!*),
         list (list ('lambda,'(n),
            list ('progn,x,'(wrs n),nil)),'(wrs nil) ))) ))
       formwrite(u,vars,mode);
+++ formechopr compiled, 44 + 48 bytes
formechopr

% PUSH and POP

%
% I want something that is broadly equivalent to
%
% smacro procedure push(a, b); car (b := a . b);
% smacro procedure pop(b); prog1(car b, b := cdr b);
% but ideally I would avoid repeated evaluation of v in those cases where
% v is messy. Eg as in "pop(car BIGEXPRESSION)" I would want BIGEXPRESSION
% to be evaluated just once. To achieve that I will use a macro rather
% than an smacro... The function cheaptoevaluate will be used to judge
% whether an expression is "big".

% I originally thought to use regular macros for the expansion here, but that
% make it hard to get "form" called properly on all relevant sub-parts. So
% I use formfns.

% When these "macros" are expanded I want the expansions to be deterministic
% both as a matter of general tidiness and because that will interact better
% with the CSL scheme that compiles some code into C. Specifically I want
% any procedure that uses any of these to expand into EXACTLY the same
% stuff each time it is parsed. This means I can not afford to use regular
% gensyms, since their identity will depend on history. But I still want some
% names that will not clash with anthing else present in the code being
% looked at...

fluid '(all!-new!-symbols current!-new!-symbols new!-symbol!-counter);nil

all!-new!-symbols := nil;nil
new!-symbol!-counter := 0;0

% Find a symbol that is distint from all those in the
% tree structure "env" and that is neither fluid nor global.

symbolic procedure local!-symbol(env);
  begin
    scalar r;
  tryagain:
    if null current!-new!-symbols then <<
      new!-symbol!-counter := new!-symbol!-counter + 1;
      r := intern list2string append('(w), explode new!-symbol!-counter);
      all!-new!-symbols := append(all!-new!-symbols, list r) >>
    else <<
      r := car current!-new!-symbols;
      current!-new!-symbols := cdr current!-new!-symbols >>;
% Note that smember is defined in alg/general.red and so this code is
% unsafe during bootstrapping until that has been compiled. At present this
% only limits use of PUSH and POP until then.
    if fluidp r or globalp r or get(r, 'constant!?) or
      smember(r, env) then go to tryagain;
    return r
  end;
+++ local!-symbol compiled, 56 + 44 bytes
local-symbol

symbolic procedure cheaptoevaluate u;
    atom u or eqcar(u, 'quote);
+++ cheaptoevaluate compiled, 8 + 16 bytes
cheaptoevaluate

symbolic procedure allcheaptoevaluate l;
  null l or
  (cheaptoevaluate car l and allcheaptoevaluate cdr l);
+++ allcheaptoevaluate compiled, 12 + 16 bytes
allcheaptoevaluate

symbolic procedure pushpop!-locals(l, r, w, g1, u);
  if null l then r . (w . g1)
  else if cheaptoevaluate car l then pushpop!-locals(cdr l, r, car l . w, g1, u)
  else begin
    scalar g;
    g := local!-symbol u;
    return pushpop!-locals(cdr l, list('setq, g, car l) . r, g . w, g . g1, u)
  end;
+++ pushpop!-locals compiled, 53 + 20 bytes
pushpop-locals 

symbolic procedure formpush(u, vars, mode);
  begin
    scalar a, b, g, g1, r, w;
    current!-new!-symbols := all!-new!-symbols;
    u := cdr u;
    if (g := length u) neq 2 then
      rederr list("push called with", g, "arguments instead of 2");
    a := car u;
    b := cadr u;
% I will expand into simple code in cases when that is safe, specifically
% if b is not a big expression and even more so if a is too.
    if atom b or allcheaptoevaluate cdr b then <<
      if cheaptoevaluate a then <<
        if a = b then
          return formc(list('prog1, a, list('setq, b, list('cons, a, b))),
                       vars, mode)
        else return formc(list('progn, list('setq, b, list('cons, a, b)), a),
                          vars, mode) >>;
      g := local!-symbol(u); 
      return formc(list('prog, list g,
          list('setq, g, a),
          list('setq, b, list('cons, g, b)),
          list('return, g)), vars, mode) >>;
% If b is messy I will introduce new local variable for arguments of b.
    r := pushpop!-locals(cdr b, nil, nil, nil, u);
    g1 := cddr r;
    w := car b . reverse cadr r;
    r := reverse car r;    
    return formc('prog . g1 .
      append(r, list(
        list('return, list('car,
          list('setq, w, list('cons, a, w)))))), vars, mode)
  end;
+++ formpush compiled, 206 + 88 bytes
formpush

put('push, 'formfn, 'formpush);formpush

symbolic procedure formpop(u, vars, mode);
  begin
    scalar g, g1, a, r, w;
    current!-new!-symbols := all!-new!-symbols;
    u := cdr u;
    if (g := length u) neq 1 then
      rederr list("pop called with", g, "arguments instead of 1");
    a := car u;
    if atom a or allcheaptoevaluate cdr a then
      return formc(list('prog1, list('car, a), list('setq, a, list('cdr, a))),
                   vars, mode);
    r := pushpop!-locals(cdr a, nil, nil, nil, u);
    g1 := (g := local!-symbol u) . cddr r;
    w := car a . reverse cadr r;
    r := reverse car r;    
    return formc('prog . g1 .
      append(r, list(
       list('setq, g, list('car, w)),
       list('setq, w, list('cdr, w)),
       list('return, g))), vars, mode)
  end;
+++ formpop compiled, 139 + 72 bytes
formpop

put('pop, 'formfn, 'formpop);formpop

endmodule;nil

end;nilmodule smacro;nil  % Support for SMACRO expansion

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


%
% This function expands an  invocation of a SMACRO.
%
% Getting this right in all cases seems to be harder than I had expected!
% One simple interpretation of what an SMACRO is is that it represents
% a simple textual expansion, so after
%   smacro procedure f(a,b) E;
% any instance of f(A,B) is expanded to E|a=>A,b=>B using textual
% substitution.
% A different intent for SMACRO is that it marks a procedure to be
% compiled/expanded in-line for performance reasons. The code in Reduce
% up to 3.8 implemented something that was part way between those!
%
% Here are some of the critical cases:
%    smacro procedure f a; ... a ... a...;
%    f(A)  ->   ... A ... A ...                               (a)
%      OR  ->   ((lambda (a) ... a ... a ...) A)              (b)
% The first is what textual expansion suggests, but if the argument A
% is either an expensive-to-evaluate form or has side-effects then
% letting it appear several times within the expansion may be bad either
% for semantics or performance or both. A variation on this arises if the
% formal parameter a does not occur at all within the body of the smacro,
% or is guarded there by an IF, and the actual argument has side-effects.
% Then one version of the expansion WILL evaluate the argument while the
% other will or may not.
%
% Reduce 3.8 uses expansion (a) if either the formal a occurs at most
% once in the body OR (b) the actual argument is one of a limited number
% of sorts of form that can be seen to be side-effect free. For smacros
% with two or more arguments it can lambda-lift just some of the parameters.
%
% Here are some cases where this may cause trouble:
%    smacro procedure f a; 'nothing;
%    ... f(print x) ...                   The print does not happen.
%                                         Maybe that was expected!
%    smacro procedure f a; << if nil then a; if nil then a; nil >>;
%    ... f(print x) ...
% Reduce 3.8 uses expansion (b) and so the print DOES happen.
%
% In these examples I will be using PRINT to stand for something arbitrary
% that may have side effects, might yield different results when called twice
% (including GENSYM and CONS) or might be an expensive computation.
%
%    smacro procedure f(a, b); b . a;
%    ... f(print x, print y) ...
% uses expansion (a) and the prints happen in an order that may be
% unexpected.
%    smacro procedure f(a, b); list(a, b, b);
%    ... f(print x, print y) ...
% uses a lambda at least for b, so y only gets printed once, but probably
% before x.
%
%    smacro procedure set_cdr(a, b); << rplacd(a, b); b >>;
%    ... set_cdr(x, cons(p, q)) ...
%    ... set_cdr(x, cddr x) ...
% if CONS is tagged as side-effect free this does TWO conses and the
% results are almost certainly not what is wanted. And simple inline
% expansion in the second case returns a "wrong" value.
%
%    smacro procedure f(a, b); << a := 1; print b; a := 2; print b >>;
%    ... f(v, v+3) ...
% Oh dear: v+3 is probably not tagged as side-effect free and both a and b
% are used twice in the function body. But there seems to be a clear
% expectation that the first argument will be textually substituted so that
% the assignments take full effect.
%
%    smacro procedure f a; ... a ... (lambda (a) ...) ...;
% This might arise if a previous smacro used (b) expansion leading to the
% embedded lambda expression, and the names used for formal in the two
% smacros happened to match. If then textual substitution is performed it
% needs to understand the scope rules of nested lambdas and progs. It
% may also need to know that a symbol at the top level of a prog names a
% label not a variable (and ditto (GO x)).
%
%   smacro procedure f x; while a do print (a := cdr a);
%   x := '(1 2 3); f x; print x;
% Depending on expansion style this prints different values at the end.
%
%   smacro procedure increment a; a := a + 1;
% This illustrates a case where it is clear that a direct textual expansion
% is expected. However despite "car x := car x + 1" being accepted syntax the
% order in which things are done means that "increment (car x)" expands to
% and illegal (setq (car x) (plus (car x) 1)) in Reduce 3.8. And
% increment (getv(x, 2)) becomes ((lambda (a) (setq a (plus a 1))) (getv x 2)).
% because while CAR is tagged as side-effect free GETV is not.
%
% Now by and large these are cases that do not arise too often when smacros
% are used for really simple things and and manually created by people who
% understand what is going on. Well the special treatment in Reduce 3.8 as
% regards how many times a formal is used in the body of the smacro and
% whether the actual argument has side effects suggests that there have been
% problems in individual cases before! But if I try to use the smacro
% mechanism as a generic way of getting in-line compilation I may scan the
% whole source of Reduce and convert small procedures into smacros. And
% then the sorts of issue discussed here bite repeatedly!

% I hope these comments will help anybody writing their own smacros. I
% have introduced a new keyword
%   inline procedure f(x); ...;
% with unambiguous call-by-value semantics, but meanwhile in any automatic
% conversion from procedure to smacro the issues here need to be thought
% about.    ACN September 2010.

% The flag !*loginlines enables reports that may help identify places where
% some of the above issues arise.  ACN March 2013.

fluid '(!*defn inlineinfo !*noinlines);nil

symbolic procedure applsmacro(u,vals,name);
   % U is smacro body of form (lambda <varlist> <body>), VALS is
   % argument list, NAME is name of smacro.
   begin scalar body,remvars,varlist,w,inlineinfo;
      varlist := cadr u;
      body := caddr u;
      inlineinfo := list(name, varlist, body);
      if length varlist neq length vals
        then rerror(rlisp,15,list("Argument mismatch for SMACRO",name));
      if !*loginlines then log_inlines(varlist, body, vals);
      if no!-side!-effect!-listp vals or one!-entry!-listp(varlist,body)
        then return subla!-q(pair(varlist,vals),body)
       else if length varlist>1
        then <<w := for each x in varlist collect (x . gensym());
               body := subla!-q(w,body);
               varlist := for each x in w collect cdr x>>;
      for each x in vals do
         <<if no!-side!-effectp x or one!-entryp(car varlist,body)
             then body := subla!-q(list(car varlist . x),body)
            else remvars := aconc(remvars,car varlist . x);
           varlist := cdr varlist>>;
      if null remvars then return body
       else <<w := list('lambda,
                         for each x in remvars collect car x,
                         body) .
                    for each x in remvars collect cdr x;
%             if not eqcar(cadr w,'setq)
%               then <<prin2 "*** inline: "; print cdr w>>;
              return w>>
   end;
+++ applsmacro redefined
+++ applsmacro compiled, 295 + 80 bytes
applsmacro

% In my analysis here I am going to be slightly sloppy in my traversal
% of code - I will not expand further macros and I may ignore special
% features of some special forms. Since this is just to generate a report
% I think that perfection is not necessary!

symbolic procedure log_inlines(varlist, body, vals);
  begin
% (1) Are there assignments to any of the variable in varlist within body?
%     If so conversion from a macro to a procedure would change the
%     behaviour.
    if log_assignment(varlist, body) then return nil;
% (2) Does body use any variables that are free in it but not fluid or
%     global? If so they may be local variables in the context that the
%     inline is used, and conversion to a procedure would change semantics.
    if log_freevars(varlist, body) then return nil;
% (3) Are any items in varlist used more than once in circumstances where
%     the corresponding actual argument is something other than a simple
%     variable or constant? If so there is a risk of wasted multiple
%     evaluation -- or if the actual parameter involves side-effects even
%     worse.
% (4) [I am not at all certain how well I can check this!]. I want to
%     detect cases where it is important that the substituted argument
%     gets evaluated just and only where shown in the inline. Current thoughts
%     are (4.1) to detect cases where an argument is only used in a context
%     where its value is ignored, as in "inline procedure f u; << A ; u; B>>;"
%     and (4.2) to detect cases where an argument is used within a branch
%     of a conditional. Note that if I have already filtered on (3) this means
%     that the single use is conditional.
  end;
+++ log_inlines redefined
+++ log_inlines compiled, 11 + 16 bytes
log_inlines

symbolic procedure log_assignment(varlist, u);
  if atom u or eqcar(u, 'quote) or eqcar(u, 'function) then nil
  else if eqcar(u, 'setq) then <<
    if member(cadr u, varlist) then <<
      if not zerop posn() then terpri();
      prin2 "+++ Assignment to parameter of inline: ";
      print u;
      prin2 "+++ Macro was: ";
      print inlineinfo;
      t>>
    else log_assignment(varlist, caddr u) >>
  else if eqcar(u, 'cond) then log_assignment_list_list(varlist, cdr u)
  else log_assignment_list(varlist, u);
+++ log_assignment redefined
+++ log_assignment compiled, 56 + 52 bytes
log_assignment

symbolic procedure log_assignment_list_list(varlist, u);
  if atom u then nil
  else if log_assignment_list(varlist, car u) then t
  else log_assignment_list_list(varlist, cdr u);
+++ log_assignment_list_list compiled, 14 + 16 bytes
log_assignment_list_list

symbolic procedure log_assignment_list(varlist, u);
  if atom u then nil
  else if log_assignment(varlist, car u) then t
  else log_assignment_list(varlist, cdr u);
+++ log_assignment_list redefined
+++ log_assignment_list compiled, 14 + 16 bytes
log_assignment_list

symbolic procedure log_freevars(varlist, u);
  if atom u then <<
% Note that in PSL at least NIL and T are not tagged as either fluid
% or global - they are special cases! Well it seems that they have a
% property 'constant!? that is true that marke them. I will still check for
% t and nil specially as well.
    if not idp u or member(u, varlist) or
       globalp u or fluidp u or
       get(u, 'constant!?) or
       u = nil or u = t then nil
    else <<
      if not zerop posn() then terpri();
      prin2 "+++ Use of free variable in smacro/inline body: ";
      print u;
      prin2 "+++ Macro was: ";
      print inlineinfo;
      t >> >>
  else if eqcar(u, 'quote) or
    (eqcar(u, 'function) and atom cadr u) or
    eqcar(u, 'go) then nil
  else if eqcar(u, 'prog) then
    log_freevars_list(append(cadr u, varlist), cdr u, t)
  else if eqcar(u, 'lambda) then
    log_freevars_list(append(cadr u, varlist), cdr u, nil)
  else if eqcar(u, 'cond) then log_freevars_list_list(varlist, cdr u)
  else if atom car u then log_freevars_list(varlist, cdr u, nil)
  else log_freevars_list(varlist, u, nil);
+++ log_freevars redefined
+++ log_freevars compiled, 137 + 76 bytes
log_freevars

symbolic procedure log_freevars_list_list(varlist, u);
  if atom u then nil
  else if log_freevars_list(varlist, car u, nil) then t
  else log_freevars_list_list(varlist, cdr u);
+++ log_freevars_list_list compiled, 17 + 16 bytes
log_freevars_list_list

symbolic procedure log_freevars_list(varlist, u, isprog);
  if atom u then nil
  else if isprog and atom car u then log_freevars_list(varlist, cdr u, t)
  else if log_freevars(varlist, car u) then t
  else log_freevars_list(varlist, cdr u, isprog);
+++ log_freevars_list redefined
+++ log_freevars_list compiled, 25 + 16 bytes
log_freevars_list

symbolic procedure no!-side!-effectp u;
   if atom u then numberp u or (idp u and not(fluidp u or globalp u))
    else if car u = 'quote then t
    else if flagp(car u,'nosideeffects)
     then no!-side!-effect!-listp cdr u
    else nil;
+++ no!-side!-effectp redefined
+++ no!-side!-effectp compiled, 37 + 40 bytes
no-side-effectp

symbolic procedure no!-side!-effect!-listp u;
   null u or no!-side!-effectp car u and no!-side!-effect!-listp cdr u;
+++ no!-side!-effect!-listp redefined
+++ no!-side!-effect!-listp compiled, 12 + 16 bytes
no-side-effect-listp

% This list USED to have CONS in it, which would grant expansion of
% inlines the right to duplicate expressions with CONS in them - and
% firstly that would waste memory, and (worse) it causes bugs when
% in the presence of RPLACA and RPLACD.  (ACN, Sept 2010)

flag('(car cdr
       caar cadr cdar cddr
% The expansion code is willing to duplicate expressions that use things
% flagged as side-effect free. I am not certain whether the following
% are sensible to duplicate calls of...
       caaar caadr cadar caddr cdaar cdadr cddar cdddr
       ),'nosideeffects);nil

% Here are some more things that do not have side effects.

flag('(not null atom eq numberp fixp floatp eqcar),'nosideeffects);nil

symbolic procedure one!-entryp(u,v);
   % determines if id U occurs less than twice in V.
   if atom v then t
    else if smemq(u,car v)
     then if smemq(u,cdr v) then nil else one!-entryp(u,car v)
    else one!-entryp(u,cdr v);
+++ one!-entryp redefined
+++ one!-entryp compiled, 23 + 12 bytes
one-entryp

symbolic procedure one!-entry!-listp(u,v);
   null u or one!-entryp(car u,v) and one!-entry!-listp(cdr u,v);
+++ one!-entry!-listp redefined
+++ one!-entry!-listp compiled, 14 + 16 bytes
one-entry-listp

symbolic procedure delasc(u,v);
  begin scalar w;
     while v do
      <<if atom car v or u neq caar v then w := car v . w; v := cdr v>>;
     return reversip w
  end;
+++ delasc redefined
+++ delasc compiled, 25 + 8 bytes
delasc

% I have updated subla!-q to let it cope better with nested scoped. At
% present I have not allowed for name clashed between parameters and the
% names of PROG labels,

symbolic procedure subla!-q(u,v);
% u is an association list of substitutions, as in
%     ((name1 . value1) (name2 . value2) ...)
% and v is a bit of Lisp code. Perform the substitutions throughout
% the code, but NOT within quoted items (QUOTE literal) and NOT in
% a manner that messes up embedded bindings. This latter is
% an enhancement to the code as of September 2010 to resolve issues
% that arose when trying to use many more inlines then before.
   begin scalar x;
        if null u or null v then return v
         else if atom v
                 then return if x:= atsoc(v,u) then cdr x else v
         else if car v = 'quote or car v = 'go then return v
         else if (eqcar(v, 'lambda) or eqcar(v, 'prog)) and
                 not atom cdr v then <<
            x := cadr v;  % (LAMBDA x . body) or (PROG x . body)
% Now the key line - discard the bindings that get hidden.
% Right now there is a residual bug in that labels in a PROG are subject
% to substitution when they should not be! I will worry about that at some
% later stage - maybe.
            for each xx in x do u := delasc(xx, u);
            x := (subla!-q(u,car v) . subla!-q(u,cdr v));
            return x >>
         else return (subla!-q(u,car v) . subla!-q(u,cdr v))
   end;
+++ subla!-q redefined
+++ subla!-q compiled, 77 + 28 bytes
subla-q


put('inline,'macrofn,'applsmacro);applsmacro
put('smacro,'macrofn,'applsmacro);applsmacro

%
% Now I would rather like to retire smacros completely because of the
% delicacies documented above. But one use for them is to provide constructors
% and accessors for data-structures. A special challange there is that "form"
% process inlines that are seen on the left hand side of assignments. Thus
% if I ever replace inlines with simple functions (even ones that an optimising
% compiler can in-line) I need to do something more about that.
%
% So here I propose syntax that describes new data types. I will illustrate
% it with how it will be used to define the shape of polynomials in the
% file poly/poly.red
%
%    accessors lc . red;
%    accessors (lpow . lc) . !_;
%    accessors ((mvar . ldeg) . !_) . !_;
%    accessors tpow . tc, (tvar . tdeg) . !_;
%    accessors numr . denr;
%
% BEWARE. I have written "!_" here for a plain unadorned underscore even
% though mostly in Reduce you can just write "_". However excalc makes a
% new token "_|" for innerprod and after that an underscore not followed
% by a vertical bar seems to cause a crash in rlisp/tok.red:scan!
%
% The constructors need to be written out by hand as in
%    inline procedure u .+ v; u . v;
% if only because although they deliver cons cells they may do more than that
% (eg at one stage at least it was arranged that powers were stored uniquely).
% The underscore is used for fields that are not to be named. Note that
% several sets of accessors can be defined on one line.
%
% The effect of such a definition will be illustrated here by looking at
% what "accessors (tvar . tdeg) . !_;" corresponds to:
%   << inline procedure tvar u; caar u;
%      inline procedure tdeg u; cdar u;
%      inline procedure set_tvar(u, v); setcar(car u, v);
%      inline procedure set_tdeg(u, v); setcdr(car u, v);
%      put('tvar, 'setqfn, '(lambda (u b) (setcar (car u) v)));
%      put('tdeg, 'setqfn, '(lambda (u b) (setcdr (car u) v))) >>;
% and if !*noinlines is true then the "inline procedure" becomes "symbolic
% procedure" instead. The provision of explicit setter functions is because
% I then wish to consider replacing any "tvar u := v;" with "set_tvar(u, v);"
% which avoids needing having the setqfn information loaded at parse time.
% When (and if) that is ever completed then the 'setqfn stuff can go away.

% I wish to optimise (eg) "car cdr car x" into "cadar x" and this code
% achieves that for me.

symbolic procedure makecarcdr(path, x);
  if null path then x
  else if null cdr path then list(car path, x)
  else if null cddr path then list(
    cdr assoc(car path . cadr path,
             '(((car . car) . caar)
               ((car . cdr) . cadr)
               ((cdr . car) . cdar)
               ((cdr . cdr) . cddr))), x)
  else list(
    cdr assoc(car path . cadr path . caddr path,
             '(((car car . car) . caaar)
               ((car car . cdr) . caadr)
               ((car cdr . car) . cadar)
               ((car cdr . cdr) . caddr)
               ((cdr car . car) . cdaar)
               ((cdr car . cdr) . cdadr)
               ((cdr cdr . car) . cddar)
               ((cdr cdr . cdr) . cdddr))),
    makecarcdr(cdddr path, x));
+++ makecarcdr compiled, 45 + 16 bytes
makecarcdr

put('car, 'mutator, 'setcar);setcar
put('cdr, 'mutator, 'setcdr);setcdr

symbolic procedure expand_accessor(u, path, r);
  if u = '!_ then r
  else if eqcar(u, 'cons) then
    expand_accessor(cadr u, 'car . path,
      expand_accessor(caddr u, 'cdr . path, r))
  else if u = nil or not idp u then typerr(u, "illegal as accessor")
  else <<
    r := list('put, mkquote u, ''number!-of!-args, 1) . r;
    if not !*noinlines then
      begin scalar p;
         p := list('putc, mkquote u, ''inline,
                   mkquote list('lambda, '(u), makecarcdr(path, 'u)));
         if !*defn then lispeval p;
         r := p . r
      end
    else <<
       r := list('de, u, '(u), makecarcdr(path, 'u)) . r;
       r := list('put, mkquote u, ''setqfn,
          mkquote list('lambda, '(u v),
                         list(get(car path, 'mutator),
                              makecarcdr(cdr path, 'u),
                              'v))) . r >>;
    u := intern list2string append('(s e t !_), explode2 u);
    r := list('put, mkquote u, ''number!-of!-args, 2) . r;
    if not !*noinlines then
       begin scalar p;
         p := list('putc, mkquote u, ''inline,
                          mkquote list('lambda, '(u v),
                          list(get(car path, 'mutator),
                               makecarcdr(cdr path, 'u),
                               'v)));
         if !*defn then lispeval p;
         r := p . r
       end
    else r := list('de, u, '(u v),
                   list(get(car path, 'mutator),
                        makecarcdr(cdr path, 'u),
                        'v)) . r;
    r >>;
+++ expand_accessor compiled, 271 + 128 bytes
expand_accessor

flag('(putc), 'eval);nil

symbolic macro procedure accessors u;
  begin
    scalar r;
    u := eval cadr u;
% u will now be a list of forms representing the structure and with
% explicit "cons" operators, as in
%     (   (cons (cons tvar tdeg) _)    )
    for each c in u do r := expand_accessor(c, nil, r);
    return 'progn . append(reverse r, '(nil));
  end;
+++ accessors_rwzksyv4la0b2 compiled, 40 + 20 bytes
accessors

put('accessors, 'stat, 'rlis);rlis

endmodule;nil

end;nilmodule io;nil % Functions for handling input and output of files.

% Author: Anthony C. Hearn.

% Copyright (c) 1995 RAND. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*echo !*int !*reduce4 semic!* ifl!* curline!*);nil

global '(contl!* ipl!* linelist!* ofl!* opl!* techo!*);nil

symbolic procedure file!-transform(u,v);
   % Performs a transformation on the file u.  V is name of function
   % used for the transformation.
   begin scalar echo,ichan,oldichan,val;
      echo := !*echo;
      !*echo := nil;
      ichan := open(u,'input);
      oldichan := rds ichan;
      val := errorset!*(list v,t);
      !*echo := echo;
      close ichan;
      rds oldichan;
      if not errorp val then return car val
   end;
+++ file!-transform compiled, 35 + 32 bytes
file-transform

symbolic procedure infile u;
   % Loads the single file u into REDUCE without echoing.
   begin scalar !*int, ifl!*, curline!*;
     ifl!* := list u;
     curline!* := 1;
     return file!-transform(u,function begin1)
   end;
+++ infile compiled, 21 + 36 bytes
infile

symbolic procedure in u; in_non_empty_list u;
+++ in compiled as link to in_non_empty_list
in  % REDUCE 3 hook.

symbolic procedure in_tex u;
   in_non_empty_list1(u,
      '(!\ e n d !{ r e d u c e !}));
+++ in_tex compiled, 4 + 16 bytes
in_tex

symbolic procedure in_non_empty_list u; in_non_empty_list1(u, nil);
+++ in_non_empty_list compiled, 4 + 12 bytes
in_non_empty_list

symbolic procedure in_non_empty_list1(u, prefixchars);
   begin scalar echop;
      echop := null(semic!* = '!$); % Record echo character from input.
      if null ifl!* then techo!* := !*echo;   % Terminal echo status.
      if !*reduce4 then u := value u;
      for each fl in u do in_list1a(fl,echop,prefixchars);
      if ipl!* then ifl!* := car ipl!* else ifl!* := nil;
      if ifl!* then curline!* := caddr ifl!*;
      if !*reduce4 then return mkobject(nil,'noval)
   end;
+++ in_non_empty_list1 compiled, 63 + 56 bytes
in_non_empty_list1

symbolic procedure mkfil!* u;
   % Converts file descriptor U into valid system filename.
   % Allows for u to have an algebraic scalar value.
   begin scalar x;
      return if stringp u then u
              else if not idp u then typerr(u,"file name")
              else if flagp(u,'share) and stringp (x := eval u)
               then x
              else string!-downcase u
   end;
+++ mkfil!* redefined
+++ mkfil!* compiled, 30 + 24 bytes
mkfil*

symbolic procedure in_list1(fl,echop);
   in_list1a(fl,echop,nil);
+++ in_list1 redefined
+++ in_list1 compiled, 6 + 12 bytes
in_list1

symbolic procedure in_list1a(fl,echop,prefixchars);
   begin scalar chan,echo,ochan,w,w1,usepipe;
      echo := !*echo;   % Save current echo status.
      if !*reduce4 then if type fl neq 'string then typerr(fl,'string)
                         else fl := value fl;
      fl := mkfil!* fl;
% Now fl is a string and if ifl!* is nil then input had been coming from
% the "terminal", otherwise car ifl!* is the name of the file currently
% being read from.
%
% Now I wish to arrange that if fl is of the form "$/xxx" (or $\xxx") that
% the "$" is replaced by the directory portion of car ifl!*. Or by "." if
% ifl!*=nil or it does not contain a "/" or "\". 
      w := explode2 fl;
      if eqcar(w, '!|) then <<
        usepipe := t;
        fl := list2string cdr w >>
      else if eqcar(w, '!$) and
         (eqcar(cdr w, '!/) or eqcar(cdr w, '!\)) then <<
        if null ifl!* then fl := list2string('!. . cdr w)
        else <<
          w1 := reverse explode2 car ifl!*;
          while w1 and not (eqcar(w1, '!/) or eqcar(w1, '!\)) do w1 := cdr w1;
          if null w1 then w1 := '(!/ !.);
          w := append(reverse w1, cddr w);
          fl := list2string w >> >>;
      chan := if usepipe then pipe!-open(fl,'input) else open(fl,'input);
      ochan := rds chan;
      if assoc(fl,linelist!*) then nil;
      curline!* := 1;
      ifl!* := list(fl,chan,1);
      ipl!* := ifl!* . ipl!*;  % Add to input file stack.
      !*echo := echop;
      begin1a(prefixchars);
      rds ochan;
      close chan;
      !*echo := echo;   % Restore echo status.
      if null ipl!* and contl!* then return nil
       else if null ipl!* or null(fl eq caar ipl!*)
        then rederr list("FILE STACK CONFUSION",fl,ipl!*)
       else ipl!* := cdr ipl!*
   end;
+++ in_list1a redefined
+++ in_list1a compiled, 187 + 116 bytes
in_list1a

symbolic procedure out u; out_non_empty_list u;
+++ out compiled as link to out_non_empty_list
out

symbolic procedure out_non_empty_list u;
   % U is a list of one file.
   begin integer n; scalar chan,fl,x;
      n := linelength nil;
      if !*reduce4 then u := value u;
      if null u then return nil;
      u := car u;
      if !*reduce4 then if type u neq 'string then typerr(u,'string)
                         else u := value u;
      if u = 't then return <<wrs(ofl!* := nil); nil>>;
      fl := mkfil u;
      if not (x := assoc(fl,opl!*))
        then <<chan := open(fl,'output);
               if chan
                 then <<ofl!*:= fl . chan; opl!*:= ofl!* . opl!*>>>>
       else ofl!* := x;
      wrs cdr ofl!*;
      linelength n;
      if !*reduce4 then return mkobject(nil,'noval)
   end;
+++ out_non_empty_list compiled, 89 + 64 bytes
out_non_empty_list

symbolic procedure shut u; shut_non_empty_list u;
+++ shut compiled as link to shut_non_empty_list
shut

symbolic procedure shut_non_empty_list u;
   % U is a list of names of files to be shut.
   begin scalar fl1;
      if !*reduce4 then u := value u;
      for each fl in u do
       <<if !*reduce4
          then if type fl neq 'string then typerr(fl,'string)
                else fl := value fl;
         if fl1 := assoc((fl := mkfil fl),opl!*)
           then <<opl!* := delete(fl1,opl!*);
                  if fl1=ofl!* then <<ofl!* := nil; wrs nil>>;
                  close cdr fl1>>
         else if not (fl1 := assoc(fl,ipl!*))
          then rerror(rlisp,26,list(fl,"not open"))
         else if fl1 neq ifl!*
          then <<close cadr fl1; ipl!* := delete(fl1,ipl!*)>>
         else rerror(rlisp,27,
                     list("Cannot shut current input file",car fl1))>>;
      if !*reduce4 then return mkobject(nil,'noval)
   end;
+++ shut_non_empty_list compiled, 125 + 80 bytes
shut_non_empty_list

deflist ('((in rlis) (in_tex rlis) (out rlis) (shut rlis)),'stat);(in in_tex out
shut)

flag ('(in in_tex out shut),'eval);nil

flag ('(in in_tex out shut),'ignore);nil

endmodule;nil

end;nilmodule infix;nil % Functions for introducing new infix operators.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*mode);nil

global '(preclis!*);nil

symbolic procedure forminfix(u,vars,mode);
   begin scalar x;
      if null(mode = 'symbolic)
       then x := for each j in cdr u collect list('mkop,mkarg(j,vars));
      u := list(car u,mkarg(cdr u,vars));
      return if x then 'progn . aconc(x,u) else u
   end;
+++ forminfix compiled, 79 + 28 bytes
forminfix

put('infix,'formfn,'forminfix);forminfix

symbolic procedure infix x;
   <<for each j in x do
        if not(j member preclis!*) then preclis!* := j . preclis!*;
     mkprec()>>;
+++ infix compiled, 28 + 16 bytes
infix

symbolic procedure precedence u;
   begin scalar x,y,z;
      preclis!* := delete(car u,preclis!*);
      y := cadr u;
      x := preclis!*;
   a: if null x then rerror(rlisp,16,list (y,"not found"))
       else if y eq car x
        then <<preclis!* :=
                  nconc!*(reversip!* z,car x . (car u . cdr x));
               mkprec();
               return nil>>;
      z := car x . z;
      x := cdr x;
      go to a
   end;
+++ precedence compiled, 50 + 40 bytes
precedence

deflist('((infix rlis) (precedence rlis)),'stat);(infix precedence)

flag('(infix precedence),'eval);nil

endmodule;nil

end;nilmodule switch;nil  % Support for switches and ON and OFF statements.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


global '(!*switchcheck switchlist!* switchtree!* switchstring!*);nil

% (memq 'psl lispsystem!*) does not work here because lispsystem!* is
% not yet fully set up.

!#if !*psl

% PSL defined ORDERP in pslrend.red - ie "not yet", so here I transcribe
% the definition that will happen so I can use it now.

% symbolic procedure orderp(u,v);
%    % U, V are non-numeric atoms (but can be vectors).
%    % Returns true if U has same or higher order than id V by some
%    % consistent convention (eg unique position in memory).
%    wleq(inf u,inf v);       % PSL 3.4 form.
% %  id2int u <= id2int v;    % PSL 3.2 form.

symbolic procedure orderp(u,v);
   % This PSL-specific definition of ORDERP is designed to work in
   % lexicographical order.  It also checks to make sure arguments are
   % truly id's, which should be true with current REDUCE.
   begin scalar i,j,k,l,m;  % All sints.
      if idp u then u := strinf symnam idinf u
       else return typerr(u,"identifier");
      if idp v then v := strinf symnam idinf v
       else return typerr(v,"identifier");
      i := 0;
      j := strlen u;
      k := strlen v;
      % In the following, we assume size of u and v are inums.
   a: if null((l := strbyt(u,i)) eq (m := strbyt(v,i)))
        then return ilessp(l,m)
       else if i eq j then return null igreaterp(j,k)
       else if i eq k then return nil;
      i := iplus2(i,1);
      go to a;
   end;

!#endif

% I will maintain an ordered binary tree of the names of switches that
% are at present available. The procedures that manage this can be used
% for other analagous data too.

symbolic procedure add!-to!-sorted!-tree(x, u);
  if null u then nil . (x . nil)
  else if x = cadr u then u
  else if orderp(x, cadr u) then
     add!-to!-sorted!-tree(x, car u) . cdr u
  else car u . (cadr u . add!-to!-sorted!-tree(x, cddr u));
+++ add!-to!-sorted!-tree redefined
+++ add!-to!-sorted!-tree compiled, 52 + 8 bytes
add-to-sorted-tree

symbolic procedure flatten!-sorted!-tree(u, l);
  if null u then l
  else flatten!-sorted!-tree(car u,
     cadr u . flatten!-sorted!-tree(cddr u, l));
+++ flatten!-sorted!-tree redefined
+++ flatten!-sorted!-tree compiled, 21 + 8 bytes
flatten-sorted-tree

% Given a list (abc def ghi) this makes a string "abc;def;ghi"

symbolic procedure string!-of!-list l;
  if null l then ""
  else list2string cdr (for each x in l conc ('!; . explode x));
+++ string!-of!-list redefined
+++ string!-of!-list compiled, 63 + 24 bytes
string-of-list

switchtree!* := nil;nil
switchstring!* := "";

% No references to RPLAC-based functions in this module.

symbolic procedure on u; for each j in u do on1 j;
+++ on redefined
+++ on compiled, 15 + 12 bytes
on

symbolic procedure off u; for each j in u do off1 j;
+++ off redefined
+++ off compiled, 15 + 12 bytes
off

symbolic procedure off1 u; onoff(u,nil);
+++ off1 redefined
+++ off1 compiled, 4 + 12 bytes
off1

symbolic procedure on1 u; onoff(u,t);
+++ on1 redefined
+++ on1 compiled, 4 + 16 bytes
on1

symbolic procedure onoff(u,bool);
   begin scalar x,y;
      if not idp u then typerr(u,"switch")
       else if not flagp(u,'switch)
%       then if !*switchcheck
               then rerror(rlisp,25,list(u,"not defined as switch"));
%             else lpriw("*****",list(u,"not defined as switch"));
      x := intern list2string ('!* . explode2 u);
      if !*switchcheck and lispeval x eq bool then return nil
       else if y := atsoc(bool,get(u,'simpfg))
        then lispeval('progn . append(cdr y,list nil));
      if bool and x = '!*!r!a!i!s!e then x := '!*raise       % Special case.
      else if bool and x = '!*!L!O!W!E!R then x := '!*lower; % Special case.
      set(x,bool)
   end;
+++ onoff redefined
+++ onoff compiled, 101 + 72 bytes
onoff

fluid '(swcksave);nil

symbolic procedure onoff!-reset u;
   % set switch to its default value
   % set !*switchcheck to t so that simpfg code is executed only 
   %  if the switch is actually toggled.
   <<!*switchcheck := t;
     onoff(u,if get(u,'switchdefault) then t else nil);
     !*switchcheck := swcksave>> where swcksave:=!*switchcheck;
+++ onoff!-reset compiled, 25 + 32 bytes
onoff-reset

symbolic procedure switch u;
   % Declare list u as switches.
   for each x in u do
      begin scalar y,dflt;
         if eqcar(x,'equal) and not atom cdr x and idp cadr x
             and not null cddr x and null cdddr x
           then if caddr x memq '(on off t nil)
                  then <<dflt := list if caddr x = 'on then t
                                       else if caddr x = 'off then nil
                                       else caddr x;
                         x := cadr x>>
                 else typerr(caddr x,"switch default value");
         if not idp x then typerr(x,"switch");
	 % Do nothing if the switch was already declared
 	 if flagp(x,'switch) and x memq switchlist!* then return;
         switchtree!* := add!-to!-sorted!-tree(x, switchtree!*);
% Building switchlist!* this way keeps it sorted, which feels tidy to me.
         switchlist!* := flatten!-sorted!-tree(switchtree!*, nil);
         switchstring!* := string!-of!-list switchlist!*;
         flag(list x,'switch);
         y := intern list2string ('!* . explode2 x);
         if not fluidp y and not globalp y then fluid list y;
         if not null dflt then <<put(x,'switchdefault,car dflt); set(y,car dflt)>>
      end;
+++ switch compiled, 156 + 96 bytes
switch

deflist('((switch rlis)),'stat);(switch)   % we use deflist since it's flagged
                                   % eval
flag('(switch),'eval);nil

put('off,'stat,'rlis);rlis

put('on,'stat,'rlis);rlis

flag ('(off on),'ignore);nil

% Symbolic mode switches:

switch backtrace,comp,defn,demo,echo,errcont,fastfor,   % eoldelimp
       int,lessspace,msg,output,pret,quotenewnam,raise,lower,time,
       strict_argcount, report_colons;nil

!*report_colons := t;t

put('eoldelimp,'simpfg,'((t (flag (list !$eol!$) 'delchar))
                         (nil (remflag (list !$eol!$) 'delchar))));((t (flag (
list $eol$) (quote delchar))) (nil (remflag (list $eol$) (quote delchar))))

% Support for REDUCE 4.

switch reduce4;nil

put('reduce4,'simpfg,'((t (load!-package 'reduce4) (!%reduce4))));((t (
load-package (quote reduce4)) (%reduce4)))

endmodule;nil

end;nilmodule where;nil  % Support for a where construct.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% global '(fixedpreclis!*);

symbolic procedure formwhere(u,vars,mode);
   begin scalar expn,equivs,y,z;
     expn := cadr u;
     equivs := remcomma caddr u;
     if not(mode = 'symbolic)
% The following line used to call formc instead of form1
%  It failed with nested rules, e.g.,
%   let { f(~x,~x) => (rp where rp => x*x) };
%       then return formc(list('whereexp,'list . equivs,expn),vars,mode);
       then return form1(list('whereexp,'list . equivs,expn),vars,mode);
     for each j in equivs do
        if not atom j and car j memq '(equal setq)
          then <<y := caddr j . y; z := cadr j . z>>
         else rerror(rlisp,17,list(j,"invalid in WHERE statement"));
     return formc(list('lambda,reversip z,expn) . reversip y,vars,mode)
   end;
+++ formwhere compiled, 90 + 56 bytes
formwhere

put('where,'formfn,'formwhere);formwhere

% fixedpreclis!* := 'where . fixedpreclis!*;  % Where has special place.

% mkprec();

endmodule;nil

end;nilmodule list;nil % Define a list as a list of expressions in curly brackets.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(orig!* posn!*);nil

global '(cursym!* simpcount!* simplimit!*);nil

% Add to system table.

put('list,'tag,'list);list

put('list,'rtypefn,'quotelist);quotelist

symbolic procedure quotelist u; 'list;
+++ quotelist redefined
+++ quotelist compiled, 2 + 12 bytes
quotelist

% Parsing interface.

symbolic procedure nconc2 (u,v);
  %. Destructive version of Append returning pointer to tail
  begin scalar w;
    if atom u then return v;
    w := u;
    while pairp cdr w do w := cdr w;
        rplacd (w,v);
        return w;
  end;
+++ nconc2 redefined
+++ nconc2 compiled, 19 + 8 bytes
nconc2

% using nconc2 here to allow for very long lists to be read
% nconc would always search the end of the list from the top

symbolic procedure xreadlist;
   % Expects a list of expressions enclosed by {, }.
   % Used to allow expressions separated by ; - treated these as progn.
   begin scalar cursym,delim,lst,lst2;
        if scan() = '!*rcbkt!* then <<scan(); return list 'list>>;
    a:  if null lst then << lst := lst2  := aconc(lst,xread1 'group)>>
        else lst2 := nconc2 (lst2,list(xread1 ' group));;
        cursym := cursym!*;
        if cursym = '!*semicol!*
          then symerr("Syntax error: semicolon in list",nil)
         else if scan() = '!*rcbkt!* and cursym = '!*comma!*
          then symerr("Syntax error: invalid comma in list",nil);
        if cursym = '!*rcbkt!*
          then return % if delim = '!*semicol!*
                      %   then 'progn . lst else
                      'list . lst
         else if null delim then delim := cursym;
%        else if not(delim eq cursym)
%         then symerr("Syntax error: mixed , and ; in list",nil);
        go to a
   end;
+++ xreadlist redefined
+++ xreadlist compiled, 72 + 60 bytes
xreadlist

put('!*lcbkt!*,'stat,'xreadlist);xreadlist

newtok '((!{) !*lcbkt!*);nil

newtok '((!}) !*rcbkt!*);nil

flag('(!*rcbkt!*),'delim);nil

flag('(!*rcbkt!*),'nodel);nil

% Evaluation interface.

put('list,'evfn,'listeval);listeval

put('list,'simpfn,'simpiden);simpiden  % This is a little kludgey, but allows
                              % things like dms2deg to work.

symbolic procedure getrlist u;
   if eqcar(u,'list) then cdr u
    else typerr(if eqcar(u,'!*sq) then prepsq cadr u else u,"list");
+++ getrlist redefined
+++ getrlist compiled, 20 + 28 bytes
getrlist

symbolic procedure listeval(u,v);
   <<if (simpcount!* := simpcount!*+1)>simplimit!*
       then <<simpcount!* := 0;
              rerror(rlisp,18,"Simplification recursion too deep")>>;
     u := if atom u
            then listeval(if flagp(u,'share) then eval u
                           else if x then cadr x else typerr(u,'list),v)
                                  where x=get(u,'avalue)
           else if car u = 'list
            then makelist for each x in cdr u collect reval1(x,v)
           else ((if x then apply2(x,cdr u,v)
                   else rerror(rlisp,19,"Illegal operation on lists"))
                 where x = get(car u,'listfn));
     simpcount!* := simpcount!* - 1;
     u>>;
+++ listeval redefined
+++ listeval compiled, 127 + 64 bytes
listeval

symbolic procedure makelist u;
   % Make a list out of elements in u.
   'list . u;
+++ makelist redefined
+++ makelist compiled, 4 + 12 bytes
makelist


% Length interface.

put('list,'lengthfn,'lengthcdr);lengthcdr

symbolic procedure lengthcdr u; length cdr u;
+++ lengthcdr redefined
+++ lengthcdr compiled, 3 + 8 bytes
lengthcdr


% Printing interface.

put('list,'prifn,'listpri);listpri

symbolic procedure listpri l;
   % This definition is basically that of INPRINT, except that it
   % decides when to split at the comma by looking at the size of
   % the argument.
   begin scalar orig,split,u;
      u := l;
      l := cdr l;
      prin2!* get('!*lcbkt!*,'prtch);
         % Do it this way so table can change.
      orig := orig!*;
      orig!* := if posn!*<18 then posn!* else orig!*+3;
      if null l then go to b;
      split := treesizep(l,40);   % 40 is arbitrary choice.
   a: maprint(negnumberchk car l,0);
      l := cdr l;
      if null l then go to b;
      oprin '!*comma!*;
      if split then terpri!* t;
      go to a;
   b: prin2!* get('!*rcbkt!*,'prtch);
%     terpri!* nil;
      orig!* := orig;
      return u
   end;
+++ listpri redefined
+++ listpri compiled, 64 + 72 bytes
listpri

symbolic procedure treesizep(u,n);
   % true if u has recursively more pairs than n.
   treesizep1(u,n)=0;
+++ treesizep redefined
+++ treesizep compiled, 5 + 16 bytes
treesizep

symbolic procedure treesizep1(u,n);
   if atom u then n - 1
    else if (n := treesizep1(car u,n))>0 then treesizep1(cdr u,n)
    else 0;
+++ treesizep1 redefined
+++ treesizep1 compiled, 19 + 12 bytes
treesizep1

% Definitions of operations on lists.

symbolic procedure listeval0 u;
   begin scalar v;
     if (simpcount!* := simpcount!*+1)>simplimit!*
        then <<simpcount!* := 0;
                rerror(rlisp,20,"Simplification recursion too deep")>>;
     if idp u
       then if flagp(u,'share) then u := listeval0 eval u
             else if (v := get(u,'avalue)) and cadr v neq u
              then u := listeval0 cadr v;
     if getrtype car u = 'array then u := listeval0 getelv u;
     simpcount!* := simpcount!* - 1;
     return u
   end;
+++ listeval0 redefined
+++ listeval0 compiled, 63 + 52 bytes
listeval0

% First, second, third and rest are designed so that only the relevant
% elements need be fully evaluated.

symbolic inline procedure rlistp u; eqcar(u,'list);
+++ Record new inline definition:
(de rlistp (u) (eqcar u (quote list)))
(progn (de rlistp (u) (eqcar u (quote list))) (put (quote rlistp) (quote
number!-of!-args) 1) (put (quote rlistp) (quote procedure_type) (quote (arrow
general general))) (putc (quote rlistp) (quote inline) (quote (lambda (u) (eqcar
u (quote list))))))
+++ rlistp compiled, 4 + 12 bytes
(lambda (u) (eqcar u (quote list)))

symbolic procedure rfirst u;
   begin scalar x;
      u := car u;
%     if null(getrtype(x := listeval0 u) = 'list)
%        and null(getrtype(x := aeval u) = 'list)
      if not rlistp(x := listeval0 u) and not rlistp(x := aeval u)
        then typerr(u,"list");
      if null cdr x then parterr(u,1) else return reval cadr x
   end;
+++ rfirst redefined
+++ rfirst compiled, 30 + 40 bytes
rfirst

put('first,'psopfn,'rfirst);rfirst

symbolic procedure parterr(u,v);
   msgpri("Expression",u,"does not have part",v,t);
+++ parterr compiled, 13 + 24 bytes
parterr

symbolic procedure rsecond u;
   begin scalar x;
      u := car u;
      if not rlistp(x := listeval0 u) and not rlistp(x := aeval u)
        then typerr(u,"list");
      if null cdr x or null cddr x then parterr(u,2)
       else return reval caddr x
   end;
+++ rsecond compiled, 34 + 40 bytes
rsecond

put('second,'psopfn,'rsecond);rsecond

symbolic procedure rthird u;
   begin scalar x;
      u := car u;
      if not rlistp(x := listeval0 u) and not rlistp(x := aeval u)
        then typerr(u,"list");
      if null cdr x or null cddr x or null cdddr x then parterr(u,3)
       else return reval cadddr x
   end;
+++ rthird compiled, 39 + 40 bytes
rthird

put('third,'psopfn,'rthird);rthird

deflist('((first (lambda (x) 'yetunknowntype))
          (second (lambda (x) 'yetunknowntype))
          (third (lambda (x) 'yetunknowntype))
          (part (lambda (x) 'yetunknowntype))),
        'rtypefn);(first second third part)

symbolic procedure rrest u;
   begin scalar x;
      argnochk('cdr . u);
      u := car u;
      if not rlistp(x := listeval0 u) and not rlistp(x := aeval u)
        then typerr(u,"list");
      if null cdr x then typerr(u,"non-empty list")
       else return 'list . for each y in cddr x collect reval y
   end;
+++ rrest compiled, 76 + 44 bytes
rrest

put('rest,'psopfn,'rrest);rrest

deflist('((first 1) (second 1) (third 1) (rest 1)),'number!-of!-args);(first
second third rest)

symbolic procedure rappend u;
   begin scalar x,y;
      argnochk('append . u);
      if null(getrtype(x := reval car u) = 'list)
        then typerr(x,"list")
      else if null(getrtype(y := reval cadr u) = 'list)
       then typerr(y,"list")
      else return 'list . append(cdr x,cdr y)
   end;
+++ rappend redefined
+++ rappend compiled, 40 + 36 bytes
rappend

put('append,'psopfn,'rappend);rappend

symbolic procedure rcons u;
   begin scalar x,y,z;
      argnochk('cons . u);
      if (y := getrtypeor(x := revlis u)) = 'hvector
    then return if get('cons,'opmtch) and (z := opmtch('cons . x))
                   then reval z
                 else prepsq subs2 simpdot x
       else if not(getrtype cadr x = 'list) then typerr(x,"list")
       else return 'list . car x . cdadr x
   end;
+++ rcons compiled, 54 + 64 bytes
rcons

put('cons,'psopfn,'rcons);rcons

symbolic procedure rreverse u;
   <<argnochk ('reverse . u);
     if null(getrtype(u := reval car u) = 'list) then typerr(u,"list")
      else 'list . reverse cdr u>>;
+++ rreverse compiled, 26 + 36 bytes
rreverse

put('reverse,'psopfn,'rreverse);rreverse

% Aggregate Property.

symbolic procedure listmap(u,v);
   begin scalar x;
      x := cadr u;
      if null eqcar(x,'list) and null eqcar(x := reval1(x,v),'list)
        then typerr(cadr u,"list");
      return 'list
              . for each j in cdr x collect reval1(car u . j . cddr u,v)
   end;
+++ listmap compiled, 73 + 24 bytes
listmap

put('list,'aggregatefn,'listmap);listmap

% Sorting.

fluid '(sortfcn!*);nil

symbolic procedure listsort u;
   begin scalar l,n,w;
     if length u neq 2 then goto err;
     l:=cdr listeval(car u,nil);
     sortfcn!*:=cadr u;
     if(w:=get(sortfcn!*,'boolfn)) then sortfcn!*:=w;
     if null getd sortfcn!* or
      (n:=get(sortfcn!*,'number!-of!-args)) and n neq 2
        then goto err;
     return 'list.sort(l,w or
        function(lambda(x,y);
           boolvalue!* reval {sortfcn!*,mkquote x,mkquote y}));
 err: rederr "illegal call to list sort";
   end;
+++ lambda_g8v2e76dsgh62 compiled, 14 + 24 bytes
+++ listsort compiled, 53 + 48 bytes
listsort

put('sort,'psopfn,'listsort);listsort

endmodule;nil

end;nilmodule array;nil % Array statement.

% Author: Anthony C. Hearn.
% Modifications by: Nancy Kirkwood.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% These definitions are very careful about bounds checking. Appropriate
% optimizations in a given system might really speed things up.

fluid '(!*rlisp88);nil

global '(erfg!*);nil

symbolic procedure getel u;
   % Returns the value of the array element U.
   (if length n neq length cdr u
      then rerror(rlisp,21,"Incorrect array reference")
     else getel1(cadr get(car u,'avalue),cdr u,n))
    where n=get(car u,'dimension);
+++ getel redefined
+++ getel compiled, 27 + 32 bytes
getel

symbolic procedure getel1(u,v,dims);
   if null v then u
    else if not fixp car v then typerr(car v,"array index")
    else if car v geq car dims or car v < 0
     then rerror(rlisp,21,"Array out of bounds")
    else getel1(getv(u,car v),cdr v,cdr dims);
+++ getel1 redefined
+++ getel1 compiled, 36 + 32 bytes
getel1

symbolic procedure setel(u,v);
   % Sets array element U to V and returns V.
   (if length n neq length cdr u
           then rerror(rlisp,22,"Incorrect array reference")
     else setel1(cadr get(car u,'avalue),cdr u,v,n))
    where n=get(car u,'dimension);
+++ setel redefined
+++ setel compiled, 33 + 32 bytes
setel

symbolic procedure setel1(u,v,w,dims);
   if not fixp car v then typerr(car v,"array index")
    else if car v geq car dims or car v < 0
     then rerror(rlisp,23,"Array out of bounds")
    else if null cdr v then putv(u,car v,w)
    else setel1(getv(u,car v),cdr v,w,cdr dims);
+++ setel1 redefined
+++ setel1 compiled, 44 + 32 bytes
setel1

symbolic procedure dimension u; get(u,'dimension);
+++ dimension compiled, 4 + 8 bytes
dimension


COMMENT further support for REDUCE arrays;

symbolic procedure typechk(u,v);
   begin scalar x;
      if (x := gettype u) eq v or x = 'parameter
        then lprim list(v,u,"redefined")
       else if x then typerr(list(x,u),v)
   end;
+++ typechk compiled, 27 + 28 bytes
typechk

symbolic procedure arrayfn(u,v);
   % U is the defining mode, V a list of lists, assumed syntactically
   % correct. ARRAYFN declares each element as an array unless a
   % semantic mismatch occurs.
   begin scalar y;
      for each x in v do
         <<typechk(car x,'array);
       y := add1lis for each z in cdr x collect lispeval z;
       if null erfg!*
         then <<put(car x,'rtype,'array);
            put(car x,'avalue,list('array,mkarray1(y,u)));
            put(car x,'dimension,y)>>>>
   end;
+++ arrayfn compiled, 95 + 48 bytes
arrayfn

flag('(arrayfn),'nochange);nil

symbolic procedure add1lis u;
   if null u then nil else (car u+1) . add1lis cdr u;
+++ add1lis compiled, 15 + 12 bytes
add1lis

symbolic macro procedure mkarray u;
   if null !*rlisp88 then mkarray1(u,'algebraic) else
     list('mkar1,'list . cdr u);
+++ mkarray_np1fq99att36 compiled, 18 + 28 bytes
mkarray

symbolic procedure mkarray1(u,v);
   % U is a list of positive integers representing array bounds, V
   % the defining mode. Value is an array structure.
   if null u then if v = 'symbolic then nil else 0
    else begin integer n; scalar x;
      n := car u - 1;
      x := mkvect n;
      for i:=0:n do putv(x,i,mkarray1(cdr u,v));
      return x
   end;
+++ mkarray1 redefined
+++ mkarray1 compiled, 44 + 16 bytes
mkarray1

put('array,'stat,'rlis);rlis

flag ('(array arrayfn),'eval);nil

symbolic procedure formarray(u,vars,mode);
   begin scalar x;
      x := cdr u;
      while x do <<if atom x then typerr(x,"Array List")
                  else if atom car x or not idp caar x
                         or not listp cdar x
                  then typerr(car x,"Array declaration");
                   x := cdr x>>;
      u := for each z in cdr u collect intargfn(z,vars,mode);
      %ARRAY arguments must be returned as quoted structures;
      return list('arrayfn,mkquote mode,'list . u)
   end;
+++ formarray compiled, 94 + 44 bytes
formarray

put('array,'formfn,'formarray);formarray

put('array,'rtypefn,'arraychk);arraychk

symbolic procedure arraychk u;
   % If arraychk receives NIL, it means that array name is being used
   % as an identifier. We no longer permit this.
   if null u then 'array else nil;
+++ arraychk redefined
+++ arraychk compiled, 5 + 12 bytes
arraychk
%  nil;

put('array,'evfn,'arrayeval);arrayeval

symbolic procedure arrayeval(u,v);
   % Eventually we'll support this properly.
   if not atom u then rerror(rlisp,24,"Array arithmetic not defined")
    else u;
+++ arrayeval compiled, 10 + 24 bytes
arrayeval

put('array,'lengthfn,'arraylength);arraylength

symbolic procedure arraylength u; 'list . get(u,'dimension);
+++ arraylength compiled, 9 + 16 bytes
arraylength

endmodule;nil

end;nilmodule inter;nil % Functions for interactive support.

% Author: Anthony C. Hearn.

% Copyright (c) 1993 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*echo !*int trap!-time!* ifl!* curline!*);nil

global '(!$eof!$
         !$eol!$
         !*lessspace
         cursym!*
         curescaped!*
         cloc!*
         contl!*
         edit!*
         eof!*
         erfg!*
         flg!*
         ipl!*
         key!*
         ofl!*
         opl!*
         techo!*);nil

symbolic procedure pause;
   %Must appear at the top-most level;
   if null !*int then nil
    else if key!* = 'pause then pause1 nil
    else %typerr('pause,"lower level command");
         pause1 nil;
+++ pause compiled, 15 + 20 bytes
pause   % Allow at lower level for now.

symbolic procedure pause1 bool;
   begin scalar x;
      if bool then
        if getd 'edit1 and erfg!* and cloc!* and yesp "Edit?"
          then return <<contl!* := nil;
           if ofl!* then <<lprim list(car ofl!*,'shut);
                           close cdr ofl!*;
                           opl!* := delete(ofl!*,opl!*);
                           ofl!* := nil>>;
           edit1(cloc!*,nil)>>
         else if flg!* then return (edit!* := nil);
      if null ifl!* or yesp "Cont?" then return nil;
      ifl!* := list(car ifl!*,cadr ifl!*,curline!*);
      if x := assoccar(car ifl!*,contl!*)
        then <<contl!* := delete(x,contl!*); close cadar x>>;
      contl!* := (ifl!* . cdr ipl!* . !*echo) . contl!*;
      ifl!* := ipl!* := nil;
      rds nil;
      !*echo := techo!*
   end;
+++ pause1 compiled, 110 + 88 bytes
pause1

symbolic procedure assoccar(u,v);
   % Returns element of v in which caar of that element = u.
   if null v then nil
    else if u=caaar v then car v
    else assoccar(u,cdr v);
+++ assoccar compiled, 14 + 8 bytes
assoccar

symbolic procedure yesp u;
   begin scalar ifl,ofl,x,y;
        if ifl!*
          then <<ifl := ifl!* := list(car ifl!*,cadr ifl!*,curline!*);
                 rds nil>>;
        if ofl!* then <<ofl:= ofl!*; wrs nil>>;
        if null !*lessspace then terpri();
        if atom u then prin2 u else lpri u;
        prin2t " (Y or N)";
        if null !*lessspace then terpri();
        y := setpchar '!?;
        x := yesp1();
        setpchar y;
        if ofl then wrs cdr ofl;
        if ifl then rds cadr ifl;
        cursym!* := '!*semicol!*;
        curescaped!* := nil;
        return x
   end;
+++ yesp compiled, 74 + 64 bytes
yesp

symbolic procedure yesp1;
   % Basic loop for reading response.
   begin scalar bool,x,y;
    a:  x := readch();
        if x eq !$eol!$ then go to a
        % Assume an end-of-file means lost control and exit.
         else if x eq !$eof!$ then eval '(bye)
         %% else if (y := x = 'y) or x = 'n then return y
         else if (y := x memq '(!y !Y)) or x memq '(!n !N)
          then return y % F.J. Wright.
         else if null bool then <<prin2t "Type Y or N"; bool := t>>;
        go to a
   end;
+++ yesp1 compiled, 38 + 40 bytes
yesp1

symbolic procedure cont;
   begin scalar fl,techo;
        if ifl!* then return nil   % CONT only active from terminal.
         else if null contl!* then rerror(rlisp,28,"No file open");
        fl := caar contl!*;
        ipl!* := fl . cadar contl!*;
        techo := cddar contl!*;
        contl!* := cdr contl!*;
        if car fl=caar ipl!* and cadr fl=cadar ipl!*
          then <<ifl!* := fl;
                 if fl then <<rds cadr fl; curline!* := caddr fl>>
                  else rds nil;
                 !*echo := techo>>
         else <<eof!* := 1; lprim list(fl,"not open"); error1()>>
   end;
+++ cont compiled, 73 + 60 bytes
cont

deflist ('((cont endstat) (pause endstat) (retry endstat)),'stat);(cont pause
retry)

flag ('(cont),'ignore);nil

% This nasty fragment of code returns a floating point value that
% is a CRUDE indication of the speed of the machine on which it is running.
% It uses around a second of CPU time the first time it is run, with that
% amount of time not depending on the nature of the host platform.

% The value returned ranges from a bit over 1.0 for the regular version of
% Reduce on a Raspberry Pi (ie about the slowest machine in common use
% today) up to almost 20.0 for the fastest desktop systems of 2018. The idea
% of this is that it can be used with with!-timeout() to end up with
% a time limit that represents at least roughly the same amount of work
% whether run on a fast or slow computer.
% A copy of Reduce build with debugging options, or the CSL "bootstrapreduce"
% can be seriously slower - perhaps by up to a factor of ten. The measurement
% here should not be viewed as a benchmark that is valid in any respectable
% way for comparing performance on different systems, and the exact results
% returned will tend to vary somewhat from run to run. Despite all
% uncertainties it may help make code that wants to set time limits be at
% least roughtly able to set ones based on how much work has to be done.

global '(machine_speed!*);nil
machine_speed!* := nil;nil

symbolic procedure machine_speed();
  if machine_speed!* then machine_speed!*
  else begin
    scalar n, t0, t1;
    n := 50;
    t1 := 0;
    while t1 < 400 do <<
      n := 2*n;
      t0 := time();
% At this stage in the Reduce source I do not yet have the infix operators
% "to", ".*" and ".+" available, so I construct a sample polynomial as a
% raw Lisp data-structure just using CONS.
      for i := 1:n do exptf((('x . 1) . 1) . 1, 40);
      t1 := time() - t0 >>;
    return (machine_speed!* := float n / float t1)
  end;
+++ machine_speed compiled, 66 + 44 bytes
machine_speed

% I will have a scheme that lets me impose a limit on the time taken by
% a calculation. This works by using a hook function that is called at the
% end of any garbage collection, and so its granularity is not very fine.
% Note in particular that if you have a very large amount of memory and/or
% the calculation involved does not allocate memory as it goes then any
% interruption may be dramatically delayed. However for many cases of
% general algebraic calculations with default allocation memory it will be
% broadly useful!
% It exits using "throw" rather than by raising an error because by doing
% that the guarded code can not use errorset to avoid the interruption.
% The time-limit is passed in units of milliseconds. I am allowed to nest
% uses of "with-timeout" however the inner ones have their time allocation
% capped at the residual of the limit set by any outer one.
%
% Sometimes a user will really want the limit to be an absolute time period,
% as in "give up if I have not got anywhere within an hour", while in
% other cases (perhaps especially in demonstration scripts) the limit will
% want to be normalised against machine seed. So I provide two versions here,
% one for each scenario. The second is called with!-normalized!-timeout and it
% takes its limit in abstract "time units" that are VERY ROUGHLY milliseconds
% on a Raspberry pi, and are of course then much smaller on faster systems.

trap!-time!* := nil;nil % nil here means no trapping active.

% Note that when I detect a timeout I not only throw an exception, but I
% clear trap!-time!* so that unwinding and processing the timeout will not
% provoke a further activation of the mechanism.
% In CSL the gc-hook function is passed an argument that indicates something
% about the garbage collection that just happened. In PSL it does not have
% an argument.

#if (memq 'psl lispsystem!*)
symbolic procedure aftergcsystemhook();
#else
symbolic procedure aftergcsystemhook u;
#endif
  if trap!-time!* and
    time() > trap!-time!* then <<
      trap!-time!* := nil;
      throw('!@timeout!@, '!@timeout!@) >>;
+++ aftergcsystemhook compiled, 15 + 16 bytes
aftergcsystemhook

!*gc!-hook!* := 'aftergcsystemhook;aftergcsystemhook

symbolic procedure trap!-time!-value();
  trap!-time!*;
+++ trap!-time!-value compiled, 2 + 12 bytes
trap-time-value

% When I first coded this I used a "begin/end" block in it, but that impacts
% on "return" statements written within the expression "u". So now I use
% lambda-binding instead. Use of
%  with!-timeout(100, << ... ; return XXX>>);
% is still delicate because the return lies within a lambda expression not
% directly in "program context" but that will either work or at worst
% lead to some diagnostic, while using a "begin/end" here make things appear
% to be OK but to behave unexpectedly.

% Absolute time limit in milliseconds...

smacro procedure with!-timeout(n, u);
  (lambda !~ott!~;
    (lambda trap!-time!*;
      << trap!-time!* := time() + fix n;
         if numberp !~ott!~ and trap!-time!* > !~ott!~ then
            trap!-time!* := !~ott!~;
         catch('!@timeout!@, u . nil)>>)(nil))
    (trap!-time!-value());(lambda (n u) ((lambda (~ott~) ((lambda (trap-time*) (
declare (special trap-time*)) (progn (setq trap-time* (plus (time) (fix n))) (
cond ((and (numberp ~ott~) (greaterp trap-time* ~ott~)) (setq trap-time* ~ott~))
) (catch (quote @timeout@) (cons u nil)))) nil)) (trap-time-value)))


% Time limit in arbitrary units such that (very roughly) slow and fast
% machines get to do about the same amount of work before being interrupted.
% I think of the argument as being very roughly "Raspberry Pi milliseconds",
% so mid or high-range laptops or desktops will take less than that time.

smacro procedure with!-normalized!-timeout(n, u);
  (lambda !~ott!~;
    (lambda trap!-time!*;
      << trap!-time!* := time() + fix (n/machine_speed());
         if numberp !~ott!~ and trap!-time!* > !~ott!~ then
             trap!-time!* := !~ott!~;
         catch('!@timeout!@, u . nil)>>)(nil))
    (trap!-time!-value());(lambda (n u) ((lambda (~ott~) ((lambda (trap-time*) (
declare (special trap-time*)) (progn (setq trap-time* (plus (time) (fix (
quotient n (machine_speed))))) (cond ((and (numberp ~ott~) (greaterp trap-time*
~ott~)) (setq trap-time* ~ott~))) (catch (quote @timeout@) (cons u nil)))) nil))
(trap-time-value)))


% A typical use of this would be:
%
%    with!-timeout(7000,               % allow 7 seconds.
%                  perform_some_calculation());
% or
%    with!-normalized_timeout(70000, % 70000 "abstract time units"
%                                    % About as previous case on a mid-range
%                                    % computer of 2018.
%                             perform_some_calculation());
%
% These return an atom if the time limit was exceeded, and otherwise a list
% whose car is the value of the protected expression.

% Note that it will be VITAL that the protected expression be such that
% interrupting it can not leave global variables or data in a state that
% will mess up further computation. If the code binds fluids that will be OK
% because they will be restored in the process of handling the interrupt,
% but Reduce global state, such as that associated with kernel ordering, would
% NOT be restored, and if RPLACx operations are performed in ways that
% could leave data in a temporarily insanitary state then that will be
% dangerous. There could at least in principle be problems with global state
% within the Lisp system too, but at present I can not provide a clear
% statement of what is safe and what might not be. Well input or output
% stream selection certainly represents global state...

% Sometimes I want to have a critical section of code that must
% not be interrupted by a timeout trap. I can arrange that using this
% macro, which disables the timeout for the duration of the evaluation
% of its argument. Note that this needs to be used with some case to
% ensure that the computation that it guards is not terribly length, since
% it is an absolute escape from any surrounding timeout!

smacro procedure without!-timeout u;
  (lambda trap!-time!*; u)(nil);(lambda (u) ((lambda (trap-time*) (declare (
special trap-time*)) u) nil))

symbolic procedure errorset_with_timeout(!~n!~, !~u!~);
  with!-timeout(!~n!~, errorset!*(!~u!~, t));
+++ errorset_with_timeout compiled, 38 + 32 bytes
errorset_with_timeout

endmodule;nil

end;nilmodule charname;nil % Set up names for extended characters

% Author: Arthur Norman.

% Copyright (c) 2014 Arthur Norman.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%

% The data here is derived from the HTML Living Standard at
% http://whatwg.org which notes on its contents page
% "Copyright 2004-2011 Apple Computer, Inc., Mozilla Foundation,
%  and Opera Software ASA. You are granted a license to use, reproduce
%  and create derivative works of this document."
% It was extracted from their information in March 2014 and the "official"
% list may change at any stage after that.

% Some of the character names are shown as mapping onto pairs of Unicode
% symbols (&acE; is the first such: I might try to render it here as
% "~=", an &ac; sign (alternating current?) followed by a lowered equals
% sign). I have commented out all such cases in that it seems bad enough
% feel like worrying about things like &Afr; (Capital letter A rendered
% in a Fractur font at codepoint U+1d504) but support for Unicode
% combining marks and composites is a step too far for me at present!

% I have added a special extra &hash; to stand for "#" just for the
% convenience of Reduce. 

% Just so you know, there are somewhat over 2000 names here. Please be
% VERY aware that just because there is a name for an entity here that
% will not guarantee that it can be displayed, in that display will
% depend on at least the font you are using.

for each x in '( 
    ("Aacute"                          193)
    ("aacute"                          225)
    ("Abreve"                          258)
    ("abreve"                          259)
    ("ac"                              8766)
    ("acd"                             8767)
 %  ("acE"                             8766, 819)
    ("Acirc"                           194)
    ("acirc"                           226)
    ("acute"                           180)
    ("Acy"                             1040)
    ("acy"                             1072)
    ("AElig"                           198)
    ("aelig"                           230)
    ("af"                              8289)
    ("Afr"                             120068)
    ("afr"                             120094)
    ("Agrave"                          192)
    ("agrave"                          224)
    ("alefsym"                         8501)
    ("aleph"                           8501)
    ("Alpha"                           913)
    ("alpha"                           945)
    ("Amacr"                           256)
    ("amacr"                           257)
    ("amalg"                           10815)
    ("amp"                             38)
    ("AMP"                             38)
    ("andand"                          10837)
    ("And"                             10835)
    ("and"                             8743)
    ("andd"                            10844)
    ("andslope"                        10840)
    ("andv"                            10842)
    ("ang"                             8736)
    ("ange"                            10660)
    ("angle"                           8736)
    ("angmsdaa"                        10664)
    ("angmsdab"                        10665)
    ("angmsdac"                        10666)
    ("angmsdad"                        10667)
    ("angmsdae"                        10668)
    ("angmsdaf"                        10669)
    ("angmsdag"                        10670)
    ("angmsdah"                        10671)
    ("angmsd"                          8737)
    ("angrt"                           8735)
    ("angrtvb"                         8894)
    ("angrtvbd"                        10653)
    ("angsph"                          8738)
    ("angst"                           197)
    ("angzarr"                         9084)
    ("Aogon"                           260)
    ("aogon"                           261)
    ("Aopf"                            120120)
    ("aopf"                            120146)
    ("apacir"                          10863)
    ("ap"                              8776)
    ("apE"                             10864)
    ("ape"                             8778)
    ("apid"                            8779)
    ("apos"                            39)
    ("ApplyFunction"                   8289)
    ("approx"                          8776)
    ("approxeq"                        8778)
    ("Aring"                           197)
    ("aring"                           229)
    ("Ascr"                            119964)
    ("ascr"                            119990)
    ("Assign"                          8788)
    ("ast"                             42)
    ("asymp"                           8776)
    ("asympeq"                         8781)
    ("Atilde"                          195)
    ("atilde"                          227)
    ("Auml"                            196)
    ("auml"                            228)
    ("awconint"                        8755)
    ("awint"                           10769)
    ("backcong"                        8780)
    ("backepsilon"                     1014)
    ("backprime"                       8245)
    ("backsim"                         8765)
    ("backsimeq"                       8909)
    ("Backslash"                       8726)
    ("Barv"                            10983)
    ("barvee"                          8893)
    ("barwed"                          8965)
    ("Barwed"                          8966)
    ("barwedge"                        8965)
    ("bbrk"                            9141)
    ("bbrktbrk"                        9142)
    ("bcong"                           8780)
    ("Bcy"                             1041)
    ("bcy"                             1073)
    ("bdquo"                           8222)
    ("becaus"                          8757)
    ("because"                         8757)
    ("Because"                         8757)
    ("bemptyv"                         10672)
    ("bepsi"                           1014)
    ("bernou"                          8492)
    ("Bernoullis"                      8492)
    ("Beta"                            914)
    ("beta"                            946)
    ("beth"                            8502)
    ("between"                         8812)
    ("Bfr"                             120069)
    ("bfr"                             120095)
    ("bigcap"                          8898)
    ("bigcirc"                         9711)
    ("bigcup"                          8899)
    ("bigodot"                         10752)
    ("bigoplus"                        10753)
    ("bigotimes"                       10754)
    ("bigsqcup"                        10758)
    ("bigstar"                         9733)
    ("bigtriangledown"                 9661)
    ("bigtriangleup"                   9651)
    ("biguplus"                        10756)
    ("bigvee"                          8897)
    ("bigwedge"                        8896)
    ("bkarow"                          10509)
    ("blacklozenge"                    10731)
    ("blacksquare"                     9642)
    ("blacktriangle"                   9652)
    ("blacktriangledown"               9662)
    ("blacktriangleleft"               9666)
    ("blacktriangleright"              9656)
    ("blank"                           9251)
    ("blk12"                           9618)
    ("blk14"                           9617)
    ("blk34"                           9619)
    ("block"                           9608)
 %  ("bne"                             61, 8421)
 %  ("bnequiv"                         8801, 8421)
    ("bNot"                            10989)
    ("bnot"                            8976)
    ("Bopf"                            120121)
    ("bopf"                            120147)
    ("bot"                             8869)
    ("bottom"                          8869)
    ("bowtie"                          8904)
    ("boxbox"                          10697)
    ("boxdl"                           9488)
    ("boxdL"                           9557)
    ("boxDl"                           9558)
    ("boxDL"                           9559)
    ("boxdr"                           9484)
    ("boxdR"                           9554)
    ("boxDr"                           9555)
    ("boxDR"                           9556)
    ("boxh"                            9472)
    ("boxH"                            9552)
    ("boxhd"                           9516)
    ("boxHd"                           9572)
    ("boxhD"                           9573)
    ("boxHD"                           9574)
    ("boxhu"                           9524)
    ("boxHu"                           9575)
    ("boxhU"                           9576)
    ("boxHU"                           9577)
    ("boxminus"                        8863)
    ("boxplus"                         8862)
    ("boxtimes"                        8864)
    ("boxul"                           9496)
    ("boxuL"                           9563)
    ("boxUl"                           9564)
    ("boxUL"                           9565)
    ("boxur"                           9492)
    ("boxuR"                           9560)
    ("boxUr"                           9561)
    ("boxUR"                           9562)
    ("boxv"                            9474)
    ("boxV"                            9553)
    ("boxvh"                           9532)
    ("boxvH"                           9578)
    ("boxVh"                           9579)
    ("boxVH"                           9580)
    ("boxvl"                           9508)
    ("boxvL"                           9569)
    ("boxVl"                           9570)
    ("boxVL"                           9571)
    ("boxvr"                           9500)
    ("boxvR"                           9566)
    ("boxVr"                           9567)
    ("boxVR"                           9568)
    ("bprime"                          8245)
    ("breve"                           728)
    ("Breve"                           728)
    ("brvbar"                          166)
    ("bscr"                            119991)
    ("Bscr"                            8492)
    ("bsemi"                           8271)
    ("bsim"                            8765)
    ("bsime"                           8909)
    ("bsolb"                           10693)
    ("bsol"                            92)
    ("bsolhsub"                        10184)
    ("bull"                            8226)
    ("bullet"                          8226)
    ("bump"                            8782)
    ("bumpE"                           10926)
    ("bumpe"                           8783)
    ("Bumpeq"                          8782)
    ("bumpeq"                          8783)
    ("Cacute"                          262)
    ("cacute"                          263)
    ("capand"                          10820)
    ("capbrcup"                        10825)
    ("capcap"                          10827)
    ("cap"                             8745)
    ("Cap"                             8914)
    ("capcup"                          10823)
    ("capdot"                          10816)
    ("CapitalDifferentialD"            8517)
 %  ("caps"                            8745, 65024)
    ("caret"                           8257)
    ("caron"                           711)
    ("Cayleys"                         8493)
    ("ccaps"                           10829)
    ("Ccaron"                          268)
    ("ccaron"                          269)
    ("Ccedil"                          199)
    ("ccedil"                          231)
    ("Ccirc"                           264)
    ("ccirc"                           265)
    ("Cconint"                         8752)
    ("ccups"                           10828)
    ("ccupssm"                         10832)
    ("Cdot"                            266)
    ("cdot"                            267)
    ("cedil"                           184)
    ("Cedilla"                         184)
    ("cemptyv"                         10674)
    ("cent"                            162)
    ("centerdot"                       183)
    ("CenterDot"                       183)
    ("cfr"                             120096)
    ("Cfr"                             8493)
    ("CHcy"                            1063)
    ("chcy"                            1095)
    ("check"                           10003)
    ("checkmark"                       10003)
    ("Chi"                             935)
    ("chi"                             967)
    ("circ"                            710)
    ("circeq"                          8791)
    ("circlearrowleft"                 8634)
    ("circlearrowright"                8635)
    ("circledast"                      8859)
    ("circledcirc"                     8858)
    ("circleddash"                     8861)
    ("CircleDot"                       8857)
    ("circledR"                        174)
    ("circledS"                        9416)
    ("CircleMinus"                     8854)
    ("CirclePlus"                      8853)
    ("CircleTimes"                     8855)
    ("cir"                             9675)
    ("cirE"                            10691)
    ("cire"                            8791)
    ("cirfnint"                        10768)
    ("cirmid"                          10991)
    ("cirscir"                         10690)
    ("ClockwiseContourIntegral"        8754)
    ("CloseCurlyDoubleQuote"           8221)
    ("CloseCurlyQuote"                 8217)
    ("clubs"                           9827)
    ("clubsuit"                        9827)
    ("colon"                           58)
    ("Colon"                           8759)
    ("Colone"                          10868)
    ("colone"                          8788)
    ("coloneq"                         8788)
    ("comma"                           44)
    ("commat"                          64)
    ("comp"                            8705)
    ("compfn"                          8728)
    ("complement"                      8705)
    ("complexes"                       8450)
    ("cong"                            8773)
    ("congdot"                         10861)
    ("Congruent"                       8801)
    ("conint"                          8750)
    ("Conint"                          8751)
    ("ContourIntegral"                 8750)
    ("copf"                            120148)
    ("Copf"                            8450)
    ("coprod"                          8720)
    ("Coproduct"                       8720)
    ("copy"                            169)
    ("COPY"                            169)
    ("copysr"                          8471)
    ("CounterClockwiseContourIntegral" 8755)
    ("crarr"                           8629)
    ("cross"                           10007)
    ("Cross"                           10799)
    ("Cscr"                            119966)
    ("cscr"                            119992)
    ("csub"                            10959)
    ("csube"                           10961)
    ("csup"                            10960)
    ("csupe"                           10962)
    ("ctdot"                           8943)
    ("cudarrl"                         10552)
    ("cudarrr"                         10549)
    ("cuepr"                           8926)
    ("cuesc"                           8927)
    ("cularr"                          8630)
    ("cularrp"                         10557)
    ("cupbrcap"
+++ Garbage collection 1 (internal cons) after 11.28+0.00 seconds
At gc end about 16.0 Mbytes of 80.0 (20.0%) of heap is in use
                        10824)
    ("cupcap"                          10822)
    ("CupCap"                          8781)
    ("cup"                             8746)
    ("Cup"                             8915)
    ("cupcup"                          10826)
    ("cupdot"                          8845)
    ("cupor"                           10821)
 %  ("cups"                            8746, 65024)
    ("curarr"                          8631)
    ("curarrm"                         10556)
    ("curlyeqprec"                     8926)
    ("curlyeqsucc"                     8927)
    ("curlyvee"                        8910)
    ("curlywedge"                      8911)
    ("curren"                          164)
    ("curvearrowleft"                  8630)
    ("curvearrowright"                 8631)
    ("cuvee"                           8910)
    ("cuwed"                           8911)
    ("cwconint"                        8754)
    ("cwint"                           8753)
    ("cylcty"                          9005)
    ("dagger"                          8224)
    ("Dagger"                          8225)
    ("daleth"                          8504)
    ("darr"                            8595)
    ("Darr"                            8609)
    ("dArr"                            8659)
    ("dash"                            8208)
    ("Dashv"                           10980)
    ("dashv"                           8867)
    ("dbkarow"                         10511)
    ("dblac"                           733)
    ("Dcaron"                          270)
    ("dcaron"                          271)
    ("Dcy"                             1044)
    ("dcy"                             1076)
    ("ddagger"                         8225)
    ("ddarr"                           8650)
    ("DD"                              8517)
    ("dd"                              8518)
    ("DDotrahd"                        10513)
    ("ddotseq"                         10871)
    ("deg"                             176)
    ("Del"                             8711)
    ("Delta"                           916)
    ("delta"                           948)
    ("demptyv"                         10673)
    ("dfisht"                          10623)
    ("Dfr"                             120071)
    ("dfr"                             120097)
    ("dHar"                            10597)
    ("dharl"                           8643)
    ("dharr"                           8642)
    ("DiacriticalAcute"                180)
    ("DiacriticalDot"                  729)
    ("DiacriticalDoubleAcute"          733)
    ("DiacriticalGrave"                96)
    ("DiacriticalTilde"                732)
    ("diam"                            8900)
    ("diamond"                         8900)
    ("Diamond"                         8900)
    ("diamondsuit"                     9830)
    ("diams"                           9830)
    ("die"                             168)
    ("DifferentialD"                   8518)
    ("digamma"                         989)
    ("disin"                           8946)
    ("div"                             247)
    ("divide"                          247)
    ("divideontimes"                   8903)
    ("divonx"                          8903)
    ("DJcy"                            1026)
    ("djcy"                            1106)
    ("dlcorn"                          8990)
    ("dlcrop"                          8973)
    ("dollar"                          36)
    ("Dopf"                            120123)
    ("dopf"                            120149)
    ("Dot"                             168)
    ("dot"                             729)
    ("DotDot"                          8412)
    ("doteq"                           8784)
    ("doteqdot"                        8785)
    ("DotEqual"                        8784)
    ("dotminus"                        8760)
    ("dotplus"                         8724)
    ("dotsquare"                       8865)
    ("doublebarwedge"                  8966)
    ("DoubleContourIntegral"           8751)
    ("DoubleDot"                       168)
    ("DoubleDownArrow"                 8659)
    ("DoubleLeftArrow"                 8656)
    ("DoubleLeftRightArrow"            8660)
    ("DoubleLeftTee"                   10980)
    ("DoubleLongLeftArrow"             10232)
    ("DoubleLongLeftRightArrow"        10234)
    ("DoubleLongRightArrow"            10233)
    ("DoubleRightArrow"                8658)
    ("DoubleRightTee"                  8872)
    ("DoubleUpArrow"                   8657)
    ("DoubleUpDownArrow"               8661)
    ("DoubleVerticalBar"               8741)
    ("DownArrowBar"                    10515)
    ("downarrow"                       8595)
    ("DownArrow"                       8595)
    ("Downarrow"                       8659)
    ("DownArrowUpArrow"                8693)
    ("DownBreve"                       785)
    ("downdownarrows"                  8650)
    ("downharpoonleft"                 8643)
    ("downharpoonright"                8642)
    ("DownLeftRightVector"             10576)
    ("DownLeftTeeVector"               10590)
    ("DownLeftVectorBar"               10582)
    ("DownLeftVector"                  8637)
    ("DownRightTeeVector"              10591)
    ("DownRightVectorBar"              10583)
    ("DownRightVector"                 8641)
    ("DownTeeArrow"                    8615)
    ("DownTee"                         8868)
    ("drbkarow"                        10512)
    ("drcorn"                          8991)
    ("drcrop"                          8972)
    ("Dscr"                            119967)
    ("dscr"                            119993)
    ("DScy"                            1029)
    ("dscy"                            1109)
    ("dsol"                            10742)
    ("Dstrok"                          272)
    ("dstrok"                          273)
    ("dtdot"                           8945)
    ("dtri"                            9663)
    ("dtrif"                           9662)
    ("duarr"                           8693)
    ("duhar"                           10607)
    ("dwangle"                         10662)
    ("DZcy"                            1039)
    ("dzcy"                            1119)
    ("dzigrarr"                        10239)
    ("Eacute"                          201)
    ("eacute"                          233)
    ("easter"                          10862)
    ("Ecaron"                          282)
    ("ecaron"                          283)
    ("Ecirc"                           202)
    ("ecirc"                           234)
    ("ecir"                            8790)
    ("ecolon"                          8789)
    ("Ecy"                             1069)
    ("ecy"                             1101)
    ("eDDot"                           10871)
    ("Edot"                            278)
    ("edot"                            279)
    ("eDot"                            8785)
    ("ee"                              8519)
    ("efDot"                           8786)
    ("Efr"                             120072)
    ("efr"                             120098)
    ("eg"                              10906)
    ("Egrave"                          200)
    ("egrave"                          232)
    ("egs"                             10902)
    ("egsdot"                          10904)
    ("el"                              10905)
    ("Element"                         8712)
    ("elinters"                        9191)
    ("ell"                             8467)
    ("els"                             10901)
    ("elsdot"                          10903)
    ("Emacr"                           274)
    ("emacr"                           275)
    ("empty"                           8709)
    ("emptyset"                        8709)
    ("EmptySmallSquare"                9723)
    ("emptyv"                          8709)
    ("EmptyVerySmallSquare"            9643)
    ("emsp13"                          8196)
    ("emsp14"                          8197)
    ("emsp"                            8195)
    ("ENG"                             330)
    ("eng"                             331)
    ("ensp"                            8194)
    ("Eogon"                           280)
    ("eogon"                           281)
    ("Eopf"                            120124)
    ("eopf"                            120150)
    ("epar"                            8917)
    ("eparsl"                          10723)
    ("eplus"                           10865)
    ("epsi"                            949)
    ("Epsilon"                         917)
    ("epsilon"                         949)
    ("epsiv"                           1013)
    ("eqcirc"                          8790)
    ("eqcolon"                         8789)
    ("eqsim"                           8770)
    ("eqslantgtr"                      10902)
    ("eqslantless"                     10901)
    ("Equal"                           10869)
    ("equals"                          61)
    ("EqualTilde"                      8770)
    ("equest"                          8799)
    ("Equilibrium"                     8652)
    ("equiv"                           8801)
    ("equivDD"                         10872)
    ("eqvparsl"                        10725)
    ("erarr"                           10609)
    ("erDot"                           8787)
    ("escr"                            8495)
    ("Escr"                            8496)
    ("esdot"                           8784)
    ("Esim"                            10867)
    ("esim"                            8770)
    ("Eta"                             919)
    ("eta"                             951)
    ("ETH"                             208)
    ("eth"                             240)
    ("Euml"                            203)
    ("euml"                            235)
    ("euro"                            8364)
    ("excl"                            33)
    ("exist"                           8707)
    ("Exists"                          8707)
    ("expectation"                     8496)
    ("exponentiale"                    8519)
    ("ExponentialE"                    8519)
    ("fallingdotseq"                   8786)
    ("Fcy"                             1060)
    ("fcy"                             1092)
    ("female"                          9792)
    ("ffilig"                          64259)
    ("fflig"                           64256)
    ("ffllig"                          64260)
    ("Ffr"                             120073)
    ("ffr"                             120099)
    ("filig"                           64257)
    ("FilledSmallSquare"               9724)
    ("FilledVerySmallSquare"           9642)
 %  ("fjlig"                           102, 106)
    ("flat"                            9837)
    ("fllig"                           64258)
    ("fltns"                           9649)
    ("fnof"                            402)
    ("Fopf"                            120125)
    ("fopf"                            120151)
    ("forall"                          8704)
    ("ForAll"                          8704)
    ("fork"                            8916)
    ("forkv"                           10969)
    ("Fouriertrf"                      8497)
    ("fpartint"                        10765)
    ("frac12"                          189)
    ("frac13"                          8531)
    ("frac14"                          188)
    ("frac15"                          8533)
    ("frac16"                          8537)
    ("frac18"                          8539)
    ("frac23"                          8532)
    ("frac25"                          8534)
    ("frac34"                          190)
    ("frac35"                          8535)
    ("frac38"                          8540)
    ("frac45"                          8536)
    ("frac56"                          8538)
    ("frac58"                          8541)
    ("frac78"                          8542)
    ("frasl"                           8260)
    ("frown"                           8994)
    ("fscr"                            119995)
    ("Fscr"                            8497)
    ("gacute"                          501)
    ("Gamma"                           915)
    ("gamma"                           947)
    ("Gammad"                          988)
    ("gammad"                          989)
    ("gap"                             10886)
    ("Gbreve"                          286)
    ("gbreve"                          287)
    ("Gcedil"                          290)
    ("Gcirc"                           284)
    ("gcirc"                           285)
    ("Gcy"                             1043)
    ("gcy"                             1075)
    ("Gdot"                            288)
    ("gdot"                            289)
    ("ge"                              8805)
    ("gE"                              8807)
    ("gEl"                             10892)
    ("gel"                             8923)
    ("geq"                             8805)
    ("geqq"                            8807)
    ("geqslant"                        10878)
    ("gescc"                           10921)
    ("ges"                             10878)
    ("gesdot"                          10880)
    ("gesdoto"                         10882)
    ("gesdotol"                        10884)
 %  ("gesl"                            8923, 65024)
    ("gesles"                          10900)
    ("Gfr"                             120074)
    ("gfr"                             120100)
    ("gg"                              8811)
    ("Gg"                              8921)
    ("ggg"                             8921)
    ("gimel"                           8503)
    ("GJcy"                            1027)
    ("gjcy"                            1107)
    ("gla"                             10917)
    ("gl"                              8823)
    ("glE"                             10898)
    ("glj"                             10916)
    ("gnap"                            10890)
    ("gnapprox"                        10890)
    ("gne"                             10888)
    ("gnE"                             8809)
    ("gneq"                            10888)
    ("gneqq"                           8809)
    ("gnsim"                           8935)
    ("Gopf"                            120126)
    ("gopf"                            120152)
    ("grave"                           96)
    ("GreaterEqual"                    8805)
    ("GreaterEqualLess"                8923)
    ("GreaterFullEqual"                8807)
    ("GreaterGreater"                  10914)
    ("GreaterLess"                     8823)
    ("GreaterSlantEqual"               10878)
    ("GreaterTilde"                    8819)
    ("Gscr"                            119970)
    ("gscr"                            8458)
    ("gsim"                            8819)
    ("gsime"                           10894)
    ("gsiml"                           10896)
    ("gtcc"                            10919)
    ("gtcir"                           10874)
    ("gt"                              62)
    ("GT"                              62)
    ("Gt"                              8811)
    ("gtdot"                           8919)
    ("gtlPar"                          10645)
    ("gtquest"                         10876)
    ("gtrapprox"                       10886)
    ("gtrarr"                          10616)
    ("gtrdot"                          8919)
    ("gtreqless"                       8923)
    ("gtreqqless"                      10892)
    ("gtrless"                         8823)
    ("gtrsim"                          8819)
 %  ("gvertneqq"                       8809, 65024)
 %  ("gvnE"                            8809, 65024)
    ("Hacek"                           711)
    ("hairsp"                          8202)
    ("half"                            189)
    ("hamilt"                          8459)
    ("HARDcy"                          1066)
    ("hardcy"                          1098)
    ("harrcir"                         10568)
    ("harr"                            8596)
    ("hArr"                            8660)
    ("harrw"                           8621)
    ("hash"                            35)    % Added by ACN
    ("Hat"                             94)
    ("hbar"                            8463)
    ("Hcirc"                           292)
    ("hcirc"                           293)
    ("hearts"                          9829)
    ("heartsuit"                       9829)
    ("hellip"                          8230)
    ("hercon"                          8889)
    ("hfr"                             120101)
    ("Hfr"                             8460)
    ("HilbertSpace"                    8459)
    ("hksearow"                        10533)
    ("hkswarow"                        10534)
    ("hoarr"                           8703)
    ("homtht"                          8763)
    ("hookleftarrow"                   8617)
    ("hookrightarrow"                  8618)
    ("hopf"                            120153)
    ("Hopf"                            8461)
    ("horbar"                          8213)
    ("HorizontalLine"                  9472)
    ("hscr"                            119997)
    ("Hscr"                            8459)
    ("hslash"                          8463)
    ("Hstrok"                          294)
    ("hstrok"                          295)
    ("HumpDownHump"                    8782)
    ("HumpEqual"                       8783)
    ("hybull"                          8259)
    ("hyphen"                          8208)
    ("Iacute"                          205)
    ("iacute"                          237)
    ("ic"                              8291)
    ("Icirc"                           206)
    ("icirc"                           238)
    ("Icy"                             1048)
    ("icy"                             1080)
    ("Idot"                            304)
    ("IEcy"                            1045)
    ("iecy"                            1077)
    ("iexcl"                           161)
    ("iff"                             8660)
    ("ifr"                             120102)
    ("Ifr"                             8465)
    ("Igrave"                          204)
    ("igrave"                          236)
    ("ii"                              8520)
    ("iiiint"                          10764)
    ("iiint"                           8749)
    ("iinfin"                          10716)
    ("iiota"                           8489)
    ("IJlig"                           306)
    ("ijlig"                           307)
    ("Imacr"                           298)
    ("imacr"                           299)
    ("image"                           8465)
    ("ImaginaryI"                      8520)
    ("imagline"                        8464)
    ("imagpart"                        8465)
    ("imath"                           305)
    ("Im"                              8465)
    ("imof"                            8887)
    ("imped"                           437)
    ("Implies"                         8658)
    ("incare"                          8453)
    ("in"                              8712)
    ("infin"                           8734)
    ("infintie"                        10717)
    ("inodot"                          305)
    ("intcal"                          8890)
    ("int"                             8747)
    ("Int"                             8748)
    ("integers"                        8484)
    ("Integral"                        8747)
    ("intercal"                        8890)
    ("Intersection"                    8898)
    ("intlarhk"                        10775)
    ("intprod"                         10812)
    ("InvisibleComma"                  8291)
    ("InvisibleTimes"                  8290)
    ("IOcy"                            1025)
    ("iocy"                            1105)
    ("Iogon"                           302)
    ("iogon"                           303)
    ("Iopf"                            120128)
    ("iopf"                            120154)
    ("Iota"                            921)
    ("iota"                            953)
    ("iprod"                           10812)
    ("iquest"                          191)
    ("iscr"                            119998)
    ("Iscr"                            8464)
    ("isin"                            8712)
    ("isindot"                         8949)
    ("isinE"                           8953)
    ("isins"                           8948)
    ("isinsv"                          8947)
    ("isinv"                           8712)
    ("it"                              8290)
    ("Itilde"                          296)
    ("itilde"                          297)
    ("Iukcy"                           1030)
    ("iukcy"                           1110)
    ("Iuml"                            207)
    ("iuml"                            239)
    ("Jcirc"                           308)
    ("jcirc"                           309)
    ("Jcy"                             1049)
    ("jcy"                             1081)
    ("Jfr"                             120077)
    ("jfr"                             120103)
    ("jmath"                           567)
    ("Jopf"                            120129)
    ("jopf"                            120155)
    ("Jscr"                            119973)
    ("jscr"                            119999)
    ("Jsercy"                          1032)
    ("jsercy"                          1112)
    ("Jukcy"                           1028)
    ("jukcy"                           1108)
    ("Kappa"                           922)
    ("kappa"                           954)
    ("kappav"                          1008)
    ("Kcedil"                          310)
    ("kcedil"                          311)
    ("Kcy"                             1050)
    ("kcy"                             1082)
    ("Kfr"                             120078)
    ("kfr"                             120104)
    ("kgreen"                          312)
    ("KHcy"                            1061)
    ("khcy"                            1093)
    ("KJcy"                            1036)
    ("kjcy"                            1116)
    ("Kopf"                            120130)
    ("kopf"                            120156)
    ("Kscr"                            119974)
    ("kscr"                            120000)
    ("lAarr"                           8666)
    ("Lacute"                          313)
    ("lacute"                          314)
    ("laemptyv"                        10676)
    ("lagran"                          8466)
    ("Lambda"                          923)
    ("lambda"                          955)
    ("lang"                            10216)
    ("Lang"                            10218)
    ("langd"                           10641)
    ("langle"                          10216)
    ("lap"                             10885)
    ("Laplacetrf"                      8466)
    ("laquo"                           171)
    ("larrb"                           8676)
    ("larrbfs"                         10527)
    ("larr"                            8592)
    ("Larr"                            8606)
    ("lArr"                            8656)
    ("larrfs"                          10525)
    ("larrhk"                          8617)
    ("larrlp"                          8619)
    ("larrpl"                          10553)
    ("larrsim"                         10611)
    ("larrtl"                          8610)
    ("latail"                          10521)
    ("lAtail"                          10523)
    ("lat"                             10923)
    ("late"                            10925)
 %  ("lates"                           10925, 65024)
    ("lbarr"                           10508)
    ("lBarr"                           10510)
    ("lbbrk"                           10098)
    ("lbrace"                          123)
    ("lbrack"                          91)
    ("lbrke"                           10635)
    ("lbrksld"                         10639)
    ("lbrkslu"                         10637)
    ("Lcaron"                          317)
    ("lcaron"                          318)
    ("Lcedil"                          315)
    ("lcedil"                          316)
    ("lceil"                           8968)
    ("lcub"                            123)
    ("Lcy"                             1051)
    ("lcy"                             1083)
    ("ldca"                            10550)
    ("ldquo"                           8220)
    ("ldquor"                          8222)
    ("ldrdhar"                         10599)
    ("ldrushar"                        10571)
    ("ldsh"                            8626)
    ("le"                              8804)
    ("lE"                              8806)
    ("LeftAngleBracket"                10216)
    ("LeftArrowBar"                    8676)
    ("leftarrow"                       8592)
    ("LeftArrow"                       8592)
    ("Leftarrow"                       8656)
    ("LeftArrowRightArrow"             8646)
    ("leftarrowtail"                   8610)
    ("LeftCeiling"                     8968)
    ("LeftDoubleBracket"               10214)
    ("LeftDownTeeVector"               10593)
    ("LeftDownVectorBar"               10585)
    ("LeftDownVector"                  8643)
    ("LeftFloor"                       8970)
    ("leftharpoondown"                 8637)
    ("leftharpoonup"                   8636)
    ("leftleftarrows"                  8647)
    ("leftrightarrow"                  8596)
    ("LeftRightArrow"                  8596)
    ("Leftrightarrow"                  8660)
    ("leftrightarrows"                 8646)
    ("leftrightharpoons"               8651)
    ("leftrightsquigarrow"             8621)
    ("LeftRightVector"                 10574)
    ("LeftTeeArrow"                    8612)
    ("LeftTee"                         8867)
    ("LeftTeeVector"                   10586)
    ("leftthreetimes"                  8907)
    ("LeftTriangleBar"                 10703)
    ("LeftTriangle"                    8882)
    ("LeftTriangleEqual"               8884)
    ("LeftUpDownVector"                10577)
    ("LeftUpTeeVector"                 10592)
    ("LeftUpVectorBar"                 10584)
    ("LeftUpVector"                    8639)
    ("LeftVectorBar"                   10578)
    ("LeftVector"                      8636)
    ("lEg"                             10891)
    ("leg"                             8922)
    ("leq"                             8804)
    ("leqq"                            8806)
    ("leqslant"                        10877)
    ("lescc"                           10920)
    ("les"                             10877)
    ("lesdot"                          10879)
    ("lesdoto"                         10881)
    ("lesdotor"                        10883)
 %  ("lesg"                            8922, 65024)
    ("lesges"                          10899)
    ("lessapprox"                      10885)
    ("lessdot"                         8918)
    ("lesseqgtr"                       8922)
    ("lesseqqgtr"                      10891)
    ("LessEqualGreater"                8922)
    ("LessFullEqual"                   8806)
    ("LessGreater"                     8822)
    ("lessgtr"                         8822)
    ("LessLess"                        10913)
    ("lesssim"                         8818)
    ("LessSlantEqual"                  10877)
    ("LessTilde"                       8818)
    ("lfisht"                          10620)
    ("lfloor"                          8970)
    ("Lfr"                             120079)
    ("lfr"                             120105)
    ("lg"                              8822)
    ("lgE"                             10897)
    ("lHar"                            10594)
    ("lhard"                           8637)
    ("lharu"                           8636)
    ("lharul"                          10602)
    ("lhblk"                           9604)
    ("LJcy"                            1033)
    ("ljcy"                            1113)
    ("llarr"                           8647)
    ("ll"                              8810)
    ("Ll"                              8920)
    ("llcorner"                        8990)
    ("Lleftarrow"                      8666)
    ("llhard"                          10603)
    ("lltri"                           9722)
    ("Lmidot"                          319)
    ("lmidot"                          320)
    ("lmoustache"                      9136)
    ("lmoust"                          9136)
    ("lnap"                            10889)
    ("lnapprox"                        10889)
    ("lne"                             10887)
    ("lnE"                             8808)
    ("lneq"                            10887)
    ("lneqq"                           8808)
    ("lnsim"                           8934)
    ("loang"                           10220)
    ("loarr"                           8701)
    ("lobrk"                           10214)
    ("longleftarrow"                   10229)
    ("LongLeftArrow"                   10229)
    ("Longleftarrow"                   10232)
    ("longleftrightarrow"              10231)
    ("LongLeftRightArrow"              10231)
    ("Longleftrightarrow"              10234)
    ("longmapsto"                      10236)
    ("longrightarrow"                  10230)
    ("LongRightArrow"                  10230)
    ("Longrightarrow"                  10233)
    ("looparrowleft"                   8619)
    ("looparrowright"                  8620)
    ("lopar"                           10629)
    ("Lopf"                            120131)
    ("lopf"                            120157)
    ("loplus"                          10797)
    ("lotimes"                         10804)
    ("lowast"                          8727)
    ("lowbar"                          95)
    ("LowerLeftArrow"                  8601)
    ("LowerRightArrow"                 8600)
    ("loz"                             9674)
    ("lozenge"                         9674)
    ("lozf"                            10731)
    ("lpar"                            40)
    ("lparlt"                          10643)
    ("lrarr"                           8646)
    ("lrcorner"                        8991)
    ("lrhar"                           8651)
    ("lrhard"                          10605)
    ("lrm"                             8206)
    ("lrtri"                           8895)
    ("lsaquo"                          8249)
    ("lscr"                            120001)
    ("Lscr"                            8466)
    ("lsh"                             8624)
    ("Lsh"                             8624)
    ("lsim"                            8818)
    ("lsime"                           10893)
    ("lsimg"                           10895)
    ("lsqb"                            91)
    ("lsquo"                           8216)
    ("lsquor"                          8218)
    ("Lstrok"                          321)
    ("lstrok"                          322)
    ("ltcc"                            10918)
    ("ltcir"                           10873)
    ("lt"                              60)
    ("LT"                              60)
    ("Lt"                              8810)
    ("ltdot"                           8918)
    ("lthree"                          8907)
    ("ltimes"                          8905)
    ("ltlarr"                          10614)
    ("ltquest"                         10875)
    ("ltri"                            9667)
    ("ltrie"                           8884)
    ("ltrif"                           9666)
    ("ltrPar"                          10646)
    ("lurdshar"                        10570)
    ("luruhar"                         10598)
 %  ("lvertneqq"                       8808, 65024)
 %  ("lvnE"                            8808, 65024)
    ("macr"                            175)
    ("male"                            9794)
    ("malt"                            10016)
    ("maltese"                         10016)
    ("Map"                             10501)
    ("map"                             8614)
    ("mapsto"                          8614)
    ("mapstodown"                      8615)
    ("mapstoleft"                      8612)
    ("mapstoup"                        8613)
    ("marker"                          9646)
    ("mcomma"                          10793)
    ("Mcy"                             1052)
    ("mcy"                             1084)
    ("mdash"                           8212)
    ("mDDot"                           8762)
    ("measuredangle"                   8737)
    ("MediumSpace"                     8287)
    ("Mellintrf"                       8499)
    ("Mfr"                             120080)
    ("mfr"                             120106)
    ("mho"                             8487)
    ("micro"                           181)
    ("midast"                          42)
    ("midcir"                          10992)
    ("mid"                             8739)
    ("middot"                          183)
    ("minusb"                          8863)
    ("minus"                           8722)
    ("minusd"                          8760)
    ("minusdu"                         10794)
    ("MinusPlus"                       8723)
    ("mlcp"                            10971)
    ("mldr"                            8230)
    ("mnplus"                          8723)
    ("models"                          8871)
    ("Mopf"                            120132)
    ("mopf"                            120158)
    ("mp"                              8723)
    ("mscr"                            120002)
    ("Mscr"                            8499)
    ("mstpos"                          8766)
    ("Mu"                              924)
    ("mu"                              956)
    ("multimap"                        8888)
    ("mumap"                           8888)
    ("nabla"                           8711)
    ("Nacute"                          323)
    ("nacute"                          324)
 %  ("nang"                            8736, 8402)
    ("nap"                             8777)
 %  ("napE"                            10864, 824)
 %  ("napid"                           8779, 824)
    ("napos"                           329)
    ("napprox"                         8777)
    ("natural"                         9838)
    ("naturals"                        8469)
    ("natur"                           9838)
    ("nbsp"                            160)
 %  ("nbump"                           8782, 824)
 %  ("nbumpe"                          8783, 824)
    ("ncap"                            10819)
    ("Ncaron"                          327)
    ("ncaron"                          328)
    ("Ncedil"                          325)
    ("ncedil"                          326)
    ("ncong"                           8775)
 %  ("ncongdot"                        10861, 824)
    ("ncup"                            10818)
    ("Ncy"                             1053)
    ("ncy"                             1085)
    ("ndash"                           8211)
    ("nearhk"                          10532)
    ("nearr"                           8599)
    ("neArr"                           8663)
    ("nearrow"                         8599)
    ("ne"                              8800)
 %  ("nedot"                           8784, 824)
    ("NegativeMediumSpace"             8203)
    ("NegativeThickSpace"              8203)
    ("NegativeThinSpace"               8203)
    ("NegativeVeryThinSpace"           8203)
    ("nequiv"                          8802)
 %  ("nesear"                          10536)
    ("nesim"                           8770, 824)
    ("NestedGreaterGreater"            8811)
    ("NestedLessLess"                  8810)
    ("NewLine"                         10)
    ("nexist"                          8708)
    ("nexists"                         8708)
    ("Nfr"                             120081)
 %  ("nfr"                             120107)
    ("ngE"                             8807, 824)
    ("nge"                             8817)
    ("ngeq"                            8817)
 %  ("ngeqq"                           8807, 824)
 %  ("ngeqslant"                       10878, 824)
 %  ("nges"                            10878, 824)
 %  ("nGg"                             8921, 824)
    ("ngsim"                           8821)
 %  ("nGt"                             8811, 8402)
    ("ngt"                             8815)
    ("ngtr"                            8815)
 %  ("nGtv"                            8811, 824)
    ("nharr"                           8622)
    ("nhArr"                           8654)
    ("nhpar"                           10994)
    ("ni"                              8715)
    ("nis"                             8956)
    ("nisd"                            8954)
    ("niv"                             8715)
    ("NJcy"                            1034)
    ("njcy"                            1114)
    ("nlarr"                           8602)
    ("nlArr"                           8653)
 %  ("nldr"                            8229)
    ("nlE"                             8806, 824)
    ("nle"                             8816)
    ("nleftarrow"                      8602)
    ("nLeftarrow"                      8653)
    ("nleftrightarrow"                 8622)
    ("nLeftrightarrow"                 8654)
    ("nleq"                            8816)
 %  ("nleqq"                           8806, 824)
 %  ("nleqslant"                       10877, 824)
 %  ("nles"                            10877, 824)
    ("nless"                           8814)
 %  ("nLl"                             8920, 824)
    ("nlsim"                           8820)
 %  ("nLt"                             8810, 8402)
    ("nlt"                             8814)
    ("nltri"                           8938)
    ("nltrie"                          8940)
 %  ("nLtv"                            8810, 824)
    ("nmid"                            8740)
    ("NoBreak"                         8288)
    ("NonBreakingSpace"                160)
    ("nopf"                            120159)
    ("Nopf"                            8469)
    ("Not"                             10988)
    ("not"                             172)
    ("NotCongruent"                    8802)
    ("NotCupCap"                       8813)
    ("NotDoubleVerticalBar"            8742)
    ("NotElement"                      8713)
    ("NotEqual"                        8800)
 %  ("NotEqualTilde"                   8770, 824)
    ("NotExists"                       8708)
    ("NotGreater"                      8815)
    ("NotGreaterEqual"                 8817)
 %  ("NotGreaterFullEqual"             8807, 824)
 %  ("NotGreaterGreater"               8811, 824)
    ("NotGreaterLess"                  8825)
 %  ("NotGreaterSlantEqual"            10878, 824)
    ("NotGreaterTilde"                 8821)
 %  ("NotHumpDownHump"                 8782, 824)
 %  ("NotHumpEqual"                    8783, 824)
    ("notin"                           8713)
 %  ("notindot"                        8949, 824)
 %  ("notinE"                          8953, 824)
    ("notinva"                         8713)
    ("notinvb"                         8951)
    ("notinvc"                         8950)
 %  ("NotLeftTriangleBar"              10703, 824)
    ("NotLeftTriangle"                 8938)
    ("NotLeftTriangleEqual"            8940)
    ("NotLess"                         8814)
    ("NotLessEqual"                    8816)
    ("NotLessGreater"                  8824)
 %  ("NotLessLess"                     8810, 824)
 %  ("NotLessSlantEqual"               10877, 824)
    ("NotLessTilde"                    8820)
 %  ("NotNestedGreaterGreater"         10914, 824)
 %  ("NotNestedLessLess"               10913, 824)
    ("notni"                           8716)
    ("notniva"                         8716)
    ("notnivb"                         8958)
    ("notnivc"                         8957)
    ("NotPrecedes"                     8832)
 %  ("NotPrecedesEqual"                10927, 824)
    ("NotPrecedesSlantEqual"           8928)
    ("NotReverseElement"               8716)
 %  ("NotRightTriangleBar"             10704, 824)
    ("NotRightTriangle"                8939)
    ("NotRightTriangleEqual"           8941)
 %  ("NotSquareSubset"                 8847, 824)
    ("NotSquareSubsetEqual"            8930)
 %  ("NotSquareSuperset"               8848, 824)
    ("NotSquareSupersetEqual"          8931)
 %  ("NotSubset"                       8834, 8402)
    ("NotSubsetEqual"                  8840)
    ("NotSucceeds"                     8833)
 %  ("NotSucceedsEqual"                10928, 824)
    ("NotSucceedsSlantEqual"           8929)
 %  ("NotSucceedsTilde"                8831, 824)
 %  ("NotSuperset"                     8835, 8402)
    ("NotSupersetEqual"                8841)
    ("NotTilde"                        8769)
    ("NotTildeEqual"                   8772)
    ("NotTildeFullEqual"               8775)
    ("NotTildeTilde"                   8777)
    ("NotVerticalBar"                  8740)
    ("nparallel"                       8742)
    ("npar"                            8742)
 %  ("nparsl"                          11005, 8421)
 %  ("npart"                           8706, 824)
    ("npolint"                         10772)
    ("npr"                             8832)
    ("nprcue"                          8928)
    ("nprec"                           8832)
 %  ("npreceq"                         10927, 824)
 %  ("npre"                            10927, 824)
 %  ("nrarrc"                          10547, 824)
    ("nrarr"                           8603)
    ("nrArr"                           8655)
 %  ("nrarrw"                          8605, 824)
    ("nrightarrow"                     8603)
    ("nRightarrow"                     8655)
    ("nrtri"                           8939)
    ("nrtrie"                          8941)
    ("nsc"                             8833)
    ("nsccue"                          8929)
 %  ("nsce"                            10928, 824)
    ("Nscr"                            119977)
    ("nscr"                            120003)
    ("nshortmid"                       8740)
    ("nshortparallel"                  8742)
    ("nsim"                            8769)
    ("nsime"                           8772)
    ("nsimeq"                          8772)
    ("nsmid"                           8740)
    ("nspar"                           8742)
    ("nsqsube"                         8930)
    ("nsqsupe"                         8931)
    ("nsub"                            8836)
 %  ("nsubE"                           10949, 824)
    ("nsube"                           8840)
 %  ("nsubset"                         8834, 8402)
    ("nsubseteq"                       8840)
 %  ("nsubseteqq"                      10949, 824)
    ("nsucc"                           8833)
 %  ("nsucceq"                         10928, 824)
    ("nsup"                            8837)
 %  ("nsupE"                           10950, 824)
    ("nsupe"                           8841)
 %  ("nsupset"                         8835, 8402)
    ("nsupseteq"                       8841)
 %  ("nsupseteqq"                      10950, 824)
    ("ntgl"                            8825)
    ("Ntilde"                          209)
    ("ntilde"                          241)
    ("ntlg"                            8824)
    ("ntriangleleft"                   8938)
    ("ntrianglelefteq"                 8940)
    ("ntriangleright"                  8939)
    ("ntrianglerighteq"                8941)
    ("Nu"                              925)
    ("nu"                              957)
    ("num"                             35)
    ("numero"                          8470)
    ("numsp"                           8199)
 %  ("nvap"                            8781, 8402)
    ("nvdash"                          8876)
    ("nvDash"                          8877)
    ("nVdash"                          8878)
    ("nVDash"                          8879)
 %  ("nvge"                            8805, 8402)
 %  ("nvgt"                            62, 8402)
    ("nvHarr"                          10500)
    ("nvinfin"                         10718)
    ("nvlArr"                          10498)
 %  ("nvle"                            8804, 8402)
 %  ("nvlt"                            60, 8402)
 %  ("nvltrie"                         8884, 8402)
    ("nvrArr"                          10499)
 %  ("nvrtrie"                         8885, 8402)
 %  ("nvsim"                           8764, 8402)
    ("nwarhk"                          10531)
    ("nwarr"                           8598)
    ("nwArr"                           8662)
    ("nwarrow"                         8598)
    ("nwnear"                          10535)
    ("Oacute"                          211)
    ("oacute"                          243)
    ("oast"                            8859)
    ("Ocirc"                           212)
    ("ocirc"                           244)
    ("ocir"                            8858)
    ("Ocy"                             1054)
    ("ocy"                             1086)
    ("odash"                           8861)
    ("Odblac"                          336)
    ("odblac"                          337)
    ("odiv"                            10808)
    ("odot"                            8857)
    ("odsold"                          10684)
    ("OElig"                           338)
    ("oelig"                           339)
    ("ofcir"                           10687)
    ("Ofr"                             120082)
    ("ofr"                             120108)
    ("ogon"                            731)
    ("Ograve"                          210)
    ("ograve"                          242)
    ("ogt"                             10689)
    ("ohbar"                           10677)
    ("ohm"                             937)
    ("oint"                            8750)
    ("olarr"                           8634)
    ("olcir"                           10686)
    ("olcross"                         10683)
    ("oline"                           8254)
    ("olt"                             10688)
    ("Omacr"                           332)
    ("omacr"                           333)
    ("Omega"                           937)
    ("omega"                           969)
    ("Omicron"                         927)
    ("omicron"                         959)
    ("omid"                            10678)
    ("ominus"                          8854)
    ("Oopf"                            120134)
    ("oopf"                            120160)
    ("opar"                            10679)
    ("OpenCurlyDoubleQuote"            8220)
    ("OpenCurlyQuote"                  8216)
    ("operp"                           10681)
    ("oplus"                           8853)
    ("orarr"                           8635)
    ("Or"                              10836)
    ("or"                              8744)
    ("ord"                             10845)
    ("order"                           8500)
    ("orderof"                         8500)
    ("ordf"                            170)
    ("ordm"                            186)
    ("origof"                          8886)
    ("oror"                            10838)
    ("orslope"                         10839)
    ("orv"                             10843)
    ("oS"                              9416)
    ("Oscr"                            119978)
    ("oscr"                            8500)
    ("Oslash"                          216)
    ("oslash"                          248)
    ("osol"                            8856)
    ("Otilde"                          213)
    ("otilde"                          245)
    ("otimesas"                        10806)
    ("Otimes"                          10807)
    ("otimes"                          8855)
    ("Ouml"                            214)
    ("ouml"                            246)
    ("ovbar"                           9021)
    ("OverBar"                         8254)
    ("OverBrace"                       9182)
    ("OverBracket"                     9140)
    ("OverParenthesis"                 9180)
    ("para"                            182)
    ("parallel"                        8741)
    ("par"                             8741)
    ("parsim"                          10995)
    ("parsl"                           11005)
    ("part"                            8706)
    ("PartialD"                        8706)
    ("Pcy"                             1055)
    ("pcy"                             1087)
    ("percnt"                          37)
    ("period"                          46)
    ("permil"                          8240)
    ("perp"                            8869)
    ("pertenk"                         8241)
    ("Pfr"                             120083)
    ("pfr"                             120109)
    ("Phi"                             934)
    ("phi"                             966)
    ("phiv"                            981)
    ("phmmat"                          8499)
    ("phone"                           9742)
    ("Pi"                              928)
    ("pi"                              960)
    ("pitchfork"                       8916)
    ("piv"                             982)
    ("planck"                          8463)
    ("planckh"                         8462)
    ("plankv"                          8463)
    ("plusacir"                        10787)
    ("plusb"                           8862)
    ("pluscir"                         10786)
    ("plus"                            43)
    ("plusdo"                          8724)
    ("plusdu"                          10789)
    ("pluse"                           10866)
    ("PlusMinus"                       177)
    ("plusmn"                          177)
    ("plussim"                         10790)
    ("plustwo"                         10791)
    ("pm"                              177)
    ("Poincareplane"                   8460)
    ("pointint"                        10773)
    ("popf"                            120161)
    ("Popf"                            8473)
    ("pound"                           163)
    ("prap"                            10935)
    ("Pr"                              10939)
    ("pr"                              8826)
    ("prcue"                           8828)
    ("precapprox"                      10935)
    ("prec"                            8826)
    ("preccurlyeq"                     8828)
    ("Precedes"                        8826)
    ("PrecedesEqual"                   10927)
    ("PrecedesSlantEqual"              8828)
    ("PrecedesTilde"                   8830)
    ("preceq"                          10927)
    ("precnapprox"                     10937)
    ("precneqq"                        10933)
    ("precnsim"                        8936)
    ("pre"                             10927)
    ("prE"                             10931)
    ("precsim"                         8830)
    ("prime"                           8242)
    ("Prime"                           8243)
    ("primes"                          8473)
    ("prnap"                           10937)
    ("prnE"                            10933)
    ("prnsim"                          8936)
    ("prod"                            8719)
    ("Product"                         8719)
    ("profalar"                        9006)
    ("profline"                        8978)
    ("profsurf"                        8979)
    ("prop"                            8733)
    ("Proportional"                    8733)
    ("Proportion"                      8759)
    ("propto"                          8733)
    ("prsim"                           8830)
    ("prurel"                          8880)
    ("Pscr"                            119979)
    ("pscr"                            120005)
    ("Psi"                             936)
    ("psi"                             968)
    ("puncsp"                          8200)
    ("Qfr"                             120084)
    ("qfr"                             120110)
    ("qint"                            10764)
    ("qopf"                            120162)
    ("Qopf"                            8474)
    ("qprime"                          8279)
    ("Qscr"                            119980)
    ("qscr"                            120006)
    ("quaternions"                     8461)
    ("quatint"                         10774)
    ("quest"                           63)
    ("questeq"                         8799)
    ("quot"                            34)
    ("QUOT"                            34)
    ("rAarr"                           8667)
 %  ("race"                            8765, 817)
    ("Racute"                          340)
    ("racute"                          341)
    ("radic"                           8730)
    ("raemptyv"                        10675)
    ("rang"                            10217)
    ("Rang"                            10219)
    ("rangd"                           10642)
    ("range"                           10661)
    ("rangle"                          10217)
    ("raquo"                           187)
    ("rarrap"                          10613)
    ("rarrb"                           8677)
    ("rarrbfs"                         10528)
    ("rarrc"                           10547)
    ("rarr"                            8594)
    ("Rarr"                            8608)
    ("rArr"                            8658)
    ("rarrfs"                          10526)
    ("rarrhk"                          8618)
    ("rarrlp"                          8620)
    ("rarrpl"                          10565)
    ("rarrsim"                         10612)
    ("Rarrtl"                          10518)
    ("rarrtl"                          8611)
    ("rarrw"                           8605)
    ("ratail"                          10522)
    ("rAtail"                          10524)
    ("ratio"                           8758)
    ("rationals"                       8474)
    ("rbarr"                           10509)
    ("rBarr"                           10511)
    ("RBarr"                           10512)
    ("rbbrk"                           10099)
    ("rbrace"                          125)
    ("rbrack"                          93)
    ("rbrke"                           10636)
    ("rbrksld"                         10638)
    ("rbrkslu"                         10640)
    ("Rcaron"                          344)
    ("rcaron"                          345)
    ("Rcedil"                          342)
    ("rcedil"                          343)
    ("rceil"                           8969)
    ("rcub"                            125)
    ("Rcy"                             1056)
    ("rcy"                             1088)
    ("rdca"                            10551)
    ("rdldhar"                         10601)
    ("rdquo"                           8221)
    ("rdquor"                          8221)
    ("rdsh"                            8627)
    ("real"                            8476)
    ("realine"                         8475)
    ("realpart"                        8476)
    ("reals"                           8477)
    ("Re"                              8476)
    ("rect"                            9645)
    ("reg"                             174)
    ("REG"                             174)
    ("ReverseElement"                  8715)
    ("ReverseEquilibrium"              8651)
    ("ReverseUpEquilibrium"            10607)
    ("rfisht"                          10621)
    ("rfloor"                          8971)
    ("rfr"                             120111)
    ("Rfr"                             8476)
    ("rHar"                            10596)
    ("rhard"                           8641)
    ("rharu"                           8640)
    ("rharul"                          10604)
    ("Rho"                             929)
    ("rho"                             961)
    ("rhov"                            1009)
    ("RightAngleBracket"               10217)
    ("RightArrowBar"                   8677)
    ("rightarrow"                      8594)
    ("RightArrow"                      8594)
    ("Rightarrow"                      8658)
    ("RightArrowLeftArrow"             8644)
    ("rightarrowtail"                  8611)
    ("RightCeiling"                    8969)
    ("RightDoubleBracket"              10215)
    ("RightDownTeeVector"              10589)
    ("RightDownVectorBar"              10581)
    ("RightDownVector"                 8642)
    ("RightFloor"                      8971)
    ("rightharpoondown"                8641)
    ("rightharpoonup"                  8640)
    ("rightleftarrows"                 8644)
    ("rightleftharpoons"               8652)
    ("rightrightarrows"                8649)
    ("rightsquigarrow"                 8605)
    ("RightTeeArrow"                   8614)
    ("RightTee"                        8866)
    ("RightTeeVector"                  10587)
    ("rightthreetimes"                 8908)
    ("RightTriangleBar"                10704)
    ("RightTriangle"                   8883)
    ("RightTriangleEqual"              8885)
    ("RightUpDownVector"               10575)
    ("RightUpTeeVector"                10588)
    ("RightUpVectorBar"                10580)
    ("RightUpVector"                   8638)
    ("RightVectorBar"                  10579)
    ("RightVector"                     8640)
    ("ring"                            730)
    ("risingdotseq"                    8787)
    ("rlarr"                           8644)
    ("rlhar"                           8652)
    ("rlm"                             8207)
    ("rmoustache"                      9137)
    ("rmoust"                          9137)
    ("rnmid"                           10990)
    ("roang"                           10221)
    ("roarr"                           8702)
    ("robrk"                           10215)
    ("ropar"                           10630)
    ("ropf"                            120163)
    ("Ropf"                            8477)
    ("roplus"                          10798)
    ("rotimes"                         10805)
    ("RoundImplies"                    10608)
    ("rpar"                            41)
    ("rpargt"                          10644)
    ("rppolint"                        10770)
    ("rrarr"                           8649)
    ("Rrightarrow"                     8667)
    ("rsaquo"                          8250)
    ("rscr"                            120007)
    ("Rscr"                            8475)
    ("rsh"                             8625)
    ("Rsh"                             8625)
    ("rsqb"                            93)
    ("rsquo"                           8217)
    ("rsquor"                          8217)
    ("rthree"                          8908)
    ("rtimes"                          8906)
    ("rtri"                            9657)
    ("rtrie"                           8885)
    ("rtrif"                           9656)
    ("rtriltri"                        10702)
    ("RuleDelayed"                     10740)
    ("ruluhar"                         10600)
    ("rx"                              8478)
    ("Sacute"                          346)
    ("sacute"                          347)
    ("sbquo"                           8218)
    ("scap"                            10936)
    ("Scaron"                          352)
    ("scaron"                          353)
    ("Sc"                              10940)
    ("sc"                              8827)
    ("sccue"                           8829)
    ("sce"                             10928)
    ("scE"                             10932)
    ("Scedil"                          350)
    ("scedil"                          351)
    ("Scirc"                           348)
    ("scirc"                           349)
    ("scnap"                           10938)
    ("scnE"                            10934)
    ("scnsim"                          8937)
    ("scpolint"                        10771)
    ("scsim"                           8831)
    ("Scy"                             1057)
    ("scy"                             1089)
    ("sdotb"                           8865)
    ("sdot"                            8901)
    ("sdote"                           10854)
    ("searhk"                          10533)
    ("searr"                           8600)
    ("seArr"                           8664)
    ("searrow"                         8600)
    ("sect"                            167)
    ("semi"                            59)
    ("seswar"                          10537)
    ("setminus"                        8726)
    ("setmn"                           8726)
    ("sext"                            10038)
    ("Sfr"                             120086)
    ("sfr"                             120112)
    ("sfrown"                          8994)
    ("sharp"                           9839)
    ("SHCHcy"                          1065)
    ("shchcy"                          1097)
    ("SHcy"                            1064)
    ("shcy"                            1096)
    ("ShortDownArrow"                  8595)
    ("ShortLeftArrow"                  8592)
    ("shortmid"                        8739)
    ("shortparallel"                   8741)
    ("ShortRightArrow"                 8594)
    ("ShortUpArrow"                    8593)
    ("shy"                             173)
    ("Sigma"                           931)
    ("sigma"                           963)
    ("sigmaf"                          962)
    ("sigmav"                          962)
    ("sim"                             8764)
    ("simdot"                          10858)
    ("sime"                            8771)
    ("simeq"                           8771)
    ("simg"                            10910)
    ("simgE"                           10912)
    ("siml"                            10909)
    ("simlE"                           10911)
    ("simne"                           8774)
    ("simplus"                         10788)
    ("simrarr"                         10610)
    ("slarr"                           8592)
    ("SmallCircle"                     8728)
    ("smallsetminus"                   8726)
    ("smashp"                          10803)
    ("smeparsl"                        10724)
    ("smid"                            8739)
    ("smile"                           8995)
    ("smt"                             10922)
    ("smte"                            10924)
 %  ("smtes"                           10924, 65024)
    ("SOFTcy"                          1068)
    ("softcy"                          1100)
    ("solbar"                          9023)
    ("solb"                            10692)
    ("sol"                             47)
    ("Sopf"                            120138)
    ("sopf"                            120164)
    ("spades"                          9824)
    ("spadesuit"                       9824)
    ("spar"                            8741)
    ("sqcap"                           8851)
 %  ("sqcaps"                          8851, 65024)
    ("sqcup"                           8852)
 %  ("sqcups"                          8852, 65024)
    ("Sqrt"                            8730)
    ("sqsub"                           8847)
    ("sqsube"                          8849)
    ("sqsubset"                        8847)
    ("sqsubseteq"                      8849)
    ("sqsup"                           8848)
    ("sqsupe"                          8850)
    ("sqsupset"                        8848)
    ("sqsupseteq"                      8850)
    ("square"                          9633)
    ("Square"                          9633)
    ("SquareIntersection"              8851)
    ("SquareSubset"                    8847)
    ("SquareSubsetEqual"               8849)
    ("SquareSuperset"                  8848)
    ("SquareSupersetEqual"             8850)
    ("SquareUnion"                     8852)
    ("squarf"                          9642)
    ("squ"                             9633)
    ("squf"                            9642)
    ("srarr"                           8594)
    ("Sscr"                            119982)
    ("sscr"                            120008)
    ("ssetmn"                          8726)
    ("ssmile"                          8995)
    ("sstarf"                          8902)
    ("Star"                            8902)
    ("star"                            9734)
    ("starf"                           9733)
    ("straightepsilon"                 1013)
    ("straightphi"                     981)
    ("strns"                           175)
    ("sub"                             8834)
    ("Sub"                             8912)
    ("subdot"                          10941)
    ("subE"                            10949)
    ("sube"                            8838)
    ("subedot"                         10947)
    ("submult"                         10945)
    ("subnE"                           10955)
    ("subne"                           8842)
    ("subplus"                         10943)
    ("subrarr"                         10617)
    ("subset"                          8834)
    ("Subset"                          8912)
    ("subseteq"                        8838)
    ("subseteqq"                       10949)
    ("SubsetEqual"                     8838)
    ("subsetneq"                       8842)
    ("subsetneqq"                      10955)
    ("subsim"                          10951)
    ("subsub"                          10965)
    ("subsup"                          10963)
    ("succapprox"                      10936)
    ("succ"                            8827)
    ("succcurlyeq"                     8829)
    ("Succeeds"                        8827)
    ("SucceedsEqual"                   10928)
    ("SucceedsSlantEqual"              8829)
    ("SucceedsTilde"                   8831)
    ("succeq"                          10928)
    ("succnapprox"                     10938)
    ("succneqq"                        10934)
    ("succnsim"                        8937)
    ("succsim"                         8831)
    ("SuchThat"                        8715)
    ("sum"                             8721)
    ("Sum"                             8721)
    ("sung"                            9834)
    ("sup1"                            185)
    ("sup2"                            178)
    ("sup3"                            179)
    ("sup"                             8835)
    ("Sup"                             8913)
    ("supdot"                          10942)
    ("supdsub"                         10968)
    ("supE"                            10950)
    ("supe"                            8839)
    ("supedot"                         10948)
    ("Superset"                        8835)
    ("SupersetEqual"                   8839)
    ("suphsol"                         10185)
    ("suphsub"                         10967)
    ("suplarr"                         10619)
    ("supmult"                         10946)
    ("supnE"                           10956)
    ("supne"                           8843)
    ("supplus"                         10944)
    ("supset"                          8835)
    ("Supset"                          8913)
    ("supseteq"                        8839)
    ("supseteqq"                       10950)
    ("supsetneq"                       8843)
    ("supsetneqq"                      10956)
    ("supsim"                          10952)
    ("supsub"                          10964)
    ("supsup"                          10966)
    ("swarhk"                          10534)
    ("swarr"                           8601)
    ("swArr"                           8665)
    ("swarrow"                         8601)
    ("swnwar"                          10538)
    ("szlig"                           223)
    ("Tab"                             9)
    ("target"                          8982)
    ("Tau"                             932)
    ("tau"                             964)
    ("tbrk"                            9140)
    ("Tcaron"                          356)
    ("tcaron"                          357)
    ("Tcedil"                          354)
    ("tcedil"                          355)
    ("Tcy"                             1058)
    ("tcy"                             1090)
    ("tdot"                            8411)
    ("telrec"                          8981)
    ("Tfr"                             120087)
    ("tfr"                             120113)
    ("there4"                          8756)
    ("therefore"                       8756)
    ("Therefore"                       8756)
    ("Theta"                           920)
    ("theta"                           952)
    ("thetasym"                        977)
    ("thetav"                          977)
    ("thickapprox"                     8776)
    ("thicksim"                        8764)
 %  ("ThickSpace"                      8287, 8202)
    ("ThinSpace"                       8201)
    ("thinsp"                          8201)
    ("thkap"                           8776)
    ("thksim"                          8764)
    ("THORN"                           222)
    ("thorn"                           254)
    ("tilde"                           732)
    ("Tilde"                           8764)
    ("TildeEqual"                      8771)
    ("TildeFullEqual"                  8773)
    ("TildeTilde"                      8776)
    ("timesbar"                        10801)
    ("timesb"                          8864)
    ("times"                           215)
    ("timesd"                          10800)
    ("tint"                            8749)
    ("toea"                            10536)
    ("topbot"                          9014)
    ("topcir"                          10993)
    ("top"                             8868)
    ("Topf"                            120139)
    ("topf"                            120165)
    ("topfork"                         10970)
    ("tosa"                            10537)
    ("tprime"                          8244)
    ("trade"                           8482)
    ("TRADE"                           8482)
    ("triangle"                        9653)
    ("triangledown"                    9663)
    ("triangleleft"                    9667)
    ("trianglelefteq"                  8884)
    ("triangleq"                       8796)
    ("triangleright"                   9657)
    ("trianglerighteq"                 8885)
    ("tridot"                          9708)
    ("trie"                            8796)
    ("triminus"                        10810)
    ("TripleDot"                       8411)
    ("triplus"                         10809)
    ("trisb"                           10701)
    ("tritime"                         10811)
    ("trpezium"                        9186)
    ("Tscr"                            119983)
    ("tscr"                            120009)
    ("TScy"                            1062)
    ("tscy"                            1094)
    ("TSHcy"                           1035)
    ("tshcy"                           1115)
    ("Tstrok"                          358)
    ("tstrok"                          359)
    ("twixt"                           8812)
    ("twoheadleftarrow"                8606)
    ("twoheadrightarrow"               8608)
    ("Uacute"                          218)
    ("uacute"                          250)
    ("uarr"                            8593)
    ("Uarr"                            8607)
    ("uArr"                            8657)
    ("Uarrocir"                        10569)
    ("Ubrcy"                           1038)
    ("ubrcy"                           1118)
    ("Ubreve"                          364)
    ("ubreve"                          365)
    ("Ucirc"                           219)
    ("ucirc"                           251)
    ("Ucy"                             1059)
    ("ucy"                             1091)
    ("udarr"                           8645)
    ("Udblac"                          368)
    ("udblac"                          369)
    ("udhar"                           10606)
    ("ufisht"                          10622)
    ("Ufr"                             120088)
    ("ufr"                             120114)
    ("Ugrave"                          217)
    ("ugrave"                          249)
    ("uHar"                            10595)
    ("uharl"                           8639)
    ("uharr"                           8638)
    ("uhblk"                           9600)
    ("ulcorn"                          8988)
    ("ulcorner"                        8988)
    ("ulcrop"                          8975)
    ("ultri"                           9720)
    ("Umacr"                           362)
    ("umacr"                           363)
    ("uml"                             168)
    ("UnderBar"                        95)
    ("UnderBrace"                      9183)
    ("UnderBracket"                    9141)
    ("UnderParenthesis"                9181)
    ("Union"                           8899)
    ("UnionPlus"                       8846)
    ("Uogon"                           370)
    ("uogon"                           371)
    ("Uopf"                            120140)
    ("uopf"                            120166)
    ("UpArrowBar"                      10514)
    ("uparrow"                         8593)
    ("UpArrow"                         8593)
    ("Uparrow"                         8657)
    ("UpArrowDownArrow"                8645)
    ("updownarrow"                     8597)
    ("UpDownArrow"                     8597)
    ("Updownarrow"                     8661)
    ("UpEquilibrium"                   10606)
    ("upharpoonleft"                   8639)
    ("upharpoonright"                  8638)
    ("uplus"                           8846)
    ("UpperLeftArrow"                  8598)
    ("UpperRightArrow"                 8599)
    ("upsi"                            965)
    ("Upsi"                            978)
    ("upsih"                           978)
    ("Upsilon"                         933)
    ("upsilon"                         965)
    ("UpTeeArrow"                      8613)
    ("UpTee"                           8869)
    ("upuparrows"                      8648)
    ("urcorn"                          8989)
    ("urcorner"                        8989)
    ("urcrop"                          8974)
    ("Uring"                           366)
    ("uring"                           367)
    ("urtri"                           9721)
    ("Uscr"                            119984)
    ("uscr"                            120010)
    ("utdot"                           8944)
    ("Utilde"                          360)
    ("utilde"                          361)
    ("utri"                            9653)
    ("utrif"                           9652)
    ("uuarr"                           8648)
    ("Uuml"                            220)
    ("uuml"                            252)
    ("uwangle"                         10663)
    ("vangrt"                          10652)
    ("varepsilon"                      1013)
    ("varkappa"                        1008)
    ("varnothing"                      8709)
    ("varphi"                          981)
    ("varpi"                           982)
    ("varpropto"                       8733)
    ("varr"                            8597)
    ("vArr"                            8661)
    ("varrho"                          1009)
    ("varsigma"                        962)
 %  ("varsubsetneq"                    8842, 65024)
 %  ("varsubsetneqq"                   10955, 65024)
 %  ("varsupsetneq"                    8843, 65024)
 %  ("varsupsetneqq"                   10956, 65024)
    ("vartheta"                        977)
    ("vartriangleleft"                 8882)
    ("vartriangleright"                8883)
    ("vBar"                            10984)
    ("Vbar"                            10987)
    ("vBarv"                           10985)
    ("Vcy"                             1042)
    ("vcy"                             1074)
    ("vdash"                           8866)
    ("vDash"                           8872)
    ("Vdash"                           8873)
    ("VDash"                           8875)
    ("Vdashl"                          10982)
    ("veebar"                          8891)
    ("vee"                             8744)
    ("Vee"                             8897)
    ("veeeq"                           8794)
    ("vellip"                          8942)
    ("verbar"                          124)
    ("Verbar"                          8214)
    ("vert"                            124)
    ("Vert"                            8214)
    ("VerticalBar"                     8739)
    ("VerticalLine"                    124)
    ("VerticalSeparator"               10072)
    ("VerticalTilde"                   8768)
    ("VeryThinSpace"                   8202)
    ("Vfr"                             120089)
    ("vfr"                             120115)
    ("vltri"                           8882)
 %  ("vnsub"                           8834, 8402)
 %  ("vnsup"                           8835, 8402)
    ("Vopf"                            120141)
    ("vopf"                            120167)
    ("vprop"                           8733)
    ("vrtri"                           8883)
    ("Vscr"                            119985)
    ("vscr"                            120011)
 %  ("vsubnE"                          10955, 65024)
 %  ("vsubne"                          8842, 65024)
 %  ("vsupnE"                          10956, 65024)
 %  ("vsupne"                          8843, 65024)
    ("Vvdash"                          8874)
    ("vzigzag"                         10650)
    ("Wcirc"                           372)
    ("wcirc"                           373)
    ("wedbar"                          10847)
    ("wedge"                           8743)
    ("Wedge"                           8896)
    ("wedgeq"                          8793)
    ("weierp"                          8472)
    ("Wfr"                             120090)
    ("wfr"                             120116)
    ("Wopf"                            120142)
    ("wopf"                            120168)
    ("wp"                              8472)
    ("wr"                              8768)
    ("wreath"                          8768)
    ("Wscr"                            119986)
    ("wscr"                            120012)
    ("xcap"                            8898)
    ("xcirc"                           9711)
    ("xcup"                            8899)
    ("xdtri"                           9661)
    ("Xfr"                             120091)
    ("xfr"                             120117)
    ("xharr"                           10231)
    ("xhArr"                           10234)
    ("Xi"                              926)
    ("xi"                              958)
    ("xlarr"                           10229)
    ("xlArr"                           10232)
    ("xmap"                            10236)
    ("xnis"                            8955)
    ("xodot"                           10752)
    ("Xopf"                            120143)
    ("xopf"                            120169)
    ("xoplus"                          10753)
    ("xotime"                          10754)
    ("xrarr"                           10230)
    ("xrArr"                           10233)
    ("Xscr"                            119987)
    ("xscr"                            120013)
    ("xsqcup"                          10758)
    ("xuplus"                          10756)
    ("xutri"                           9651)
    ("xvee"                            8897)
    ("xwedge"                          8896)
    ("Yacute"                          221)
    ("yacute"                          253)
    ("YAcy"                            1071)
    ("yacy"                            1103)
    ("Ycirc"                           374)
    ("ycirc"                           375)
    ("Ycy"                             1067)
    ("ycy"                             1099)
    ("yen"                             165)
    ("Yfr"                             120092)
    ("yfr"                             120118)
    ("YIcy"                            1031)
    ("yicy"                            1111)
    ("Yopf"                            120144)
    ("yopf"                            120170)
    ("Yscr"                            119988)
    ("yscr"                            120014)
    ("YUcy"                            1070)
    ("yucy"                            1102)
    ("yuml"                            255)
    ("Yuml"                            376)
    ("Zacute"                          377)
    ("zacute"                          378)
    ("Zcaron"                          381)
    ("zcaron"                          382)
    ("Zcy"                             1047)
    ("zcy"                             1079)
    ("Zdot"                            379)
    ("zdot"                            380)
    ("zeetrf"                          8488)
    ("ZeroWidthSpace"                  8203)
    ("Zeta"                            918)
    ("zeta"                            950)
    ("zfr"                             120119)
    ("Zfr"                             8488)
    ("ZHcy"                            1046)
    ("zhcy"                            1078)
    ("zigrarr"                         8669)
    ("zopf"                            120171)
    ("Zopf"                            8484)
    ("Zscr"                            119989)
    ("zscr"                            120015)
    ("zwj"                             8205)
    ("zwnj"                            8204)
  ) do put(intern car x, 'unicode_character, cadr x);nil


endmodule;nil

end;nilmodule rprintf;nil % formatted printing

% Note that I must not call this just "printf" because PSL has that as
% an existing module name.

% Author: Arthur Norman.

% Copyright (c) 2016 Arthur Norman.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%

% I will support bldmsg by having versions of the print primitives that
% dump characters in a list...

fluid '(bldmsg_chars!* !*ll!*);nil
bldmsg_chars!* := nil;nil

symbolic procedure p_princ(u, blankfirst);
  begin
    scalar w;
% With CSL if u is a string or a symbol with a print representation that
% contains characters outside the Basic Latin unicode block then the
% list w will contain a single item for each wide character. If you try the
% same in PSL then you may or may not survive...
    w := explode2 u;
    if bldmsg_chars!* then <<
      if blankfirst then bldmsg_chars!* := '!  . bldmsg_chars!*;
      for each c in w do bldmsg_chars!* := c . bldmsg_chars!* >>
    else <<
      if blankfirst then <<
         if posn() + length w  + 1 > !*ll!* then terpri();
         prin2 " " >>
      else if posn() + length w > !*ll!* then terpri();
      prin2 u >>
  end;
+++ p_princ redefined
+++ p_princ compiled, 69 + 28 bytes
p_princ

symbolic procedure p_prin(u, blankfirst);
  begin
    scalar w;
    w := explode u;
% At the time I implemented this PSL explodes the symbol with name "_a"
% as just (_ a) rather than as (! _ a). That would mean that the result
% would not read back into Reduce properly - so I stick in the extra
% escape character.
    if eqcar(w, '!_) then w := '!! . w;
    if bldmsg_chars!* then <<
      if blankfirst then bldmsg_chars!* := '!  . bldmsg_chars!*;
      for each c in w do bldmsg_chars!* := c . bldmsg_chars!* >>
    else <<
      if blankfirst then <<
        if posn() + length w + 1 > !*ll!* then terpri();
        prin2 " " >>
      else if posn() + length w > !*ll!* then terpri();
      for each c in w do prin2 c >>
  end;
+++ p_prin redefined
+++ p_prin compiled, 90 + 36 bytes
p_prin

%
% Code to print potentially re-entrant lists
%

fluid '(!*print!-array!*
        !*print!-length!*
        !*print!-level!*);nil

!*print!-array!* := t;t        % Display contents if vectors if true
!*print!-length!* := nil;nil     % Limit length of lists printed if an integer
!*print!-level!* := nil;nil      % Limit depth of nesting if an integer.

fluid '(!*prinl_visited_nodes!* !*prinl_index!* );nil

!*prinl_visited_nodes!* := mkhash(10, 0, 1.5)$#H(0 0 61 [~ ~ ~ ~ ~ ~ ~ ~] [~ ~ ~
~ ~ ~ ~ ~])

symbolic procedure p_prinl0(x, escaped);
% print x even if it has loops in it. If escaped is true then printing
% is in the style of prin1, otherwise prin2.
  begin
    scalar !*prinl_index!*;
    !*prinl_index!*:=0;
% Clear the hash table AFTER use, so that the junk that goes into it does
% not gobble memory between calls to prinl. This relies on unwind!-protect
% to make sure that it is indeed always cleared. Errors (eg ^C) during the
% clean-up operation could lead to curious displays in the next use of
% prinl.
    unwind!-protect(<< p_prinl1(x, 0); p_prinl2(x, 0, escaped, nil) >>,
                    clrhash !*prinl_visited_nodes!*);
    return x
  end;
+++ p_prinl0 compiled, 34 + 36 bytes
p_prinl0

symbolic procedure p_prinl1(x, depth);
% Find all the nodes in x and record them in the hash table.
% The first time a node is met it is inserted with associated value 0.
% If a node is met a second time then it is assigned an unique positive
% integer code that will later be used in its label.
  begin
    scalar w, length;
    if fixp !*print!-level!* and depth > !*print!-level!* then return nil;
    length := 0;
 top:
    if atom x and not vectorp x and not gensymp x then return nil
    else if w := gethash(x,!*prinl_visited_nodes!*) then <<
       if w = 0 then <<
         !*prinl_index!* := !*prinl_index!* + 1;
         puthash(x,!*prinl_visited_nodes!*, !*prinl_index!*) >>;
       return nil >>
    else <<
      puthash(x, !*prinl_visited_nodes!*, 0);
      if vectorp x then <<
        if !*print!-array!* then <<
          length := upbv x;
          if fixp !*print!-length!* and !*print!-length!* < length then
              length := !*print!-length!*;
          for i:=0:length do p_prinl1(getv(x,i), depth+1) >> >>
      else if not atom x then <<
          p_prinl1(car x, depth+1);
          if fixp !*print!-length!* and
             (length := length+1) > !*print!-length!* then return nil;
          x := cdr x;
          go to top >> >>
  end;
+++ p_prinl1 compiled, 126 + 44 bytes
p_prinl1

symbolic procedure p_printref(w, blankfirst, ch);
% This prints "#NN#" possibly with a blank in front of it and
% perhaps splitting the line. Well it can also do "#NN=".
  begin
    scalar len;
    len := length explode w;
    if blankfirst then len := len + 1;
% Here I will break the line unless I can fit on "#nn#" or " #nn#" as
% relevant.
    if not bldmsg_chars!* and
       posn() + 2 + len > !*ll!* then <<
      blankfirst := nil;
      terpri() >>;
    p_princ("#", blankfirst);
    p_princ(w, nil);
    p_princ(ch, nil)
  end;
+++ p_printref compiled, 39 + 28 bytes
p_printref

symbolic procedure p_prinl2(x, depth, escaped, blankfirst);
% Scan a structure that was previously processed by p_prinl1. Thus all
% nodes in x are already in the hash table. Those with value zero
% are only present once in x, while those with strictly positive values
% occur at least twice.  After printing a label for such value this resets the
% value negative so that the printing can tell when the visit is for
% a second rather than first time.  The output format is intended to
% bear some resemblance to the expectations of Common Lisp.
%
% Note that if the hash table is in fact empty then this will just print
% what "ordinary" prin/princ would.
    if fixp !*print!-level!* and depth > !*print!-level!* then
       p_princ("#", blankfirst)
    else if atom x and not vectorp x and not gensymp x then <<
       if escaped then p_prin(x, blankfirst)
       else p_princ(x, blankfirst) >>
    else begin scalar w, length;
      w := gethash(x,!*prinl_visited_nodes!*);
      if w and not zerop w then <<
        if w < 0 then <<
          p_printref(-w, blankfirst, "#");
          return nil >>
        else <<
          puthash(x,!*prinl_visited_nodes!*, -w);
          p_printref(w, blankfirst, "=");
          blankfirst := nil >> >>;
      if vectorp x then <<
         p_princ("%(", blankfirst);
         if !*print!-array!* then <<
           length := upbv x;
           if fixp !*print!-length!* and !*print!-length!* < length then
               length := !*print!-length!*;
           for i:=0:length do
             p_prinl2(getv(x,i), depth+1, escaped, i neq 0) >>
         else p_princ("...", nil);
         p_princ(")", nil);
         return nil >>
      else if atom x then <<
        if escaped then p_prin(x, blankfirst)
        else p_princ(x, blankfirst);
        return nil >>;
      p_princ("(", blankfirst);
      p_prinl2(car x, depth+1, escaped, nil);
      x:=cdr x;
      length := 0;
  loop:
      if atom x then <<
        if x neq nil then <<
          p_princ(".", t);
          p_prinl2(x, depth, escaped, t) >>;
        return p_princ(")", nil) >>;
      if fixp !*print!-length!* and
         (length := length + 1) > !*print!-length!* then <<
             p_princ("...", t);
             return p_princ(")", nil) >>;
      w := gethash(x, !*prinl_visited_nodes!*);
      if w and not zerop w then <<
        if w < 0 then <<
          p_princ(".", t);
          p_printref(-w, t, "#");
          return p_princ(")", nil) >>
        else <<
          p_princ(".", t);
          p_prinl2(x, depth+1, escaped, t);
          return p_princ(")", nil) >> >>;
      p_prinl2(car x, depth+1, escaped, t);
      x:=cdr x;
      go to loop
    end;
+++ p_prinl2 redefined
+++ p_prinl2 compiled, 308 + 84 bytes
p_prinl2

symbolic procedure rlisp_printl x;
 << rplisp_prinl x;
    terpri();
    x >>;
+++ rlisp_printl compiled, 6 + 12 bytes
rlisp_printl

symbolic procedure rlisp_printcl x;
 << rlisp_princl x;
    terpri();
    x >>;
+++ rlisp_printcl compiled, 6 + 12 bytes
rlisp_printcl

symbolic procedure rlisp_princl x;
  begin
    scalar !*ll!*;
    !*ll!* := linelength nil - 2;
    p_prinl0(x, nil);
    return x;
  end;
+++ rlisp_princl compiled, 17 + 24 bytes
rlisp_princl

symbolic procedure rlisp_prinl x;
  begin
    scalar !*ll!*;
    !*ll!* := linelength nil - 2;
    p_prinl0(x, t);
    return x;
  end;
+++ rlisp_prinl compiled, 18 + 28 bytes
rlisp_prinl

symbolic procedure portable_print x;
 << portable_prin x;
    terpri();
    x >>;
+++ portable_print redefined
+++ portable_print compiled, 6 + 12 bytes
portable_print

symbolic procedure portable_printc x;
 << portable_princ x;
    terpri();
    x >>;
+++ portable_printc compiled, 6 + 12 bytes
portable_printc

symbolic procedure portable_princ x;
  begin
    scalar !*ll!*;
    !*ll!* := linelength nil - 2;
    p_prinl2(x, 0, nil, nil);
    return x;
  end;
+++ portable_princ compiled, 26 + 28 bytes
portable_princ

symbolic procedure portable_prin x;
  begin
    scalar !*ll!*;
    !*ll!* := linelength nil - 2;
    p_prinl2(x, 0, t, nil);
    return x;
  end;
+++ portable_prin redefined
+++ portable_prin compiled, 26 + 32 bytes
portable_prin

% The following will print a prefix expression. It will use infix
% notation and understand precedence for expt, times, quotient, plus,
% difference and minus -- all other operators are treated as general
% function applications. If !*SQ is encountered within the formula it
% will be expanded out using prepsq.

% The output from prepf does not use DIFFERENCE as an operator, but in
% case one is fed in from some other odd source I will normalise things
% here.

symbolic procedure p_minus u;
  if eqcar(u, 'minus) then cadr u
  else if eqcar(u, 'plus) then
    'plus . for each v in cdr u collect p_minus v
  else if eqcar(u, 'difference) then
    'plus . p_minus cadr u . cddr u
  else list('minus, u);
+++ p_minus compiled, 72 + 20 bytes
p_minus

symbolic procedure p_diff2minus u;
  begin
    scalar r;
    r := car u;
    while u := cdr u do r := p_minus car u . r;
    return 'plus . reverse r
  end;
+++ p_diff2minus compiled, 23 + 16 bytes
p_diff2minus

symbolic procedure p_prefix(u, prec);
  if atom u then p_princ(u, nil)
  else if eqcar(u, '!*sq) then p_prefix(prepsq cadr u, prec)
  else
    begin
      scalar op, p1;
      op := car u;
% I will have a crude code-based (rather than table-driven) treatment of the
% small number of special cases of infix operators that I support here...
      if op ='expt then <<
        if prec > 3 then p_princ("(", nil);
        p_prefix(cadr u, 4);
        p_princ("^", nil);
        p_prefix(caddr u, 3);
        if prec > 3 then p_princ(")", nil);
        return nil >>
      else if op = 'times or op = 'quotient then <<
        if prec > 2 then p_princ("(", nil);
        p_prefix(car (u := cdr u), 2);
        if op = 'times then << p1 := 2; op := "*" >>
        else << p1 := 3; op := "/" >>;
% If I have (quotient a (times b c)) I must parenthesize the use of "times",
% but if I had (times a (quotient b c)) I need not parenthesize the quotient
% because (a*(b/c)) has the same value as (a*b)/c so can be displated as
% just a*b/c safely.
        while not atom (u := cdr u) do <<
          p_princ(op, nil);
          p_prefix(car u, p1) >>;
        if prec > 2 then p_princ(")", nil);
        return nil >>;
      if op = 'difference then return p_prefix(p_diff2minus cdr u, prec)
      else if op = 'plus then <<
        if prec > 1 then p_princ("(", nil);
        p_prefix(car (u := cdr u), 1);
        while not atom (u := cdr u) do <<
          p1 := car u;
          if eqcar(p1, 'minus) then <<
            p1 := cadr p1;
            p_princ(" - ", nil) >>
          else p_princ(" + ", nil);
          p_prefix(p1, 1) >>;
        if prec > 1 then p_princ(")", nil);
        return nil >>
      else if op = 'minus then <<
        p_princ("-", nil);
        if prec < 2 then prec := 2;
        return p_prefix(cadr u, prec) >>;
% Here I have something I will display as a raw function application. I will
% take special action if the "function" part is complicated!
      if (not atom op) or (numberp op and minusp op) then <<
        p_princ("(", nil);
        p_prefix(op, 0);
        p_princ(")", nil) >>
      else p_princ(op, nil);
      op := "(";
% A function with no args needs "()" after it.
      if atom (u := cdr u) then p_princ("(", nil)
      else for each x in u do <<
        p_princ(op, nil);
        op := ",";
        p_prefix(x, 0) >>;
      return p_princ(")", nil)
    end;
+++ p_prefix compiled, 260 + 104 bytes
p_prefix

% Sometimes I want to print a Lisp expression starting at the current
% column and with confidence that My Lisp system will keep output within
% consistent line-length limits. Here I provide functions to do that which
% might lead to a display of the style:    (here is where I start an if
%                                          something is not going to fit
%                                          on the line I wrap to the
%                                          starting column. If
%                      someextraordinaryilylongstmbolisincludedthatcannot
%                                          cope with the given width I
%                                          will right-align it as shown.
%

symbolic procedure prin_with_margin u;
   print_with_margin_sub(u, posn(), linelength nil-2, function explode);
+++ prin_with_margin redefined
+++ prin_with_margin compiled, 17 + 20 bytes
prin_with_margin

symbolic procedure princ_with_margin u;
   print_with_margin_sub(u, posn(), linelength nil-2, function explode2);
+++ princ_with_margin compiled, 17 + 20 bytes
princ_with_margin

symbolic procedure print_with_margin u;
 << prin_with_margin u;
    terpri();
    u >>;
+++ print_with_margin compiled, 6 + 12 bytes
print_with_margin

symbolic procedure printc_with_margin u;
 << princ_with_margin u;
    terpri();
    u >>;
+++ printc_with_margin compiled, 6 + 12 bytes
printc_with_margin

% I will cope with symbols, numbers, strings and lists. Vectors and other
% objects will be rendered cryptically at best.

symbolic procedure print_with_margin_sub(u, left, right, explfn);
  begin
    scalar v;
% Override pathologically narrow cases.
    if right < 10 then right := 10;
    if left > right-10 then left := right-10;
    v := u;
% Cope with lists.
    if not atom v then <<
      if posn() >= right then << terpri(); ttab left >>;
      prin2 "(";
      print_with_margin_sub(car v, left, right, explfn);
      while not atom (v := cdr v) do <<
        if posn() >= right then << terpri(); ttab left >>
        else prin2 " ";
        print_with_margin_sub(car v, left, right, explfn) >>;
      if not null v then <<
        if posn() >= right-1 then << terpri(); ttab left; prin2 ". " >>
        else prin2 " .";
        print_with_margin_sub(v, left, right, explfn) >>;
        if posn() >= right then << terpri(); ttab left >>;
        prin2 ")";
      return u >>;
% Here I have something atomic. Use the explode operator I was handed
% to see how long its printed representation would be.
    v := apply(explfn, list u);
% In the case of unreasonably long atoms I will need to split things
% across lines, and I come back to here when I have made at least some
% headway.
verylong:
    if posn() + length v < right then <<
      for each c in v do prin2 c;
      return u >>
    else if length v <= right-left then <<
      terpri();
      ttab left;
      for each c in v do prin2 c;
      return u >>
    else if length v < right then <<
      terpri();
      ttab(right - length v);
      for each c in v do prin2 c;
      return u >>
    else <<
      if posn() >= right-5 then << terpri(); ttab left >>;
      while posn() < right-1 do <<
        prin2 car v;
        v := cdr v >>;
      prin2 "\";
      terpri();
      go to verylong >>
  end;
+++ print_with_margin_sub redefined
+++ print_with_margin_sub compiled, 279 + 44 bytes
print_with_margin_sub


% Now for printf...

% The special sequences that can occur in format strings are as follows.
% I will make my tests for directives case insensitive, so for instance
% either %b or %B will be recognized.
%       %b    do that many spaces
%       %c    next arg is a character code. display character
%       %d    print an integer (equivalent to %w)
% *     %f    do a terpri() unless posn()=0
%       %l    prin2 items from given list, blank separated
% *     %n    do a terpri()
%       %o    print in octal
%       %q    print as with prin1 but such that looped structures are OK
%       %p    print using prin1
%       %r    As '%q'
%       %s    print as a string (equivalent to %w)
%       %t    move to given column, performing a terpri first
%             if currently beyond it.
%       %w    use prin2
%       %x    print in hexadecimal
% *     %%    print a '%' character
%       %@f   print as standard form
%       %@q   print as standard quotient
%       %@p   print as prefix form
% All except those marked with "*" use an argument.


symbolic procedure bldmsg_internal(fmt, args);
  begin
    scalar bldmsg_chars!*, u, v;
    bldmsg_chars!* := t;
    printf_internal(fmt, args);
    while not atom bldmsg_chars!* do <<
      u := cdr bldmsg_chars!*;
      rplacd(bldmsg_chars!*, v);
      v := bldmsg_chars!*;
      bldmsg_chars!* := u >>;
    return list2widestring v
  end;
+++ bldmsg_internal compiled, 32 + 28 bytes
bldmsg_internal

symbolic procedure p_posn();
  if bldmsg_chars!* then
  begin
    scalar w, n;
    n := 0;
    w := bldmsg_chars!*;
    while not atom w and not (car w = !$eol!$) do <<
      n := n + 1;
      w := cdr w >>;
    return n
  end
  else posn();
+++ p_posn compiled, 25 + 20 bytes
p_posn

% I want octal and hex printing. For portability I implement my own.

global '(p_hexdigits!*);nil

<< p_hexdigits!* := mkvect 15;
   putv(p_hexdigits!*, 0, '!0);
   putv(p_hexdigits!*, 1, '!1);
   putv(p_hexdigits!*, 2, '!2);
   putv(p_hexdigits!*, 3, '!3);
   putv(p_hexdigits!*, 4, '!4);
   putv(p_hexdigits!*, 5, '!5);
   putv(p_hexdigits!*, 6, '!6);
   putv(p_hexdigits!*, 7, '!7);
   putv(p_hexdigits!*, 8, '!8);
   putv(p_hexdigits!*, 9, '!9);
   putv(p_hexdigits!*, 10, '!a);
   putv(p_hexdigits!*, 11, '!b);
   putv(p_hexdigits!*, 12, '!c);
   putv(p_hexdigits!*, 13, '!d);
   putv(p_hexdigits!*, 14, '!e);
   putv(p_hexdigits!*, 15, '!f) >>;f

symbolic procedure p_prinhex n;
  if not fixp n then p_princ("<not-a-number>", nil)
  else begin
    scalar b, w;
    if n >= 0 then <<
      while n >= 16 do <<
        b := getv(p_hexdigits!*, w := mod(n, 16)) . b;
        n := (n - w)/16 >>;
      b := getv(p_hexdigits!*, mod(n, 16)) . b >>
    else <<
      while n < -1 do <<
        b := getv(p_hexdigits!*, w := mod(n, 16)) . b;
        n := (n - w)/16 >>;
      b := '!~ . getv(p_hexdigits!*, mod(n, 16)) . b >>;
    if null bldmsg_chars!* and (posn() + length b) > !*ll!* then terpri();
    for each c in b do p_princ(c, nil)
  end;
+++ p_prinhex compiled, 133 + 44 bytes
p_prinhex

symbolic procedure p_prinoctal n;
  if not fixp n then p_princ("<not-a-number>", nil)
  else begin
    scalar b, w;
    if n >= 0 then <<
      while n >= 8 do <<
        b := (w := mod(n, 8)) . b;
        n := (n - w)/8 >>;
      b := mod(n, 8) . b >>
    else <<
      while n < -1 do <<
        b := (w := mod(n, 8)) . b;
        n := (n - w)/8 >>;
      b := '!~ . mod(n, 8) . b >>;
    if null bldmsg_chars!* and (posn() + length b) > !*ll!* then terpri();
    for each c in b do p_princ(c, nil)
  end;
+++ p_prinoctal compiled, 111 + 40 bytes
p_prinoctal

symbolic procedure printf_internal(fmt, args);
  begin
    scalar a, c, !*ll!*;
    !*ll!* := linelength nil - 2;
    fmt := explode2 fmt;
    while fmt do <<
      c := car fmt;
      fmt := cdr fmt;
      if c neq '!% then p_princ(c, nil)
      else <<
        c := car fmt;
        fmt := cdr fmt;
        if c = '!f then << if not bldmsg_chars!* and
                              not zerop posn() then terpri() >>  
        else if c = '!n or c = '!N then p_princ(!$eol!$, nil)
        else if c = '!% then p_princ(c, nil)
        else <<
          if null args then a := nil
          else <<
            a := car args;
            args := cdr args >>;
          if (c = '!b or c = '!B) and fixp a then
            for i := 1:a do p_princ(" ", nil)
          else if c = '!c or c = '!C then <<
% "%c" will accept either an integer or a symbol that should be a single
% character.
             if fixp a then p_princ(list2widestring list a, nil)
             else p_princ(a, nil) >> 
          else if c = '!l or c = '!L then <<
            if not atom a then <<
              portable_princ car a;
              for each x in cdr a do <<
                p_princ(" ", nil);
                portable_princ x >> >> >>
          else if c = '!o or c = '!O then p_prinoctal a
          else if c = '!p or c = '!P then portable_prin a
          else if c = '!q or c = '!Q then rlisp_prinl a
          else if c = '!r or c = '!R then <<
            p_princ("'", nil); rlisp_prinl a; p_princ("'", nil) >>
          else if (c = '!t or c = '!T) and fixp a then <<
            if p_posn() > a then p_princ(!$eol!$, nil);
            while p_posn() < a do p_princ(" ", nil) >>
% "%w", "%d" and "%s" here all just use princ. The original idea was that
% "%d" was for (decimal) integers and "%s" for strings, but there is no
% really useful optimisation to be had by trying to find type-specific
% print functions to call here.
          else if c = '!w or c = '!d or c = '!s or
                  c = '!W or c = '!D or c = '!S then portable_princ a
% As with octal output, PSL can achieve this a diffenent way and will
% generate differently formatted output.
          else if c = '!x or c = '!X then p_prinhex a
          else if c = '!@ then <<
            c := car fmt;
            fmt := cdr fmt;
            if c = '!f or c = '!F then p_prefix(prepf a, 0)
            else if c = '!q or c = '!Q then p_prefix(prepsq a, 0)
            else if c = '!p or c = '!P then p_prefix(a, 0)
            else << p_princ("%@", nil); p_princ(c, nil) >> >>
          else if c = '!e or c = '!E then eval a 
% Rather than generating an error I will display %? (where ? is any
% unrecognized character) unchanged.
          else << p_princ("%", nil); p_princ(c, nil) >> >> >> >>
  end;
+++ printf_internal compiled, 444 + 224 bytes
printf_internal

symbolic macro procedure rlisp_printf u;
   list('printf_internal, cadr u, 'list . cddr u);
+++ rlisp_printf_4uwk2xuv7pzc3 compiled, 15 + 16 bytes
rlisp_printf

symbolic macro procedure rlisp_bldmsg u;
  list('bldmsg_internal, cadr u, 'list . cddr u);
+++ rlisp_bldmsg_e6rauk7i5jab1 compiled, 15 + 16 bytes
rlisp_bldmsg

flag('(rlisp_printf rlisp_bldmsg), 'variadic);nil


% There is a significant issue here. PSL has functions printf and
% bldmsg built in to its kernel. They are defined as regular functions
% that take an indefinite number of arguments., and it looks to me
% If I overwrite those definitions with the macro that I use here
% the result is disaster.instead I define my macros with the private
% names rlisp_printf and rlisp_bldmsg then get rlisp to map the names
% printf and bldmsg onto those. 
% I follow this path on both CSL and PSL even though there are no terrible
% clashes with CSL.

put('printf, 'newnam, 'rlisp_printf);rlisp_printf
put('bldmsg, 'newnam, 'rlisp_bldmsg);rlisp_bldmsg
put('prinl,  'newnam, 'rlisp_prinl);rlisp_prinl

endmodule;nil

end;nil
nil


(load!-package!-sources 'smacros 'support)% smacros.red - automatically generated from other source files

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%




end;nil
nil


(load!-package!-sources rend_file 'support)module cslrend;nil % CSL REDUCE "back-end".

% Authors: Martin L. Griss and Anthony C. Hearn.
% Modified by Arthur Norman for use with CSL.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%

% $Id: cslrend.red 5305 2020-03-28 22:38:19Z arthurcnorman $

create!-package('(cslrend csl),nil);
+++ Creating a package: cslrend
cslrend

fluid '(!*break
        !*echo
        !*eolinstringok
        !*int
        !*mode
        !*raise
        !*lower
        !*keepsqrts
        outputhandler!*
        ifl!*
        !*savedef
        lispsystem!*
        !*backtrace);nil

global '(!$eol!$
         !*extraecho
         cr!*
         crchar!*
         date!*
         esc!*
         ff!*
         ipl!*
         largest!-small!-modulus
         ofl!*
         spare!*
         statcounter
         crbuflis!*
         tab!*
         version!*
         author1!*
         author2!*
         loadable!-packages!*
         switches!*
         symchar!*);nil

author1!* := "A C Hearn, 1971-2016";A C Hearn, 1971-2016
author2!* := "Codemist, 1989-2019";Codemist, 1989-2019

% Lists of packages & switches...

% The following code arranges that the list of loadable packages
% is constructed once at compile time. That is good because at that time
% Reduce must be set up so as to have access to the path referred to
% here as "$reduce" and the package map will be within the source tree.
% Otherwise Reduce could not be being built!

symbolic macro procedure find!-loadable!-packages u;
  begin
    scalar i, e;
% Configuration information is held in a file called something like
% "package.map".
    if boundp 'minireduce and symbol!-value 'minireduce then
       i := "package.map"
    else i := "$reduce/packages/package.map";
    i := open(i, 'input);
    i := rds i;
    e := !*echo;
    !*echo := nil;
    u := read();
    !*echo := e;
    i := rds i;
    close i;
% I make a list of all the packages that are tagged as suitable for use with
% CSL.
    u :=
      for each x in u conc
         if member('csl, cddr x) then list car x else nil;
% Now I delete the ones that will have already been loaded, since there
% would be no merit in loading any of those a second time.
    for each x in '(rlisp cslrend smacros poly arith alg
                    mathpr tmprint entry cslcompat user
                    cslprolo) do
      u := delete(x, u);
% Put things in alphabetic order at least to keep things neat.
    return mkquote sort(u, 'orderp)
  end;
+++ find!-loadable!-packages_yq8r59bfhv4n1 compiled, 130 + 56 bytes
find-loadable-packages

loadable!-packages!* := find!-loadable!-packages();(acfsf algint applysym arnum
assert assist atensor avector bibasis boolean breduce cali camal cantens cde
cdiff cedit cgb changevr cl clprl coeff2 compact conlaw crack cuba cvit dcfsf
defint desir dfpart dipoly dummy dvfsf eds excalc ezgcd factor fide fide1
fmprint fps gcref gentran geoprover gnuplot groebner groebnr2 guardian gurobi
hephys ibalp ideals ineq int invbase lalr laplace libreduce lie liepde limits
linalg listvecops lpdo mathml mathmlom matrix misc modsr mri mri_ofsf mri_pasf
mrvlimit ncpoly nlopt noncom2 normform numeric odesolve ofsf orthovec pasf pf
pgauss physop pident plot pm polydiv pretty profile qhull qqe qqe_ofsf qsum
randpoly ranum rataprx ratint rcref reacteqn redfront redlog reduce4 reset
residue revision rlfi rlisp88 rlsupport rltools roots roots2 rprint rsolve
rtrace rubi_red scope sets sfgamma smt solve sparse spde specbess specfaux
specfn specfn2 sstools sum susy2 symaux symmetry tables talp taylor tps tri
trigd trigint trigsimp turtle utf8 v3tools wu xcolor xideal z3 zeilberg ztrans)



% This amazingly long list of switches was created as a by-product
% of building the bootstrap version of Reduce. In that build use of
% the directive that introduces switches is logged. Not all of these switches
% are really aimed at the general public, and almost all only apply when
% some particular module is loaded.

% The extraction of this list from buildlogs/bootstrapreduce.log uses
%    grep "Declaring a switch" buildlogs/bootstrapreduce.log > ...
% followed by minor hand editing then use of sort and dups with a final
% editing pass to get the table neatly lined up.

% I could clearly automake this more thoroughly!

% This list included here was created on August 5th 2014 based on the
% development version of Reduce on that date. I rather expect that new
% flags only get added at a fairly slow rate so this list not always
% being kept up to date may not be a calamity.

%%% Updated 2018-06-08 RmS
switches!* := '(
    acinfo                    acn                       adjprec
    again                     algint                    algpri
    allbranch                 allfac                    allowdfint
    allpoly                   anticom                   anygcd
    arbvars                   arnum                     assert
    assertbreak               assertstatistics          asterisk
    backtrace                 balanced_mod              
    batch_mode                bcsimp                    bezout
    bfspace                   boese                     both
    carcheckflag              centergrid                cgbcheckg
    cgbcontred                cgbcounthf                cgbfaithful
    cgbfullred                cgbgs                     cgbreal
    cgbsgreen                 cgbstat                   cgbupdb
    cgbverbose                checkord                  clprlproject
    clprlverbose              coates                    combineexpt
    combinelogs               commutedf                 commuteint
    comp                      complex                   compxroots
    contract                  cramer                    cref
    cvit                      dcfsfold                  debug
    debug_times               defn                      demo
    detectunits               dfint                     dfprint
    diffsoln                  dispjacobian              distribute
    div                       dolzmann                  double
    dqegradord                dqeoptqelim               dqeoptsimp
    dqeverbose                dummypri                  dzopt
    echo                      edsdebug                  edsdisjoint
    edssloppy                 edsverbose                eqfu
    errcont                   essl                      evalassert
    evallhseqp                exdelt                    exp
    expand_td                 expanddf                  expandexpt
    expandlogs                ezgcd                     f90
    factor                    factorprimes              factorunits
    failhard                  fancy                     fancy_tex
    fast_la                   fastfor                   fastresexpand
    fastresvb                 fastsimplex               faststructs
    fastvector                force_gnuplot_term        fort
    fortupper                 fourier                   ftch
    fulleq                    fullpoly                  fullprec
    fullprecision             fullroots                 gbltbasis
    gc                        gcd                       gcref
    gcrefall                  gcrefudg                  gdqe
    gdsmart                   gendecs                   genpos
    gentranopt                gentranseg                getdecs
    gltbasis                  groebfac                  groebfullreduction
    groebopt                  groebprot                 groebrm
    groebstat                 groebweak                 gsugar
    guardian                  hack                      hardzerotest
    heugcd                    horner                    hyperbolic
    ibalp_kapurdisablegb      ibalp_kapurgb             ibalp_kapurgbdegd
    ibalpbadvarsel            ifactor                   imaginary
    imsl                      inputc                    instantiate
    int                       int_test                  intern
    intstr                    kacem                     keepdecs
    lalr_verbose              lasimp                    latex
    lcm                       lessspace                 lexefgb
    lhyp                      limitedfactors            list
    listargs                  lmon                      looking_good
    lower                     lower_matrix              lpdocoeffnorm
    lpdodf                    lpdotrsym                 lpkeepfiles
    lrxml                     ltrig                     makecalls
    mathml                    mcd                       mod_was_on
    modular                   msg                       multiplicities
    multiroot                 mymatch                   nag
    nat                       nero                      nested
    noacn                     noarg                     nocommutedf
    nocompile                 noconvert                 noetherian
    noint                     nointint                  nointsubst
    nolnr                     nonlnr                    nopowers
    nopropzero                nosplit                   nosturm
    not_negative              notailcall                novarmsg
    numval                    odesolve_basis            odesolve_check
    odesolve_diff             odesolve_equidim_y        odesolve_expand
    odesolve_explicit         odesolve_fast             odesolve_full
    odesolve_implicit         odesolve_noint            odesolve_norecurse
    odesolve_noswap           odesolve_simp_arbparam    odesolve_verbose
    ofsfvs                    ofsfvsblockbtr            ofsfvsqetree2gml
    onespace                  only_integer              optdecs
    ord                       outerzeroscheck           output
    overview                  parse_errors_fatal        partialint
    partialintdf              partialintint             period
    pgaftermath               pggeneric                 pginfosm
    pginfosol                 pgnoarbcomplex            pgsourcedirect
    pgspqe                    pgspsimpl                 pgverbose
    pgwd                      pidentmore                plap
    plotkeep                  plotusepipe               prapprox
    precise                   precise_complex           prefix
    prephold                  pret                      prfourmat
    pri                       priall                    primat
    prlinineq                 promptnumbers             psen
    psprintorder              pvector                   pwrds
    qgosper_down              qgosper_specialsol        qhullkeepfiles
    qsum_nullspace            qsum_trace                qsumrecursion_certificate
    qsumrecursion_down        qsumrecursion_exp         qsumrecursion_profile
    quotenewnam               r2i                       rahidepoly
    raise                     ranpos                    ranum
    rarat                     rasifac                   rasimpl
    rat                       ratarg                    rational
    rationalize               ratpri                    ratroot
    red_total                 redfront_mode             reduce4
    reduced                   report_colons             revalp
    revpri                    rladdcond                 rlanuexgcdnormalize
    rlanuexsgnopt             rlanuexverbose            rlataltheo
    rlbnfsac                  rlbnfsm                   rlbqlimits
    rlbrkcxk                  rlbrop                    rlcadans
    rlcaddecdeg               rlcaddnfformula           rlcadextonly
    rlcadfasteval             rlcadfulldimonly          rlcadmc3
    rlcadpbfvs                rlcadpreponly             rlcadprojonly
    rlcadrawformula           rlcadrmwc                 rlcadte
    rlcadtree2dot             rlcadtree2gml             rlcadtree2gmlxml
    rlcadtree2tgf             rlcadtrimtree             rlcadverbose
    rldavgcd                  rldimaincludefirst        rldpepiverbose
    rldpepverbose             rlelimsetoptmarek         rlenf1twice
    rlenffac                  rlenffacne                rlenfsimpl
    rlexprngnatural           rlffi                     rlgaussdebug
    rlgausstheo               rlgensymintern            rlgetrtypecar
    rlgsbnf                   rlgserf                   rlgsprod
    rlgsrad                   rlgsred                   rlgssub
    rlgsutord                 rlgsvb                    rlgurobi
    rlhqeconnect              rlhqedim0                 rlhqegbdimmin
    rlhqegbred                rlhqestrconst             rlhqetfcfast
    rlhqetfcfullsplit         rlhqetfcsplit             rlhqetheory
    rlhqevarsel               rlhqevarselx              rlhqevb
    rlidentify                rlisp88                   rlkapurchkcont
    rlkapurchktaut            rlmrivb                   rlmrivb2
    rlmrivbio                 rlnzden                   rlopt1s
    rlourdet                  rlparallel                rlpasfbapprox
    rlpasfconf                rlpasfdnffirst            rlpasfdnfqeexblock
    rlpasfexpand              rlpasfgauss               rlpasfgc
    rlpasfsc                  rlpasfses                 rlpasfsimplify
    rlpasfvb                  rlpcprint                 rlpcprintall
    rlplsimpl                 rlposden                  rlpqeold
    rlpscsgen                 rlqeaprecise              rlqeasri
    rlqebacksub               rlqedfs                   rlqedyn
    rlqeexpand                rlqefb                    rlqefbmma
    rlqefbqepcad              rlqefbslfq                rlqefilterbounds
    rlqefullans               rlqegen1                  rlqegenct
    rlqegsd                   rlqeheu                   rlqeidentify
    rlqeinfcore               rlqeinfirst               rlqelog
    rlqepnf                   rlqeprecise               rlqeqsc
    rlqesqsc                  rlqesr                    rlqestdans
    rlqestdansint             rlqestdansq               rlqestdansvb
    rlqesubf                  rlqesubi                  rlqevarsel
    rlqevarseltry             rlqevb                    rlqevbold
    rlrealtime                rlresi                    rlresolveuniversal
    rlsetequalqhash           rlsiatadv                 rlsichk
    rlsid                     rlsiexpl                  rlsiexpla
    rlsifac                   rlsifaco                  rlsiidem
    rlsimpl                   rlsimplfloor              rlsipd
    rlsiplugtheo              rlsipo                    rlsippatl
    rlsippsignchk             rlsippsubst               rlsipw
    rlsism                    rlsiso                    rlsisocx
    rlsitsqspl                rlsiverbose               rlslfqvb
    rlsmprint                 rlsusi                    rlsusiadd
    rlsusigs                  rlsusimult                rltnft
    rltropdel0                rltropilp                 rltroplcm
    rltropsos                 rlverbose                 rlvmatvb
    rlvsllearn                rlvsllog                  rlxopt
    rlxoptpl                  rlxoptri                  rlxoptric
    rlxoptrir                 rlxoptsb                  rlxoptses
    rmonl                     rootmsg                   roundall
    roundbf                   rounded                   rprint_lower
    rtrace                    s_changes_parity          saveactives
    savedef                   saveprops                 savesfs
    savestructr               semantic                  sfto_musser
    sfto_tobey                sfto_yun                  show_grid
    sidrel                    simpnoncomdf              smtsilent
    smtslog                   solvesingular             spec
    specification             strict_argcount           symmetric
    t_changes_parity          talpqegauss               talpqp
    taylorautocombine         taylorautoexpand          taylorkeeporiginal
    taylornocache             taylorprintorder          tdusetorder
    tensor                    test_plot                 testecho
    tex                       texbreak                  texindent
    time                      tr_lie                    tra
    tracefps                  tracelex                  tracelimit
    traceratint               tracespecfns              tracetrig
    trallfac                  trchrstrem                trcompact
    trdefint                  trdesir                   trdint
    trfac                     trfield                   trgroeb
    trgroeb1                  trgroebr                  trgroebs
    trham                     trigform                  trint
    trintsubst                trinvbase                 trlinineq
    trlinineqint              trlinrec                  trmin
    trnonlnr                  trnumeric                 trode
    trplot                    trpm                      trroot
    trrubi                    trsolve                   trsum
    trtaylor                  trwu                      trxideal
    trxmod                    twogrid                   twosided
    unicode_in_off_nat        unsafecar                 upper_matrix
    useold                    usetaylor                 usez
    utf8                      utf82d                    utf82dround
    utf8diffquot              utf8exp                   utf8expall
    utf8pad                   varopt                    vectorc
    verbatim                  verboseload               vslfast
    vslgreaterplem            vslseprintnls             vslsprintil
    vslsprintnl               vslsprintsl               vtrace
    web                       windexpri                 wrchri
    xfullreduce               xpartialint               xpartialintdf
    xpartialintint            zb_factor                 zb_inhomogeneous
    zb_proof                  zb_timer                  zb_trace
    zeilberg                                            
);(acinfo acn adjprec again algint algpri allbranch allfac allowdfint allpoly
anticom anygcd arbvars arnum assert assertbreak assertstatistics asterisk
backtrace balanced_mod batch_mode bcsimp bezout bfspace boese both carcheckflag
centergrid cgbcheckg cgbcontred cgbcounthf cgbfaithful cgbfullred cgbgs cgbreal
cgbsgreen cgbstat cgbupdb cgbverbose checkord clprlproject clprlverbose coates
combineexpt combinelogs commutedf commuteint comp complex compxroots contract
cramer cref cvit dcfsfold debug debug_times defn demo detectunits dfint dfprint
diffsoln dispjacobian distribute div dolzmann double dqegradord dqeoptqelim
dqeoptsimp dqeverbose dummypri dzopt echo edsdebug edsdisjoint edssloppy
edsverbose eqfu errcont essl evalassert evallhseqp exdelt exp expand_td expanddf
expandexpt expandlogs ezgcd f90 factor factorprimes factorunits failhard fancy
fancy_tex fast_la fastfor fastresexpand fastresvb fastsimplex faststructs
fastvector force_gnuplot_term fort fortupper fourier ftch fulleq fullpoly
fullprec fullprecision fullroots gbltbasis gc gcd gcref gcrefall gcrefudg gdqe
gdsmart gendecs genpos gentranopt gentranseg getdecs gltbasis groebfac
groebfullreduction groebopt groebprot groebrm groebstat groebweak gsugar
guardian hack hardzerotest heugcd horner hyperbolic ibalp_kapurdisablegb
ibalp_kapurgb ibalp_kapurgbdegd ibalpbadvarsel ifactor imaginary imsl inputc
instantiate int int_test intern intstr kacem keepdecs lalr_verbose lasimp latex
lcm lessspace lexefgb lhyp limitedfactors list listargs lmon looking_good lower
lower_matrix lpdocoeffnorm lpdodf lpdotrsym lpkeepfiles lrxml ltrig makecalls
mathml mcd mod_was_on modular msg multiplicities multiroot mymatch nag nat nero
nested noacn noarg nocommutedf nocompile noconvert noetherian noint nointint
nointsubst nolnr nonlnr nopowers nopropzero nosplit nosturm not_negative
notailcall novarmsg numval odesolve_basis odesolve_check odesolve_diff
odesolve_equidim_y odesolve_expand odesolve_explicit odesolve_fast odesolve_full
odesolve_implicit odesolve_noint odesolve_norecurse odesolve_noswap
odesolve_simp_arbparam odesolve_verbose ofsfvs ofsfvsblockbtr ofsfvsqetree2gml
onespace only_integer optdecs ord outerzeroscheck output overview
parse_errors_fatal partialint partialintdf partialintint period pgaftermath
pggeneric pginfosm pginfosol pgnoarbcomplex pgsourcedirect pgspqe pgspsimpl
pgverbose pgwd pidentmore plap plotkeep plotusepipe prapprox precise
precise_complex prefix prephold pret prfourmat pri priall primat prlinineq
promptnumbers psen psprintorder pvector pwrds qgosper_down qgosper_specialsol
qhullkeepfiles qsum_nullspace qsum_trace qsumrecursion_certificate
qsumrecursion_down qsumrecursion_exp qsumrecursion_profile quotenewnam r2i
rahidepoly raise ranpos ranum rarat rasifac rasimpl rat ratarg rational
rationalize ratpri ratroot red_total redfront_mode reduce4 reduced report_colons
revalp revpri rladdcond rlanuexgcdnormalize rlanuexsgnopt rlanuexverbose
rlataltheo rlbnfsac rlbnfsm rlbqlimits rlbrkcxk rlbrop rlcadans rlcaddecdeg
rlcaddnfformula rlcadextonly rlcadfasteval rlcadfulldimonly rlcadmc3 rlcadpbfvs
rlcadpreponly rlcadprojonly rlcadrawformula rlcadrmwc rlcadte rlcadtree2dot
rlcadtree2gml rlcadtree2gmlxml rlcadtree2tgf rlcadtrimtree rlcadverbose rldavgcd
rldimaincludefirst rldpepiverbose rldpepverbose rlelimsetoptmarek rlenf1twice
rlenffac rlenffacne rlenfsimpl rlexprngnatural rlffi rlgaussdebug rlgausstheo
rlgensymintern rlgetrtypecar rlgsbnf rlgserf rlgsprod rlgsrad rlgsred rlgssub
rlgsutord rlgsvb rlgurobi rlhqeconnect rlhqedim0 rlhqegbdimmin rlhqegbred
rlhqestrconst rlhqetfcfast rlhqetfcfullsplit rlhqetfcsplit rlhqetheory
rlhqevarsel rlhqevarselx rlhqevb rlidentify rlisp88 rlkapurchkcont
rlkapurchktaut rlmrivb rlmrivb2 rlmrivbio rlnzden rlopt1s rlourdet rlparallel
rlpasfbapprox rlpasfconf rlpasfdnffirst rlpasfdnfqeexblock rlpasfexpand
rlpasfgauss rlpasfgc rlpasfsc rlpasfses rlpasfsimplify rlpasfvb rlpcprint
rlpcprintall rlplsimpl rlposden rlpqeold rlpscsgen rlqeaprecise rlqeasri
rlqebacksub rlqedfs rlqedyn rlqeexpand rlqefb rlqefbmma rlqefbqepcad rlqefbslfq
rlqefilterbounds rlqefullans rlqegen1 rlqegenct rlqegsd rlqeheu rlqeidentify
rlqeinfcore rlqeinfirst rlqelog rlqepnf rlqeprecise rlqeqsc rlqesqsc rlqesr
rlqestdans rlqestdansint rlqestdansq rlqestdansvb rlqesubf rlqesubi rlqevarsel
rlqevarseltry rlqevb rlqevbold rlrealtime rlresi rlresolveuniversal
rlsetequalqhash rlsiatadv rlsichk rlsid rlsiexpl rlsiexpla rlsifac rlsifaco
rlsiidem rlsimpl rlsimplfloor rlsipd rlsiplugtheo rlsipo rlsippatl rlsippsignchk
rlsippsubst rlsipw rlsism rlsiso rlsisocx rlsitsqspl rlsiverbose rlslfqvb
rlsmprint rlsusi rlsusiadd rlsusigs rlsusimult rltnft rltropdel0 rltropilp
rltroplcm rltropsos rlverbose rlvmatvb rlvsllearn rlvsllog rlxopt rlxoptpl
rlxoptri rlxoptric rlxoptrir rlxoptsb rlxoptses rmonl rootmsg roundall roundbf
rounded rprint_lower rtrace s_changes_parity saveactives savedef saveprops
savesfs savestructr semantic sfto_musser sfto_tobey sfto_yun show_grid sidrel
simpnoncomdf smtsilent smtslog solvesingular spec specification strict_argcount
symmetric t_changes_parity talpqegauss talpqp taylorautocombine taylorautoexpand
taylorkeeporiginal taylornocache taylorprintorder tdusetorder tensor test_plot
testecho tex texbreak texindent time tr_lie tra tracefps tracelex tracelimit
traceratint tracespecfns tracetrig trallfac trchrstrem trcompact trdefint
trdesir trdint trfac trfield trgroeb trgroeb1 trgroebr trgroebs trham trigform
trint trintsubst trinvbase trlinineq trlinineqint trlinrec trmin trnonlnr
trnumeric trode trplot trpm trroot trrubi trsolve trsum trtaylor trwu trxideal
trxmod twogrid twosided unicode_in_off_nat unsafecar upper_matrix useold
usetaylor usez utf8 utf82d utf82dround utf8diffquot utf8exp utf8expall utf8pad
varopt vectorc verbatim verboseload vslfast vslgreaterplem vslseprintnls
vslsprintil vslsprintnl vslsprintsl vtrace web windexpri wrchri xfullreduce
xpartialint xpartialintdf xpartialintint zb_factor zb_inhomogeneous zb_proof
zb_timer zb_trace zeilberg)

% Constants used in scanner.

flag('(define!-constant),'eval);nil

cr!* := compress(list('!!, special!-char 6));   % carriage return
ff!* := compress(list('!!, special!-char 5));   % form feed
tab!*:= compress(list('!!, special!-char 3));	   % tab key


% One inessential reference to REVERSIP in this module (left unchanged).

% This file defines the system dependent code necessary to run REDUCE
% under CSL.

COMMENT The following functions, which are referenced in the basic
REDUCE source (RLISP, ALG1, ALG2, MATR and PHYS) should be defined to
complete the definition of REDUCE:

        BYE
        EVLOAD
        ERROR1
        FILETYPE
        MKFIL
        ORDERP
        QUIT
        SEPRP
        SETPCHAR.

Prototypical descriptions of these functions are as follows;

remprop('bye,'stat);nil

symbolic procedure bye;
   %Returns control to the computer's operating system command level.
   %The current REDUCE job cannot be restarted;
   <<close!-output!-files(); stop 0>>;
+++ bye compiled, 6 + 16 bytes
bye

deflist('((bye endstat)),'stat);(bye)

remprop('quit,'stat);nil

symbolic procedure quit;
   %Returns control to the computer's operating system command level.
   %The current REDUCE job cannot be restarted;
   <<close!-output!-files(); stop 0>>;
+++ quit compiled, 6 + 16 bytes
quit

deflist('((quit endstat)),'stat);(quit)

symbolic procedure seprp u;
   % Returns true if U is a blank, end-of-line, tab, carriage return or
   % form feed.  This definition replaces the one in the BOOT file.
   u eq '!  or u eq tab!* or u eq !$eol!$ or u eq ff!* or u eq cr!*;nil

symbolic procedure filetype u;
   % Determines if string U has a specific file type.
   begin scalar v,w;
      v := cdr explode u;
      while v and not(car v eq '!.) do
        <<if car v eq '!< then while not(car v eq '!>) do v := cdr v;
          v := cdr v>>;
      if null v then return nil;
      v := cdr v;
      while v and not(car v eq '!") do <<w := car v . w; v := cdr v>>;
      return intern compress reversip w
   end;
+++ filetype compiled, 54 + 24 bytes
filetype

symbolic procedure mkfil u;
   % Converts file descriptor U into valid system filename.
   if stringp u then u
    else if not idp u then typerr(u,"file name")
    else string!-downcase u;
+++ mkfil redefined
+++ mkfil compiled, 20 + 24 bytes
mkfil


COMMENT The following functions are only referenced if various flags are
set, or the functions are actually defined. They are defined in another
module, which is not needed to build the basic system. The name of the
flag follows the function name, enclosed in parentheses:

        CEDIT (?)
        COMPD (COMP)
        EDIT1   This function provides a link to an editor. However, a
                definition is not necessary, since REDUCE checks to see
                if it has a function value.
        EMBFN (?)
        EZGCDF (EZGCD)
        PRETTYPRINT (DEFN --- also called by DFPRINT)
                This function is used in particular for output of RLISP
                expressions in LISP syntax. If that feature is needed,
                and the prettyprint module is not available, then it
                should be defined as PRINT
        RPRINT (PRET)
        TIME (TIME) returns elapsed time from some arbitrary initial
                    point in milliseconds;



COMMENT The following operator is used to save a REDUCE session as a
file for later use;

symbolic procedure savesession u;
   preserve('begin);
+++ savesession compiled, 3 + 16 bytes
savesession

flag('(savesession),'opfn);nil

flag('(savesession),'noval);nil


COMMENT make "system" available as an operator;

flag('(system),'opfn);nil

flag('(system),'noval);nil


COMMENT to make "faslend" an endstat;

put('faslend,'stat,'endstat);endstat


COMMENT The current REDUCE model allows for the availability of fast
arithmetical operations on small integers (called "inums").  All modern
LISPs provide such support.  However, the program will still run without
these constructs.  The relevant functions that should be defined for
this purpose are as follows;

flag('(iplus itimes iplus2 itimes2 iadd1 isub1 iminus iminusp
       idifference iquotient iremainder ilessp igreaterp ileq igeq
       izerop ionep iequal apply1 apply2 apply3), 'lose);nil

flag('(fp!-infinite fp!-nan fp!-finite fp!-subnorm), 'lose);nil

COMMENT There are also a number of system constants required for each
implementation. In systems that don't support inums, the equivalent
single precision integers should be used;

% LARGEST!-SMALL!-MODULUS is the largest power of two that can
% fit in the fast arithmetic (inum) range of the implementation.
% This is constant for the life of the system and could be
% compiled in-line if the compiler permits it.

% As of December 2010 CSL will actually support up to 2^27, but until
% people have had several months to install a newly compiled CSL I will
% restrict myself to the limit that applied up until them.

% largest!-small!-modulus := 2**24 - 1;

% Well in August 2011 I conclude that matching the value that PSL uses is
% important for compatibility... so I hope that if PSL ever changes somebody
% will tell me.

largest!-small!-modulus := 2**23;8388608

!#if (not (memq 'vsl lispsystem!*))

flag('(modular!-difference modular!-minus modular!-number
       modular!-plus modular!-quotient modular!-reciprocal
       modular!-times modular!-expt set!-small!-modulus
       safe!-modular!-reciprocal), 'lose);nil

!#endif

% flag('(random next!-random!-number), 'lose);

set!-small!-modulus 3;1

% The following are now built into CSL, where by using the C library
% and (hence?) maybe low level tricks or special floating point
% tricks can help with speed.

!#if (or (memq  'vsl lispsystem!*) (memq 'jlisp lispsystem!*))

flag('(cos exp expt log sin sqrt atan fix
       ceiling floor round clrhash puthash gethash remhash), 'lose);

!#else

flag('(acos acosd acosh acot acotd acoth acsc acscd acsch asec asecd
       asech asin asind asinh atan atand atan2 atan2d atanh cbrt cos
       cosd cosh cot cotd coth csc cscd csch exp expt hypot ln log
       logb log10 sec secd sech sin sind sinh sqrt tan tand tanh fix
       ceiling floor round clrhash puthash gethash remhash
       primep32), 'lose);nil

!#endif


fluid '(no!_init!_file);nil
global '(loaded!-packages!* personal!-dir!*);nil

personal!-dir!* := "$HOME";$HOME


% We need to define a function BEGIN, which acts as the top-level
% call to REDUCE, and sets the appropriate variables;

remflag('(begin),'go);nil

symbolic procedure begin;
  begin
     scalar w,!*redefmsg;
     !*echo := not !*int;
     !*extraecho := t;
% Enable heavy debugging option in bootstrap version. The effect of this
% will be that all errors display a backtrace even within a use of
% (errorset E nil nil). Some of these backtraces are a nuisance since
% the "error" is not in any sense a problem, but when things are going
% wrong it can be most frustrating if the evidence is hidden.
% Hmmm this is more nuisance than it is worth, so disable it but leave this
% to show how to reinstate if when things become desparate!
%    if !*savedef and getd 'enable!-errorset then enable!-errorset(3,3);
     if modulep 'tmprint then <<
        w := verbos 0;
        load!-module 'tmprint;
        verbos w;
        if outputhandler!* = 'fancy!-output then fmp!-switch nil >>;
% If invoked from texmacs do something special...
     if getd 'fmp!-switch and member('texmacs, lispsystem!*) then <<
         w := verbos 0;
         fmp!-switch t;
         off1 'promptnumbers;
         load!-module 'tmprint;
         on1 'redfront_mode;
         verbos w >>
% If the tmprint module is loaded and I have a window that can support it
% I will display things in a "fancy" way within the CSL world.
     else if getd 'fmp!-switch then <<
        if member('showmath, lispsystem!*) then fmp!-switch t
        else if outputhandler!* = 'fancy!-output then fmp!-switch nil >>;
     ifl!* := ipl!* := ofl!* := nil;
     if date!* then <<
        verbos nil;
% The linelength may need to be adjusted if we are running in a window.
% To cope with this, CSL allows (linelength t) to set a "default" line
% length that can even vary as window sizes are changed. An attempt
% will be made to ensure that it is 80 at the start of a run, but
% (linelength nil) can return varying values as the user re-sizes the
% main window (in some versions of CSL). However this is still not
% perfect! The protocol
%   old := linelength nil;
%   <do something, possibly changing linelength as you go>
%   linelength old;
% can not restore the variability characteristic. However I make
%   old := linelength n; % n numeric or T
%   ...
%   linelength old;
% preserve things by returning T from (linelength n) in relevant cases.
        linelength t;
% The next four lines have been migrated into the C code in "restart.c"
% so that some sort of information gets back to the user nice and early.
%       prin2 version!*;
%       prin2 ", ";
%       prin2 date!*;
%       prin2t " ...";
        if memq('experiment, lispsystem!*) then
            printc "*** EXPERIMENTAL version...";
        if getd 'addsq then <<
% I assume here that this is an algebra system if ADDSQ is defined, and
% in that case process an initialisation file. Starting up without ADDSQ
% defined means I either have just RLISP built or I am in the middle of
% some bootstrap process. Also if a variable no_init_file is set to TRUE
% then I avoid init file processing.
           !*mode := 'algebraic;
           if null no!_init!_file then begin
              scalar name;
              name := assoc('shortname, lispsystem!*);
              if atom name then name := "reduce"
              else name := list2string explode2lc cdr name;
              erfg!* := nil;
              read!-init!-file name end >>
        else !*mode := 'symbolic;
        % date!* := nil;
        >>;
% % If there is a patches module that is later than one that I currently
% % have installed then load it up now.
%      if version!* neq "REDUCE Development Version"
%        then load!-patches!-file();
     w := assoc('opsys, lispsystem!*);
     if not atom w then w := cdr w;
% For MOST systems I will let ^G (bell) be the escape character, but
% under win32 I use that as an interrupt character, and so there I go
% back and use ESC instead.  I do the check at BEGIN time rather than
% further out so that common checkpoint images can be used across
% systems.
     esc!*:= compress list('!!,
                special!-char (if w = 'win32 then 10 else 9));
     while errorp errorset('(begin1), !*backtrace, !*backtrace) do nil;
     prin2t "Leaving REDUCE ... "
  end;
+++ begin compiled, 218 + 200 bytes
begin

flag('(begin),'go);nil

% The following function is used in some CSL-specific operations. It is
% also defined in util/rprint, but is repeated here to avoid loading
% that module unnecessarily, and because the definition given there is
% rather PSL specific.

% There is an ugliness here that arises because cslrend is processed during
% bootstrapping and then read a second time to create the version of it that
% will remain in the final working system. An effect is that a LOSE property
% established when it is initially loaded could cause the function concerned
% to be ignored the second time - with pretty bad conseqences. So any function
% that is defined here and needs to be tagged LOSE must have the LOSE
% property explicitly removed ahead of its definition. The same issue arises
% in a few other files that are loaded really early in the bootstrapping part
% of the Reduce build - and obviously for PSL just as much as for CSL.

remflag('(string!-downcase),'lose);nil

symbolic procedure string!-downcase u;
   compress('!" . append(explode2lc u,'(!")));
+++ string!-downcase redefined
+++ string!-downcase compiled, 14 + 16 bytes
string-downcase

% princ!-upcase and princ!-downcase are used for fortran output

flag('(string!-downcase princ!-upcase princ!-downcase),'lose);nil

% This function is used in Rlisp '88.

symbolic inline procedure igetv(u,v); getv(u,v);
+++ Record new inline definition:
(de igetv (u v) (getv u v))
(progn (de igetv (u v) (getv u v)) (put (quote igetv) (quote number!-of!-args) 2
) (put (quote igetv) (quote procedure_type) (quote (arrow (times general general
) general))) (putc (quote igetv) (quote inline) (quote (lambda (u v) (getv u v))
)))
+++ igetv compiled as link to getv
(lambda (u v) (getv u v))
symbolic inline procedure iputv(u,v,w); putv(u,v,w);
+++ Record new inline definition:
(de iputv (u v w) (putv u v w))
(progn (de iputv (u v w) (putv u v w)) (put (quote iputv) (quote
number!-of!-args) 3) (put (quote iputv) (quote procedure_type) (quote (arrow (
times general general general) general))) (putc (quote iputv) (quote inline) (
quote (lambda (u v w) (putv u v w)))))
+++ iputv compiled as link to putv
(lambda (u v w) (putv u v w))

% The following functions are NOT in Standard Lisp and should NOT be
% used anywhere in the REDUCE sources, but the amount of trouble I have
% had with places where they do creep in has encouraged me to define
% them here anyway and put up with the (small) waste of space.

% Well I note that avector/avector.red also defined these, and to keep
% the way I process inline definitions happy I must use the same name for
% the formal parameter here and there so that the definitions are exactly
% the same rather than merely equivalent in function. So it is important to
% use "u" here!

remflag('(first second third fourth rest), 'lose);nil

symbolic inline procedure first u; car u;
+++ Record new inline definition:
(de first (u) (car u))
(progn (de first (u) (car u)) (put (quote first) (quote number!-of!-args) 1) (
put (quote first) (quote procedure_type) (quote (arrow general general))) (putc
(quote first) (quote inline) (quote (lambda (u) (car u)))))
+++ first compiled as link to car
(lambda (u) (car u))

symbolic inline procedure second u; cadr u;
+++ Record new inline definition:
(de second (u) (cadr u))
(progn (de second (u) (cadr u)) (put (quote second) (quote number!-of!-args) 1)
(put (quote second) (quote procedure_type) (quote (arrow general general))) (
putc (quote second) (quote inline) (quote (lambda (u) (cadr u)))))
+++ second compiled as link to cadr
(lambda (u) (cadr u))

symbolic inline procedure third u; caddr u;
+++ Record new inline definition:
(de third (u) (caddr u))
(progn (de third (u) (caddr u)) (put (quote third) (quote number!-of!-args) 1) (
put (quote third) (quote procedure_type) (quote (arrow general general))) (putc
(quote third) (quote inline) (quote (lambda (u) (caddr u)))))
+++ third compiled as link to caddr
(lambda (u) (caddr u))

symbolic inline procedure fourth u; cadddr u;
+++ Record new inline definition:
(de fourth (u) (cadddr u))
(progn (de fourth (u) (cadddr u)) (put (quote fourth) (quote number!-of!-args) 1
) (put (quote fourth) (quote procedure_type) (quote (arrow general general))) (
putc (quote fourth) (quote inline) (quote (lambda (u) (cadddr u)))))
+++ fourth compiled as link to cadddr
(lambda (u) (cadddr u))

symbolic inline procedure rest u; cdr u;
+++ Record new inline definition:
(de rest (u) (cdr u))
(progn (de rest (u) (cdr u)) (put (quote rest) (quote number!-of!-args) 1) (put
(quote rest) (quote procedure_type) (quote (arrow general general))) (putc (
quote rest) (quote inline) (quote (lambda (u) (cdr u)))))
+++ rest compiled as link to cdr
(lambda (u) (cdr u))

flag('(first second third fourth rest), 'lose);nil

COMMENT Initial setups for REDUCE;

spare!* := 0;0    % We need this for bootstrapping.

symchar!* := t;t  % Changed prompt when in symbolic mode.


% The current CSL gensym uses an upper case G as the root,
% which causes inconsistencies in some tests (e.g., int and qsum).
% This definition cures that.

symbolic smacro procedure gensym; gensym1 'g;(lambda nil (gensym1 (quote g)))


symbolic procedure initreduce;
   initrlisp();
+++ initreduce compiled as link to initrlisp
initreduce   % For compatibility.

symbolic procedure initrlisp;
  % Initial declarations for REDUCE
  <<statcounter := 0;
    crbuflis!* := nil;
    spare!* := 0;
    !*int := t;
  >>;
+++ initrlisp compiled, 12 + 32 bytes
initrlisp

symbolic procedure rlispmain;
    lispeval '(begin);
+++ rlispmain compiled, 3 + 16 bytes
rlispmain

flag('(rdf preserve reclaim),'opfn);nil

flag('(rdf preserve),'noval);nil

flag('(load reload),'noform);nil

deflist('((load rlis) (reload rlis)),'stat);(load reload)

symbolic macro procedure load x; psl!-load(cdr x, nil);
+++ load_rw242a00rb5s2 compiled, 6 + 12 bytes
load
symbolic macro procedure reload x; psl!-load(cdr x, t);
+++ reload_5r8gmmoujli7 compiled, 6 + 16 bytes
reload

global '(psl!-loaded!*);nil
psl!-loaded!* := nil;nil

symbolic procedure psl!-load(mods, reloadp);
  for each x in mods do <<
    if reloadp or not member(x, psl!-loaded!*) then <<
%      load!-module x;
       load!-package x;
       psl!-loaded!* := union(list x, psl!-loaded!*) >> >>;
+++ psl!-load compiled, 30 + 20 bytes
psl-load

symbolic macro procedure tr x;
   list('trace, list('quote, cdr x));
+++ tr_6qgg94kugeg62 compiled, 11 + 16 bytes
tr

symbolic macro procedure untr x;
   list('untrace, list('quote, cdr x));
+++ untr_ajahltgk9lyv3 compiled, 11 + 16 bytes
untr

symbolic macro procedure trst x;
   list('traceset, list('quote, cdr x));
+++ trst_4lf8buq6y3fr2 compiled, 11 + 16 bytes
trst

symbolic macro procedure untrst x;
   list('untraceset, list('quote, cdr x));
+++ untrst_bd5d95nthyme1 compiled, 11 + 16 bytes
untrst

flag('(tr untr
      trst untrst
      ),'noform);nil

deflist('((tr rlis)     (trst rlis)
          (untr rlis)   (untrst rlis)
         ),'stat);(tr trst untr untrst)

% Now built-in to CSL
%symbolic procedure prop x; plist x;  % Yukky PSL compatibility.

COMMENT The following declarations are needed to build various modules;

flag('(mkquote spaces subla boundp error1),'lose);nil

% The exact order of items in the lists produced by these is important
% to REDUCE.
flag('(union intersection), 'lose);nil

% I USED to flag ordp as LOSE, but there are three different definitions in
% different places within Reduce and the LOSE mechanism is not quite
% refined enough to allow for the single one of them that has a version
% built into CSL directly.

flag('(threevectorp), 'lose);nil

deflist('((imports rlis)),'stat);(imports)

flag('(sort stable!-sort stable!-sortip reversip2),'lose);nil

% We also need this.

flag('(lengthc),'lose);nil
flag('(widelengthc),'lose);nil

symbolic procedure concat2(u,v); concat(u,v);
+++ concat2 compiled as link to concat
concat2

symbolic procedure concat(u,v);
   list2string append(string2list u, string2list v);
+++ concat redefined
+++ concat compiled, 11 + 16 bytes
concat

remflag('(copyd), 'lose);nil

symbolic procedure copyd(new,old);
% Copy the function definition from old id to new. For CSL this plays
% extra games with the '!*savedef property. The extra behaviour was
% originally to favour the Reduce "patching" scheme but that is no longer
% in use...
   begin scalar x;
      x := getd old;
% If loading with !*savedef = '!*savedef then the actual definitions
% do not get loaded, but the source forms do...
      if null x then progn(
        if not (!*savedef = '!*savedef)
          then rerror('rlisp,1,list(old,"has no definition in copyd")) )
      else progn(putd(new,car x,cdr x),
                 if flagp(old, 'lose) then flag(list new, 'lose) );
% The transfer of the saved definition is needed if the REDUCE "patch"
% mechanism is to work fully properly.
      if (x := get(old, '!*savedef)) then put(new, '!*savedef, x);
      return new
   end;
+++ copyd redefined
+++ copyd compiled, 50 + 44 bytes
copyd

flag('(copyd), 'lose);nil

% CSL defined a function called VECTOR but Reduce wants to as well, so I
% will move the CSL one out of the way. I rather dislike this.

if getd 'vector then <<
  copyd('csl!-vector, 'vector);
  remd 'vector >>;(expr . vector#code)

% The following is intended to run the test on a single package.
% In due course I will improve it so it also checks the output,
% but even as it is I find it useful to be able to say
%        test_package solve;
% to test the solve package (etc).

symbolic procedure test_package m;
 << load!-module 'remake;
    test_a_package list m;
    0 >>;
+++ test_package compiled, 9 + 20 bytes
test_package % because test_a_package restarts Reduce the result here should
          % never actually end up being delivered.

flag('(test_package), 'opfn);nil

% Foreign functions are EXPERIMENTAL in CSL at the time I put this in,
% but the function to invoke one is variadic...

flag('(call!-foreign!-function), 'variadic);nil

% These functions (in CSL) have optional arguments args or default
% values for final arguments, and so it is unhelpful to generate
% warning messages about excess or missing arguments.

flag('(load!-source load!-selected!-source gcd gcdn lcmn complex
       float!-sign logand land logor logior lor logxor lxor leqv
       make!-random!-state max min plus !+ times !* difference !-
       !/ !/!= !< !<!= != !> !>!= random quotient lessp greaterp
       leq geq validate!-number atan iplus itimes rseek rdf peekch
       readch readline spool dribble intern unintern remob extern
       import make!-package idapply apply funcall funcall!* values
       macroexpand macroexpand!-1 date!-and!-time error throw
       all!-symbols restart!-lisp restart!-csl symbol!-make!-fastget
       preserve nreverse append aref aset vector!-subseq!* list!-subseq!*
       char!-equal char!-not!-equal char!-lessp char!-greaterp
       char!-not!-lessp char!-not!-greaterp char!/!= char!< char!<!=
       char!> char!>!= char!= digit!-char digit!-char!-p windows!-heading
       open!-library prinhex prinoctal prinbinary make!-broadcast!-stream
       make!-concatenated!-stream make!-string!-input!-stream
       mkhash gethash puthash remhash clrhash mknewhash
       getnewhash putnewhash remnewhash clrnewhash library!-members
       resource!-limit errorset gc!-forcer
       representation stop float round floor ceiling truncate), 'variadic);nil

% Arrange (for PSL compatibility) that "on gc;" and "off gc;" switch
% garbage collector messages on or off.

put('gc, 'simpfg, '((t (verbos t))
                    (nil (verbos nil))));((t (verbos t)) (nil (verbos nil)))

global '(!*psl !*csl);nil
!*psl := nil;nil
!*csl := t;t

% Suppress RCREF error message about special being called with the wrong number of arguments

flag('(special),'naryargs);nil

endmodule;nil

end;nilmodule csl;nil  % Support for fast floating point arithmetic in CSL.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


imports ash, ash1, logand, msd;nil

exports msd!:;nil

global '(!!nbfpd);nil

remflag ('(fl2bf msd!: fix2 rndpwr timbf),'lose);nil

symbolic inline procedure fix2 u; fix u;
+++ Record new inline definition:
(de fix2 (u) (fix u))
(progn (de fix2 (u) (fix u)) (put (quote fix2) (quote number!-of!-args) 1) (put
(quote fix2) (quote procedure_type) (quote (arrow general general))) (putc (
quote fix2) (quote inline) (quote (lambda (u) (fix u)))))
+++ fix2 compiled as link to fix
(lambda (u) (fix u))

flag('(lshift ashift), 'lose);nil

symbolic inline procedure msd!: u; msd u;
+++ Record new inline definition:
(de msd!: (u) (msd u))
(progn (de msd!: (u) (msd u)) (put (quote msd!:) (quote number!-of!-args) 1) (
put (quote msd!:) (quote procedure_type) (quote (arrow general general))) (putc
(quote msd!:) (quote inline) (quote (lambda (u) (msd u)))))
+++ msd!: compiled as link to msd
(lambda (u) (msd u))

remflag('(make!:ibf), 'lose);nil

symbolic inline procedure make!:ibf (mt, ep);
  '!:rd!: . (mt . ep);
+++ Record new inline definition:
(de make!:ibf (mt ep) (cons (quote !:rd!:) (cons mt ep)))
(progn (de make!:ibf (mt ep) (cons (quote !:rd!:) (cons mt ep))) (put (quote
make!:ibf) (quote number!-of!-args) 2) (put (quote make!:ibf) (quote
procedure_type) (quote (arrow (times general general) general))) (putc (quote
make!:ibf) (quote inline) (quote (lambda (mt ep) (cons (quote !:rd!:) (cons mt
ep))))))
+++ make!:ibf compiled, 5 + 12 bytes
(lambda (mt ep) (cons (quote :rd:) (cons mt ep)))

flag('(make!:ibf), 'lose);nil

fluid '(!:bprec!:);nil

symbolic inline procedure rndpwr j;
  begin
    scalar !#w;   % I use an odd name here to avoid clashes (inline)
%   !#w := mt!: j;
    !#w := cadr j;
    if !#w = 0 then return make!:ibf(0, 0);
    !#w := inorm(!#w, !:bprec!:);
%   return make!:ibf(car !#w, cdr !#w + ep!: j)
    return make!:ibf(car !#w, cdr !#w + cddr j)
  end;
+++ Record new inline definition:
(de rndpwr (j) (prog (!#w) (setq !#w (cadr j)) (cond ((equal !#w 0) (return (
cons (quote !:rd!:) (cons 0 0))))) (setq !#w (inorm !#w !:bprec!:)) (return (
cons (quote !:rd!:) (cons (car !#w) (plus (cdr !#w) (cddr j)))))))
(progn (de rndpwr (j) (prog (!#w) (setq !#w (cadr j)) (cond ((equal !#w 0) (
return (cons (quote !:rd!:) (cons 0 0))))) (setq !#w (inorm !#w !:bprec!:)) (
return (cons (quote !:rd!:) (cons (car !#w) (plus (cdr !#w) (cddr j))))))) (put
(quote rndpwr) (quote number!-of!-args) 1) (put (quote rndpwr) (quote
procedure_type) (quote (arrow general general))) (putc (quote rndpwr) (quote
inline) (quote (lambda (j) (prog (!#w) (setq !#w (cadr j)) (cond ((equal !#w 0)
(return (cons (quote !:rd!:) (cons 0 0))))) (setq !#w (inorm !#w !:bprec!:)) (
return (cons (quote !:rd!:) (cons (car !#w) (plus (cdr !#w) (cddr j))))))))))
+++ rndpwr compiled, 28 + 24 bytes
(lambda (j) (prog (#w) (setq #w (cadr j)) (cond ((equal #w 0) (return (cons (
quote :rd:) (cons 0 0))))) (setq #w (inorm #w :bprec:)) (return (cons (quote
:rd:) (cons (car #w) (plus (cdr #w) (cddr j)))))))

symbolic procedure csl_normbf x;
   begin
      scalar mt,s;
      integer ep;
% Note I write out mt!: and ep!: here because the inlines for them are
% not yet available.
      if (mt := cadr x)=0 then return '(!:rd!: 0 . 0);
      if mt<0 then <<mt := -mt; s := t>>;
% This is pretty well the only place that the LSD function from CSL is used in Reduce.
% Reduce. Up to June 2016 it returned a result perhaps better described as
% "count trailing zeros" rather than "least significant digit". At that stage
% it was rationalized to match its name. The hack here allows fof either old
% or new behaviour.
!#if (equal (lsd 1) 0)
      ep := lsd mt;
!#else
      ep := sub1 lsd mt;
!#endif
      mt := lshift(mt, -ep);
      if s then mt := -mt;
      ep := ep + cddr x;
      return make!:ibf(mt,ep)
   end;
+++ csl_normbf redefined
+++ csl_normbf compiled, 50 + 32 bytes
csl_normbf

% Use "!#if" not "#if" for bootstrapping reasons.

!#if (not (memq 'vsl lispsystem!*))

remflag('(normbf), 'lose);nil

symbolic procedure normbf x;
   csl_normbf x;
+++ normbf compiled as link to csl_normbf
normbf

flag('(normbf), 'lose);nil

symbolic procedure csl_timbf(u, v);
  begin
     scalar m;
%    m := mt!: u * mt!: v;
     m := cadr u * cadr v;
     if m = 0 then return '(!:rd!: 0 . 0);
     m := inorm(m, !:bprec!:);
%    return make!:ibf(car m, cdr m + ep!: u + ep!: v)
     return make!:ibf(car m, cdr m + cddr u + cddr v)
  end;
+++ csl_timbf redefined
+++ csl_timbf compiled, 33 + 28 bytes
csl_timbf

symbolic inline procedure timbf(u, v); csl_timbf(u, v);
+++ Record new inline definition:
(de timbf (u v) (csl_timbf u v))
(progn (de timbf (u v) (csl_timbf u v)) (put (quote timbf) (quote
number!-of!-args) 2) (put (quote timbf) (quote procedure_type) (quote (arrow (
times general general) general))) (putc (quote timbf) (quote inline) (quote (
lambda (u v) (csl_timbf u v)))))
+++ timbf compiled as link to csl_timbf
(lambda (u v) (csl_timbf u v))

!#endif

symbolic procedure fl2bf x;
  if not fp!-finite x then rederr list("Floating point infinity or NaN",x)
  else begin scalar u;
    u := frexp x;
    x := cdr u; % mantissa between 0.5 and 1
    u := car u; % exponent
    x := fix(x*2**!!nbfpd);
    return normbf make!:ibf(x,u-!!nbfpd)
  end;
+++ fl2bf redefined
+++ fl2bf compiled, 44 + 40 bytes
fl2bf

!#if (memq 'vsl lispsystem!*)
flag ('(fl2bf msd!: fix2), 'lose);
!#else
flag ('(fl2bf msd!: fix2 rndpwr timbf), 'lose);nil
!#endif

set!-print!-precision 6;6

% The following definition is appropriate for MSDOS, and the value of
% !!maxbflexp should be OK for all IEEE systems. BEWARE if you have a
% computer with non-IEEE arithmetic, and worry a bit about !!flexperr
% (which is hardly ever used anyway...).
% I put this here to avoid having arith.red do a loop that is terminated
% by a floating point exception, since as of Nov 1994 CSL built using
% Watcom C 10.0a can not recover from such errors more than (about) ten
% times in any one run - this avoids that during system building.
%
% Hahaha - the above comments shows traces of the way in which historical
% real oddities and pain can end up frozen into code. In February 2015
% comments about the situation in November 1994 seem "historical".

global '(!!flexperr !!!~xx !!maxbflexp);nil

remflag('(find!!maxbflexp), 'lose);nil

symbolic procedure find!!maxbflexp();
  << !!flexperr := t;
     !!!~xx := expt(2.0, 1023);
     !!maxbflexp := 1022 >>;
+++ find!!maxbflexp compiled, 13 + 36 bytes
find!maxbflexp

flag('(find!!maxbflexp), 'lose);nil

inline procedure int2id x; % Turns 8-bit value into name. Only OK is under 0x80
  intern list2string list x;
+++ Record new inline definition:
(de int2id (x) (intern (list2string (list x))))
(progn (de int2id (x) (intern (list2string (list x)))) (put (quote int2id) (
quote number!-of!-args) 1) (put (quote int2id) (quote procedure_type) (quote (
arrow general general))) (putc (quote int2id) (quote inline) (quote (lambda (x)
(intern (list2string (list x)))))))
+++ int2id compiled, 6 + 12 bytes
(lambda (x) (intern (list2string (list x))))

inline procedure id2int x; % Gets first octet of UTF-8 form of name
  car string2list x;
+++ Record new inline definition:
(de id2int (x) (car (string2list x)))
(progn (de id2int (x) (car (string2list x))) (put (quote id2int) (quote
number!-of!-args) 1) (put (quote id2int) (quote procedure_type) (quote (arrow
general general))) (putc (quote id2int) (quote inline) (quote (lambda (x) (car (
string2list x))))))
+++ id2int compiled, 4 + 12 bytes
(lambda (x) (car (string2list x)))

symbolic macro procedure bothtimes u;
   list('eval!-when, '(compile load eval), cadr u);
+++ bothtimes_9j6vn20x09ui compiled, 9 + 16 bytes
bothtimes

symbolic macro procedure compiletime u;
   list('eval!-when, '(compile eval), cadr u);
+++ compiletime_1xbt328t8fvd compiled, 9 + 16 bytes
compiletime

symbolic macro procedure loadtime u;
   list('eval!-when, '(load eval), cadr u);
+++ loadtime_zmbq3prk3wqz1 compiled, 9 + 16 bytes
loadtime

put('gc, 'simpfg, '((t (verbos t)) (nil (verbos nil))));((t (verbos t)) (nil (
verbos nil)))
flag('(gc), 'switch);nil

endmodule;nil

end;nil
nil


(load!-package!-sources 'poly 'poly)module poly;nil  % Header module and low-level support for poly package.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


create!-package('(poly polrep polydiv quotf gcd exptf kernel mksp reord dmode
                 dmodeop rational rnelem gint cpxrn compopr modular
                 facform homog tdconv primfac specfac kronf conj diff
                 polyop decompos interpol subs2q subs3q subs4q horner heugcd),
                nil);
+++ Creating a package: poly
poly

flag('(poly),'core_package);nil

fluid '(!*mcd !*nosq wtl!*);nil

% switch nosq;


% Particular infix operators used in standard forms.

flag('(newtok infix), 'eval);nil 

newtok '((!. !+) add);nil

newtok '((!. !*) mult);nil

newtok '((!. !^) to);nil

newtok '((!. !* !*) to);nil

newtok '((!. !/) over);nil

infix .^,.*,.+,./;nil

% Constructors and selectors for standard forms.

% Observe a function definition using infix notation here...

inline procedure u .+ v; % Standard (polynomial) addition constructor.
   u . v;
+++ Record new inline definition:
(de add (u v) (cons u v))
(progn (de add (u v) (cons u v)) (put (quote add) (quote number!-of!-args) 2) (
put (quote add) (quote procedure_type) (quote (arrow (times general general)
general))) (putc (quote add) (quote inline) (quote (lambda (u v) (cons u v)))))
+++ add compiled as link to cons
(lambda (u v) (cons u v))

accessors lt . red, (lpow . lc) . !_, ((mvar . ldeg) . !_) . !_;nil

accessors tpow . tc, (tvar . tdeg) . !_;nil

accessors !_pvar!_ . pdeg;nil

accessors numr . denr;nil

inline procedure u .* v;  % Standard form multiplication constructor.
   u . v;
+++ Record new inline definition:
(de mult (u v) (cons u v))
(progn (de mult (u v) (cons u v)) (put (quote mult) (quote number!-of!-args) 2)
(put (quote mult) (quote procedure_type) (quote (arrow (times general general)
general))) (putc (quote mult) (quote inline) (quote (lambda (u v) (cons u v)))))
+++ mult compiled as link to cons
(lambda (u v) (cons u v))

inline procedure u ./ v; % Constructor for standard quotient.
   u . v;
+++ Record new inline definition:
(de over (u v) (cons u v))
(progn (de over (u v) (cons u v)) (put (quote over) (quote number!-of!-args) 2)
(put (quote over) (quote procedure_type) (quote (arrow (times general general)
general))) (putc (quote over) (quote inline) (quote (lambda (u v) (cons u v)))))
+++ over compiled as link to cons
(lambda (u v) (cons u v))

symbolic inline procedure domainp u; atom u or atom car u;
+++ Record new inline definition:
(de domainp (u) (or (atom u) (atom (car u))))
(progn (de domainp (u) (or (atom u) (atom (car u)))) (put (quote domainp) (quote
number!-of!-args) 1) (put (quote domainp) (quote procedure_type) (quote (arrow
general general))) (putc (quote domainp) (quote inline) (quote (lambda (u) (or (
atom u) (atom (car u)))))))
+++ domainp compiled, 8 + 12 bytes
(lambda (u) (or (atom u) (atom (car u))))


% Procedures for converting between parts of standard quotients and
% prefix forms.

symbolic procedure !*a2f u;
   % U is an algebraic expression. Value is the equivalent form
   % or an error if conversion is not possible;
   !*q2f simp!* u;
+++ !*a2f redefined
+++ !*a2f compiled, 5 + 16 bytes
*a2f

symbolic procedure !*a2k u;
   % U is an algebraic expression. Value is the equivalent kernel
   % or an error if conversion is not possible.
   % Note: earlier versions used SIMP0.
   begin scalar x;
      if kernp(x := simp!* u) then return mvar numr x
       else typerr(if null u then 0 else u,'kernel)
   end;
+++ !*a2k redefined
+++ !*a2k compiled, 21 + 28 bytes
*a2k

symbolic procedure !*a2kwoweight u;
   % U is an algebraic expression. Value is the equivalent kernel
   % neglecting any weights, or an error if conversion is not possible.
   (if kernp x then mvar numr x else typerr(u,'kernel))
    where x=simp!* u where !*uncached=t,wtl!*=nil;
+++ !*a2kwoweight redefined
+++ !*a2kwoweight compiled, 27 + 36 bytes
*a2kwoweight

symbolic procedure !*d2q u;
   % Converts domain element U into a standard quotient.
   if numberp u
     then if zerop u then nil ./ 1
   %       else if floatp u then mkfloat u ./ 1
           else u ./ 1
   % The following converts a domain rational to a SQ, which may not
   % be desirable.
   % else if eqcar(u,'!:rn!:) and !*mcd then cdr u
    else if !:zerop u then nil ./ 1 else u ./ 1;
+++ !*d2q redefined
+++ !*d2q compiled, 30 + 16 bytes
*d2q

symbolic procedure !*ff2a(u,v);
   % Converts ratio of two forms U and V to a prefix form.
   (if wtl!* then prepsq x else mk!*sq x) where x = cancel( u ./ v);
+++ !*ff2a redefined
+++ !*ff2a compiled, 12 + 24 bytes
*ff2a

inline procedure !*f2a u; prepf u;
+++ Record new inline definition:
(de !*f2a (u) (prepf u))
(progn (de !*f2a (u) (prepf u)) (put (quote !*f2a) (quote number!-of!-args) 1) (
put (quote !*f2a) (quote procedure_type) (quote (arrow general general))) (putc
(quote !*f2a) (quote inline) (quote (lambda (u) (prepf u)))))
+++ !*f2a compiled as link to prepf
(lambda (u) (prepf u))

inline procedure !*f2q u;
   % U is a standard form, value is a standard quotient.
   u . 1;
+++ Record new inline definition:
(de !*f2q (u) (cons u 1))
(progn (de !*f2q (u) (cons u 1)) (put (quote !*f2q) (quote number!-of!-args) 1)
(put (quote !*f2q) (quote procedure_type) (quote (arrow general general))) (putc
(quote !*f2q) (quote inline) (quote (lambda (u) (cons u 1)))))
+++ !*f2q compiled, 4 + 12 bytes
(lambda (u) (cons u 1))

inline procedure !*k2f u;
   % U is a kernel, value is a standard form.
   list((u .** 1) . 1);
+++ Record new inline definition:
(de !*k2f (u) (list (cons (to u 1) 1)))
(progn (de !*k2f (u) (list (cons (to u 1) 1))) (put (quote !*k2f) (quote
number!-of!-args) 1) (put (quote !*k2f) (quote procedure_type) (quote (arrow
general general))) (putc (quote !*k2f) (quote inline) (quote (lambda (u) (list (
cons (to u 1) 1))))))
+++ !*k2f compiled, 7 + 16 bytes
(lambda (u) (list (cons (to u 1) 1)))

symbolic inline procedure !*kk2f u;
   % U is a non-unique kernel, value is a standard form.
   list(mksp(u,1) . 1);
+++ Record new inline definition:
(de !*kk2f (u) (list (cons (mksp u 1) 1)))
(progn (de !*kk2f (u) (list (cons (mksp u 1) 1))) (put (quote !*kk2f) (quote
number!-of!-args) 1) (put (quote !*kk2f) (quote procedure_type) (quote (arrow
general general))) (putc (quote !*kk2f) (quote inline) (quote (lambda (u) (list
(cons (mksp u 1) 1))))))
+++ !*kk2f compiled, 7 + 16 bytes
(lambda (u) (list (cons (mksp u 1) 1)))

symbolic inline procedure !*kk2q u;
   % U is a non-unique kernel, value is a standard quotient.
   list(mksp(u,1) .* 1) ./ 1;
+++ Record new inline definition:
(de !*kk2q (u) (cons (list (cons (mksp u 1) 1)) 1))
(progn (de !*kk2q (u) (cons (list (cons (mksp u 1) 1)) 1)) (put (quote !*kk2q) (
quote number!-of!-args) 1) (put (quote !*kk2q) (quote procedure_type) (quote (
arrow general general))) (putc (quote !*kk2q) (quote inline) (quote (lambda (u)
(cons (list (cons (mksp u 1) 1)) 1)))))
+++ !*kk2q compiled, 9 + 16 bytes
(lambda (u) (cons (list (cons (mksp u 1) 1)) 1))

inline procedure !*k2q u;
   % U is a kernel, value is a standard quotient.
   list((u .** 1) . 1) . 1;
+++ Record new inline definition:
(de !*k2q (u) (cons (list (cons (to u 1) 1)) 1))
(progn (de !*k2q (u) (cons (list (cons (to u 1) 1)) 1)) (put (quote !*k2q) (
quote number!-of!-args) 1) (put (quote !*k2q) (quote procedure_type) (quote (
arrow general general))) (putc (quote !*k2q) (quote inline) (quote (lambda (u) (
cons (list (cons (to u 1) 1)) 1)))))
+++ !*k2q compiled, 9 + 16 bytes
(lambda (u) (cons (list (cons (to u 1) 1)) 1))

symbolic procedure !*n2f u;
   % U is a number. Value is a standard form.
   if zerop u then nil else u;
+++ !*n2f redefined
+++ !*n2f compiled, 6 + 8 bytes
*n2f

inline procedure !*p2f u;
   % U is a standard power, value is a standard form.
   list(u . 1);
+++ Record new inline definition:
(de !*p2f (u) (list (cons u 1)))
(progn (de !*p2f (u) (list (cons u 1))) (put (quote !*p2f) (quote
number!-of!-args) 1) (put (quote !*p2f) (quote procedure_type) (quote (arrow
general general))) (putc (quote !*p2f) (quote inline) (quote (lambda (u) (list (
cons u 1))))))
+++ !*p2f compiled, 5 + 12 bytes
(lambda (u) (list (cons u 1)))

inline procedure !*p2q u;
   % U is a standard power, value is a standard quotient.
   list(u . 1) . 1;
+++ Record new inline definition:
(de !*p2q (u) (cons (list (cons u 1)) 1))
(progn (de !*p2q (u) (cons (list (cons u 1)) 1)) (put (quote !*p2q) (quote
number!-of!-args) 1) (put (quote !*p2q) (quote procedure_type) (quote (arrow
general general))) (putc (quote !*p2q) (quote inline) (quote (lambda (u) (cons (
list (cons u 1)) 1)))))
+++ !*p2q compiled, 7 + 12 bytes
(lambda (u) (cons (list (cons u 1)) 1))

symbolic procedure !*q2a u;
   % U is a standard quotient, value is an algebraic expression.
   !*q2a1(u,!*nosq);
+++ !*q2a redefined
+++ !*q2a compiled, 4 + 16 bytes
*q2a

symbolic procedure !*q2a1(u,v);
   if null v then mk!*sq u else prepsqxx u;
+++ !*q2a1 redefined
+++ !*q2a1 compiled, 10 + 16 bytes
*q2a1

symbolic procedure !*q2f u;
   % U is a standard quotient, value is a standard form.
   if denr u=1 then numr u else typerr(prepsq u,'polynomial);
+++ !*q2f redefined
+++ !*q2f compiled, 11 + 24 bytes
*q2f

symbolic procedure !*q2k u;
   % U is a standard quotient, value is a kernel or an error if
   % conversion not possible.
   if kernp u then mvar numr u else typerr(prepsq u,'kernel);
+++ !*q2k compiled, 16 + 24 bytes
*q2k

inline procedure !*t2f u;
   % U is a standard term, value is a standard form.
   list u;
+++ Record new inline definition:
(de !*t2f (u) (list u))
(progn (de !*t2f (u) (list u)) (put (quote !*t2f) (quote number!-of!-args) 1) (
put (quote !*t2f) (quote procedure_type) (quote (arrow general general))) (putc
(quote !*t2f) (quote inline) (quote (lambda (u) (list u)))))
+++ !*t2f compiled as link to list
(lambda (u) (list u))

inline procedure !*t2q u;
   % U is a standard term, value is a standard quotient.
   list u . 1;
+++ Record new inline definition:
(de !*t2q (u) (cons (list u) 1))
(progn (de !*t2q (u) (cons (list u) 1)) (put (quote !*t2q) (quote
number!-of!-args) 1) (put (quote !*t2q) (quote procedure_type) (quote (arrow
general general))) (putc (quote !*t2q) (quote inline) (quote (lambda (u) (cons (
list u) 1)))))
+++ !*t2q compiled, 5 + 12 bytes
(lambda (u) (cons (list u) 1))

endmodule;nil

end;nilmodule polrep;nil % Arithmetic operations on standard forms and quotients.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*asymp!* !*exp !*factor !*gcd !*lcm !*mcd !*rationalize frlis!*
        !*roundall !*rounded !*sqfree !*sub2 asymplis!* dmode!* subfg!*
        ncmp!* powlis!* wtl!* !*!*processed !*ncmp);nil

global '(!*group rd!-tolerance!* cr!-tolerance!* !*physop!-loaded
         !*sstools!-loaded);nil

put('roundall,'simpfg,'((t (rmsubs))));((t (rmsubs)))

switch roundall;nil

!*roundall := t;t   % Default is on.

symbolic inline procedure subtrsq(u,v); addsq(u,negsq v);
+++ Record new inline definition:
(de subtrsq (u v) (addsq u (negsq v)))
(progn (de subtrsq (u v) (addsq u (negsq v))) (put (quote subtrsq) (quote
number!-of!-args) 2) (put (quote subtrsq) (quote procedure_type) (quote (arrow (
times general general) general))) (putc (quote subtrsq) (quote inline) (quote (
lambda (u v) (addsq u (negsq v))))))
+++ subtrsq compiled, 8 + 16 bytes
(lambda (u v) (addsq u (negsq v)))

symbolic procedure addsq(u,v);
   % U and V are standard quotients.
   % Value is canonical sum of U and V.
   if null numr u then v
    else if null numr v then u
    else if denr u=1 and denr v=1 then addf(numr u,numr v) ./ 1
    else begin scalar x,y,z;
        if null !*exp then <<u := numr u ./ mkprod denr u;
                             v := numr v ./ mkprod denr v>>;
        if !*lcm then x := gcdf!*(denr u,denr v)
         else x := gcdf(denr u,denr v);
        z := canonsq(quotf!-fail(denr u,x) ./ quotf!-fail(denr v,x));
        y := addf(multf(denr z,numr u),multf(numr z,numr v));
        if null y then return nil ./ 1;
        z := multf(denr u,denr z);
        if (x := gcdf(y,x)) neq 1 then <<y := quotf!-fail(y,x);
                                         z := quotf!-fail(z,x)>>;
        if !*gcd then return if x=1 then y ./ z else canonsq(y ./ z);
% If gcd is off (which is the default) y and z can still have an
% incomplete gcd. Therefore to ensure full simplification we need to
% take (the incomplete) gcd of y and z and divide it out.
        return if (x := gcdf(y,z))=1 then canonsq(y ./ z)
                else canonsq(quotf!-fail(y,x) ./ quotf!-fail(z,x))
    end;
+++ addsq redefined
+++ addsq compiled, 139 + 52 bytes
addsq

symbolic procedure multsq(u,v);
   % U and V are standard quotients.
   % Value is canonical product of U and V.
   if null numr u or null numr v then nil ./ 1
    else if denr u=1 and denr v=1 then multf(numr u,numr v) ./ 1
    else begin scalar x,y,z;
        x := gcdf(numr u,denr v);
        y := gcdf(numr v,denr u);
        z := multf(quotf!-fail(numr u,x),quotf!-fail(numr v,y));
        x := multf(quotf!-fail(denr u,y),quotf!-fail(denr v,x));
        return canonsq(z ./ x)
    end;
+++ multsq redefined
+++ multsq compiled, 59 + 28 bytes
multsq

symbolic procedure negsq u; negf numr u ./ denr u;
+++ negsq redefined
+++ negsq compiled, 5 + 12 bytes
negsq

inline procedure multpq(u,v);
   multsq(!*p2q u,v);
+++ Record new inline definition:
(de multpq (u v) (multsq (cons (list (cons u 1)) 1) v))
(progn (de multpq (u v) (multsq (cons (list (cons u 1)) 1) v)) (put (quote
multpq) (quote number!-of!-args) 2) (put (quote multpq) (quote procedure_type) (
quote (arrow (times general general) general))) (putc (quote multpq) (quote
inline) (quote (lambda (u v) (multsq (cons (list (cons u 1)) 1) v)))))
+++ multpq compiled, 9 + 16 bytes
(lambda (u v) (multsq (cons (list (cons u 1)) 1) v))

symbolic procedure cancel u;
   %returns canonical form of non-canonical standard form U;
   if !*mcd or denr u=1 then multsq(numr u ./ 1,1 ./ denr u)
    else multsq(numr u ./ 1,simpexpt list(mk!*sq(denr u ./ 1),-1));
+++ cancel redefined
+++ cancel compiled, 31 + 32 bytes
cancel


% ***** FUNCTIONS FOR ADDING AND MULTIPLYING STANDARD FORMS *****

symbolic inline procedure peq(u,v);
% tests for equality of powers U and V. This now INSISTS that kernels
% are kept stored uniquely so I can use EQ rather than EQUAL to compare
% them.
   car u eq car v and eqn(cdr u, cdr v);
+++ Record new inline definition:
(de peq (u v) (and (eq (car u) (car v)) (eqn (cdr u) (cdr v))))
(progn (de peq (u v) (and (eq (car u) (car v)) (eqn (cdr u) (cdr v)))) (put (
quote peq) (quote number!-of!-args) 2) (put (quote peq) (quote procedure_type) (
quote (arrow (times general general) general))) (putc (quote peq) (quote inline)
(quote (lambda (u v) (and (eq (car u) (car v)) (eqn (cdr u) (cdr v)))))))
+++ peq compiled, 10 + 8 bytes
(lambda (u v) (and (eq (car u) (car v)) (eqn (cdr u) (cdr v))))


%symbolic procedure addf(u,v);
%   % U and V are standard forms. Value is standard form for U+V.
%   if null u then v
%    else if null v then u
%    else if domainp u then addd(u,v)
%    else if domainp v then addd(v,u)
%    else if peq(lpow u,lpow v)
%       then (if null x then y else lpow u .* x .+ y)
%             where x=addf(lc u,lc v),y=addf(red u,red v)
%    else if ordpp(lpow u,lpow v) then lt u .+ addf(red u,v)
%    else lt v .+ addf(u,red v);

% Now a version that avoids having a recursion depth that is as
% deep as the length of the polynomial. I will still permit
% myself recursion to a depth equal to to the number of distinct
% variables that are present.

symbolic procedure addf(u,v);
  % U and V are standard forms. Value is standard form for U+V.
  begin
    scalar r, w;
% r will end up as a (reversed) list of items to be put
% in front of the terminating item w.
  top:
    if null u then << w := v; go to exit >>
    else if null v then << w := u; go to exit >>
    else if domainp u then << w := addd(u, v); go to exit >>
    else if domainp v then << w := addd(v, u); go to exit >>
    else if peq(lpow u, lpow v) then <<
      w := addf(lc u, lc v);
      if not null w then r := (lpow u .* w) .+ r;
      u := red u;
      v := red v >>
    else if ordpp(lpow u, lpow v) then <<
      r := lt u .+ r;
      u := cdr u >>
    else <<
      r := lt v .+ r;
      v := red v >>;
    go to top;
  exit:
    while r do <<
      u := cdr r;
      rplacd(r, w);
      w := r;
      r := u >>;
    return w;
  end;
+++ addf compiled, 99 + 16 bytes
addf

symbolic procedure addd(u,v);
   % U is a domain element, V a standard form.
   % Value is a standard form for U+V.
   if null v then u
    else if domainp v then adddm(u,v)
    else lt v .+ addd(u,red v);
+++ addd redefined
+++ addd compiled, 29 + 12 bytes
addd

symbolic procedure adddm(u,v);
   % U and V are both non-zero domain elements.
   % Value is standard form for U+V.
   % The int-equiv-chk is needed to convert say (:MOD: . 0) to NIL.
   % A simpler function might therefore be possible and more efficient.
   if atom u and atom v
     then (if null dmode!* or not flagp(dmode!*,'convert) then !*n2f x
            else int!-equiv!-chk apply1(get(dmode!*,'i2d),x))
          where x=plus2(u,v)
    else dcombine(u,v,'plus);
+++ adddm redefined
+++ adddm compiled, 32 + 28 bytes
adddm

% in poly.red
% symbolic inline procedure domainp u; atom u or atom car u;

symbolic procedure noncomp u;
   !*ncmp and noncomp1 u;
+++ noncomp redefined
+++ noncomp compiled, 7 + 16 bytes
noncomp

symbolic procedure noncomp1 u;
  if null pairp u then nil
   else if pairp car u then noncomfp u
   else if car u eq '!*sq then noncomfp numr cadr u
   else if car u eq 'taylor!* then nil
   else if car u eq 'mat then noncomlistp cadr u
   else flagp(car u,'noncom) or noncomlistp cdr u;
+++ noncomp1 redefined
+++ noncomp1 compiled, 50 + 32 bytes
noncomp1

symbolic procedure noncomlistp u;
   pairp u and (noncomp1 car u or noncomlistp cdr u);
+++ noncomlistp redefined
+++ noncomlistp compiled, 13 + 12 bytes
noncomlistp

% The physop module defines a new versions of multf and multfnc. Having name
% clashes and function redefinitions causes pain for the CSL optimisation
% model, so here I make physop just set a flag so that multf and multfnc can
% divert into its version. A nicer solution will be to consolidate the two
% versions into one, but for now I am not ready to go that far. Maybe somebody
% who really understand the physop code will feel like working on that at
% some time. 

symbolic procedure multf(u, v);
  if !*physop!-loaded then physop!-multf(u, v)
  else poly!-multf(u, v);
+++ multf redefined
+++ multf compiled, 10 + 20 bytes
multf

symbolic procedure poly!-multf(u,v);
   % U and V are standard forms.
   % Value is standard form for U*V.
   begin scalar x,y;
    a:  if null u or null v then return nil
         else if u=1 then return v     % ONEP
         else if v=1 then return u     % ONEP
         else if domainp u then return multd(u,v)
         else if domainp v then return multd(v,u)
         else if not(!*exp or ncmp!* or wtl!* or x)
          then <<u := mkprod u; v := mkprod v; x := t; go to a>>;
        x := mvar u;
        y := mvar v;
        if noncomfp v and (noncomp x or null !*!*processed)
          then return poly!-multfnc(u,v)
         else if x eq y
          then <<% Allow for free variables in rules.
                 if not fixp ldeg u or not fixp ldeg v
                   then x := x .** reval list('plus,ldeg u,ldeg v)
                  else x := mkspm(x,ldeg u+ldeg v);
                 % The order in the next line is IMPORTANT. See analysis
                 % by J.H. Davenport et al. for details.
                 y := addf(poly!-multf(red u,v),poly!-multf(!*t2f lt u,red v));
                 return if null x or null(u := poly!-multf(lc u,lc v))
                    then <<!*asymp!* := t; y>>
                   else if x=1 then addf(u,y)
                   else if null !*mcd then addf(!*t2f(x .* u),y)
                   else x .* u .+ y>>
         else if ordop(x,y)
          then <<x := poly!-multf(lc u,v);
                 y := poly!-multf(red u,v);
                 return if null x then y else lpow u .* x .+ y>>;
        x := poly!-multf(u,lc v);
        y := poly!-multf(u,red v);
        return if null x then y else lpow v .* x .+ y
   end;
+++ poly!-multf redefined
+++ poly!-multf compiled, 204 + 84 bytes
poly-multf

symbolic procedure noncomfp u;
   % It's possible that ncmp!* would work here.
   !*ncmp and noncomfp1 u;
+++ noncomfp redefined
+++ noncomfp compiled, 7 + 16 bytes
noncomfp

symbolic procedure noncomfp1 u;
   not domainp u
      and (noncomp mvar u or noncomfp1 lc u or noncomfp1 red u);
+++ noncomfp1 redefined
+++ noncomfp1 compiled, 21 + 12 bytes
noncomfp1

symbolic procedure multfnc(u,v);
  if !*physop!-loaded then physop!-multfnc(u, v)
   else if !*sstools!-loaded then sstools!-multfnc(u,v) 
   else poly!-multfnc(u, v);
+++ multfnc compiled, 17 + 28 bytes
multfnc

symbolic procedure poly!-multfnc(u,v);
   % Returns canonical product of U and V, with both main vars non-
   % commutative.
   if !*sstools!-loaded then sstools!-multfnc(u,v) else
   begin scalar x,y;
      x := poly!-multf(lc u,!*t2f lt v);
      if null x then nil
       else if not domainp x and mvar x eq mvar u
        then x := addf(if null (y := mkspm(mvar u,ldeg u+ldeg x))
                         then nil
                        else if y = 1 then lc x
                        else !*t2f(y .* lc x),
                       poly!-multf(!*p2f lpow u,red x))
       else if noncomp mvar u then x := !*t2f(lpow u .* x)
       else x := poly!-multf(!*p2f lpow u,x) where !*!*processed=t;
      return addf(x,addf(poly!-multf(red u,v),poly!-multf(!*t2f lt u,red v)))
   end;
+++ poly!-multfnc redefined
+++ poly!-multfnc compiled, 119 + 48 bytes
poly-multfnc

symbolic procedure multd(u,v);
   % U is a domain element, V a standard form.
   % Value is standard form for U*V.
   if null v then nil
    else if v=1 then u      % Common enough to be tested.
    else if domainp v then multdm(u,v)
    else lpow v .* multd(u,lc v) .+ multd(u,red v);
+++ multd redefined
+++ multd compiled, 40 + 20 bytes
multd

symbolic procedure multdm(u,v);
   % U and V are both non-zero domain elements.
   % Value is standard form for U*V;
   if atom u and atom v
     then (lambda x; if null dmode!*
                        or not flagp(dmode!*,'convert) then x
                      else % int!-equiv!-chk
                              apply1(get(dmode!*,'i2d),x))
           times2(u,v)
    else dcombine(u,v,'times);
+++ multdm redefined
+++ multdm compiled, 27 + 20 bytes
multdm

inline procedure multpf(u,v); multf(!*p2f u,v);
+++ Record new inline definition:
(de multpf (u v) (multf (list (cons u 1)) v))
(progn (de multpf (u v) (multf (list (cons u 1)) v)) (put (quote multpf) (quote
number!-of!-args) 2) (put (quote multpf) (quote procedure_type) (quote (arrow (
times general general) general))) (putc (quote multpf) (quote inline) (quote (
lambda (u v) (multf (list (cons u 1)) v)))))
+++ multpf compiled, 7 + 16 bytes
(lambda (u v) (multf (list (cons u 1)) v))

symbolic procedure negf u;
   if null u then nil
    else if domainp u
           then !:minus if atom u and flagp(dmode!*,'convert)
                          then apply1(get(dmode!*,'i2d),u)
                         else u
    else lpow u .* negf lc u .+ negf red u;
+++ negf redefined
+++ negf compiled, 45 + 20 bytes
negf

symbolic procedure degreef(pol,var);
   % Find degree of kernel in standard form pol.
   % Note: uniqueness of kernel assumed.
   if domainp pol then 0
    else if mvar pol eq var then ldeg pol
    else max(degreef(lc pol,var),degreef(red pol,var));
+++ degreef redefined
+++ degreef compiled, 27 + 16 bytes
degreef

put('!*sq,'lengthfn,'!*sqlength);*sqlength

symbolic procedure !*sqlength u;
   (if denr car u=1 then x else x+termsf denr car u)
    where x = termsf numr car u;
+++ !*sqlength compiled, 17 + 16 bytes
*sqlength

symbolic procedure terms u;
   <<lprim "Please use LENGTH instead"; termsf numr simp!* u>>;
+++ terms compiled, 9 + 24 bytes
terms

flag('(terms),'opfn);nil

flag('(terms),'noval);nil

symbolic procedure termsf u;
   % U is a standard form.
   % Value is number of terms in U (excluding kernel structure).
   begin integer n;
      while not domainp u do <<n := n + termsf lc u; u := red u>>;
      return if null u then n else n+1
   end;
+++ termsf redefined
+++ termsf compiled, 27 + 12 bytes
termsf

symbolic procedure tmsf u;
   % U is a standard form.
   % Value is number of terms in U (including kernel structure).
   begin integer n; scalar x;
    % Integer declaration initializes N to 0.
      while not domainp u do
       <<n := n+(if sfp(x := mvar u) then tmsf x else 1)+tmsf!* lc u;
         if ldeg u neq 1 then if ldeg u=2 then n := n+1 else n := n+2;
         u := red u>>;   % Previously, if U was non-zero, we used to add
                         % one more here.
      return if null u then n else n+1
   end;
+++ tmsf redefined
+++ tmsf compiled, 58 + 28 bytes
tmsf

symbolic procedure tmsf!* u;
   if numberp u and abs fix u=1 then 0 else tmsf u;
+++ tmsf!* redefined
+++ tmsf!* compiled, 16 + 20 bytes
tmsf* % Was tmsf u+1.

symbolic procedure tms u; tmsf numr simp!* u;
+++ tms compiled, 6 + 16 bytes
tms

flag('(tms),'opfn);nil

flag('(tms),'noval);nil


% ***** FUNCTIONS FOR WORKING WITH STRUCTURED FORMS *****

fluid '(!*really_off_exp);nil

symbolic procedure offexpchk u;
   % Return structured form for standard quotient u.
   % The freevar check is required to correctly evaluate rules like
   % for all n let f(a^n-b^n)=c when exp is off and gcd on.
   if !*really_off_exp or
        (frlis!* and freevarinexptchk numr u or freevarinexptchk denr u)
     then u
    else canprod(mkprod numr u,mkprod denr u);
+++ offexpchk redefined
+++ offexpchk compiled, 24 + 28 bytes
offexpchk

symbolic procedure freevarinexptchk u;
   not domainp u and(not numberp ldeg u or freevarinexptchk lc u
                                   or freevarinexptchk red u);
+++ freevarinexptchk redefined
+++ freevarinexptchk compiled, 22 + 12 bytes
freevarinexptchk

symbolic procedure mkprod u;
   begin scalar w,x,y,z,!*exp,!*sub2;
      if null u or kernlp u then return u;
      % First make sure there are no further simplifications.
      !*sub2 := t;
      x := subs2(u ./ 1);
      if denr x neq 1 then return u  % We can't do much more here.
       else if numr x neq u
        then <<u := numr x; if null u or kernlp u then return u>>;
      !*exp := t;
      w := ckrn u;
      u := quotf(u,w);
      x := expnd u;
      if null x or kernlp x then return multf(w,x);
      % After this point, X is not KERNLP.
      % The check below for *MCD was suggested by James Davenport.
      % Without it, on gcd; off mcd,exp; (x**2+2x+1)/x+1; loops
      % forever.
      if !*mcd and (!*sqfree or !*factor or !*gcd)
        then y := fctrf x
       else <<y := ckrn x; x := quotf(x,y); y := list(y,x . 1)>>;
      if cdadr y>1 or cddr y
        then <<z := car y;
               for each j in cdr y do
                  z := multf(mksp!*(car j,cdr j),z)>>
       else if not !*group and tmsf u>tmsf caadr y
        then z := multf(mksp!*(caadr y,cdadr y),car y)
       else z := mksp!*(u,1);
      return multf(w,z)
   end;
+++ mkprod redefined
+++ mkprod compiled, 184 + 84 bytes
mkprod

symbolic procedure expnd u;
  if !*really_off_exp then u else
   begin scalar !*sub2,v;
      u := expnd1 u;
      return if !*sub2 and denr(v := subs2f u) = 1 then numr v
              else u
   end;
+++ expnd redefined
+++ expnd compiled, 26 + 32 bytes
expnd

symbolic procedure expnd1 u;
   if domainp u then u
    else addf(if not sfp mvar u or ldeg u<0
                then multpf(lpow u,expnd1 lc u)
        else multf(exptf(expnd1 mvar u,ldeg u),expnd1 lc u),
                        expnd1 red u);
+++ expnd1 redefined
+++ expnd1 compiled, 63 + 28 bytes
expnd1

symbolic procedure canprod(p,q);
   % P and Q are kernel product standard forms, value is P/Q in
   % which a  top level standard form kernel by itself has been
   % unwound.
   begin scalar v,w,x,y,z;
      if domainp q or red q or (not domainp p and red p)
        then return cancel(p ./ q);
      % Look for possible cancellations.
      while not domainp p or not domainp q do
      if sfpf p then <<z := cprod1(mvar p,ldeg p,v,w);
                       v := car z; w := cdr z; p := lc p>>
       else if sfpf q then <<z := cprod1(mvar q,ldeg q,w,v);
                             w := car z; v := cdr z; q := lc q>>
       else if domainp p then <<y := lpow q . y; q := lc q>>
       else if domainp q then <<x := lpow p . x; p := lc p>>
       else <<x := lpow p . x; y := lpow q . y;
              p := lc p; q := lc q>>;
      v := reprod(v,reprod(x,p));
      w := reprod(w,reprod(y,q));
      if minusf w then <<v := negf v; w := negf w>>;
      w := cancel(v ./ w);
      % Final check for unnecessary structure.
      v := numr w;
      if not domainp v and null red v and lc v=1
         and ldeg v=1 and sfp(x := mvar v)
        then v := x;
      w := denr w;
      if not domainp w and null red w and lc w=1
         and ldeg w=1 and sfp(x := mvar w)
        then w := x;
      return canonsq(v ./ w)
   end;
+++ canprod compiled, 235 + 44 bytes
canprod

symbolic procedure sfpf u;
   not domainp u and sfp mvar u;
+++ sfpf redefined
+++ sfpf compiled, 11 + 12 bytes
sfpf

symbolic procedure sfp u;
   % True if mvar U is a standard form.
   not atom u and not atom car u;
+++ sfp redefined
+++ sfp compiled, 9 + 12 bytes
sfp

symbolic procedure reprod(u,v);
   % U is a list of powers, V a standard form.
   % Value is product of terms in U with V.
   <<while u do <<v := multpf(car u,v); u := cdr u>>; v>>;
+++ reprod redefined
+++ reprod compiled, 16 + 16 bytes
reprod

symbolic procedure cprod1(p,m,v,w);
   % U is a standard form, which occurs in a kernel raised to power M.
   % V is a list of powers multiplying P**M, W a list dividing it.
   % Value is a dotted pair of lists of powers after all possible
   % kernels have been cancelled.
   begin scalar z;
      z := cprod2(p,m,w,nil);
      w := cadr z;
      v := append(cddr z,v);
      z := cprod2(car z,m,v,t);
      v := cadr z;
      w := append(cddr z,w);
      if car z neq 1 then v := mksp(car z,m) . v;
      return v . w
   end;
+++ cprod1 compiled, 56 + 24 bytes
cprod1

symbolic procedure cprod2(p,m,u,b);
   %P and M are as in CPROD1. U is a list of powers. B is true if P**M
   %multiplies U, false if it divides.
   %Value has three parts: the first is the part of P which does not
   %have any common factors with U, the second a list of powers (plus
   %U) which multiply U, and the third a list of powers which divide U;
   %it is implicit here that the kernel standard forms are positive;
   begin scalar n,v,w,y,z;
      while u and p neq 1 do
        <<if (z := gcdf(p,caar u)) neq 1
            then
           <<p := quotf!-fail(p,z);
             y := quotf!-fail(caar u,z);
             if y neq 1 then v := mksp(y,cdar u) . v;
             if b then v := mksp(z,m+cdar u) . v
              else if (n := m-cdar u)>0 then w := mksp(z,n) . w
              else if n<0 then v := mksp(z,-n) . v>>
            else v := car u . v;
           u := cdr u>>;
      return (p . nconc!*(u,v) . w)
   end;
+++ cprod2 compiled, 107 + 32 bytes
cprod2

symbolic procedure mkspm(u,p);
   %U is a unique kernel, P an integer;
   %value is 1 if P=0, NIL if U**P is 0, else standard power of U**P;
   % should we add a check for NOT(U EQ K!*) in first line?
   if p=0 then 1
    else begin scalar x;
        if subfg!* and (x:= atsoc(u,asymplis!*)) and cdr x<=p
          then return nil;
        sub2chk u;
        return u .** p
   end;
+++ mkspm redefined
+++ mkspm compiled, 25 + 32 bytes
mkspm

symbolic procedure sub2chk u;
   %determines if kernel U is such that a power substitution is
   %necessary;
   if subfg!*
      and(atsoc(u,powlis!*) or not atom u and car u memq '(expt sqrt))
     then !*sub2 := t;
+++ sub2chk redefined
+++ sub2chk compiled, 19 + 28 bytes
sub2chk


% ***** FUNCTIONS FOR DIVIDING STANDARD FORMS *****

symbolic procedure quotsq(u,v);
   multsq(u,invsq v);
+++ quotsq redefined
+++ quotsq compiled, 8 + 16 bytes
quotsq

symbolic procedure quotf!*(u,v);
   % We do the rationalizesq step to allow for surd divisors.
   if null u then nil
    else (if x then x
           else (if denr y = 1 then numr y
                  else errach list("DIVISION FAILED",u,v))
                 where y=rationalizesq(u ./ v))
          where x=quotf(u,v);
+++ quotf!* redefined
+++ quotf!* compiled, 26 + 28 bytes
quotf*

symbolic procedure quotf(u,v);
   quotf1(u,v) where !*exp = t;
+++ quotf redefined
+++ quotf compiled, 11 + 24 bytes
quotf

symbolic procedure quotf1(p,q);
   % P and Q are standard forms.
   % Value is the quotient of P and Q if it exists or NIL.
   if null p then nil
    else if p=q then 1
    else if q=1 then p
    else if domainp q then quotfd(p,q)
    else if domainp p then nil
    else if mvar p eq mvar q
     then begin scalar u,v,w,x,xx,y,z,z1; integer n;
    a:if idp(u := rank p) or idp(v := rank q) or u<v then return nil;
        % The above IDP test is because of the possibility of a free
        % variable in the degree position from LET statements.
        u := lt!* p;
        v := lt!* q;
        w := mvar q;
        x := quotf1(tc u,tc v);
        if null x then return nil;
        n := tdeg u-tdeg v;
        if n neq 0 then y := w .** n;
%       p := addf2zro(p,multf(if n=0 then q
%       p := addf(p,multf(negf x,if n=0 then q else multpf(y,q)));
        xx := multf(negf x,red q);
        % The following expression for p explicitly calculates the
        % needed remainder.  It has to be this way for non-commuting
        % expressions.
        p := addf(red p,if n=0 then xx else multpf(y,xx));
        % Leading terms of P and Q do not cancel if MCD is off. However,
        % there may be a problem with off exp.
        if p and (domainp p or not(mvar p eq w)) then return nil
         else if n=0 then go to b;
        z := aconc!*(z,y .* x);
        %provided we have a non-zero power of X, terms
        %come out in right order;
        if null p then return if z1 then rnconc(z,z1) else z;
        go to a;
    b:  if null p then return rnconc(z,x)
         else if !*mcd then return nil
         else z1 := x;
        go to a
   end
    else if ordop(mvar p,mvar q) then quotk(p,q)
    else nil;
+++ quotf1 redefined
+++ quotf1 compiled, 182 + 68 bytes
quotf1

% symbolic procedure addf2zro(p,q);
%    <<q := addf(p,q);
%      if not dmode!* memq '(!:rd!: !:cr!:)
%         or null q or null (p := quotf(q,p)) then q
%      else if domainp p then
%         if eqcar(p,'!:rd!:)
%            and lessp!:(abs!: bfloat round!* p,rd!-tolerance!*)
%         or eqcar(p,'!:cr!:)
%        and (lessp!:(plus!:(times!:(x,x),times!:(y,y)),cr!-tolerance!*)
%               where x=bfloat round!* tagrl p,y=bfloat round!* tagim p)
%        then nil else q>>;

symbolic procedure rnconc(u,v);
   if null u then v
    else if !*ncmp and noncomfp1 u and noncomfp1 v then addf(u,v)
    else begin scalar w;
   % This is like nconc, but doesn't assume its second argument is a
   % list.
            w := u;
            while cdr w do <<w := cdr w>>;
            rplacd(w,v);
            return u
         end;
+++ rnconc redefined
+++ rnconc compiled, 34 + 20 bytes
rnconc

symbolic procedure quotfd(p,q);
   % P is a standard form, Q a domain element.
   % Value is P/Q if exact division is possible, or NIL otherwise.
   if p=q then 1
   else if flagp(dmode!*,'field) then divd(p,q)
   else if domainp p then quotdd(p,q)
   else quotk(p,q);
+++ quotfd redefined
+++ quotfd compiled, 28 + 28 bytes
quotfd

symbolic procedure divd(v,u);
   % U is a domain element, V a standard form.
   % Value is standard form for V/U.
   if null u
     then if null v then rerror(poly,1,"0/0 formed")
           else rerror(poly,2,"Zero divisor")
    else if null v then nil
    else if domainp v then divdm(v,u)
    else lpow v .* divd(lc v,u) .+ divd(red v,u);
+++ divd redefined
+++ divd compiled, 61 + 40 bytes
divd

symbolic procedure divdm(v,u);
   % U and V are both non-zero domain elements.
   % Value is standard form for V/U.
   if atom v and atom u
     then if remainder(v,u)=0 then v/u
           else !:rn2rd mkrn(v,u)
    else y % (if null dmode!* then y else int!-equiv!-chk y)
          where y=dcombine(v,u,'quotient);
+++ divdm compiled, 28 + 28 bytes
divdm

symbolic procedure quotdd(u,v);
   % U and V are domain elements.  Value is U/V if division is exact,
   % NIL otherwise.
   begin scalar w;
      if atom u then
        if atom v then
          <<w := divide(u,v); return if cdr w = 0 then car w else nil>>
          else if (w := get(car v,'i2d)) then u := apply1(w,u)
      else if atom v and (w := get(car u,'i2d)) then v := apply1(w,v);
      return dcombine(u,v,'quotient)
   end;
+++ quotdd redefined
+++ quotdd compiled, 44 + 20 bytes
quotdd

symbolic procedure quotk(p,q);
   (lambda w;
      if w then if null red p then list (lpow p .* w)
                 else (lambda y;if y then lpow p .* w .+ y else nil)
                          quotf1(red p,q)
         else nil)
      quotf1(lc p,q);
+++ quotk redefined
+++ quotk compiled, 28 + 12 bytes
quotk

symbolic procedure quotf!-fail(a,b);
% version of quotf that fails if the division does;
% if roundall is on in rounded mode, try again without conversion to rounded
  if null a then nil
  else begin scalar w;
    w:=quotf(a,b);
    if null w and !*rounded and !*roundall then (w:=quotf(a,b) where !*roundall:=nil);
    if null w then rerror(poly,99,{"UNEXPECTED DIVISION FAILURE",a,b})
    else return w
  end;
+++ quotf!-fail redefined
+++ quotf!-fail compiled, 41 + 40 bytes
quotf-fail


symbolic procedure rank p;
   %P is a standard form
   %Value is the rank of P;
   if !*mcd then ldeg p
    else begin integer m,n; scalar y;
        n := ldeg p;
        y := mvar p;
    a:  m := ldeg p;
        if null red p then return n-m;
        p := red p;
        if degr(p,y)=0 then return if m<0 then if n<0 then -m
                else n-m else n;
        go to a
    end;
+++ rank redefined
+++ rank compiled, 47 + 20 bytes
rank

symbolic procedure lt!* p;
   %Returns true leading term of polynomial P;
   if !*mcd or ldeg p>0 then car p
    else begin scalar x,y;
        x := lt p;
        y := mvar p;
    a:  p := red p;
        if null p then return x
         else if degr(p,y)=0 then return (y . 0) .* p;
        go to a
   end;
+++ lt!* redefined
+++ lt!* compiled, 32 + 20 bytes
lt*

symbolic procedure remf(u,v);
   %returns the remainder of U divided by V;
   if null v then rerror(poly,201,"Zero divisor") else cdr qremf(u,v);
+++ remf compiled, 13 + 28 bytes
remf

%% removed 2017-09-14: polydiv loaded in core
%put('remainder,'polyfn,'remf);

symbolic procedure qremf(u,v);
   % Returns the quotient and remainder of U divided by V.
   % Exp cannot be off, otherwise a loop can occur. e.g.,
   % qremf('(((x . 1) . -1) . 1),'(((x . 2)  . -3) . 4)).
   begin integer n; scalar !*exp,x,y,z;
        !*exp := t;
        if domainp v then return qremd(u,v);
        z := list nil;   % Final value.
    a:  if domainp u then return praddf(z,nil . u)
         else if mvar u eq mvar v
          then if (n := ldeg u-ldeg v)<0 then return praddf(z,nil . u)
                else <<x := qremf(lc u,lc v);
                y := multpf(lpow u,cdr x);
                z := praddf(z,(if n=0 then car x
                                else multpf(mvar u .** n,car x))
                                . y);
                u := if null car x then red u
                        else addf(addf(u,multf(if n=0 then v
                                        else multpf(mvar u .** n,v),
                                        negf car x)), negf y);
                go to a>>
         else if not ordop(mvar u,mvar v)
          then return praddf(z,nil . u);
        x := qremf(lc u,v);
        z := praddf(z,multpf(lpow u,car x) . multpf(lpow u,cdr x));
        u := red u;
        go to a
   end;
+++ qremf redefined
+++ qremf compiled, 205 + 56 bytes
qremf

symbolic procedure praddf(u,v);
   % U and V are dotted pairs of standard forms.
   addf(car u,car v) . addf(cdr u,cdr v);
+++ praddf redefined
+++ praddf compiled, 11 + 12 bytes
praddf

symbolic procedure qremd(u,v);
   % Returns a dotted pair of quotient and remainder of form U
   % divided by domain element V.
   if null u then u . u
    else if v=1 then list u
    else if flagp(dmode!*,'field) then list multd(!:recip v,u)
    else if domainp u then !:divide(u,v)
    else begin scalar x;
        x := qremf(lc u,v);
        return praddf(multpf(lpow u,car x) . multpf(lpow u,cdr x),
                        qremd(red u,v))
   end;
+++ qremd redefined
+++ qremd compiled, 66 + 40 bytes
qremd

symbolic procedure lqremf(u,v);
   %returns a list of coeffs of powers of V in U, constant term first;
   begin scalar x,y;
      y := list u;
      while car(x := qremf(car y,v)) do y := car x . cdr x . cdr y;
      return reversip!* y
   end;
+++ lqremf compiled, 23 + 16 bytes
lqremf

symbolic procedure minusf u;
   %U is a non-zero standard form.
   %Value is T if U has a negative leading numerical coeff,
   %NIL otherwise;
   if null u then nil
    else if domainp u
           then if atom u then u<0 else apply1(get(car u,'minusp),u)
    else minusf lc u;
+++ minusf redefined
+++ minusf compiled, 25 + 8 bytes
minusf

symbolic procedure absf!* u;
   % Returns representation for absolute value of standard form U.
   (if domainp u then x else !*p2f mksp(list('abs,prepf x),1))
    where x = absf u;
+++ absf!* compiled, 23 + 28 bytes
absf*

symbolic procedure absf u;
   if minusf u then negf u else u;
+++ absf redefined
+++ absf compiled, 11 + 16 bytes
absf

symbolic procedure canonsq u;
   % U is a standard quotient.  Value is a standard quotient in which
   % the leading power of the denominator has a positive numerical
   % coefficient and the denominator is normalized where possible.
   if denr u=1 then u
    else if null numr u then nil ./ 1
    else begin scalar x,y;
       % This example shows the following gcd check is needed:
       % a:=1+x/2; let x**2=0; a*a;
       % Should only be needed when an asymptotic reduction occurs.
       if asymplis!* and ((x := gcdf(numr u,denr u)) neq 1)
         then u := quotf!-fail(numr u,x) ./ quotf!-fail(denr u,x);
       % Now adjust for a positive leading numerical coeff in denr.
        x := lnc denr u;
        if x=1 then return u
         else if atom x then if minusp x
                               then <<u := negf numr u ./ negf denr u;
                                      x := -x>>
                              else nil
         else if apply1(get(car x,'minusp),x)
                               then <<u := negf numr u ./ negf denr u;
                                      x:= apply2(get(car x,'difference),
                                              apply1(get(car x,'i2d),0),
                                                     x)>>;
        % Now check for a global field mode, a leading domain coeff
        % with field properties or "unit" properties so we can adjust
        % numr and denr.  The tests are done in the following order
        % since the other order will give wrong results with some
        % polynomials with decimal coefficients in dmode :gi:.
      return if not numberp x and (y := get(dmode!*,'unitsfn))
            then apply2(y,u,x)
         else if flagp(dmode!*,'field)
            or not atom x and flagp(car x,'field) then fieldconv(x,u)
         else u
   end;
+++ canonsq redefined
+++ canonsq compiled, 122 + 52 bytes
canonsq

symbolic procedure fieldconv(x,u);
   % U is a standard quotient and x the leading numerical coefficient
   % of the denominator.  Returns inverse(x)*numr u/denr u.
   % X is a domain, but d may not be; dmode!* or x is field.
   begin scalar n,d,y; n := numr u; d := denr u;
      if null dmode!* then
         <<if not eqcar(x,'!:rn!:)
             then if (y := get(car x,'!:rn!:)) and atom y
                    then x := apply1(y,x)
                   else if get(car x,'quotient)
                    then <<x := dcombine(1,x,'quotient);
                           return multd(x,numr u) ./ multd(x,denr u)>>
                   else errach list("field conversion",x);
           x := (car x) . (cddr x) . cadr x;
           return simpgd if domainp d then multd(x,n) ./ 1
                          else multd(x,n) ./ multd(x,d)>>;
      return if domainp d then divd(n,d) ./ 1
              else divd(n,x) ./ divd(d,x)
   end;
+++ fieldconv redefined
+++ fieldconv compiled, 106 + 48 bytes
fieldconv

symbolic procedure simpgd u;
   if null flagp(dmode!*,'field) then u
   else begin scalar x;
           if (x := gcdf(numr u,denr u)) neq 1
             then u := quotf!-fail(numr u,x) ./ quotf!-fail(denr u,x);
           return u
        end;
+++ simpgd compiled, 25 + 24 bytes
simpgd

symbolic procedure lnc u;
   % U is a standard form.  Value is the leading numerical coefficient.
   if null u then 0
    else if domainp u then u
    else lnc lc u;
+++ lnc redefined
+++ lnc compiled, 15 + 12 bytes
lnc

symbolic procedure invsq u;
   begin
      if null numr u then rerror(poly,3,"Zero divisor");
      u := revpr u;
      if !*rationalize then u := gcdchk u;
      % Since result may not be in lowest terms.
      return canonsq u
   end;
+++ invsq redefined
+++ invsq compiled, 20 + 40 bytes
invsq

symbolic procedure gcdchk u;
   % Makes sure standard quotient u is in lowest terms.
   (if x neq 1 then quotf!-fail(numr u,x) ./ quotf!-fail(denr u,x) else u)
   where x = gcdf(numr u,denr u);
+++ gcdchk compiled, 19 + 20 bytes
gcdchk

endmodule;nil

end;nilmodule polydiv;nil  % Enhanced polynomial division.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% F.J.Wright@Maths.QMW.ac.uk, 6 Nov 1995.

% Defines (or redefines) the following polynomial division operators:
%   divide, div and remainder (mod),
%   pseudo_divide, pseudo_quotient (pseudo_div) and pseudo_remainder.

% However, for now, div has been commented out, since it conflicts with
% other packages (avector and fide).

% ===================================================================

% Enhanced algebraic-mode operators for performing polynomial division
% over the current coefficient domain, based on the operator REMAINDER
% currently defined in poly.red by  put('remainder,'polyfn,'remf);

% divide(p,q) or p divide q returns an algebraic list {quotient,
% remainder} of p divided by q as polynomials over the current domain.

% div(p,q) or p div q returns only the quotient.
% remainder(p,q) or p mod q returns only the remainder.

% div and mod are the operator names used in Pascal for Euclidean
% (integer) division.

% An optional third argument (for the prefix forms) specifies the
% variable to treat as the leading variable for the (effectively
% univariate) polynomial division.


% Interface code
% ==============

% Regular division:
% ----------------

put('divide, 'psopfn, 'poly!-divide);poly-divide
symbolic procedure poly!-divide u;
   poly!-divide!*(u, nil, nil);
+++ poly!-divide compiled, 6 + 12 bytes
poly-divide

remprop('remainder, 'polyfn);nil
put('remainder, 'psopfn, 'poly!-remainder);poly-remainder
put('mod, 'psopfn, 'poly!-remainder);poly-remainder   % name from Pascal
symbolic procedure poly!-remainder u;
   poly!-divide!*(u, 'remainder, nil);
+++ poly!-remainder redefined
+++ poly!-remainder compiled, 6 + 16 bytes
poly-remainder

% put('div, 'psopfn, 'poly!-quotient);    % name from Pascal
symbolic procedure poly!-quotient u;
   poly!-divide!*(u, 'quotient, nil);
+++ poly!-quotient compiled, 6 + 16 bytes
poly-quotient

infix divide, mod;nil
% infix div;
% Set a relatively low precedence:
precedence divide, freeof;nil  % higher than freeof, lower than +
% precedence div, divide;
% precedence mod, div;


% Pseudo-division:
% ---------------

put('pseudo_divide, 'psopfn, 'pseudo!-divide);pseudo-divide
symbolic procedure pseudo!-divide u;
   poly!-divide!*(u, nil, t);
+++ pseudo!-divide compiled, 6 + 16 bytes
pseudo-divide

put('pseudo_remainder, 'psopfn, 'pseudo!-remainder);pseudo-remainder
symbolic procedure pseudo!-remainder u;
   poly!-divide!*(u, 'remainder, t);
+++ pseudo!-remainder compiled, 6 + 20 bytes
pseudo-remainder

put('pseudo_div, 'psopfn, 'pseudo!-quotient);pseudo-quotient
put('pseudo_quotient, 'psopfn, 'pseudo!-quotient);pseudo-quotient
symbolic procedure pseudo!-quotient u;
   poly!-divide!*(u, 'quotient, t);
+++ pseudo!-quotient compiled, 6 + 20 bytes
pseudo-quotient


fluid '(kord!*);nil

symbolic procedure poly!-divide!*(u, fn, pseudo);  % u = (p, q, x)
   % Returns the quotient and remainder of p (pseudo-)divided by q.
   % If specified, x is made the leading variable before dividing,
   % otherwise the first variable found is used.
   begin scalar p, q, x, new_kord;
      if null cdr u then rederr "Divisor required";
      if length u > 3 then
         rederr "Division operators take 2 or 3 arguments.";
      if null (q := !*a2f cadr u) then rederr "Zero divisor";
      p := !*a2f car u;
      if cddr u and (x := !*a2k caddr u) and
         not(kord!* and x eq car kord!*) then <<
            new_kord := t;  updkorder x;
            p := reorder p;  q := reorder q
         >> where kord!* = kord!*;      % preserve environment
      u := if pseudo then pseudo!-qremf(p, q, x) else qremf(p, q);
      p := car u;  q := cdr u;
      if new_kord then <<
         if not(fn eq 'remainder) then p := reorder p;
         if not(fn eq 'quotient) then q := reorder q
      >>;
      return
         if fn eq 'remainder then mk!*sq (q ./ 1)
         else if fn eq 'quotient then mk!*sq (p ./ 1)
         else {'list, mk!*sq (p ./ 1), mk!*sq (q ./ 1)}
   end;
+++ poly!-divide!* compiled, 140 + 84 bytes
poly-divide*


% Pseudo-division code
% ====================

symbolic procedure pseudo!-qremf(u, v, var);
   % Returns quotient and remainder of u pseudo-divided by v wrt var.
   % u and v are standard forms, var is a kernel or nil.
   % If var = nil then var := first kernel found.
   % Internally, polynomials are represented as coeff lists wrt var,
   % i.e. as lists of forms.
   % (Knuth 1981, Seminumerical Algorithms, Algorithm R, page 407.)
   begin scalar no_var, m, n, k, q0, q, car_v, car_u, vv;
      no_var := null var;
      m := if domainp u or (var and not(mvar u eq var)) then  0
      else << if not var then var := mvar u;  ldeg u >>;
      n := if domainp v or (var and not(mvar v eq var)) then  0
      else << if not var then var := mvar v;  ldeg v >>;

      %% The following special-case code for n = 0 and m < n is not
      %% necessary, but could be a cheap efficiency measure.
      %% if zerop n then return multf(exptf(v,m), u) . nil;
      %% if minusp(k := m - n) then return nil . u;

      u := if zerop m then {u} else coeffs u;
      v := if zerop n then {v} else coeffs v;
      if no_var and not(domainp_list v and domainp_list u) then
         msgpri("Main division variable selected is", var,
            nil, nil, nil);
      k := m - n;  car_v := car v;
      while k >= 0 do <<
         %% Compute the quotient q EFFICIENTLY.
         %% q0 = (q_0 ... q_k) without powers of v_n
         q0 := (car_u := car u) . q0;
         vv := cdr v;
         u := for each c in cdr u collect <<
            c := multf(c, car_v);
            if vv then <<
               c := subtrf(c, multf(car_u, car vv));
               vv := cdr vv
            >>;
            c
         >>;
         k := k - 1
      >>;
      if q0 then <<
         %% Reverse q0 and multiply in powers of v_n:
         q := car q0 . nil;  vv := 1;   % v_n^0
         while (q0 := cdr q0) do
            q := multf(car q0, (vv := multf(vv, car_v))) . q
      >>;
      return coeffs!-to!-form(q, var) . coeffs!-to!-form(u, var)
   end;
+++ pseudo!-qremf compiled, 267 + 44 bytes
pseudo-qremf

symbolic procedure coeffs!-to!-form(coeff_list, var);
   % Convert a coefficient list in DESCENDING power order to a
   % standard form wrt the specified variable var:
   coeff_list and
      coeffs!-to!-form1(coeff_list, var, length coeff_list - 1);
+++ coeffs!-to!-form redefined
+++ coeffs!-to!-form compiled, 14 + 12 bytes
coeffs-to-form

symbolic procedure coeffs!-to!-form1(coeff_list, var, d);
   if d > 0 then
      ( if car coeff_list then
         ((var .^ d) .* (car coeff_list)) .+ reductum
      else reductum )
         where reductum =
            coeffs!-to!-form1(cdr coeff_list, var, d - 1)
   else car coeff_list;
+++ coeffs!-to!-form1 redefined
+++ coeffs!-to!-form1 compiled, 30 + 16 bytes
coeffs-to-form1

symbolic procedure domainp_list coeff_list;
   % Returns true if argument is a list of domain elements:
   null coeff_list or
      (domainp car coeff_list and domainp_list cdr coeff_list);
+++ domainp_list redefined
+++ domainp_list compiled, 15 + 12 bytes
domainp_list

endmodule;nil

end;nilmodule quotfx;nil

% Author:  Herbert Melenk.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


COMMENT in many calls to QUOTF, the result is not checked for NIL
because the caller is sure there will be no remainder, e.g. if the
divisor is a gcd.  This occurs not only at several places in the REDUCE
kernel, but especially in Groebner, which simplifies polynomials with
parameters by dividing out their contents.

In all those cases, QUOTF computes too much: if you divide

   P= p_n x^n + p_n-1 x^(n-1) + ...
   Q= q_m x^m + q_m-1 x^(m-1) + ...
        (the coefficients may be polynomials in other variables)

the result comes only from the first k=(n-m+1) coefficients of P.  The
remaining terms only have influence on the potential remainder.  So it
is not necessary to execute the subtractions completely if we don't
need the remainder (or test for its absence).

You can stop after the the power x^(n-k) in P and x^(m-k) in Q, and in
the loop n down to m you can stop in Q again at each step depending on
the actual k.

The method is a polynomial extension of Jebelean's method for dividing
bignums where you know in advance they have no remainder.  The
resulting code is a modification of the standard QUOTF code in polrep;

symbolic procedure quotfx(u,v);
  if null !*exp or null !*mcd then quotf(u,v) else quotfx1(u,v);
+++ quotfx redefined
+++ quotfx compiled, 12 + 24 bytes
quotfx

symbolic procedure quotfx1(p,q);
   % P and Q are standard forms where Q divides P without remainder.
   % Value is the quotient of P and Q.
   if null p then quotfxerr(p,q)
    else if p=q then 1
    else if q=1 then p
    else if domainp q then quotfdx(p,q)
    else if domainp p then quotfxerr(p,q)
    else if mvar p eq mvar q
     then begin scalar f,dp,dq,u,v,w,x,y,z; integer n;
        w := mvar q;
        dq:=ldeg q;
    a:  if (dp:=ldeg p) <dq then return quotfxerr(p,q);
        u := lt!* p;
        v := lt!* q;
        w := mvar q;
        x := quotfx1(tc u,tc v);
        n := idifference(dp,dq);
        if n=0 then return rnconc(z,x);
        y := w .** n;
        if null f then p := cutf(p,w,isub1 idifference(dp,n));
        f:=t;
        q:=cutf(q,w,isub1 idifference(dq,n));
        p := addf(p,multf(if n=0 then q else multpf(y,q),negf x));
        if p and (domainp p or not(mvar p eq w)) then
             return quotfxerr(p,q);
        z := aconc!*(z,y .* x);
        if null p then return z;
        go to a
    end
    else if ordop(mvar p,mvar q) then quotkx(p,q)
    else quotfxerr(p,q);
+++ quotfx1 redefined
+++ quotfx1 compiled, 207 + 68 bytes
quotfx1

symbolic procedure quotkx(p,q);
   (if w then if null red p then list(lpow p .* w)
               else (if y then lpow p .* w .+ y else nil)
                     where y=quotfx1(red p,q)
     else nil)
    where w=quotfx1(lc p,q);
+++ quotkx redefined
+++ quotkx compiled, 28 + 12 bytes
quotkx

symbolic procedure quotfdx(p,q);
   if p=q then 1
   else if flagp(dmode!*,'field) then divd(p,q)
   else if domainp p then quotdd(p,q)
   else quotkx(p,q);
+++ quotfdx redefined
+++ quotfdx compiled, 28 + 28 bytes
quotfdx

symbolic procedure quotfxerr(u,v);
   rederr("exact division failed");
+++ quotfxerr compiled, 3 + 16 bytes
quotfxerr

symbolic procedure cutf(u,x,n);
   % U is a standard form. Delete the terms with a degree in x below n.
   if ilessp(n,1) then u else cutf1(u,x,n);
+++ cutf compiled, 11 + 16 bytes
cutf

symbolic procedure cutf1(u,x,n);
   if domainp u or mvar u neq x or ilessp(ldeg u,n) then nil else
    lt u .+ cutf1(red u,x,n);
+++ cutf1 compiled, 28 + 12 bytes
cutf1

endmodule;nil

end;nilmodule gcd;nil % Greatest common divisor routines.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*exp !*anygcd !*ezgcd !*gcd !*heu!-gcd !*mcd asymplis!* dmode!*
        !*combineexpt);nil

switch anygcd,ezgcd,heugcd;nil
!*anygcd := t;t

% put('heugcd,'simpfg,'((t (load!-package 'heugcd)))); % added by AB

% Note: The handling of non-commuting quantities in the following is
% dubious. The problem is that to do things properly, a left- and
% right-hand gcd and quotient would be necessary.  For now, the code
% returns 1 if the quotient tests fail in gcdf1 for non-commuting
% arguments.

symbolic procedure comfac p;
  % P is a non-atomic standard form.
  % CAR of result is lowest common power of leading kernel in
  % every term in P (or NIL). CDR is gcd of all coefficients of
  % powers of leading kernel.
  % If field elements are involved, lnc is normalized to 1.
  % We need GCDF here since the same function is used by EZGCD.
   begin scalar x,y;
        if flagp(dmode!*,'field) and ((x := lnc p) neq 1)
          then p := multd(!:recip x,p);
        if null red p then return lt p; % really lpow p . lc p (!)
        x := lc p;
        y := mvar p;
    a:  p := red p;
        if degr(p,y)=0
          then return nil
            . if domainp p or not(noncomp y and noncomp mvar p)
                then gcdf(x,p)
               else 1
         else if null red p then return lpow p . gcdf(x,lc p)
         else x := gcdf(lc p,x);
        go to a
   end;
+++ comfac redefined
+++ comfac compiled, 84 + 44 bytes
comfac

symbolic procedure degr(u,var);
   if domainp u or not(mvar u eq var) then 0 else ldeg u;
+++ degr redefined
+++ degr compiled, 15 + 12 bytes
degr

put('gcd,'polyfn,'gcdf!*);gcdf*

put('gcd,'number!-of!-args,2);2

symbolic procedure gcdf!*(u,v);
   begin scalar !*gcd; !*gcd := t; return gcdf(u,v) end;
+++ gcdf!* redefined
+++ gcdf!* compiled, 12 + 24 bytes
gcdf*

symbolic procedure gcdf(u,v);
   % U and V are standard forms.
   % Value is the gcd of U and V, complete only if *GCD is true.
   begin scalar !*exp,!*rounded,mcdsaved;
      % The next line was to prevent numerators moving to denominators
      % as in weight x=1,y=2$ wtlevel 4$ wtest:=(z^4-z^3*y-z^3*x+z^2*y^2
      % +2*z^2*x*y+z^2*x^2-3*z*x^2*y-z*x^3+x^4)/z^5; wtest where z=>a;
      % However, the results are formally correct without it, and it
      % causes other problems.
      % if wtl!* then return 1;
      mcdsaved := !*mcd;
      !*exp := t;
      u := if domainp u or domainp v or not !*ezgcd
      %       or dmode!* memq '(!:rn!: !:rd!:)  % Should be generalized.
              or dmode!* % I don't know what to do in this case.
              or free!-powerp u or free!-powerp v
             then <<if !*combineexpt then !*mcd := t;
                    gcdf1(u,v)>>
            else ezgcdf(u,v);
      !*mcd := mcdsaved;
      return if minusf u then negf u else u
   end;
+++ gcdf redefined
+++ gcdf compiled, 72 + 60 bytes
gcdf

symbolic procedure free!-powerp u;
   not domainp u
      and (not fixp ldeg u or free!-powerp lc u or free!-powerp red u);
+++ free!-powerp redefined
+++ free!-powerp compiled, 22 + 12 bytes
free-powerp

symbolic procedure gcdf1(u,v);
   begin scalar w;
      if null u then return v
       else if null v then return u
       else if u=1 or v=1 then return 1
       else if domainp u then return gcdfd(u,v)
       else if domainp v then return gcdfd(v,u)
% "off anygcd" can prevent anything that could even possibly be expensive.
       else if not !*anygcd or
               not num!-exponents u or
               not num!-exponents v then return 1
       else if quotf1(u,v) then return v
       else if quotf1(v,u) then return u;
      w := gcdf2(u,v);
      if !*gcd and not(dmode!* memq '(!:rd!: !:cr!:))
          and (null quotf1(u,w) or null quotf1(v,w))
        then if noncomfp u or noncomfp v then return 1
              else errach list("gcdf failed",prepf u,prepf v);
              % This probably implies that integer overflow occurred.
      return w
   end;
+++ gcdf1 redefined
+++ gcdf1 compiled, 103 + 60 bytes
gcdf1

symbolic procedure gcdf2(u,v);
   % U and V are both non-trivial forms. Value is their GCD.
   % We need to rebind asymplis!* to avoid setting higher powers to 0.
   begin scalar asymplis!*,w,z;
      if not !*anygcd or
         not num!-exponents u or
         not num!-exponents v then return 1;
      if !*gcd and length(w := kernord(u,v))>1
        then <<w := list setkorder w;   % List used to make sure non-NIL
               u := reorder u;
               v := reorder v>>
       else w := nil;
      % Things can go wrong with noncom oprs.  However, empirically we
      % only need to make sure that both u and v do not have a leading
      % noncom opr.
      if mvar u eq mvar v
        then begin scalar x,y;
                x := comfac u;
                y := comfac v;
                z := gcdf1(cdr x,cdr y);
                u := quotf1(u,comfac!-to!-poly x);
                v := quotf1(v,comfac!-to!-poly y);
                if !*gcd then z := multf(gcdk(u,v),z)
                 else if v and quotf1(u,v) then z := multf(v,z)
                 else if u and quotf1(v,u) then z := multf(u,z);
                if car x and car y
                  then if pdeg car x>pdeg car y
                         then z := multpf(car y,z)
                        else z := multpf(car x,z)
             end
       else if noncomp mvar u and noncomp mvar v
        then z := gcdfnc(u,v,mvar v)
       else if ordop(mvar u,mvar v) then z := gcdf1(cdr comfac u,v)
       else z := gcdf1(cdr comfac v,u);
      if w then <<setkorder car w; z := reorder z>>;
      return z
   end;
+++ gcdf2 redefined
+++ gcdf2 compiled, 216 + 80 bytes
gcdf2

symbolic procedure gcdfnc(x,p,y);
   if domainp x or not noncomp mvar x then gcdf1(x,p)
    else if null red x then gcdfnc(lc x,p,y)
    else gcdf1(gcdfnc(lc x,p,y),gcdfnc(red x,p,y));
+++ gcdfnc compiled, 37 + 16 bytes
gcdfnc

symbolic procedure num!-exponents u;
  % check that all exponents are integers (this may not be true in
  % rules).
   domainp u or
   fixp ldeg u and num!-exponents lc u and num!-exponents red u;
+++ num!-exponents redefined
+++ num!-exponents compiled, 22 + 12 bytes
num-exponents

symbolic procedure gcdfd(u,v);
   % U is a domain element, V a form.
   % Value is gcd of U and V.
%  if not atom u and flagp(car u,'field) then 1 else gcdfd1(u,v);
   if flagp(dmode!*,'field) then 1 else gcdfd1(u,v);
+++ gcdfd redefined
+++ gcdfd compiled, 10 + 20 bytes
gcdfd

symbolic procedure gcdfd1(u,v);
   if null v then u
    else if domainp v then gcddd(u,v)
    else gcdfd1(gcdfd1(u,lc v),red v);
+++ gcdfd1 redefined
+++ gcdfd1 compiled, 20 + 12 bytes
gcdfd1

symbolic procedure gcddd(u,v);
   %U and V are domain elements.  If they are invertable, value is 1
   %otherwise the gcd of U and V as a domain element;
   if u=1 or v=1 then 1
%   else if atom u and atom v then gcdn(u,v)
    else if atom u then if atom v then gcdn(u,v)
                         else if fieldp v then 1
                         else dcombine(u,v,'gcd)
    else if atom v
     then if flagp(car u,'field) then 1 else dcombine(u,v,'gcd)
    else if flagp(car u,'field) or flagp(car v,'field) then 1
    else dcombine(u,v,'gcd);
+++ gcddd redefined
+++ gcddd compiled, 70 + 24 bytes
gcddd

symbolic procedure gcdk(u,v);
   % U and V are primitive polynomials in the main variable VAR.
   % Result is gcd of U and V.
   begin scalar lclst,var,w,x;
        if u=v then return u
         else if domainp u or degr(v,(var := mvar u))=0 then return 1
         else if ldeg u<ldeg v then <<w := u; u := v; v := w>>;
        if quotf1(u,v) then return v
         else if !*heugcd and not !*ezgcd and   % added by AB
	         (x := heu!-gcd(u,v)) then return x
%        else if flagp(dmode!*,'field) then return 1
              % otherwise problems arise.
         else if ldeg v=1
           or getd 'modular!-multicheck and modular!-multicheck(u,v,var)
           or not !*mcd
          then return 1;
    a:  w := remk(u,v);
        if null w then return v
         else if degr(w,var)=0 then return 1;
        lclst := addlc(v,lclst);
        if x := quotf1(w,lc w) then w := x
         else for each y in lclst do
              % prevent endless loop in !:gi!: or field modes.
            if atom y and not flagp(dmode!*,'field)
              or not
               (domainp y and (flagp(dmode!*,'field)
                  or ((x := get(car y,'units))
                       and y member (for each z in x collect car z))))
            then while (x := quotf1(w,y)) do w := x;
        u := v; v := prim!-part w;
        if degr(v,var)=0 then return 1 else go to a
   end;
+++ gcdk redefined
+++ gcdk compiled, 222 + 64 bytes
gcdk

symbolic procedure addlc(u,v);
   if u=1 then v
    else (lambda x;
      if x=1 or x=-1 or not atom x and flagp(car x,'field) then v
       else x . v)
     lc u;
+++ addlc compiled, 27 + 16 bytes
addlc

symbolic procedure delallasc(u,v);
   if null v then nil
    else if u eq caar v then delallasc(u,cdr v)
    else car v . delallasc(u,cdr v);
+++ delallasc redefined
+++ delallasc compiled, 22 + 12 bytes
delallasc

symbolic procedure kernord(u,v);
   <<u := kernord!-split(u,v);
     append(kernord!-sort car u,kernord!-sort cdr u)>>;
+++ kernord redefined
+++ kernord compiled, 13 + 16 bytes
kernord

symbolic procedure kernord!-split(u,v);
   % splits U and V into a set of powers of those kernels occurring in
   % one form and not the other, and those occurring in both;
   begin scalar x,y;
      u := powers u;
      v := powers v;
      for each j in u do
          if assoc(car j,v) then y := j . y else x := j . x;
      for each j in v do
          if assoc(car j,u) then y := j . y else x := j . x;
      return reversip x . reversip y
   end;
+++ kernord!-split redefined
+++ kernord!-split compiled, 76 + 12 bytes
kernord-split

symbolic procedure kernord!-sort u;
   % returns list of kernels ordered so that kernel with lowest maximum
   % power in U (a list of powers) is first, and so on;
   begin scalar x,y;
      while u do
       <<x := maxdeg(cdr u,car u);
         u := delallasc(car x,u);
         y := car x . y>>;
      return y
   end;
+++ kernord!-sort redefined
+++ kernord!-sort compiled, 19 + 16 bytes
kernord-sort

symbolic procedure maxdeg(u,v);
   if null u then v
    else if cdar u>cdr v then maxdeg(cdr u,car u)
    else maxdeg(cdr u,v);
+++ maxdeg redefined
+++ maxdeg compiled, 22 + 8 bytes
maxdeg

symbolic procedure powers form;
   % returns a list of the maximum powers of each kernel in FORM.
   % order tends to be opposite to original order.
   powers0(form,nil);
+++ powers redefined
+++ powers compiled, 4 + 12 bytes
powers

symbolic procedure powers0(form,powlst);
   if null form or domainp form then powlst
    else begin scalar x;
        if (x := atsoc(mvar form,powlst))
%         then ldeg form>cdr x and rplacd(x,ldeg form)
          then (if ldeg form>cdr x
                  then powlst := repasc(mvar form,ldeg form,powlst))
         else powlst := (mvar form . ldeg form) . powlst;
        return powers0(red form,powers0(lc form,powlst))
     end;
+++ powers0 redefined
+++ powers0 compiled, 51 + 12 bytes
powers0

put('lcm,'polyfn,'lcm!*);lcm*

put('lcm,'number!-of!-args,2);2

symbolic procedure lcm!*(u,v);
   begin scalar !*gcd; !*gcd := t; return lcm(u,v) end;
+++ lcm!* compiled, 12 + 24 bytes
lcm*

symbolic procedure lcm(u,v);
   %U and V are standard forms. Value is lcm of U and V;
   if null u or null v then nil
    else if u=1 then v     % ONEP
    else if v=1 then u     % ONEP
    else multf(u,quotf!-fail(v,gcdf(u,v)));
+++ lcm redefined
+++ lcm compiled, 26 + 24 bytes
lcm

symbolic procedure remk(u,v);
   %modified pseudo-remainder algorithm
   %U and V are polynomials, value is modified prem of U and V;
   begin scalar f1,var,x; integer k,n;
        f1 := lc v;
        var := mvar v;
        n := ldeg v;
        while (k := degr(u,var)-n)>=0 do
         <<x := negf multf(lc u,red v);
           if k>0 then x := multpf(var .** k,x);
           u := addf(multf(f1,red u),x)>>;
        return u
   end;
+++ remk redefined
+++ remk compiled, 59 + 36 bytes
remk

symbolic procedure prim!-part u;
   %returns the primitive part of the polynomial U wrt leading var;
   quotf1(u,comfac!-to!-poly comfac u);
+++ prim!-part redefined
+++ prim!-part compiled, 9 + 20 bytes
prim-part

symbolic procedure comfac!-to!-poly u;
   if null car u then cdr u else list u;
+++ comfac!-to!-poly redefined
+++ comfac!-to!-poly compiled, 8 + 8 bytes
comfac-to-poly

endmodule;nil

end;nilmodule exptf;nil % Functions for raising canonical forms to a power.

% Author: Anthony C. Hearn.

% Copyright (c) 1990 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*exp);nil

symbolic procedure exptsq(u,n);
   begin scalar x;
      if n=1 then return u
       else if n=0
         then return if null numr u then rerror(poly,4," 0**0 formed")
                      else 1 ./ 1
       else if null numr u then return u
       else if n<0 then return simpexpt list(mk!*sq u,n)
       else if null !*exp
        then return mksfpf(numr u,n) ./ mksfpf(denr u,n)
       else if kernp u then return mksq(mvar numr u,n)
       else if denr u=1 then return exptf(numr u,n) ./ 1
       else if domainp numr u
        then x := multsq(!:expt(numr u,n) ./ 1,1 ./ exptf(denr u,n))
       else <<x := u;
              % Since U is in lowest terms, then so is U^N.
              while (n := n-1)>0
                 do x := multf(numr u,numr x) ./ multf(denr u,denr x);
              % We need canonsq for a:=1+x/2; let x^2=0; a^2;
              x := canonsq x>>;
      if null cdr x then rerror(poly,101,"Zero divisor");
      return x
   end;
+++ exptsq redefined
+++ exptsq compiled, 143 + 84 bytes
exptsq

symbolic procedure exptf(u,n);
   if n < 0 then errach {"exptf",u,n}
    else if domainp u then !:expt(u,n)
    else if !*exp or kernlp u then exptf1(u,n)
    else mksfpf(u,n);
+++ exptf redefined
+++ exptf compiled, 36 + 36 bytes
exptf

symbolic procedure exptf1(u,n);
   % Iterative multiplication seems to be faster than a binary sub-
   % division algorithm, probably because multiplying a small polynomial
   % by a large one is cheaper than multiplying two medium sized ones.
   if n=0 then 1
    else begin scalar x;
         x := u; while (n := n-1)>0 do x := multf(u,x); return x
         end;
+++ exptf1 redefined
+++ exptf1 compiled, 23 + 20 bytes
exptf1

symbolic procedure exptf2(u,n);
   % Binary version of EXPTF1, Used with EXP off, since expressions
   % formed in that case tend to be smaller than with EXP on.
   if n=0 then 1
    else begin scalar x; integer m;
         x := 1;
    a:   m := n;
         if m-2*(n := n/2) neq 0 then x := multf(u,x);
         if n=0 then return x;
         u := multf(u,u);
         go to a
      end;
+++ exptf2 compiled, 41 + 24 bytes
exptf2

endmodule;nil

end;nilmodule kernel;nil   % Functions for operations on kernels.

% Author: Anthony C. Hearn.

% Copyright (c) 1990 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


global '(exlist!* kprops!*);nil

!#if (memq 'csl lispsystem!*)

global '(kernhash);nil

kernhash := mkhash(20, 3, nil);#H(3 0 61 [~ ~ ~ ~ ~ ~ ~ ~] [~ ~ ~ ~ ~ ~ ~ ~])

symbolic procedure fkern u;
% Finds the unique "p-list" reference to the kernel U.  The choice of
% the search and merge used here has a strong influence on some
% timings.  The ordered list used here is also used by prepsq* to
% order factors in printed output, so cannot be unilaterally changed.
  begin
    scalar x,y;
    if atom u then return list(u,nil)
    else if x := get(car u,'fkernfn) then return apply1(x,u);
% This version maintains a single hash table of all non-atomic
% kernels such that when a key is looked up in it a unique item will
% be recovered. This hash table contains information that is in
% parallel with the set of values stored via the 'klist property.
% so klist information shoould remain exactly as it always has been.
% however anywhere that klist information is to be discarded the
% hash table will need an extry cleared too, so simple use of REMPROP
% will no longer suffice - so I will provide a remklist function to
% capture what I do need to do.
    if null (x := gethash(u, kernhash)) then <<
      x := list(u, nil);
      puthash(u, kernhash, x);
      if atom car u then <<
         if null (car u member kprops!*) then kprops!* := car u . kprops!*;
         put(car u, 'klist, ordad(x, get(car u, 'klist))) >>
      else exlist!* := ordad(x, exlist!*) >>;
    return x
  end;
+++ fkern compiled, 67 + 40 bytes
fkern

symbolic procedure remklist x;
  begin
    for each u in get(x, 'klist) do remhash(car u, kernhash);
    remprop(x, 'klist);
  end;
+++ remklist compiled, 24 + 20 bytes
remklist

symbolic procedure resetklist(x, v);
 << remklist x;
    for each u in v do puthash(car u, kernhash, u);
    put(x, 'klist, v) >>;
+++ resetklist compiled, 30 + 28 bytes
resetklist

!#else
symbolic procedure fkern u;
   % Finds the unique "p-list" reference to the kernel U.  The choice of
   % the search and merge used here has a strong influence on some
   % timings.  The ordered list used here is also used by prepsq* to
   % order factors in printed output, so cannot be unilaterally changed.
   begin scalar x,y;
        if atom u then return list(u,nil)
         else if x := get(car u,'fkernfn) then return apply1(x,u);
        y := if atom car u then get(car u,'klist) else exlist!*;
        if not (x := assoc(u,y))
          then <<x := list(u,nil);
                 y := ordad(x,y);
                 if atom car u
                   then <<kprops!* := union(list car u,kprops!*);
                          put(car u,'klist,y)>>
                  else exlist!* := y>>;
        return x
   end;

symbolic inline procedure remklist x;
  remprop(x, 'klist);

symbolic procedure resetklist(x, v);
  put(x, 'klist, v);

!#endif

symbolic procedure kernels u;
   % Returns list of kernels in standard form u.
   kernels1(u,nil);
+++ kernels redefined
+++ kernels compiled, 4 + 12 bytes
kernels

symbolic procedure kernels1(u,v);
   % We append to end of list to put kernels in the right order, even
   % though a cons on the front of the list would be faster.
   if domainp u then v
    else kernels1(lc u,
                  kernels1(red u,
                           if x memq v then v else append(v,list x)))
         where x=mvar u;
+++ kernels1 redefined
+++ kernels1 compiled, 35 + 8 bytes
kernels1

symbolic procedure kernp u;
   % True if U is standard quotient representation for a kernel.
   denr u=1 and not domainp(u := numr u)
        and null red u and lc u=1 and ldeg u=1;
+++ kernp redefined
+++ kernp compiled, 33 + 16 bytes
kernp     % onep

endmodule;nil

end;nilmodule mksp;nil % Functions for making standard powers.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% This module has a non-trivial use of ACONC.

fluid '(!*nosubs !*sub2 asymplis!* powlis!* subfg!* wtl!*);nil

% fluid '(varstack!*);

global '(!*resubs);nil

% exports mksfpf,mksp,mksq,to;

% imports !*p2f,aconc,eqcar,exptf,exptsq,leq,mkprod!*,module,multsq,
%       ordad,over,simpcar,union;

symbolic procedure getpower(u,n);
   %U is a list (<kernel> . <properties>), N a positive integer.
   %Value is the standard power of U**N;
   <<if eqcar(car u,'expt) and n>1 then !*sub2 := t; car u . n>>;
+++ getpower redefined
+++ getpower compiled, 15 + 24 bytes
getpower
%   begin scalar v;
%       v := cadr u;
%       if null v then return caar rplaca(cdr u,list (car u . n));
%    a: if n=cdar v then return car v
%        else if n<cdar v
%           then return car rplacw(v,(caar v . n) . (car v . cdr v))
%        else if null cdr v
%           then return cadr rplacd(v,list (caar v . n));
%       v := cdr v;
%       go to a
%   end;

symbolic procedure mksp(u,p);
   %U is a (non-unique) kernel and P a non-zero integer
   %Value is the standard power for U**P;
   getpower(fkern u,p);
+++ mksp redefined
+++ mksp compiled, 6 + 16 bytes
mksp

symbolic procedure u to p;
   %U is a (unique) kernel and P a non-zero integer;
   %Value is the standard power of U**P;
   u . p;
+++ to compiled as link to cons
to
%   getpower(fkern u,p);

symbolic procedure mksp!*(u,n);
   % Returns a standard form for U**N. If U is a kernel product,
   % direct exponentiation is used.  Otherwise, U is first made
   % positive and then converted into a kernel.
   begin scalar b;
      if null u or kernlp u then return exptf(u,n)
       else if minusf u then <<b := t; u := negf u>>;
      u := !*p2f mksp(u,n);
      return if b and not evenp n then negf u else u
   end;
+++ mksp!* redefined
+++ mksp!* compiled, 36 + 36 bytes
mksp*

symbolic procedure mksfpf(u,n);
   % Raises form U to power N with EXP off. Returns a form.
   % If we assume that MKPROD returns a kernlp form, check for red x
   % is redundant.
   (if n=1 then x
     else if domainp x then !:expt(x,n)
     else if n>=0 and onep lc x and null red x
      then (((if subfg!* and z and cdr z<=m then nil
               else !*p2f mksp(y,m))
            where z=assoc(y,asymplis!*)) where m=ldeg x*n,y=mvar x)
     else exptf2(x,n))
    where x=mkprod u;
+++ mksfpf redefined
+++ mksfpf compiled, 61 + 40 bytes
mksfpf

symbolic procedure mksq(u,nn);
    % U is a kernel, NN a non-zero integer.
    % Value is a standard quotient of U**N, after making any
    % possible substitutions for U.
   begin scalar x,y,z;
%  (begin scalar x,y,z;
        if null subfg!* then go to a1
         else if (y := assoc(u,wtl!*))
                and null car(y := mksq('k!*,nn*cdr y)) then return y
         else if not atom u then go to b
         else if null !*nosubs and (z:= get(u,'avalue)) then go to c;
        if idp u then flag(list u,'used!*);
        %tell system U used as algebraic var (unless it's a string);
    a:  if !*nosubs or nn=1 then go to a1
         else if (z:= assoc(u,asymplis!*)) and cdr z<=nn
          then return nil ./ 1
         else if ((z:= assoc(u,powlis!*))
                or not atom u and car u memq '(expt sqrt)
                and (z := assoc(cadr u,powlis!*)))
             and not(nn*cadr z<0)
           % Implements explicit sign matching.
          then !*sub2 := t;
    a1: if null x then x := fkern u;
        x := !*p2f getpower(x,nn) ./ 1;
        return if y then multsq(y,x) else x;
    b:  if null !*nosubs and atom car u
           and ((z := get(car u,'mksqsubfn)) and (z := apply1(z,u))
                or (z:= assoc(u,get(car u,'kvalue))))
          then go to c
         else if not('used!* memq cddr (x := fkern u))
          then aconc(x,'used!*);
        go to a;
    c:  z := cdr z;
%       varstack!* := u . varstack!*;   % I don't think this is needed.
        %optimization is possible as shown if all expression
        %dependency is known;
        %if cdr z then return exptsq(cdr z,nn); % Value already computed.
        if null !*resubs then !*nosubs := t;
        x := simpcar z;
        !*nosubs := nil;
        %rplacd(z,x);           % Save simplified value.
        %subl!* := z . subl!*;
        return exptsq(x,nn)
   end;
+++ mksq redefined
+++ mksq compiled, 189 + 88 bytes
mksq
%  end) where varstack!* := varstack!*; % I don't think this is needed.

endmodule;nil

end;nilmodule reord;nil % Functions for reordering standard forms.

% Author: Anthony C. Hearn.

% Copyright (c) 1990 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(alglist!* kord!* ncmp!*);nil

alglist!* := nil . nil;(nil)         % This is first module that uses this.

symbolic procedure reordsq u;
   % Reorders a standard quotient so that current kernel order is used.
   reorder numr u ./ reorder denr u;
+++ reordsq redefined
+++ reordsq compiled, 9 + 12 bytes
reordsq

symbolic procedure reorder u;
   % Reorders a standard form so that current kernel order is used.
   % Note: this version does not reorder any sfs used as kernels.
   if domainp u then u
    else raddf(rmultpf(lpow u,reorder lc u),reorder red u);
+++ reorder redefined
+++ reorder compiled, 34 + 16 bytes
reorder

symbolic procedure raddf(u,v);
   % Adds reordered forms U and V.
   if null u then v
    else if null v then u
    else if domainp u then addd(u,v)
    else if domainp v then addd(v,u)
    else if peq(lpow u,lpow v)
     then (lpow u .* raddf(lc u,lc v)) .+ raddf(red u,red v)
    else if ordpp(lpow u,lpow v) then lt u . raddf(red u,v)
    else lt v . raddf(u,red v);
+++ raddf compiled, 90 + 16 bytes
raddf

symbolic procedure rmultpf(u,v);
  % Multiplies power U by reordered form V.
   if null v then nil
    else if domainp v or reordop(car u,mvar v) then !*t2f(u .* v)
    else (lpow v .* rmultpf(u,lc v)) .+ rmultpf(u,red v);
+++ rmultpf redefined
+++ rmultpf compiled, 39 + 16 bytes
rmultpf

symbolic procedure reordop(u,v);
   (!*ncmp and noncomp1 u and noncomp1 v) or ordop(u,v);
+++ reordop redefined
+++ reordop compiled, 15 + 20 bytes
reordop

symbolic procedure kernel!-list u;
  % Converts u to a list of kernels, expanding lists in u.
  for each x in u join
   <<x:=reval x;
     if eqcar(x,'list) then kernel!-list cdr x else {!*a2k x}>>;
+++ kernel!-list compiled, 61 + 24 bytes
kernel-list

symbolic procedure korder u;
   <<kord!* := if u = '(nil) then nil else kernel!-list u;
     rmsubs()>>;
+++ korder compiled, 14 + 24 bytes
korder

rlistat '(korder);nil

symbolic procedure setkorder u;
   begin scalar v;
      v := kord!*;
      if u=v then return v;
      kord!* := u;
      alglist!* := nil . nil;        % Since kernel order has changed.
      return v
   end;
+++ setkorder redefined
+++ setkorder compiled, 13 + 16 bytes
setkorder

symbolic procedure updkorder u;
   % U is a kernel.  Value is previous kernel order.
   % This function is used when it is necessary to give one kernel
   % highest precedence (e.g., when extracting coefficients), but not
   % change the order of the other kernels.
   begin scalar v,w;
      v := kord!*;
      w := u . delete(u,v);
      if v=w then return v;
      kord!* := w;
      alglist!* := nil . nil;        % Since kernel order has changed.
      return v
   end;
+++ updkorder redefined
+++ updkorder compiled, 23 + 16 bytes
updkorder

endmodule;nil

end;nilmodule dmode;nil % Functions for defining and using poly domain modes.

% Author: Anthony C. Hearn.
% Modifications by: Stanley L. Kameny.

% Copyright (c) 1992 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


COMMENT
   *** Description of Definition Requirements for Domain arithmetics ***

Syntactically, such elements have the following form:

<domain element>:=NIL|integer|<structured domain element>

<structured domain element> ::=
        (<domain identifier>.<domain structure>),

where NIL represents the domain element zero.

To introduce a new domain, we need to define:

1) A conversion function from integer to the given mode, stored under
   the attribute I2D.

2) A conversion function from new mode to or from every other mode.

3) Particular instances of the binary operations +,- and * for this
   mode.

4) Particular instances of ZEROP, ONEP and MINUSP for this mode.
   Although ONEP could be defined in terms of ZEROP, we believe it is
   more efficient to have both functions (though this has not been
   thoroughly tested).

5) If domain is a field, a quotient must be defined.  If domain is a
   ring, a gcd and divide must be defined, and also a quotient
   function which returns NIL if the division fails.

6) A printing function for this mode that can print the object in a
   linear form. The printing function is associated with the attribute
   PRIFN.  This printing function should enclose the printed expression
   in parentheses if its top level operator has a precedence greater
   than +.

7) A function to convert structure to an appropriate prefix form.

8) A reading function for this mode.

9) A DNAME property for the tag, and a TAG property for the DNAME

10) Optionally, an exponentiation function. If this is not provided,
    repeated squaring is used (cf !:expt in dmodeop.red)

11) Optionally, a function for computing the absolute value. If this is
    not provided, the corresponding instance of MINUSP is used to determine
    the absolute value.

To facilitate this, all such modes should be listed in the global
variable DOMAINLIST!*.

The following rules should also be followed when introducing new
domains:

Some modes, such as modular arithmetic, require that integers be
converted to domain elements when input or addition or multiplication
of such objects occurs.  Such modes should be flagged "convert".

A domain which holds mutable internal state should be flagged
"resimplify" (no Reduce domains are currently so flagged) which means
that attempts to simplify domain elements will actually do so, rather
than just thinking "domain elements are always simplified".

In ALL cases it is assumed that any domain element that tests true to
the zero test can be converted into an explicit 0 (represented by NIL),
and any that tests true to the onep test can be converted into an
explicit 1.  If the domain allows for the conversion of other elements
into equivalent integers, a function under the optional attribute
INTEQUIVFN may also be defined to effect this conversion.

The result of an arithmetic (as opposed to a boolean) operation on
structured domain elements with the same tag must be another structured
domain element with the same tag.  In particular, a domain zero must be
returned as a tagged zero in that domain.

In some cases, it is possible to map functions on domain elements to
domain elements.  To provide for this capability in the complete
system, one can give such functions the domain tag as an indicator.
The results of this evaluation must be a tagged domain element (or an
integer?), but not necessarily an element from the same domain, or the
evaluation should abort with an error.  The error number associated
with this should be in the range 100-150;

fluid '(!*complex dmode!* gdmode!*);nil

global '(domainlist!*);nil

symbolic procedure initdmode u;
   % Checks that U is a valid domain mode, and sets up appropriate
   % interfaces to the system.
   begin
      dmodechk u;
      put(u,'simpfg,list(list(t,list('setdmode,mkquote u,t)),
                         list(nil,list('setdmode,mkquote u,nil))))
   end;
+++ initdmode compiled, 37 + 32 bytes
initdmode

% switch complex!-rational,complex!-rounded;

symbolic procedure setdmode(u,bool);
   % Sets polynomial domain mode.  If bool is NIL, integers are used,
   % or in the case of complex, set to the lower domain.
   % Otherwise mode is set to u, or derived from it.
   begin scalar x;
      if (x := get(u,'dname)) then u := x;  % Allow a tag as argument.
      if u eq 'complex!-rational then
        <<if (x := dmode!*) then x := get(x,'dname);
          onoff('complex,bool); onoff('rational,bool);
          return x>>
        else if u eq 'complex!-rounded then
          <<if (x := dmode!*) then x := get(x,'dname);
            onoff('complex,bool); onoff('rounded,bool);
            return x>>;
      if null get(u,'tag)
        then rerror(poly,5,
                   list("Domain mode error:",u,"is not a domain mode"));
      if x := get(u,'package!-name) then load!-package x;
      return if u eq 'complex or !*complex then setcmpxmode(u,bool)
              else setdmode1(u,bool)
   end;
+++ setdmode redefined
+++ setdmode compiled, 87 + 80 bytes
setdmode

symbolic procedure setdmode1(u,bool);
   begin scalar x,y,z;
      x := get(u,'tag);
      y := dmode!*;
      if null bool
        then return if null y then nil
                     else if u eq (y := get(y,'dname))
                      then <<rmsubs(); gdmode!* := dmode!* := nil; y>>
                     else offmoderr(u,y)
        else <<if u memq '(rounded complex!-rounded) then !!mfefix();
               if x eq y then return x>>;
      % Now make sure there are no other domain switches left on.
      if not (z := get(x,'realtype)) then z := x;
      for each j in domainlist!* do
         if j neq '!:gi!: and not(j eq z)
           then set(intern compress
                       append(explode '!*,explode get(j,'dname)),
                    nil);
      rmsubs();
      y := get(y,'dname);
      if y then lprim list("Domain mode",y,"changed to",u);
      gdmode!* := dmode!* := x;
      return y
   end;
+++ setdmode1 redefined
+++ setdmode1 compiled, 121 + 72 bytes
setdmode1

symbolic procedure offmoderr(u,y);
   lpriw("***",list("Failed attempt to turn off",u,"when",y,"is on"));
+++ offmoderr compiled, 17 + 36 bytes
offmoderr

symbolic procedure dmodechk u;
   % Checks to see if U has complete specification for a domain mode.
   begin scalar z;
      if not(z := get(u,'tag))
        then rerror(poly,6,list("Domain mode error:","No tag for",u))
       else if not(get(z,'dname) eq u)
        then rerror(poly,7,list("Domain mode error:",
                                 "Inconsistent or missing DNAME for",z))
       else if not(z memq domainlist!*)
        then rerror(poly,8,list("Domain mode error:",
                                 z,"not on domain list"));
      u := z;
      for each x in domainlist!*
        do if u=x then nil
            else <<if not get(u,x) then put(u,x,mkdmoderr(u,x));
                   if not get(x,u) then put(x,u,mkdmoderr(x,u))>>;
%            then rederr list("Domain mode error:",
%                          "No conversion defined between",U,"and",X);
      z := '(plus difference times quotient i2d prepfn prifn
             minusp onep zerop);
      if not flagp(u,'field) then z := 'divide . 'gcd . z;
      for each x in z do if not get(u,x)
             then rerror(poly,9,list("Domain mode error:",
                                      x,"is not defined for",u))
   end;
+++ dmodechk compiled, 187 + 88 bytes
dmodechk

symbolic procedure dmoderr(u,v);
   rerror(poly,10,list("Conversion between",get(u,'dname),
                       "and",get(v,'dname),"not defined"));
+++ dmoderr compiled, 24 + 40 bytes
dmoderr

symbolic procedure mkdmoderr(u,v);
   list('lambda,'(!*x!*),list('dmoderr,mkquote u,mkquote v));
+++ mkdmoderr redefined
+++ mkdmoderr compiled, 18 + 24 bytes
mkdmoderr

endmodule;nil

end;nilmodule dmodeop;nil  % Generic operators for domain arithmetic.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% internal dividef;

fluid '(!*noequiv);nil    % !*convert

% switch convert;

% !*convert := t;

symbolic procedure !:difference(u,v);
   if null u then !:minus v else if null v then u
    else if u=v then nil
    else if atom u and atom v then u-v
    else dcombine(u,v,'difference);
+++ !:difference redefined
+++ !:difference compiled, 30 + 20 bytes
:difference

symbolic procedure !:divide(u,v);
   % Returns a dotted pair of quotient and remainder of non-invertable
   % domain element U divided by non-invertable domain element V.
   % Note that a zero is returned as NIL.
   if null u then nil . nil
    else if null v then rerror(poly,202,"zero divisor")
    else if atom u and atom v then dividef(u,v)
    else dcombine(u,v,'divide);
+++ !:divide redefined
+++ !:divide compiled, 30 + 36 bytes
:divide

symbolic procedure dividef(m,n);
   ((if car x=0 then nil else car x) . if cdr x=0 then nil else cdr x)
   where x=divide(m,n);
+++ dividef redefined
+++ dividef compiled, 23 + 12 bytes
dividef

symbolic procedure !:expt(u,n);
   % Raises domain element U to integer power N.  Value is a domain
   % element.
   if null u then if n=0 then rerror(poly,11,"0/0 formed") else nil
    else if n=0 then 1
    else if n=1 then u
    else if u=1 then 1
    else if n<0
     then !:recip !:expt(if not fieldp u then mkratnum u else u,-n)
    else if atom u then u**n
%    Moved into the exponentiation method of !:mod!:
%    else if car u eq '!:mod!:
%     then (lambda x; if x=0 then nil else if x=1 then 1 else car u . x)
%          general!-modular!-expt(cdr u,n)
    else begin scalar v,w,x;
      if x := get(car u,'expt)
         then return apply2(x,u,n);
         % There was a special exponentiation method.
      v := apply1(get(car u,'i2d),1);   % unit element.
      x := get(car u,'times);
   a: w := n;
      if w-2*(n := n/2) neq 0 then v := apply2(x,u,v);
      if n=0 then return v;
      u := apply2(x,u,u);
      go to a
   end;
+++ !:expt redefined
+++ !:expt compiled, 124 + 52 bytes
:expt

symbolic procedure !:gcd(u,v);
  if null u then v else if null v then u
   else if atom u and atom v then gcdn(u,v)
   else if fieldp u or fieldp v then 1
   else dcombine(u,v,'gcd);
+++ !:gcd compiled, 33 + 24 bytes
:gcd

% symbolic procedure !:i2d u;

symbolic procedure !:minus u;
   % U is a domain element. Value is -U.
   if null u then nil
    else if atom u then -u
    else (if x then apply1(x,u) else dcombine(u,-1,'times))
         where x=get(car u,'minus);
+++ !:minus redefined
+++ !:minus compiled, 24 + 24 bytes
:minus

symbolic procedure !:minusp u;
   if atom u then minusp u else apply1(get(car u,'minusp),u);
+++ !:minusp redefined
+++ !:minusp compiled, 12 + 8 bytes
:minusp

symbolic procedure !:onep u;
   if atom u then onep u else apply1(get(car u,'onep),u);
+++ !:onep redefined
+++ !:onep compiled, 12 + 8 bytes
:onep

symbolic procedure !:plus(u,v);
   if null u then v else if null v then u
    else if atom u and atom v
     then (if w=0 then nil else w) where w=u+v
    else dcombine(u,v,'plus);
+++ !:plus redefined
+++ !:plus compiled, 24 + 20 bytes
:plus

% symbolic procedure !:prep u;

% symbolic procedure !:print u;

symbolic procedure !:quotient(u,v);
   if null u or u=0 then nil
    else if null v or v=0 then rerror(poly,12,"Zero divisor")
    else if atom u and atom v
     % We might also check that remainder is zero in integer case.
     then if null dmode!* then u/v else
        (if atom recipv then u*recipv else dcombine(u,recipv,'times))
                where recipv=!:recip v
    else dcombine(u,v,'quotient);
+++ !:quotient redefined
+++ !:quotient compiled, 54 + 48 bytes
:quotient

symbolic procedure !:recip u;
   % U is an invertable domain element. Value is 1/U.
   begin
      if numberp u
        then if abs u=1 then return u
       else if null dmode!* or dmode!* memq '(!:rd!: !:cr!:)
          then return !:rn2rd mkrn(1,u)
       else u := apply1(get(dmode!*,'i2d),u);
      return (if not atom x and car x='!:rn!: then !:rn2rd x else x)
         where x=dcombine(1,u,'quotient)
   end;
+++ !:recip compiled, 45 + 40 bytes
:recip

symbolic procedure !:rn2rd x;
   % Convert rn to rd in dmodes rd and cr if roundall is on.
   if !*roundall and !*rounded then !*rn2rd x else x;
+++ !:rn2rd redefined
+++ !:rn2rd compiled, 9 + 20 bytes
:rn2rd

symbolic procedure !:times(u,v);
   % We assume neither u nor v can be 0.
   if null u or null v then nil
    else if atom u and atom v then u*v
    else dcombine(u,v,'times);
+++ !:times redefined
+++ !:times compiled, 18 + 16 bytes
:times

symbolic procedure !:zerop u;
   if null u or u=0 then t
    else if atom u then nil
    else apply1(get(car u,'zerop),u);
+++ !:zerop redefined
+++ !:zerop compiled, 16 + 16 bytes
:zerop

symbolic procedure fieldp u;
   % U is a domain element. Value is T if U is invertable, NIL
   % otherwise.
   not atom u and flagp(car u,'field);
+++ fieldp redefined
+++ fieldp compiled, 7 + 8 bytes
fieldp

symbolic procedure gettransferfn(u,v);
   % This may be unnecessary.  If dmodechk has been called, then all
   % transfer functions should be defined.
   (if x then x else dmoderr(u,v)) where x=get(u,v);
+++ gettransferfn compiled, 9 + 12 bytes
gettransferfn

symbolic procedure dcombine(u,v,fn);
   % U and V are domain elements, but not both atoms (integers).
   % FN is a binary function on domain elements;
   % Value is the domain element representing FN(U,V)
   % or pair of domain elements representing divide(u,v).
   <<u := if atom u
        then apply2(get(car v,fn),apply1(get(car v,'i2d),u),v)
       else if atom v
        then apply2(get(car u,fn),u,apply1(get(car u,'i2d),v))
       else if car u eq car v then apply2(get(car u,fn),u,v) else
      % convert anything to :ps: but not the reverse;
      % convert real to complex, never the reverse;
      % also convert rn or crn to rd or cr but not the reverse:
      % hence crn or gi plus rd requires that *both* convert to cr.
      (<<if (not(x and atom x)
             or (get(du,'cmpxfn) and not get(dv,'cmpxfn)
             or du memq dl and not(dv memq dl)) and dv neq '!:ps!:)
              % extra test added above by Alan Barnes to ensure
              % result is :ps: if either operand is a :ps:
            and not flagp(dv,'noconvert) then
           % convert v -> u but may first have to convert u.
            <<if du memq dml and dv eq '!:rd!:
                 or du eq '!:rd!: and dv memq dml then
                 <<u := apply1(get(du,'!:cr!:),u); du := '!:cr!:>>
              else if du eq '!:rn!: and dv eq '!:gi!:
                 or du eq '!:gi!: and dv eq '!:rn!: then
                 <<u := apply1(get(du,'!:crn!:),u); du := '!:crn!:>>;
              v := apply1(get(dv,du),v); x := get(du,fn)>>
            else <<u := apply1(x,u); x := get(dv,fn)>>;
         apply2(x,u,v)>>
       where x=get(du,dv),dml='(!:crn!: !:gi!:),dl='(!:rd!: !:cr!:))
       where du=car u,dv=car v;
       if !*rounded and !*roundall and not atom u then
        % atom test added by Alan Barnes in case a power series
        % operation has already produced an integer.
       int!-equiv!-chk
         if (v := car u) eq '!:rn!: and cddr u neq 1 then !*rn2rd u
         else if v eq '!:crn!: and (cdadr u neq 1 or cdddr u neq 1)
            then !*crn2cr u
         else u
       else if fn eq 'divide then   % Modified by Francis Wright.
          int!-equiv!-chk car u . int!-equiv!-chk cdr u
       else int!-equiv!-chk u>>;
+++ dcombine redefined
+++ dcombine compiled, 238 + 76 bytes
dcombine

symbolic procedure int!-equiv!-chk u;
   % U is a domain element. If U can be converted to 0, result is NIL,
   % if U can be converted to 1, result is 1,
   % if U is a rational or a complex rational and can be converted to
   % an integer, result is that integer,
   % if *convert is on and U can be converted to an integer, result
   % is that integer. Otherwise, U is returned.
   % In most cases, U will be structured.
   if !*noequiv then u
    else begin scalar x;
           if atom u then return if u=0 then nil else u
            else if apply1(get(car u,'zerop),u) then return nil
            else if apply1(get(car u,'onep),u) then return 1
%           else if null !*convert then return u
            else if (x := get(car u,'intequivfn)) and (x := apply1(x,u))
             then return if x=0 then nil else x
            else return u
      end;
+++ int!-equiv!-chk redefined
+++ int!-equiv!-chk compiled, 43 + 20 bytes
int-equiv-chk

% symbolic procedure minuschk u;
%    if eqcar(u,'minus)
%       and (numberp cadr u
%          or not atom cadr u and idp caadr u and get(caadr u,'dname))
%      then !:minus cadr u
%     else u;

% RmS 2014-08-08: support for abs, needed for non-constant domain modes
%                 like !:ps!:

symbolic procedure !:abs u;
   if null u then nil
    else if atom u then if minusp u then -u else u
    else (if x then apply1(x,u)
           else if apply1(get(car u,'minusp),u) then !:minus u
           else u)
       where x=get(car u,'abs);
+++ !:abs compiled, 34 + 16 bytes
:abs

endmodule;nil

end;nilmodule rational;nil % *** Tables for rational numbers ***.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


global '(domainlist!*);nil

switch rational;nil

domainlist!* := union('(!:rn!:),domainlist!*);(:rn:)
put('rational,'tag,'!:rn!:);:rn:
put('!:rn!:,'dname,'rational);rational
flag('(!:rn!:),'field);nil
put('!:rn!:,'i2d,'!*i2rn);*i2rn
put('!:rn!:,'!:ft!:,'!*rn2ft);*rn2ft
put('!:rn!:,'minus,'rnminus!:);rnminus:
put('!:rn!:,'minusp,'rnminusp!:);rnminusp:
put('!:rn!:,'plus,'rnplus!:);rnplus:
put('!:rn!:,'times,'rntimes!:);rntimes:
put('!:rn!:,'difference,'rndifference!:);rndifference:
put('!:rn!:,'quotient,'rnquotient!:);rnquotient:
put('!:rn!:,'zerop,'rnzerop!:);rnzerop:
put('!:rn!:,'onep,'rnonep!:);rnonep:
put('!:rn!:,'factorfn,'rnfactor!:);rnfactor:
put('!:rn!:,'expt,'rnexpt!:);rnexpt:
put('!:rn!:,'prepfn,'rnprep!:);rnprep:
put('!:rn!:,'prifn,'rnprin);rnprin
put('!:rn!:,'intequivfn,'rnequiv);rnequiv
put('!:rn!:,'rootfn,'rn!:root);rn:root
flag('(!:rn!:),'ratmode);nil

symbolic procedure rnexpt!:(u,n);
  % U is a tagged rational number, n an integer.
  begin scalar v;
     if n=0 then return 1;
     v:=cdr u;
     if (n<0) then <<
        n:=-n;
        if (car v < 0) then
           v:= (- cdr v) . (- car v)
           else v:= (cdr v) . (car v) >>;
     if (n=1) then return (car u) . v;
     return (car u) . ((car v ** n) . (cdr v ** n));
     % No more cancellation can take place in this exponentiation.
  end;
+++ rnexpt!: compiled, 59 + 16 bytes
rnexpt:

symbolic procedure mkratnum u;
   % U is a domain element. Value is equivalent real or complex
   % rational number.
   if atom u then !*i2rn u
    else if car u eq '!:gi!:
     then apply1(get('!:gi!:,'!:crn!:),u)
    else apply1(get(car u,'!:rn!:),u);
+++ mkratnum redefined
+++ mkratnum compiled, 22 + 24 bytes
mkratnum

symbolic procedure mkrn(u,v);
   %converts two integers U and V into a rational number, an integer
   %or NIL;
   if v<0 then mkrn(-u,-v)
    else (lambda m; '!:rn!: . ((u/m) . (v/m))) gcdn(u,v);
+++ mkrn redefined
+++ mkrn compiled, 32 + 12 bytes
mkrn

symbolic procedure !*i2rn u;
   %converts integer U to rational number;
   '!:rn!: . (u . 1);
+++ !*i2rn redefined
+++ !*i2rn compiled, 6 + 16 bytes
*i2rn

symbolic procedure rnminus!: u;
   % We must allow for a rational with structured arguments, since
   % lowest-terms can produce such objects.
   car u . !:minus cadr u . cddr u;
+++ rnminus!: redefined
+++ rnminus!: compiled, 9 + 12 bytes
rnminus:

symbolic procedure rnminusp!: u;
   % We must allow for a rational with structured arguments, since
   % lowest-terms can produce such objects.
   if atom (u := cadr u) then u < 0 else apply1(get(car u,'minusp),u);
+++ rnminusp!: redefined
+++ rnminusp!: compiled, 14 + 8 bytes
rnminusp:

symbolic procedure rnplus!:(u,v);
   mkrn(cadr u*cddr v+cddr u*cadr v,cddr u*cddr v);
+++ rnplus!: redefined
+++ rnplus!: compiled, 23 + 12 bytes
rnplus:

symbolic procedure rntimes!:(u,v);
   mkrn(cadr u*cadr v,cddr u*cddr v);
+++ rntimes!: redefined
+++ rntimes!: compiled, 15 + 12 bytes
rntimes:

symbolic procedure rndifference!:(u,v);
   mkrn(cadr u*cddr v-cddr u*cadr v,cddr u*cddr v);
+++ rndifference!: redefined
+++ rndifference!: compiled, 24 + 12 bytes
rndifference:

symbolic procedure rnquotient!:(u,v);
   mkrn(cadr u*cddr v,cddr u*cadr v);
+++ rnquotient!: redefined
+++ rnquotient!: compiled, 15 + 12 bytes
rnquotient:

symbolic procedure rnzerop!: u; cadr u=0;
+++ rnzerop!: redefined
+++ rnzerop!: compiled, 5 + 12 bytes
rnzerop:

symbolic procedure rnonep!: u; cadr u=1 and cddr u=1;
+++ rnonep!: redefined
+++ rnonep!: compiled, 10 + 12 bytes
rnonep:

symbolic procedure rnfactor!: u;
   begin scalar x,y,dmode!*; integer m,n;
     x := subf(u,nil);
     if not domainp denr x then return {1,(u . 1)};
        % Don't know what else to do.
     y := internal!-factorf numr x;
     n := car y;
     dmode!* := '!:rn!:;
     y := for each j in cdr y collect
           <<n := n*(m := (lnc ckrn car j)**cdr j);
             quotfd(car j,m) . cdr j>>;
     return int!-equiv!-chk mkrn(n,denr x) . y
   end;
+++ rnfactor!: compiled, 130 + 56 bytes
rnfactor:

symbolic procedure rnprep!: u;
   % PREPF is called on arguments, since the LOWEST-TERMS code in extout
   % can create rational objects with structured arguments.
   (if cddr u=1 then x else list('quotient,x,prepf cddr u))
    where x = prepf cadr u;
+++ rnprep!: redefined
+++ rnprep!: compiled, 20 + 20 bytes
rnprep:

symbolic procedure rnprin u;
   <<prin2!* cadr u; prin2!* "/"; prin2!* cddr u>>;
+++ rnprin compiled, 11 + 16 bytes
rnprin

symbolic procedure rnequiv u;
   % Returns an equivalent integer if possible.
   if cdr(u := cdr u)=1 then car u else nil;
+++ rnequiv redefined
+++ rnequiv compiled, 8 + 12 bytes
rnequiv

symbolic procedure rn!:root(u,n);
   (if x eq 'failed or y eq 'failed then 'failed else mkrn(x,y))
    where x=rootxf(cadr u,n), y=rootxf(cddr u,n);
+++ rn!:root compiled, 21 + 20 bytes
rn:root

initdmode 'rational;nil

endmodule;nil

end;nilmodule rnelem;nil

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*rounded);nil

% This module adds 10 integer functions to mode rational.

deflist('((fix rnfix!*) (round rnround!*)
  (ceiling rnceiling!*) (floor rnfloor!*) % (isqrt rnisqrt!*)
% (icbrt rnicbrt!*) (irootn rnirootn!*) (ilog2 rnilog2!*) (sgn rnsgn!*)
  (factorial rnfactorial!*) (perm rnperm!*) (choose rnchoose!*))
  ,'!:rn!:);(fix round ceiling floor factorial perm choose)

for each c in '(fix round ceiling floor % isqrt icbrt irootn ilog2 sgn
 factorial perm choose) do put(c,'simpfn,'simpiden);nil

flag('(fix floor ceiling round isqrt icbrt irootn ilog2 factorial % sgn
 perm choose) ,'integer);nil

deflist('((perm 2) (choose 2)),'number!-of!-args);(perm choose)

symbolic procedure rnfix!* x; quotient(cadr x,cddr x);
+++ rnfix!* redefined
+++ rnfix!* compiled, 7 + 8 bytes
rnfix*

symbolic procedure rnfixchk x;
   (if cdr y=0 then car y
    else error(0,list(prepf x,"is not an integer equivalent")))
   where y=divide(cadr x,cddr x);
+++ rnfixchk compiled, 22 + 24 bytes
rnfixchk

% symbolic procedure rnsgn!* x; sgn cadr x;

symbolic procedure rnfloor!* x;
   if cdr(x := divide(cadr x,cddr x))<0 then car x-1 else car x;
+++ rnfloor!* redefined
+++ rnfloor!* compiled, 16 + 8 bytes
rnfloor*

symbolic procedure rnceiling!* x;
   if cdr(x := divide(cadr x,cddr x))>0 then car x+1 else car x;
+++ rnceiling!* compiled, 17 + 12 bytes
rnceiling*

symbolic procedure rnround!* x;
   (if cadr rndifference!:(x,!*i2rn y)=0 then y
    else if rnminusp!: x then -rnround!*('!:rn!: . ((-cadr x) . cddr x))
    else rnfloor!*(rnplus!:(x,'!:rn!: . (1 . 2)))) where y=rnfix!* x;
+++ rnround!* compiled, 45 + 48 bytes
rnround*

% symbolic procedure rnisqrt!* x; isqrt rnfix!* x;

symbolic procedure rnilog2!* x; ilog2 rnfix!* x;
+++ rnilog2!* compiled, 5 + 16 bytes
rnilog2*

symbolic procedure rnfactorial!* x;
   (if fixp y and not(y<0) then nfactorial y
    else !*p2f mksp(list('factorial,y),1))
    where y=rnfixchk x;
+++ rnfactorial!* compiled, 24 + 28 bytes
rnfactorial*

symbolic procedure rnperm!*(x,n); perm(rnfixchk x,rnfixchk n);
+++ rnperm!* compiled, 9 + 16 bytes
rnperm*

symbolic procedure perm(x,n);
   if not fixp x or not fixp n or x<0 or x>n
      then terrlst(list(x,n),'perm) else for j := n-x+1:n product j;
+++ perm compiled, 44 + 16 bytes
perm

symbolic procedure rnchoose!*(x,n); choose(rnfixchk x,rnfixchk n);
+++ rnchoose!* compiled, 9 + 16 bytes
rnchoose*

symbolic procedure choose(x,n); perm(x,n)/factorial x;
+++ choose compiled, 9 + 16 bytes
choose

symbolic procedure simprn x;
   begin scalar !*rounded,dmode!*;
      dmode!* := '!:rn!:;
      return for each a in simplist x collect
         if atom a then !*i2rn a else a
   end;
+++ simprn compiled, 61 + 32 bytes
simprn

% symbolic procedure rnicbrt!* x; icbrt rnfix!* x;

symbolic procedure rnirootn!*(x,n); irootn(rnfix!* x,rnfixchk n);
+++ rnirootn!* compiled, 9 + 20 bytes
rnirootn*


endmodule;nil

end;nilmodule gint;nil  % Support for gaussian integers (complex numbers).

% Author: Eberhard Schruefer.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


global '(domainlist!*);nil

fluid '(!*complex !*gcd);nil

switch complex;nil

domainlist!* := union('(!:gi!:),domainlist!*);(:gi: :rn:)

symbolic procedure setcmpxmode(u,bool);
   % Sets polynomial domain mode in complex case.
   begin scalar x,y;
      x := get(u,'tag);
      if u eq 'complex
        then if null dmode!*
               then return if null bool then nil
                else <<put('i,'idvalfn,'mkdgi);
                       setdmode1('complex,bool)>>
         else if null bool
                then return if null !*complex then nil
                else if get(dmode!*,'dname) eq 'complex
                      then <<remprop('i,'idvalfn);
                             setdmode1('complex,nil)>>
                     else <<remprop('i,'idvalfn);
                           setdmode1(get(get(dmode!*,'realtype),'dname),
                                       t)>>
         else if dmode!* eq '!:gi!: or get(dmode!*,'realtype)
            then return nil
         else if not (y := get(dmode!*,'cmpxtype))
               then dmoderr(dmode!*,x)
         else <<put('i,'idvalfn,get(y,'ivalue));
                     return setdmode1(get(y,'dname),bool)>>
      else if null bool then
         if u eq (y := get(get(dmode!*,'realtype),'dname)) then
            <<put('i,'idvalfn,'mkdgi); return setdmode1('complex,t)>>
            else if null y then return nil
            else offmoderr(u,y)
      else <<u := get(u,'tag);
             y := get(u,'cmpxtype);
             if null y then dmoderr(u,'!:gi!:);
             put('i,'idvalfn,get(y,'ivalue));
             return setdmode1(get(y,'dname),bool)>>
   end;
+++ setcmpxmode compiled, 160 + 72 bytes
setcmpxmode

% Used by gcdk.

symbolic procedure intgcdd(u,v);
   if null u then v
   else if atom u then
      if atom v then gcdn(u,v) else gcdn(cadr v,gcdn(cddr v,u))
   else if atom v then intgcdd(v,u)
      else intgcdd(cadr u,intgcdd(cddr u,v));
+++ intgcdd compiled, 46 + 8 bytes
intgcdd

put('complex,'tag,'!:gi!:);:gi:
put('!:gi!:,'dname,'complex);complex
put('!:gi!:,'i2d,'!*i2gi);*i2gi
put('!:gi!:,'minusp,'giminusp!:);giminusp:
put('!:gi!:,'zerop,'gizerop!:);gizerop:
put('!:gi!:,'onep,'gionep!:);gionep:
put('!:gi!:,'plus,'giplus!:);giplus:
put('!:gi!:,'difference,'gidifference!:);gidifference:
put('!:gi!:,'times,'gitimes!:);gitimes:
put('!:gi!:,'quotient,'giquotient!:);giquotient:
put('!:gi!:,'divide,'gidivide!:);gidivide:
put('!:gi!:,'gcd,'gigcd!:);gigcd:
put('!:gi!:,'factorfn,'gifactor!:);gifactor:
% put('!:gi!:,'rationalizefn,'girationalize!:);
put('!:gi!:,'prepfn,'giprep!:);giprep:
put('!:gi!:,'intequivfn,'gintequiv!:);gintequiv:
put('!:gi!:,'specprn,'giprn!:);giprn:
put('!:gi!:,'prifn,'giprn!:);giprn:
put('!:gi!:,'cmpxfn,'mkgi);mkgi

put('!:gi!:,'unitsfn,'!:gi!:unitconv);:gi:unitconv

symbolic procedure !:gi!:unitconv(u,v);
   unitconv(u,v,get('!:gi!:,'units));
+++ !:gi!:unitconv compiled, 11 + 16 bytes
:gi:unitconv

put('!:gi!:,'units,'(((!:gi!: 0 . 1) . (!:gi!: 0 . -1))
             ((!:gi!: 0 . -1) . (!:gi!: 0 . 1))));(((:gi: 0 . 1) :gi: 0 . -1) ((
:gi: 0 . -1) :gi: 0 . 1))

symbolic procedure unitconv(u,v,w);
   begin scalar z;
   a: if null w then return u;
      z := quotf1(v,caar w);
      if null z or not fixp z then <<w := cdr w; go to a>>;
      z := multf(denr u,cdar w);
      w := multf(numr u,cdar w);
      if minusf z then <<w := negf w; z := negf z>>;
      return w ./ z
   end;
+++ unitconv compiled, 42 + 24 bytes
unitconv

symbolic procedure !*i2gi u; '!:gi!: . (u . 0);
+++ !*i2gi redefined
+++ !*i2gi compiled, 6 + 16 bytes
*i2gi

symbolic procedure giminusp!: u;
   %*** this is rather a test for u being in a canonical form! ***;
   if cadr u = 0 then minusp cddr u else minusp cadr u;
+++ giminusp!: redefined
+++ giminusp!: compiled, 14 + 12 bytes
giminusp:

symbolic procedure gizerop!: u;
   cadr u = 0 and cddr u = 0;
+++ gizerop!: redefined
+++ gizerop!: compiled, 10 + 12 bytes
gizerop:

symbolic procedure gionep!: u;
   cadr u=1 and cddr u=0;
+++ gionep!: redefined
+++ gionep!: compiled, 10 + 16 bytes
gionep:

symbolic procedure gintequiv!: u;
   if cddr u=0 then cadr u else nil;
+++ gintequiv!: redefined
+++ gintequiv!: compiled, 8 + 12 bytes
gintequiv:

symbolic procedure mkdgi u;
   ('!:gi!: . (0 . 1)) ./ 1;
+++ mkdgi compiled, 8 + 20 bytes
mkdgi

symbolic procedure mkgi(re,im);
   '!:gi!: . (re . im);
+++ mkgi redefined
+++ mkgi compiled, 5 + 12 bytes
mkgi

symbolic procedure giplus!:(u,v);
   mkgi(cadr u+cadr v,cddr u+cddr v);
+++ giplus!: redefined
+++ giplus!: compiled, 15 + 12 bytes
giplus:

symbolic procedure gidifference!:(u,v);
   mkgi(cadr u-cadr v,cddr u-cddr v);
+++ gidifference!: compiled, 15 + 12 bytes
gidifference:

symbolic procedure gitimes!:(u,v);
   (lambda r1,i1,r2,i2;
       mkgi(r1*r2-i1*i2,r1*i2+r2*i1))
    (cadr u,cddr u,cadr v,cddr v);
+++ gitimes!: redefined
+++ gitimes!: compiled, 36 + 12 bytes
gitimes:

symbolic procedure giquotient!:(u,v);
% Quotient when the quotient is exact, otherwise zero.
   begin integer r1,i1,r2,i2,d; scalar rr,ii;
     r1 := cadr u; i1 := cddr u;
     r2 := cadr v; i2 := cddr v;
     d := r2*r2+i2*i2;
     rr := divide(r1*r2+i1*i2,d);
     ii := divide(i1*r2-i2*r1,d);
     return if cdr ii=0 and cdr rr=0 then mkgi(car rr,car ii)
             else '!:gi!: . (0 . 0)
   end;
+++ giquotient!: compiled, 72 + 20 bytes
giquotient:

symbolic procedure gidivide!:(u,v);
% Rounded quotient and corresponding remainder. This rounds to the
% NEAREST quotient. In some cases there can be several such (eg when
% dividing by 2) and in that case use resolve the ambiguity by selecting
% the result closes to zero in real and imaginary parts.
   begin integer r1,i1,r2,i2,d,rr,ir,rq,iq;
     r1 := cadr u; i1 := cddr u;
     r2 := cadr v; i2 := cddr v;
     d := r2*r2+i2*i2;
     rq := r1*r2+i1*i2;
     iq := i1*r2-i2*r1;
     rq := car divide(2*rq+if rq<0 then -d+1 else d-1,2*d);
     iq := car divide(2*iq+if iq<0 then -d+1 else d-1,2*d);
     rr := r1-(rq*r2-iq*i2);
     ir := i1-(iq*r2+rq*i2);
     return mkgi(rq,iq) . mkgi(rr,ir)
   end;
+++ gidivide!: compiled, 153 + 20 bytes
gidivide:

symbolic procedure giremainder(u,v);
% Remainder as from gidivide:
   begin integer r1,i1,r2,i2,d,rr,ir,rq,iq;
     r1 := cadr u; i1 := cddr u;
     r2 := cadr v; i2 := cddr v;
     d := r2*r2+i2*i2;
     rq := r1*r2+i1*i2;
     iq := i1*r2-i2*r1;
     rq := car divide(2*rq+if rq<0 then -d+1 else d-1,2*d);
     iq := car divide(2*iq+if iq<0 then -d+1 else d-1,2*d);
     rr := r1-(rq*r2-iq*i2);
     ir := i1-(iq*r2+rq*i2);
     return '!:gi!: . (rr . ir)
   end;
+++ giremainder compiled, 148 + 20 bytes
giremainder

symbolic procedure gigcd!:(u,v);
   % Straightforward Euclidean algorithm.
   if gizerop!: v then fqa u else gigcd!:(v,giremainder(u,v));
+++ gigcd!: redefined
+++ gigcd!: compiled, 17 + 20 bytes
gigcd:

symbolic procedure fqa u;
   %calculates the unique first-quadrant associate of u;
  if cddr u=0 then abs cadr u
   else if cadr u=0 then '!:gi!: . (abs cddr u . 0)
   else if (cadr u*cddr u)>0 then
                  '!:gi!: . (abs cadr u . abs cddr u)
   else '!:gi!: . (abs cddr u . abs cadr u);
+++ fqa compiled, 61 + 16 bytes
fqa

symbolic procedure gifactor!: u;
   % Trager's modified version of Van der Waerdens algorithm.
   begin scalar x,y,norm,aftrs,ftrs,mvu,dmode!*,!*exp,w,z,l,bool;
         integer s;
     !*exp := t;
     w := 1;
     if realp u
        then <<u := fctrf u; w := car u; u := cdr u>>
      else u := list(u . 1);
     for each f in u do begin
     u := car f;
     dmode!* := '!:gi!:;
     mvu := power!-sort powers u;
     bool := contains!-oddpower mvu;
     if realp u and bool
        then <<u := normalize!-lcgi u;
               w := multd(car u,w);
               aftrs := (cdr u . 1) . aftrs;
               return>>;
     mvu := caar mvu;
     y := u;
     go to b;
     a: l := list(mvu . prepf addf(!*k2f mvu,multd(s,!*k2f 'i)));
        u := numr subf1(y,l);
     b: if realp u
           then if bool
                   then <<y := normalize!-lcgi y;
                          w := multd(car y,w);
                          aftrs := (cdr y . 1) . aftrs;
                          return>>
                 else <<s := s-1; go to a>>;
        norm := multf(u,conjgd u);
        if not sqfrp norm then <<s := s-1; go to a>>;
     dmode!* := nil;
     ftrs := fctrf norm;
     dmode!* := '!:gi!:;
     if null cddr ftrs then <<y := normalize!-lcgi y;
                              w := multd(car y,w);
                              aftrs := (cdr y . 1) . aftrs;
                              return>>;
     w := car ftrs;
     l := if s=0 then nil
           else list(mvu . prepf addf(!*k2f mvu,
                                      negf multd(s,!*k2f 'i)));
     for each j in cdr ftrs do
         <<x := gcdf!*(car j,u);
           u := quotf!*(u,x);
           z := if l then numr subf1(x,l) else x;
           z := normalize!-lcgi z;
           w := multd(car z,w);
           aftrs := (cdr z . 1) . aftrs>>;
     w := multf(u,w) end;
     return w . aftrs
   end;
+++ gifactor!: compiled, 393 + 108 bytes
gifactor:

symbolic procedure normalize!-lcgi u;
   % Normalize lnc by using units as canonsq would do it.
   begin scalar l,x,y;
     l := lnc u;
     if numberp l then return if minusp l then (-1) . negf u
                               else 1 . u;
     x := get('!:gi!:,'units);
     a: if null x then return 1 . u;
        y := quotf1(l,caar x);
        if null y or null fixp y then <<x := cdr x; go to a>>;
        u := multd(cdar x,u);
        return if minusf u then negf caar x . negf u
                else caar x . u
   end;
+++ normalize!-lcgi compiled, 70 + 40 bytes
normalize-lcgi

symbolic procedure contains!-oddpower u;
   if null u then nil
    else if evenp cdar u then contains!-oddpower cdr u
    else t;
+++ contains!-oddpower compiled, 14 + 12 bytes
contains-oddpower

symbolic procedure power!-sort u;
   begin scalar x,y;
     while u do
       <<x := maxdeg(cdr u,car u);
         u := delallasc(car x,u);
         y := x . y>>;
     return y
   end;
+++ power!-sort compiled, 18 + 16 bytes
power-sort

symbolic procedure sqfrp u;
   % Square free test for poly u over the integers.
   % It works best with ezgcd on.
   begin scalar !*ezgcd, dmode!*;
     % Make sure ezgcd loaded.
     if null getd 'ezgcdf1 then load_package ezgcd;
     !*ezgcd := t;
     return domainp gcdf!*(u,diff(u,mvar u))
   end;
+++ sqfrp compiled, 39 + 48 bytes
sqfrp

symbolic procedure realp u;
   if domainp u
     then atom u
        or not get(car u,'cmpxfn)
        or cddr u = cddr apply1(get(car u,'i2d),1)
    else realp lc u and realp red u;
+++ realp compiled, 44 + 20 bytes
realp

symbolic procedure fd2f u;
   if atom u then u
    else if car u eq '!:gi!:
        then addf(!*n2f cadr u,multf(!*k2f 'i,!*n2f cddr u))
    else addf(multf(!*p2f lpow u,fd2f lc u),fd2f red u);
+++ fd2f compiled, 48 + 36 bytes
fd2f


% symbolic procedure giprep!: u;  %giprep1 cdr u;
%   prepsq!* addsq(!*n2f cadr u ./ 1,
%                  multsq(!*n2f cddr u ./ 1, !*k2q 'i));

% symbolic procedure giprep1 u;  %not used now;
%    if cdr u=0 then car u
%     else if car u=0 then retimes list(cdr u,'i)
%     else begin scalar gn;
%            gn := gcdn(car u,cdr u);
%            return retimes list(gn,
%                       replus list(car u/gn,retimes list(cdr u/gn,'i)))
%          end;

symbolic procedure giprep!: u;
   <<if im=0 then rl else if rl=0 then giprim im
     else if im<0 then list('difference,rl,giprim(minus im))
     else list('plus,rl,giprim im)>>
   where rl=cadr u,im=cddr u;
+++ giprep!: compiled, 42 + 24 bytes
giprep:

symbolic procedure giprim im; if im=1 then 'i else list('times,im,'i);
+++ giprim redefined
+++ giprim compiled, 11 + 20 bytes
giprim

symbolic procedure giprn!: v;
   (lambda u;
    if atom u or (car u eq 'times) then maprin u
     else <<prin2!* "("; maprin u; prin2!* ")" >>) giprep!: v;
+++ giprn!: compiled, 18 + 32 bytes
giprn:

% symbolic procedure girationalize!: u;
%    %Rationalizes standard quotient u over the gaussian integers.
%    begin scalar x,y,z;
%       y := denr u;
%       z := conjgd y;
%       if y=z then return u;
%       x := multf(numr u,z);
%       y := multf(y,z);
%       return x ./ y
%    end;

symbolic procedure girationalize!: u;
   % Rationalizes standard quotient u over the gaussian integers.
   begin scalar y,z,!*gcd;
      !*gcd := t;
      if y=(z := conjgd(y := denr u)) then return u;
      % Remove from z any real polynomial factors of y and z.
      z := quotf!-fail(z,quotf(
         gcdf(addf(y,z),multf(addf(z,negf y),'!:gi!: . (0 . 1))),2));
      % The following subs2 can undo the above if !*match is non-NIL.
%     return subs2 gigcdsq(multf(numr u,z),multf(y,z))
      return gigcdsq(multf(numr u,z),multf(y,z))
   end;
+++ girationalize!: redefined
+++ girationalize!: compiled, 67 + 68 bytes
girationalize:

symbolic procedure gigcdsq(x,y); % remove integer common factor.
   <<if x then
        (<<if d neq 1 and (d := giintgcd(x,d)) neq 1 then
              <<x := quotf(x,d); y := quotf(y,d)>> >>
         where d=giintgcd(y,0)); x ./ y >>;
+++ gigcdsq redefined
+++ gigcdsq compiled, 30 + 24 bytes
gigcdsq

symbolic procedure giintgcd(u,d);
   if d=1 then 1 else if null u then d else if atom u then gcdn(u,d)
   else if eqcar(u,'!:gi!:) then gcdn(cadr u,gcdn(cddr u,d))
   else giintgcd(lc u,giintgcd(red u,d));
+++ giintgcd redefined
+++ giintgcd compiled, 42 + 16 bytes
giintgcd

symbolic procedure conjgd u;
   begin scalar x;
      return if atom u then u
              else if domainp u and (x := get(car u,'cmpxfn))
               then
                  apply2(x,cadr u,
                   if numberp cddr u then -cddr u
                       % Allow for tagged parts of complex object.
                       else if domainp cddr u and not numberp caddr u
                          then !:minus cddr u
                       else cdr !:minus (get(car u,'realtype).cddr u))
              else if domainp u then u   % Should be a real number now.
              else addf(multpf(lpow u,conjgd lc u),conjgd red u)
   end;
+++ conjgd redefined
+++ conjgd compiled, 86 + 32 bytes
conjgd

initdmode 'complex;nil

endmodule;nil

end;nilmodule cpxrn;nil % *** Support for Complex Rationals.

% Authors: Anthony C. Hearn and Stanley L. Kameny.

% Copyright (c) 1989 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


COMMENT this module defines a complex rational as:

      (<tag>. (<structure> . <structure>>).

The <tag> is '!:crn!: and the <structure> is (n . d) where n and d are
integers;

fluid '(!:prec!:);nil

global '(bfone!* epsqrt!*);nil

fluid '(dmode!* !*bfspace !*numval);nil

switch bfspace,numval;nil !*bfspace := !*numval := t;t

global '(domainlist!*);nil

domainlist!* := union('(!:crn!:),domainlist!*);(:crn: :gi: :rn:)

fluid '(!*complex!-rational);nil

put('complex!-rational,'tag,'!:crn!:);:crn:
put('!:crn!:,'dname,'complex!-rational);complex-rational
flag('(!:crn!:),'field);nil
put('!:crn!:,'i2d,'i2crn!*);i2crn*
put('!:crn!:,'plus,'crn!:plus);crn:plus
put('!:crn!:,'times,'crn!:times);crn:times
put('!:crn!:,'difference,'crn!:differ);crn:differ
put('!:crn!:,'quotient,'crn!:quotient);crn:quotient
put('!:crn!:,'zerop,'crn!:zerop);crn:zerop
put('!:crn!:,'onep,'crn!:onep);crn:onep
put('!:crn!:,'prepfn,'crn!:prep);crn:prep
put('!:crn!:,'prifn,'crn!:prin);crn:prin
put('!:crn!:,'minus,'crn!:minus);crn:minus
put('!:crn!:,'factorfn,'crn!:factor);crn:factor
put('!:crn!:,'rationalizefn,'girationalize!:);girationalize:
put('!:crn!:,'!:rn!:,'!*crn2rn);*crn2rn
put('!:rn!:,'!:crn!:,'!*rn2crn);*rn2crn
put('!:rd!:,'!:crn!:,'!*rd2crn);*rd2crn
put('!:crn!:,'!:rd!:,'!*crn2rd);*crn2rd
put('!:gi!:,'!:crn!:,'!*gi2crn);*gi2crn
put('!:crn!:,'cmpxfn,'mkcrn);mkcrn
put('!:crn!:,'ivalue,'mkdcrn);mkdcrn
put('!:crn!:,'intequivfn,'crnequiv);crnequiv
put('!:crn!:,'realtype,'!:rn!:);:rn:
put('!:rn!:,'cmpxtype,'!:crn!:);:crn:

put('!:crn!:,'minusp,'crn!:minusp);crn:minusp

symbolic procedure mkcrn(u,v); '!:crn!: . u . v;
+++ mkcrn redefined
+++ mkcrn compiled, 5 + 12 bytes
mkcrn

symbolic inline procedure crntag x; '!:crn!: . x;
+++ Record new inline definition:
(de crntag (x) (cons (quote !:crn!:) x))
(progn (de crntag (x) (cons (quote !:crn!:) x)) (put (quote crntag) (quote
number!-of!-args) 1) (put (quote crntag) (quote procedure_type) (quote (arrow
general general))) (putc (quote crntag) (quote inline) (quote (lambda (x) (cons
(quote !:crn!:) x)))))
+++ crntag compiled, 4 + 12 bytes
(lambda (x) (cons (quote :crn:) x))

symbolic inline procedure rntag x; '!:rn!: . x;
+++ Record new inline definition:
(de rntag (x) (cons (quote !:rn!:) x))
(progn (de rntag (x) (cons (quote !:rn!:) x)) (put (quote rntag) (quote
number!-of!-args) 1) (put (quote rntag) (quote procedure_type) (quote (arrow
general general))) (putc (quote rntag) (quote inline) (quote (lambda (x) (cons (
quote !:rn!:) x)))))
+++ rntag compiled, 4 + 12 bytes
(lambda (x) (cons (quote :rn:) x))

symbolic inline procedure crnrl x; cadr x;
+++ Record new inline definition:
(de crnrl (x) (cadr x))
(progn (de crnrl (x) (cadr x)) (put (quote crnrl) (quote number!-of!-args) 1) (
put (quote crnrl) (quote procedure_type) (quote (arrow general general))) (putc
(quote crnrl) (quote inline) (quote (lambda (x) (cadr x)))))
+++ crnrl compiled as link to cadr
(lambda (x) (cadr x))

symbolic inline procedure crnim x; cddr x;
+++ Record new inline definition:
(de crnim (x) (cddr x))
(progn (de crnim (x) (cddr x)) (put (quote crnim) (quote number!-of!-args) 1) (
put (quote crnim) (quote procedure_type) (quote (arrow general general))) (putc
(quote crnim) (quote inline) (quote (lambda (x) (cddr x)))))
+++ crnim compiled as link to cddr
(lambda (x) (cddr x))

symbolic procedure crn!:minusp u; car crnim u=0 and minusp car crnrl u;
+++ crn!:minusp compiled, 12 + 12 bytes
crn:minusp

symbolic procedure crn!:simp u; (crntag u) ./ 1;
+++ crn!:simp compiled, 6 + 16 bytes
crn:simp

put('!:crn!:,'simpfn,'crn!:simp);crn:simp

symbolic procedure mkdcrn u;
   ('!:crn!: . ((0 . 1) . (1 . 1))) ./ 1;
+++ mkdcrn compiled, 15 + 20 bytes
mkdcrn

symbolic procedure i2crn!* u; mkcrn(u . 1,0 . 1);
+++ i2crn!* compiled, 11 + 20 bytes
i2crn*
   %converts integer U to tagged crn form.

symbolic procedure !*crn2rn n;
   % Converts a crn number n into a rational if possible.
   if not(car crnim n=0) then cr2rderr() else '!:rn!: . crnrl n;
+++ !*crn2rn compiled, 13 + 20 bytes
*crn2rn

symbolic procedure !*rn2crn u; mkcrn(cdr u,0 . 1);
+++ !*rn2crn compiled, 9 + 20 bytes
*rn2crn
   % Converts the (tagged) rational u/v into a (tagged) crn.

symbolic procedure !*crn2rd n;
   if not(car crnim n=0) then cr2rderr() else
     mkround chkrn!* r2bf crnrl n;
+++ !*crn2rd compiled, 16 + 28 bytes
*crn2rd

symbolic procedure !*rd2crn u; mkcrn(realrat x,0 . 1) where x=round!* u;
+++ !*rd2crn compiled, 13 + 28 bytes
*rd2crn

symbolic procedure !*gi2crn u; mkcrn((cadr u) . 1,(cddr u) . 1);
+++ !*gi2crn compiled, 13 + 16 bytes
*gi2crn

symbolic procedure crn!:plus(u,v);
   mkcrn(cdr rnplus!:(rntag crnrl u,rntag crnrl v),
         cdr rnplus!:(rntag crnim u,rntag crnim v));
+++ crn!:plus compiled, 31 + 20 bytes
crn:plus

symbolic procedure crn!:differ(u,v);
   mkcrn(cdr rndifference!:(rntag crnrl u,rntag crnrl v),
         cdr rndifference!:(rntag crnim u,rntag crnim v));
+++ crn!:differ compiled, 31 + 20 bytes
crn:differ

symbolic procedure crn!:times(u,v);
   mkcrn(cdr rndifference!:(rntimes!:(ru,rv),rntimes!:(iu,iv)),
         cdr rnplus!:(rntimes!:(ru,iv),rntimes!:(rv,iu)))
   where ru=rntag crnrl u,iu=rntag crnim u,
         rv=rntag crnrl v,iv=rntag crnim v;
+++ crn!:times compiled, 47 + 28 bytes
crn:times

symbolic procedure crn!:quotient(u,v);
 <<v := rnplus!:(rntimes!:(rv,rv),rntimes!:(iv,iv));
  mkcrn(cdr rnquotient!:(rnplus!:(rntimes!:(ru,rv),rntimes!:(iu,iv)),v),
cdr rnquotient!:(rndifference!:(rntimes!:(iu,rv),rntimes!:(ru,iv)),v))>>
  where ru=rntag crnrl u,iu=rntag crnim u,
        rv=rntag crnrl v,iv=rntag crnim v;
+++ crn!:quotient compiled, 61 + 32 bytes
crn:quotient

symbolic procedure crn!:minus u;
   mkcrn((-car ru) . cdr ru,(-car iu) . cdr iu)
   where ru=crnrl u,iu=crnim u;
+++ crn!:minus compiled, 21 + 12 bytes
crn:minus

symbolic procedure crn!:zerop u; car crnrl u=0 and car crnim u=0;
+++ crn!:zerop redefined
+++ crn!:zerop compiled, 12 + 12 bytes
crn:zerop

symbolic procedure crn!:onep u;  car crnim u=0 and crnrl u='(1 . 1);
+++ crn!:onep compiled, 11 + 16 bytes
crn:onep

symbolic procedure crn!:prep u;
   crnprep1((rntag crnrl u) . rntag crnim u);
+++ crn!:prep compiled, 14 + 16 bytes
crn:prep

symbolic procedure crn!:factor u;
   (begin scalar m,n,p,x,y;
     setdmode('rational,nil) where !*msg = nil;
     x := subf(u,nil);
     y := fctrf numr x;
     n := car y;
     setdmode('rational,t) where !*msg = nil;
     y := for each j in cdr y collect
           <<p := numr subf(car j,nil);
             n := multd(n,m := exptf(lnc ckrn p,cdr j));
             quotfd(p,m) . cdr j>>;
     return int!-equiv!-chk quotfd(n,denr x) . y
   end) where dmode!*=dmode!*;
+++ crn!:factor compiled, 137 + 68 bytes
crn:factor

symbolic procedure crnprimp u;
   if rnonep!: u then 'i
   else if rnonep!: rnminus!: u then list('minus,'i)
   else list('times,rnprep!: u,'i);
+++ crnprimp compiled, 25 + 32 bytes
crnprimp

symbolic procedure crnprep1 u;
   if rnzerop!: cdr u then rnprep!: car u
   else if rnzerop!: car u then crnprimp cdr u
   else
% Make sure for that a negative real part has always minus as toplevel prefix op.
% Otherwise, a number like -1/2 + i would be returned as
%   (plus (quotient (minus 1) 2) i)
% Now it returns (plus (minus (quotient 1 2)) i) 
%  which is better handled in printing.
      (if rnminusp!: cdr u
       then list('difference,v,crnprimp rnminus!: cdr u)
      else list('plus,v,crnprimp cdr u))
	 where v := if rnminusp!: car u then {'minus,rnprep!: rnminus!: car u} else rnprep!: car u;
+++ crnprep1 compiled, 62 + 40 bytes
crnprep1

symbolic procedure crn!:prin u;
   (if atom v or car v eq 'times or car v memq domainlist!*
      then maprin v
    else <<prin2!* "("; maprin v; prin2!* ")">>) where v=crn!:prep u;
+++ crn!:prin compiled, 24 + 36 bytes
crn:prin

symbolic procedure crnequiv u;
   % Returns an equivalent integer if possible.
   if cadr(u := cdr u) = 0 and cdar u = 1 then caar u else nil;
+++ crnequiv compiled, 12 + 16 bytes
crnequiv

initdmode 'complex!-rational;nil

endmodule;nil

end;nilmodule compopr;nil   % Operators on Complex Expressions.

% Author: Eberhard Schruefer.
% Modifications by:  Francis Wright, Rainer Schoepf & Alan Barnes.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*exp !*factor kord!*);nil

put('repart,'simpfn,'simprepart);simprepart

symbolic procedure simprepart u;
   repartsq simp!* car u where !*factor = nil;
+++ simprepart redefined
+++ simprepart compiled, 11 + 24 bytes
simprepart

symbolic procedure repartsq u;
   multsq(addsq(multsq(repartnum,repartden),
                multsq(impartnum,impartden)),
          invsq addsq(multsq(repartden,repartden),
                      multsq(impartden,impartden)))
   where repartnum = car reimnum, impartnum = cdr reimnum,
         repartden = car reimden, impartden = cdr reimden
   where reimnum = splitcomplex numr u,
         reimden = splitcomplex denr u;
+++ repartsq redefined
+++ repartsq compiled, 40 + 24 bytes
repartsq

put('impart,'simpfn,'simpimpart);simpimpart

symbolic procedure simpimpart u;
   impartsq simp!* car u where !*factor = nil;
+++ simpimpart redefined
+++ simpimpart compiled, 11 + 24 bytes
simpimpart

symbolic procedure impartsq u;
   multsq(addsq(multsq(impartnum,repartden),
                negsq multsq(repartnum,impartden)),
          invsq addsq(multsq(repartden,repartden),
                      multsq(impartden,impartden)))
   where repartnum = car reimnum, impartnum = cdr reimnum,
         repartden = car reimden, impartden = cdr reimden
   where reimnum = splitcomplex numr u,
         reimden = splitcomplex denr u;
+++ impartsq redefined
+++ impartsq compiled, 40 + 28 bytes
impartsq

put('conj,'simpfn,'simpconj);simpconj

% symbolic procedure simpconj u;
%    conjsq simp!* car u;

% Changes by Eberhard Schruefer & Alan Barnes to support rules for
% conj(<kernel>), October 2018.

symbolic procedure simpconj u;
   multsq(cmpx_conjsf numr x, invsq cmpx_conjsf denr x)
   where x = simp car u;
+++ simpconj compiled, 13 + 24 bytes
simpconj

symbolic procedure cmpx_conjsf u;
   if domainp u then
      if atom u or not get(car u, 'cmpxfn)
          then u ./ 1  else conjsq(u ./ 1)
    else addsq(cmpx_conjt lt u, cmpx_conjsf red u);
+++ cmpx_conjsf compiled, 44 + 28 bytes
cmpx_conjsf
    
symbolic procedure cmpx_conjt u;
   begin scalar x,y,z;
     y := tvar u;
     z := if atom y and flagp(y, 'realvalued) then !*k2q y
           else if null atom y and flagp(y,'alwaysrealvalued)
	     then !*k2q y
           else if null atom y and flagp(car y, 'selfconjugate)
             then simp((car y) . foreach arg in cdr y collect {'conj, arg})
           else if x := get_conj(y) then simp x
	   else if null atom y and (x := get_conj(car y)) then
	          if null atom x then typerr(x, "operator")
                  else simp(x . foreach arg in cdr y collect {'conj, arg})
	   else conjsq simp y;
     return multsq(exptsq(z,tdeg u), cmpx_conjsf tc u);
end;
+++ cmpx_conjt compiled, 179 + 64 bytes
cmpx_conjt

symbolic procedure get_conj y;
begin scalar cnj;
   cnj := rassoc({y}, get('conj, 'kvalue));
   if cnj then return cadar cnj;
   cnj := car getpower(fkern({'conj, y}),1);
   cnj := assoc(cnj, get('conj, 'kvalue));
   if cnj then return cadr cnj
   else return nil;
end;
+++ get_conj compiled, 38 + 28 bytes
get_conj

symbolic procedure conjsq u;
  (if null numr w then u else addsq(repartsq u,negsq multsq(simp 'i,w)))
   where w=impartsq u;
+++ conjsq compiled, 20 + 36 bytes
conjsq

inline procedure idomainp; get('i,'idvalfn);
+++ Record new inline definition:
(de idomainp nil (get (quote i) (quote idvalfn)))
(progn (de idomainp nil (get (quote i) (quote idvalfn))) (put (quote idomainp) (
quote number!-of!-args) 0) (put (quote idomainp) (quote procedure_type) (quote (
arrow unit general))) (putc (quote idomainp) (quote inline) (quote (lambda nil (
get (quote i) (quote idvalfn))))))
+++ idomainp compiled, 4 + 12 bytes
(lambda nil (get (quote i) (quote idvalfn)))
  % Tests if 'i' is transformed to a domain structure.

symbolic procedure splitcomplex u;
   (begin scalar v;
      v := if idomainp() then expand!-imrepart u
            else <<if smemq('i,u) then
                   <<setkorder('i . kord!*); u:=reorder u>>;
                   subs2 expand!-imrepart u>>;
      return take!-realpart v . take!-impart v
    end) where kord!* = kord!*,!*exp = t;
+++ splitcomplex redefined
+++ splitcomplex compiled, 51 + 52 bytes
splitcomplex

symbolic procedure expand!-imrepart u;
   if domainp u then u ./ 1
    else addsq(multsq(expand!-imrepartpow lpow u,
                      expand!-imrepart lc u),
               expand!-imrepart red u);
+++ expand!-imrepart redefined
+++ expand!-imrepart compiled, 37 + 24 bytes
expand-imrepart

symbolic procedure expand!-imrepartpow u;
   % This needs to treat kernels that are standard forms smarter.
   % At the moment, we expand to get the required result.
   begin scalar !*exp,cmpxsplitfn;
     !*exp := t;
     cmpxsplitfn := pairp !_pvar!_ u and idp car !_pvar!_ u and
                    get(car !_pvar!_ u,'cmpxsplitfn);
     return
       exptsq(if null cmpxsplitfn
                 then if !_pvar!_ u eq 'i then !*k2q 'i
                       else addsq(mkrepart !_pvar!_ u,
                                  multsq(simp 'i,
                                         mkimpart !_pvar!_ u))
               else apply1(cmpxsplitfn,!_pvar!_ u),pdeg u)
    end;
+++ expand!-imrepartpow redefined
+++ expand!-imrepartpow compiled, 66 + 64 bytes
expand-imrepartpow

symbolic procedure mkrepart u;
   if sfp u
     then if realvaluedp!-sf u then !*k2q u
            else repartsq(u ./ 1)
    else if realvaluedp u then !*k2q u
    else mksq(list('repart, u),1);
+++ mkrepart redefined
+++ mkrepart compiled, 48 + 40 bytes
mkrepart

symbolic procedure mkimpart u;
   if sfp u
     then if realvaluedp!-sf u then nil ./ 1
            else impartsq(u ./ 1)
    else if realvaluedp u then nil ./ 1
    else mksq(list('impart, u),1);
+++ mkimpart redefined
+++ mkimpart compiled, 37 + 36 bytes
mkimpart

symbolic procedure take!-realpart u;
% real part of numerator and the denominator may have a common factor 
% so must use multsq here
%   repartf numr u ./ denr u;
   multsq(repartf(numr u) ./ 1, 1 ./ denr u);
+++ take!-realpart redefined
+++ take!-realpart compiled, 12 + 20 bytes
take-realpart

symbolic procedure repartf u;
   % We can't check for null dmode!* as there may still be complex
   % domain elements in the expression (e.g., e^repart x).
  (if domainp u
      then if atom u then u
            else if get(car u,'cmpxfn)
            % We now know u is of form (<tag> <re> . <im>).
              then int!-equiv!-chk(car u . cadr u .
                        cadr apply1(get(car u,'i2d),0))
        % Otherwise we assume it is real
       else u
    else if mvar u eq 'i then repartf red u
%    else if null dmode!* then addf(!*t2f lt u,repartf red u)
    else addf(multpf(lpow u,repartf lc u),repartf red u))
       where u = reorder u where kord!* = 'i . kord!*;
+++ repartf redefined
+++ repartf compiled, 74 + 48 bytes
repartf

symbolic procedure take!-impart u;
% imaginary part of numerator and the denominator may have a common factor 
% so must use multsq here
%   impartf numr u ./ denr u;
   multsq(impartf(numr u) ./ 1, 1 ./ denr u);
+++ take!-impart redefined
+++ take!-impart compiled, 12 + 20 bytes
take-impart

symbolic procedure impartf u;
   % We can't check for null dmode!* as there may still be complex
   % domain elements in the expression.
  (if domainp u
     then if atom u then nil
           else if get(car u,'cmpxfn)
            % We now know u is of form (<tag> <re> . <im>).
             then int!-equiv!-chk(car u . cddr u .
                                  cadr apply1(get(car u,'i2d),0))
        % Otherwise we assume it is real
       else nil
    else if mvar u eq 'i then addf(lc u,impartf red u)
%   else if null dmode!* then impartf red u
    else addf(multpf(lpow u,impartf lc u),impartf red u))
       where u = reorder u where kord!* = 'i . kord!*;
+++ impartf redefined
+++ impartf compiled, 82 + 48 bytes
impartf

% The following code attempts to improve the way that the complex
% operators CONJ, REPART and IMPART handle values that are implicitly
% real, namely composed "reality-preserving" functions of explicitly
% real numbers, implicitly real symbolic constants and variables that
% the user has declared using the REALVALUED command defined below.

% All arithmetic operations, direct trig functions and the exponential
% function are "reality-preserving", but inverse trig functions and the
% logarithm are "reality-preserving" only for real arguments in a
% restricted range.  This relates to piecewise-defined functions!  This
% code is believed to make the right decision about implicit reality in
% straightforward cases, and otherwise errs on the side of caution and
% makes no assumption at all, as does the standard REDUCE 3.4 code.  It
% performs only very limited numerical evaluation, which should be very
% fast.  It never performs any approximate numerical evaluation, or any
% sophisticated analysis, both of which would be much slower and/or
% complicated.  The current strategy is believed to represent a
% reasonable compromise, and will normally give the user what they
% expect without undue overhead.

rlistat '(realvalued notrealvalued selfconjugate);nil
% Make user operators.

symbolic procedure realvalued u;
   % Command to allow the user to declare functions or variables to be
   % implicitly real valued.
   <<rmsubs();  % So that an expression can be re-evaluated.
     for each v in u do
        if not idp v then typerr(v,"id")
         else flag(list v,'realvalued)>>;
+++ realvalued compiled, 30 + 24 bytes
realvalued

symbolic procedure notrealvalued u;
   % Undo realvalued declaration.
   % Cannot recover "complexity", so no need for rmsubs().
   for each v in u do
      if not idp v then typerr(v,"id")
       else remflag(list v, 'realvalued);
+++ notrealvalued compiled, 27 + 24 bytes
notrealvalued

flag('(realvaluedp),'boolean);nil % Make realvaluedp available in
                               % algebraic mode.

symbolic procedure realvaluedp u;
   % True if the true prefix kernel form u is explicitly or implicitly
   % real-valued.
   if atom u then numberp u or flagp(u, 'realvalued)
   else begin scalar caru, cnd;
     return
      flagp((caru := car u), 'alwaysrealvalued)
         % real-valued for all possible argument values
      or (flagp(caru, 'realvalued) and realvaluedlist cdr u)
         % real-valued function if arguments are real-valued,
         % an important common special case of condrealvalued.
      or ((cnd := get(caru, 'condrealvalued)) and apply(cnd, cdr u))
         % real-valued function if arguments satisfy conditions
         % that depend on the function
%      or caru eq '!:rd!:;  % rounded number - not now needed
   end;
+++ realvaluedp redefined
+++ realvaluedp compiled, 39 + 32 bytes
realvaluedp

symbolic procedure realvaluedlist u;
   % True if every element of the list u of true prefix kernel forms
   % is real-valued.
   realvaluedp car u and (null cdr u or realvaluedlist cdr u);
+++ realvaluedlist compiled, 13 + 16 bytes
realvaluedlist

symbolic procedure realvaluedp!-sf u;
   if atom u then t      % either nil or a number
   else if domainp u then flagp(car u,'realvalued)
   else (realvaluedp!-sf lc u and
          (if sfp mvar u then realvaluedp!-sf mvar u
	     else realvaluedp mvar u)) and realvaluedp!-sf red u;
+++ realvaluedp!-sf compiled, 39 + 24 bytes
realvaluedp-sf

% Define the real valued properties
% ---------------------------------

% Only operators that can remain symbolic need be considered,
% e.g. NOT nextprime, num, den, deg, det.

% A very small number of functions are real-valued for ALL arguments:

flag('(repart impart abs ceiling floor fix round max min sign),
       'alwaysrealvalued);nil

% Symbolic constants:

flag('(pi e infinity),'realvalued);nil

% Domain elements

flag('(!:rn!: !:rd!: !:mod!:),'alwaysrealvalued);nil

% caused a bug in realvaluedp when dmode!* was rounded
% flag('(!:rn!: !:rd!: !:mod!:),'realvalued); 

% Some functions are real-valued if all their arguments are
% real-valued, without further constraints:

% Arithmetic operators:

flag('(plus minus times quotient), 'realvalued);nil

% Elementary transcendental functions, etc:

% should hypot, cbrt and factorial be flagged "alwaysrealvalued" as they
% are real everywhere they are properly defined; cf ceiling, floor etc.?

flag('(exp cbrt hypot sin cos tan csc sec cot sind cosd tand cscd secd
       cotd sinh cosh tanh csch sech coth atan atand atan2 atan2d acot
       acotd asinh acsch factorial),
     'realvalued);nil

% Additional such variables and functions can be declared by the user
% with the REALVALUED command defined above.

symbolic procedure expt!-realvalued(base,expo);
   % returns t if (expt base expo) is realvalued
   % in general this is true iff impart(expo*log(base)) is an integer multiple of pi
   % however, this is difficult to check
   fixp expo and realvaluedp base;
+++ expt!-realvalued compiled, 9 + 12 bytes
expt-realvalued
%      or realvaluedp expo and realvaluedp {'log,base};
%      	 or ((denr r = 1 and fixp numr r)
%	    where r := simp!* {'quotient,{'impart,{'times,expo,{'log,base}}},'pi});

put('expt,'condrealvalued,'expt!-realvalued);expt-realvalued

% The principal value of the following inverse functions (and log and sqrt)
% is real-valued on the real axis except on the branch cut.

% do we need the test realvaluedp arg as if it succeeds sign!-of will
% surely return -1, 0 or +1?

symbolic procedure log!-realvalued arg;
   % returns t it (log arg) is realvalued
   % in general this is true iff arg is realvalued and positive
    sign!-of arg = 1;
+++ log!-realvalued compiled, 5 + 16 bytes
log-realvalued
%   realvaluedp arg and sign!-of arg = 1;
 
put('log, 'condrealvalued, 'log!-realvalued);log-realvalued
put('log10, 'condrealvalued, 'log!-realvalued);log-realvalued

symbolic procedure sqrt!-realvalued(x);
% branch-cut is the negative real axis
  (s and s >= 0) where  s=sign!-of x;
+++ sqrt!-realvalued compiled, 11 + 16 bytes
sqrt-realvalued

put('sqrt, 'condrealvalued, 'sqrt!-realvalued);sqrt-realvalued

symbolic procedure asin!-realvalued(x);
% branch-cut is the complement of the interval [-1, 1]
  (s1 and s1>=0  and (s2 and s2 <=0) where s2=sign!-of(reval({'plus, x, -1})))
         where s1=sign!-of(reval({'plus, x, 1}));
+++ asin!-realvalued compiled, 32 + 32 bytes
asin-realvalued
		      
put('asin, 'condrealvalued, 'asin!-realvalued);asin-realvalued
put('acos, 'condrealvalued, 'asin!-realvalued);asin-realvalued

symbolic procedure asec!-realvalued(x);
% branch-cut is  the interval (-1, 1)
  (s1 and s1<=0 or (s2 and s2>=0) where s2=sign!-of(reval({'plus, x, -1})))
            where s1=sign!-of(reval({'plus, x, 1}));
+++ asec!-realvalued compiled, 32 + 32 bytes
asec-realvalued

put('asec, 'condrealvalued, 'asec!-realvalued);asec-realvalued
put('acsc, 'condrealvalued, 'asec!-realvalued);asec-realvalued

symbolic procedure atanh!-realvalued(x);
% branch-cut is the complement of the interval (-1, 1)
  (s1 and s1=1 and (s2 and s2=-1) where s2=sign!-of(reval({'plus, x, -1})))
       where s1=sign!-of(reval({'plus, x, 1}));
+++ atanh!-realvalued compiled, 29 + 28 bytes
atanh-realvalued

put('atanh, 'condrealvalued, 'atanh!-realvalued);atanh-realvalued

symbolic procedure acoth!-realvalued(x);
% branch-cut is the interval [-1, 1]
  (s1 and s1=1  or (s2 and s2=-1) where s2=sign!-of(reval({'plus, x, 1})))
       where s1=sign!-of(reval({'plus, x, -1}));
+++ acoth!-realvalued compiled, 30 + 28 bytes
acoth-realvalued


put('acoth, 'condrealvalued, 'acoth!-realvalued);acoth-realvalued

symbolic procedure acosh!-realvalued(x);
% branch cut is the interval (-infinity, 1)
 (s1 and s1>=0) where s1=sign!-of(reval({'plus, x, -1}));
+++ acosh!-realvalued compiled, 16 + 28 bytes
acosh-realvalued

put('acosh, 'condrealvalued, 'acosh!-realvalued);acosh-realvalued

symbolic procedure asech!-realvalued(x);
% branch cut is the complement of the interval (0, 1]
 (s1 and s1=1 and (s2 and s2 <=0) where s2=sign!-of(reval({'plus, x, -1})))
       where s1=sign!-of(x);
+++ asech!-realvalued compiled, 25 + 32 bytes
asech-realvalued

put('asech, 'condrealvalued, 'asech!-realvalued);asech-realvalued

% Added by Alan Barnes, October 2018 to improve simplification of conj.

symbolic procedure conjugate u;
   % Command to allow the user to declare which functions are well-behaved
   % under cojugation i.e. conj(f(z)) = f(conj(z))
    <<rmsubs();  % So that an expression can be re-evaluated.
     for each v in u do
        if not idp v then typerr(v,"id")
         else flag(list v,'conjugate)>>;
+++ conjugate redefined
+++ conjugate compiled, 30 + 24 bytes
conjugate

% Elementary transcendental functions are holomorphic everywhere
% and satisfy the self-conjugate property (i.e. conj(f(z)) = f(conj(z))
% everywhere. So do the principal values of atan acot, asinh and acsch
% even on their branch cuts (which are subsets of the imaginary axis).
% For the remaining inverse functions, sqrt and log the conjugate property
% fails only on the branch cuts (which are subsets of the real axis).

flag('(exp sin cos tan csc sec cot sind cosd tand cscd secd
       cotd sinh cosh tanh csch sech coth atan atand acot acotd asinh acsch
       df), 'selfconjugate);nil

symbolic procedure selfconjugate u;
   % Command to allow the user to declare operators to be
   % declared self-conjugate i.e conj f => f so conj(f(z)) =>f(conj(z)).
   % NB the elementary trancendental functions etc. are selfconjugate.
   <<rmsubs();  % So that an expression can be re-evaluated.
     for each v in u do
        if not idp v then typerr(v,"id")
	 else if not get(v, 'simpfn) then typerr(v, "operator")
         else flag(list v,'selfconjugate)>>;
+++ selfconjugate compiled, 40 + 28 bytes
selfconjugate

% currently there is no property "condselfconjugate" for the remaining
% inverse functions asin, atanh etc., log and sqrt.

% Procedures to find the real and imaginary parts of elementary functions.

put('sin,'cmpxsplitfn,'reimsin);reimsin

symbolic procedure reimsin u;
   addsq(multsq(simp list('sin,rearg),
                simp list('cosh,imarg)),
         multsq(simp 'i,
                multsq(simp list('cos,rearg),
                       simp list('sinh,imarg))))
   where rearg = prepsq simprepart cdr u,
         imarg = prepsq simpimpart cdr u;
+++ reimsin compiled, 46 + 52 bytes
reimsin

put('sinh,'cmpxsplitfn,'reimsinh);reimsinh

symbolic procedure reimsinh u;
   addsq(multsq(simp list('sinh,rearg),
                simp list('cos,imarg)),
         multsq(simp 'i,
                multsq(simp list('cosh,rearg),
                       simp list('sin,imarg))))
   where rearg = prepsq simprepart cdr u,
         imarg = prepsq simpimpart cdr u;
+++ reimsinh compiled, 46 + 52 bytes
reimsinh

put('cos,'cmpxsplitfn,'reimcos);reimcos

symbolic procedure reimcos u;
   addsq(multsq(simp list('cos,rearg),
                simp list('cosh,imarg)),
         multsq(simp 'i,negsq
                multsq(simp list('sin,rearg),
                       simp list('sinh,imarg))))
   where rearg = prepsq simprepart cdr u,
         imarg = prepsq simpimpart cdr u;
+++ reimcos compiled, 49 + 56 bytes
reimcos

put('cosh,'cmpxsplitfn,'reimcosh);reimcosh

symbolic procedure reimcosh u;
   addsq(multsq(simp list('cosh,rearg),
                simp list('cos,imarg)),
         multsq(simp 'i,
                multsq(simp list('sinh,rearg),
                       simp list('sin,imarg))))
   where rearg = prepsq simprepart cdr u,
         imarg = prepsq simpimpart cdr u;
+++ reimcosh compiled, 46 + 52 bytes
reimcosh

      
put('expt,'cmpxsplitfn,'reimexpt);reimexpt

% symbolic procedure reimexpt u;
%    if cadr u eq 'e %or numberp cadr u
%      then multsq(simp {'exp,{'times,{'log,cadr u},prepsq simprepart cddr u}},
%                  addsq(reimcos {'cos,imarg},
%                        multsq(simp 'i,reimsin {'sin,imarg})))
%             where imarg = {'times,{'log,cadr u},prepsq simpimpart cddr u}
% %     then addsq(reimcos list('cos,reval list('times,'i,caddr u)),
% %                multsq(simp list('minus,'i),
% %                    reimsin list('sin,reval list('times,'i,caddr u))))
%     else if fixp cadr u and cadr u > 0
%               and eqcar(caddr u,'quotient)
%               and fixp cadr caddr u
%               and fixp caddr caddr u
%      then mksq(u,1)
%     else addsq(mkrepart u,multsq(simp 'i,mkimpart u));

% This normally returns the principal value for complex arguments including
% cases with a rational real exponent. However, for (powers of) the nth root 
% (n odd) of a real negative number, it returns a real value.
% This is due to simplifications performed by simpexpt prior to the call
% of reimexpt.
%
% Thus, for example, 
%     x := repart((-2)^(u+i*v)); x where u => 1/3, v=>0;
% produces the real part of  the (complex) principal value whereas
%     x := repart((-2)^(1/3));
% produces the real negative cube root.
% cf the numerical evaluation od (-2)^(1/3) after on rounded; 
%   compared with the behaviour after on rounded, complex;
symbolic procedure reimexpt u;
  begin scalar x, y, v, w, z1, z2;
    x := reimlog{'log, cadr u};
    y := prepsq take!-impart x;
    x := prepsq take!-realpart x;
    v := prepsq simprepart cddr u;
    w := prepsq simpimpart cddr u;
    z1 := simp {'exp, {'difference, {'times, x, v}, {'times, y, w}}};
    z2 := {'plus, {'times, x, w}, {'times, y, v}};
    return
      multsq(z1, addsq(simp{'cos, z2}, multsq(simp 'i, simp{'sin, z2}))); 
  end;
+++ reimexpt compiled, 100 + 76 bytes
reimexpt

put('sqrt, 'cmpxsplitfn, 'reimsqrt);reimsqrt

% only called when !*keepsqrts is true
symbolic procedure reimsqrt u;
   reimexpt {'expt, cadr u, {'quotient, 1, 2}};
+++ reimsqrt compiled, 15 + 28 bytes
reimsqrt

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The procedures below were added by Alan Barnes to handle tan, tanh, cot,
% coth, sec, csc, sech, csch.
% They all return results in terms of sin, cos, sinh and cosh of 
% the real and imaginary parts of the argument of the function concerned. 
% There are several equivalent ways of expressing the denominators;
% below denominators are always expressed as the sum of 2 squares 

put('tan,'cmpxsplitfn,'reimtan);reimtan

symbolic procedure reimtan u;
begin scalar rearg, imarg, sinx, sinhy, cosx, coshy;
   rearg := prepsq simprepart cdr u;
   imarg := prepsq simpimpart cdr u;
   sinx  := simp {'sin, rearg};
   sinhy := simp {'sinh, imarg};
   cosx  := simp {'cos, rearg};
   coshy := simp {'cosh, imarg};

   return quotsq(
      addsq(multsq(sinx, cosx),
            multsq(simp 'i, multsq(sinhy, coshy))),
      addsq(multsq(cosx, cosx), multsq(sinhy, sinhy)));
end;
+++ reimtan compiled, 68 + 56 bytes
reimtan

put('tanh,'cmpxsplitfn,'reimtanh);reimtanh

symbolic procedure reimtanh u;
begin scalar rearg, imarg, sinhx, siny, coshx, cosy;
   rearg := prepsq simprepart cdr u;
   imarg := prepsq simpimpart cdr u;
   sinhx := simp {'sinh, rearg};
   siny  := simp {'sin, imarg};
   coshx := simp {'cosh, rearg};
   cosy  := simp {'cos, imarg};

   return quotsq(
      addsq(multsq(sinhx, coshx),
            multsq(simp 'i, multsq(siny, cosy))),
      addsq(multsq(cosy, cosy), multsq(sinhx, sinhx)));
end;
+++ reimtanh compiled, 68 + 56 bytes
reimtanh

put('cot,'cmpxsplitfn,'reimcot);reimcot

symbolic procedure reimcot u;
begin scalar rearg, imarg, sinx, sinhy, cosx, coshy;
   rearg := prepsq simprepart cdr u;
   imarg := prepsq simpimpart cdr u;
   sinx  := simp {'sin, rearg};
   sinhy := simp {'sinh, imarg};
   cosx  := simp {'cos, rearg};
   coshy := simp {'cosh, imarg};

   return quotsq(
      addsq(multsq(sinx, cosx),
            multsq(simp 'i, negsq multsq(sinhy, coshy))),
      addsq(multsq(sinhy, sinhy), multsq(sinx, sinx)));
end;
+++ reimcot compiled, 71 + 60 bytes
reimcot

put('coth,'cmpxsplitfn,'reimcoth);reimcoth

symbolic procedure reimcoth u;
begin scalar rearg, imarg, sinhx, siny, coshx, cosy;
   rearg := prepsq simprepart cdr u;
   imarg := prepsq simpimpart cdr u;
   sinhx := simp {'sinh, rearg};
   siny  := simp {'sin, imarg};
   coshx := simp {'cosh, rearg};
   cosy  := simp {'cos, imarg};

  return quotsq(
      addsq(multsq(sinhx, coshx),
            multsq(simp 'i, negsq multsq(siny, cosy))),
      addsq(multsq(sinhx, sinhx), multsq(siny, siny)));
end;
+++ reimcoth compiled, 71 + 60 bytes
reimcoth

put('sec,'cmpxsplitfn,'reimsec);reimsec

symbolic procedure reimsec u;
begin scalar rearg, imarg, sinx, sinhy, cosx, coshy;
   rearg := prepsq simprepart cdr u;
   imarg := prepsq simpimpart cdr u;
   sinx  := simp {'sin, rearg};
   sinhy := simp {'sinh, imarg};
   cosx  := simp {'cos, rearg};
   coshy := simp {'cosh, imarg};

   return quotsq(
      addsq(multsq(cosx, coshy),
            multsq(simp 'i, multsq(sinx, sinhy))),
      addsq(multsq(cosx, cosx), multsq(sinhy, sinhy)));
end;
+++ reimsec compiled, 68 + 56 bytes
reimsec

put('sech,'cmpxsplitfn,'reimsech);reimsech

symbolic procedure reimsech u;
begin scalar rearg, imarg, sinhx, siny, coshx, cosy;
   rearg := prepsq simprepart cdr u;
   imarg := prepsq simpimpart cdr u;
   sinhx := simp {'sinh, rearg};
   siny  := simp {'sin, imarg};
   coshx := simp {'cosh, rearg};
   cosy  := simp {'cos, imarg};

   return quotsq(
      addsq(multsq(coshx, cosy),
            multsq(simp 'i, negsq multsq(sinhx, siny))),
      addsq(multsq(cosy, cosy), multsq(sinhx, sinhx)));
end;
+++ reimsech compiled, 71 + 60 bytes
reimsech

put('csc,'cmpxsplitfn,'reimcsc);reimcsc

symbolic procedure reimcsc u;
begin scalar rearg, imarg, sinx, sinhy, cosx, coshy;
   rearg := prepsq simprepart cdr u;
   imarg := prepsq simpimpart cdr u;
   sinx  := simp {'sin, rearg};
   sinhy := simp {'sinh, imarg};
   cosx  := simp {'cos, rearg};
   coshy := simp {'cosh, imarg};

   return quotsq(
      addsq(multsq(sinx, coshy),
            multsq(simp 'i, negsq multsq(cosx, sinhy))),
      addsq(multsq(sinhy, sinhy), multsq(sinx, sinx)));
end;
+++ reimcsc compiled, 71 + 60 bytes
reimcsc

put('csch,'cmpxsplitfn,'reimcsch);reimcsch

symbolic procedure reimcsch u;
begin scalar rearg, imarg, sinhx, siny, coshx, cosy;
   rearg := prepsq simprepart cdr u;
   imarg := prepsq simpimpart cdr u;
   sinhx := simp {'sinh, rearg};
   siny  := simp {'sin, imarg};
   coshx := simp {'cosh, rearg};
   cosy  := simp {'cos, imarg};

  return quotsq(
      addsq(multsq(sinhx, cosy),
            multsq(simp 'i, negsq multsq(coshx, siny))),
      addsq(multsq(sinhx, sinhx), multsq(siny, siny)));
end;
+++ reimcsch compiled, 71 + 60 bytes
reimcsch


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Inverse Functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

put('log,'cmpxsplitfn,'reimlog);reimlog
put('log10,'cmpxsplitfn,'reimlog);reimlog

% When Re(x) is a number in log(x), there is no point in computing the squares
% and square roots. Return log(abs(x)) as real part.
% This improves simplification of, e.g., repart(log(5)) and repart(log(-5))
% which both used to return log(25)/2
symbolic procedure reimlog u;
  (addsq(if imarg=0 then simp {op, {'abs, rearg}}
          else if rearg=0 then simp {op, {'abs, imarg}}
          else simp {'quotient, {op, {'plus, {'expt, rearg, 2},
                                               {'expt, imarg , 2}}}, 2},
         multsq(simp if op='log10 then '(quotient i (log 10)) else 'i,
                simp {'atan2, imarg, rearg})))
   where op = car u,
         rearg = prepsq simprepart cdr u,
      	 imarg = prepsq simpimpart cdr u;
+++ reimlog compiled, 95 + 72 bytes
reimlog

% Subsidiary function called from next three split functions
% Returns a dotted pair of the arguments for acos and acosh resp.
% The first value is guaranteed to be in the range [-1, +1] 
% and the second is always >= 1
symbolic procedure invfn!-args(x, y);
  if x=0 then 1 . {'plus, 1, {'times, 2, {'expt, y, 2}}}
  else
    begin scalar ssq, sroot;
       ssq :=  simp {'plus, {'expt, x, 2}, {'expt, y, 2}};
       if y=0 then 
         sroot := simp {'abs, {'plus, prepsq ssq, -1}}
       else
         sroot := simp {'sqrt, {'plus, {'expt, {'plus, prepsq ssq, -1}, 2},
                                       {'times, 4, {'expt, y, 2}}}};
       return
         (prepsqxx addsq(sroot, negsq ssq)) . (prepsqx addsq(ssq, sroot));
end;
+++ invfn!-args compiled, 129 + 72 bytes
invfn-args

% The split functions below for asin, acos, asinh and acosh do not use the 
% split function for log and the identities of these functions 
% in terms of logarithm; this generally led to expressions involving 
% nested square roots.
% Instead they calculate the real and imaginary parts of the form 
% acos(R1)/2 & acosh(R2)/2 where R1 & R2 are real with |R1| <=1 & |R2|>=1.
% Then they choose the correct branch by examining the signs of the real &
% imaginary parts of the the argument. This avoids nested sqare roots, but
% for a non-numeric argument involes rather messy expressions involving the
% sign operator applied to the real and imaginary parts of the argument. 

put('asin, 'cmpxsplitfn, 'reimasin);reimasin
put('acos, 'cmpxsplitfn, 'reimasin);reimasin

symbolic procedure reimasin u;
begin scalar rearg, imarg, x, y, sr, si, op, res;
  rearg := prepsq simprepart cdr u;
  imarg := prepsq simpimpart cdr u;
  op := car u;
  if rearg=0 then <<
     res := simp {'times, 'i, {'asinh, imarg}};
     if op='asin then return res
     else return addsq(simp {'quotient, 'pi, 2}, negsq res)>>;

  y := invfn!-args(rearg, imarg);

% testing car and cdr here improves the handling of purely numerical real args
  if cdr y = 1 then  % |rearg| <= 1 & imarg=0
     return simp {op, rearg}
  else if car y = -1 then <<  % |rearg| > 1 amd imarg=0
     x := simp {'quotient, 'pi, 2};
     y := simp {'acosh, {'abs, rearg}}>>
  else <<
    x := simp {'quotient, {'acos, car y}, 2};
    y := simp {'quotient, {'acosh, cdr y}, 2}>>;  

  sr := simp!-sign1 rearg;
  si := simp!-sign1 imarg;

  % Multiply x by sr if sr neq 0 and by 1 if sr=0
  x := multsq(x, addsq(1 ./ 1, multsq(sr, addsq(1 ./ 1, negsq sr)))); 
  % Multiply y by si if si neq 0 and by -sr if si=0
  y := multsq(y, addsq(si, 
                       multsq(sr, addsq(multsq(si, si), (-1) ./ 1))));
		       
  res := addsq(x, multsq(simp 'i, y));
  if op='asin then return res
  else return addsq(simp {'quotient, 'pi, 2}, negsq res);

end;
+++ reimasin compiled, 214 + 96 bytes
reimasin

put('asinh, 'cmpxsplitfn, 'reimasinh);reimasinh

symbolic procedure reimasinh u;
begin scalar rearg, imarg, x, y, sr, si;
  rearg := prepsq simprepart cdr u;
  imarg := prepsq simpimpart cdr u;
  if imarg=0 then return simp {'asinh, rearg};
  x := invfn!-args(imarg, rearg);

% testing car and cdr here improves the handling of purely numerical imag args
  if cdr x = 1 then  % |imarg| <= 1 & rearg=0
     return simp {'times, 'i, {'asin, imarg}}
  else if car x = -1 then <<  % |imarg| > 1 amd rearg=0
     x := simp {'acosh, {'abs, imarg}};
     y := simp {'quotient, 'pi, 2}>>
  else <<
     y := simp {'quotient, {'acos, car x}, 2};
     x := simp {'quotient, {'acosh, cdr x}, 2}>>;

  sr := simp!-sign1 rearg;
  si := simp!-sign1 imarg;

  % Multiply y by si if si neq 0 and by 1 if si=0
  y := multsq(y, addsq(1 ./ 1, multsq(si, addsq(simp 1, negsq si))));
  % Multiply x by sr if sr neq 0 and by si if sr=0
  x := multsq(x, addsq(sr, 
                       multsq(si, addsq(negsq multsq(sr, sr), 1 ./ 1))));

  return addsq(x, multsq(simp 'i, y));
end;
+++ reimasinh compiled, 169 + 96 bytes
reimasinh

put('acosh, 'cmpxsplitfn, 'reimacosh);reimacosh

symbolic procedure reimacosh u;
begin scalar rearg, imarg, x, y, sr, si;
  rearg := prepsq simprepart cdr u;
  imarg := prepsq simpimpart cdr u;
  x := invfn!-args(rearg, imarg);

% testing car and cdr here improves the handling of purely numerical
% real and args
  if rearg=0  then <<
     x := simp {'asinh, {'abs, imarg}};
     y := simp {'quotient, 'pi, 2} >>
  else if car x = -1 then << % imarg=0 & |rearg| >=1
     y := nil ./ 1;
     x := simp {'acosh, {'abs, rearg}} >>
  else if cdr x = 1 then << % imarg=0 & |rearg| < 1
     y := simp {'acos, {'abs, rearg}};
     x := nil ./ 1 >>
  else <<
     y := simp {'quotient, {'acos, {'minus, car x}}, 2};
     x := simp {'quotient, {'acosh, cdr x}, 2} >>;

  sr := simp!-sign1 rearg;
  si := simp!-sign1 imarg;

  % leave y unchanged when sr=1 or sr=0 else y := pi-y when sr=-1
  y := addsq(y, (multsq(multsq(sr, addsq(sr, (-1) ./ 1)), 
                        addsq(simp {'quotient, 'pi, 2}, negsq y))));
  % Now multiply y by si if si neq 0 and by 1 if si=0 
  y := multsq(y, addsq(1 ./ 1, multsq(si, addsq(1 ./ 1, negsq si))));

  return addsq(x, multsq(simp 'i, y));
end;
+++ reimacosh compiled, 199 + 92 bytes
reimacosh

put('atanh, 'cmpxsplitfn, 'reimatanh);reimatanh

symbolic procedure reimatanh u;
begin scalar rearg, imarg, x, y, sr, si, s1;
  rearg := prepsq simprepart cdr u;
  imarg := prepsq simpimpart cdr u;
  if rearg =0 then return simp {'times, 'i, {'atan, imarg}};
  sr := simp!-sign1 rearg;

  % s1 = 1 if |rearg| >1, -1; if |rearg| <1; else 0
  s1 := simp {'sign, {'difference, {'expt, rearg, 2}, 1}}; 
  % s1 = 2 if |rearg| > 1 else if |rearg| <1  s1 = 0 ; else s1 =1 
  s1 := addsq(1 ./ 1, s1);

  if imarg = 0 then <<
    x := {'quotient, {'plus, 1, rearg}, {'difference, 1,  rearg}};
    x := simp {'quotient, {'log, {'abs, x}}, 2};
    % y = -pi/2 if rearg>1, y =pi/2 if rearg<-1 else y=0
    y := multsq(multsq(sr, simp {'quotient, 'pi, -4}), s1)>>
  else <<
    si := prepsq simp!-sign1 imarg;
    % si =-1 if imarg =0 else si = 0
    si := simp {'difference, {'expt, si, 2}, 1}; 

    x := {'plus, {'expt, {'plus, rearg, 1}, 2}, {'expt, imarg, 2}}; 
    y := {'plus, {'expt, {'difference, 1, rearg}, 2}, {'expt, imarg, 2}}; 
    x := simp {'quotient, {'log, {'quotient, x, y}}, 4};

    y := {'difference, 1, {'plus, {'expt, rearg, 2}, {'expt, imarg, 2}}};
    y := simp {'quotient, {'atan2, {'times, 2, imarg}, y}, 2};
    % subtract pi iff imarg=0 and rearg >1
    y := addsq(multsq(multsq(si, multsq(s1, addsq(1 ./ 1, sr))),
               simp {'quotient, 'pi, 4}), y)>>;

  return addsq(x, multsq(simp 'i, y));
end;
+++ reimatanh compiled, 286 + 104 bytes
reimatanh

% % Produces a simpler imaginary part for non-numerical arguments, 
% % but for numeric arguments the imaginary part is the sum of two atan terms
% % rather than one with the method above.
% symbolic procedure reimatanh1 u;
% begin scalar rearg, imarg, x, y;
%   rearg := prepsq simprepart cdr u;
%   imarg := prepsq simpimpart cdr u;
%   if rearg =0 then return simp {'times, 'i, {'atan, imarg}};
%   if imarg = 0 then <<
%     x:= {'quotient, {'plus, 1, rearg}, {'difference, 1,  rearg}};
%     x := simp {'quotient, {'log, {'abs, x}}, 2}>>
%   else <<
%     x := {'plus, {'expt, {'plus, rearg, 1}, 2}, {'expt, imarg, 2}}; 
%     y := {'plus, {'expt, {'difference, 1, rearg}, 2}, {'expt, imarg, 2}}; 
%     x := simp {'quotient, {'log, {'quotient, x, y}}, 4}>>;
% 
%   y := {'quotient, {'plus, {'atan2, imarg, {'plus, 1, rearg}},
%                            {'atan2, imarg, {'difference, 1, rearg}}},
%                     2};
% 
%   return addsq(x, multsq(simp 'i, simp y));
% end;

put('atan, 'cmpxsplitfn, 'reimatan);reimatan
put('acot, 'cmpxsplitfn, 'reimatan);reimatan

symbolic procedure reimatan u;
   (if imarg=0 then simp {op, rearg}
    else (if op='atan then negsq res 
          else if op='acot then addsq(simp {'quotient, 'pi, 2}, res))
       where res=multsq(simp 'i, reimatanh({car u, {'times, 'i, cadr u}})))
   where op = car u,
         rearg = prepsq simprepart cdr u, 
         imarg = prepsq simpimpart cdr u;
+++ reimatan compiled, 64 + 72 bytes
reimatan

put('asec, 'cmpxsplitfn, 'reimasec);reimasec

symbolic procedure reimasec u;
  reimasin({'acos, {'quotient, 1, cadr u}});
+++ reimasec compiled, 13 + 24 bytes
reimasec

put('acsc, 'cmpxsplitfn, 'reimacsc);reimacsc

symbolic procedure reimacsc u;
  reimasin({'asin, {'quotient, 1, cadr u}});
+++ reimacsc compiled, 13 + 24 bytes
reimacsc

put('asech, 'cmpxsplitfn, 'reimasech);reimasech

symbolic procedure reimasech u;
  reimacosh({'acosh, {'quotient, 1, cadr u}});
+++ reimasech compiled, 13 + 24 bytes
reimasech

put('acsch, 'cmpxsplitfn, 'reimacsch);reimacsch

symbolic procedure reimacsch u;
  reimasinh({'asinh, {'quotient, 1, cadr u}});
+++ reimacsch compiled, 13 + 24 bytes
reimacsch   

put('acoth, 'cmpxsplitfn, 'reimacoth);reimacoth

symbolic procedure reimacoth u;
begin scalar rearg, imarg, x, y, sr, si, s1;
  rearg := prepsq simprepart cdr u;
  imarg := prepsq simpimpart cdr u;
  
  if rearg=0 then << 
     y := simp {'times, 'i, {'acot, {'abs, imarg}}};
     si := simp!-sign1 imarg;

     % if imarg > 0 x=-1 else x=+1
     x := addsq(simp 1, negsq multsq(si, addsq(1 ./ 1, si)));
     return multsq(x, y)>>;

  % s1 = 1 if |rearg| <1, s1=-1; if |rearg| >1; else s1=0
  s1 := simp {'sign, {'difference, 1, {'expt, rearg, 2}}}; 
  % s1 = 2 if |rearg| < 1 else if |rearg| >1  s1 = 0 ; else s1 =1 
  s1 := addsq(1 ./ 1, s1);

  sr := simp!-sign1 rearg;
  % sr=-1 if rearg > 0, 1 if rearg<=0 
  sr := addsq(1 ./ 1, negsq multsq(sr, addsq(1 ./ 1, sr)));

  if imarg = 0 then <<
    x:= {'quotient, {'plus, 1, rearg}, {'difference, rearg, 1}};
    x := simp {'quotient, {'log, {'abs, x}}, 2};

    y := simp {'quotient, {'atan2, 0, {'difference, {'expt, rearg, 2}, 1}}, 4};
    % y = -pi/2 if 0<rearg<1, y =pi/2 if -1<rearg<=0 else y=0
    y := multsq(multsq(sr, s1), y)>>
  else <<
    si := prepsq simp!-sign1 imarg;
    % si =1 if imarg =0 else si = 0
    si := simp {'difference, 1, {'expt, si, 2}}; 

    x :=  {'plus, {'expt, {'plus, rearg, 1}, 2}, {'expt, imarg, 2}}; 
    y :=  {'plus, {'expt, {'difference, 1, rearg}, 2}, {'expt, imarg, 2}}; 
    x := simp {'quotient, {'log, {'quotient, x, y}}, 4};

    y :=  {'difference, {'plus, {'expt, rearg, 2}, {'expt, imarg, 2}}, 1};
    y := simp {'quotient, {'atan2, {'times, -2, imarg}, y}, 2};
    % subtract pi iff imarg=0 and 0<rearg<1
    y := addsq(multsq(multsq(si, multsq(s1, addsq((-1) ./ 1, sr))),
               simp {'quotient, 'pi, 4}), y)>>;

  return addsq(x, multsq(simp 'i, y));
end;
+++ reimacoth compiled, 367 + 112 bytes
reimacoth

% % Produces a simpler imaginary part for non-numeric arguments, but for numeric
% % arguments the imaginary part is the sum of two atan terms rather than one.
% % When u=0, an error is raised due to the formation of atan2(0, 0) 
% % rather than returning the correct value i*pi/2.
% symbolic procedure reimacoth1 u;
% begin scalar rearg, imarg, x, y, si;
%   rearg := prepsq simprepart cdr u;
%   imarg := prepsq simpimpart cdr u;
%   
%   if rearg=0 then << 
%      y := simp {'times, 'i, {'acot, {'abs, imarg}}};
%      si := simp!-sign1 imarg;
%      % if imarg > 0 x=-1 else x=+1
%      x := addsq(simp 1, negsq multsq(si, addsq(simp 1, si)));
%      return multsq(x, y)>>;
% 
%   if imarg = 0 then <<
%     x := {'quotient, {'plus, 1, rearg}, {'difference, rearg, 1}};
%     x := simp {'quotient, {'log, {'abs, x}}, 2}>>
%   else <<
%     x :=  {'plus, {'expt, {'plus, rearg, 1}, 2}, {'expt, imarg, 2}}; 
%     y :=  {'plus, {'expt, {'difference, 1, rearg}, 2}, {'expt, imarg, 2}}; 
%     x := simp {'quotient, {'log, {'quotient, x, y}}, 4}>>;
% 
%   y := {'plus, {'expt, rearg, 2}, {'expt, imarg, 2}};
%   y := {'quotient, {'difference, {'atan2, {'minus, imarg}, {'plus, y, rearg}},
%                                  {'atan2, imarg, {'difference, y, rearg}}},
%                     2};
%   return addsq(x, multsq(simp 'i, simp y));
% end;


%%% special cases

put('arbint,'cmpxsplitfn,'simp);simp


endmodule;nil

end;nilmodule modular;nil % *** Tables for modular integers ***.

% Author: Anthony C. Hearn and Herbert Melenk.

% Copyright (c) 1995 The RAND Corporation. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


global '(domainlist!*);nil

fluid '(!*balanced_mod !*modular !*precise current!-modulus alglist!*
        dmode!*);nil

switch modular,balanced_mod;nil

domainlist!* := union('(!:mod!:),domainlist!*);(:mod: :crn: :gi: :rn:)

put('modular,'tag,'!:mod!:);:mod:
put('!:mod!:,'dname,'modular);modular
flag('(!:mod!:),'field);nil
flag('(!:mod!:),'convert);nil
put('!:mod!:,'i2d,'!*i2mod);*i2mod
put('!:mod!:,'!:ft!:,'modcnv);modcnv
put('!:mod!:,'!:rn!:,'modcnv);modcnv
put('!:mod!:,'minusp,'modminusp!:);modminusp:
put('!:mod!:,'plus,'modplus!:);modplus:
put('!:mod!:,'times,'modtimes!:);modtimes:
put('!:mod!:,'difference,'moddifference!:);moddifference:
put('!:mod!:,'quotient,'modquotient!:);modquotient:
put('!:mod!:,'divide,'moddivide!:);moddivide:
put('!:mod!:,'gcd,'modgcd!:);modgcd:
put('!:mod!:,'zerop,'modzerop!:);modzerop:
put('!:mod!:,'onep,'modonep!:);modonep:
put('!:mod!:,'factorfn,'factormod!:);factormod:
put('!:mod!:,'sqfrfactorfn,'factormod!:);factormod:
put('!:mod!:,'expt,'exptmod!:);exptmod:
put('!:mod!:,'prepfn,'modprep!:);modprep:
put('!:mod!:,'prifn,'(lambda(x) (prin2!* (prepf x))));(lambda (x) (prin2* (prepf
x)))

put('!:mod!:,'unitsfn,'!:mod!:unitconv);:mod:unitconv

symbolic procedure !*modular2f u;
   % Convert u to a modular number.  Treat 0 as special case, but not 1.
   % Also allow for !*balanced_mod.
   if u=0 then nil
%   else if u=1 then 1
    else if !*balanced_mod
     then if u+u>current!-modulus
            then '!:mod!: . (u - current!-modulus)
           else if u+u <= - current!-modulus
            then !*modular2f(u + current!-modulus)
           else '!:mod!: . u
    else '!:mod!: . u;
+++ !*modular2f redefined
+++ !*modular2f compiled, 48 + 24 bytes
*modular2f

symbolic procedure exptmod!:(u,n);
% This procedure will check for cdr u > n-1 if n prime.
% This used to treat 1 as a special case.
   !*modular2f general!-modular!-expt(cdr u,n);
+++ exptmod!: redefined
+++ exptmod!: compiled, 6 + 16 bytes
exptmod:

symbolic procedure !:mod!:unitconv(u,v);
  if v=1 then u else
   (if x then multd(x,numr u) ./ multd(x,denr u)
     else mod!-error {'quotient,1,cdr v})
    where x = !*modular2f !:mod!:units(current!-modulus,y,0,1)
    where y = if cdr v>0 or null !*balanced_mod then cdr v
               else current!-modulus+cdr v;
+++ !:mod!:unitconv compiled, 55 + 44 bytes
:mod:unitconv

symbolic procedure !:mod!:units(a,b,x,y);
   % Same procedure as general!-reciprocal!-by!-degree in genmod
   %  without error call.
   if b=0 then 0
    else if b=1 then if y < 0 then y+current!-modulus else y
    else begin scalar w;
           w := a/b;
           return !:mod!:units(b,a-b*w,y,x-y*w)
         end;
+++ !:mod!:units redefined
+++ !:mod!:units compiled, 50 + 20 bytes
:mod:units

symbolic procedure !*i2mod u;
   % Converts integer U to modular form.
%  if (u := general!-modular!-number u)=0 then nil else '!:mod!: . u;
   !*modular2f general!-modular!-number u;
+++ !*i2mod redefined
+++ !*i2mod compiled, 5 + 16 bytes
*i2mod

symbolic procedure modcnv u;
   rerror(poly,13,list("Conversion between modular integers and",
                       get(car u,'dname),"not defined"));
+++ modcnv compiled, 15 + 28 bytes
modcnv

symbolic procedure modminusp!: u;
   if !*balanced_mod then 2*cdr u > current!-modulus else nil;
+++ modminusp!: redefined
+++ modminusp!: compiled, 9 + 20 bytes
modminusp:

symbolic procedure modplus!:(u,v);
   !*modular2f general!-modular!-plus(cdr u,cdr v);
+++ modplus!: redefined
+++ modplus!: compiled, 6 + 16 bytes
modplus:

symbolic procedure modtimes!:(u,v);
   !*modular2f general!-modular!-times(cdr u,cdr v);
+++ modtimes!: redefined
+++ modtimes!: compiled, 6 + 16 bytes
modtimes:

symbolic procedure moddifference!:(u,v);
   !*modular2f general!-modular!-difference(cdr u,cdr v);
+++ moddifference!: compiled, 6 + 16 bytes
moddifference:

symbolic procedure moddivide!:(u,v); !*i2mod 0 . u;
+++ moddivide!: compiled, 5 + 16 bytes
moddivide:

symbolic procedure modgcd!:(u,v); !*i2mod 1;
+++ modgcd!: compiled, 3 + 16 bytes
modgcd:

symbolic procedure modquotient!:(u,v);
   !*modular2f general!-modular!-times(cdr u,
                                   general!-modular!-reciprocal cdr v);
+++ modquotient!: redefined
+++ modquotient!: compiled, 10 + 20 bytes
modquotient:

symbolic procedure modzerop!: u; cdr u=0;
+++ modzerop!: redefined
+++ modzerop!: compiled, 4 + 12 bytes
modzerop:

symbolic procedure modonep!: u; cdr u=1;
+++ modonep!: redefined
+++ modonep!: compiled, 4 + 12 bytes
modonep:

symbolic procedure factormod!: u;
   begin scalar alglist!*,dmode!*;
      % 1 is needed since factorize expects first factor to be a number.
      return pfactor(!*q2f resimp(u ./ 1),current!-modulus)
   end;
+++ factormod!: compiled, 19 + 40 bytes
factormod:

symbolic procedure modprep!: u;
   cdr u;
+++ modprep!: compiled as link to cdr
modprep:

initdmode 'modular;nil


% Modular routines are defined in the GENMOD module with the exception
% of the following:

symbolic procedure setmod u;
   % Returns value of CURRENT!-MODULUS on entry unless an error
   % occurs.  It crudely distinguishes between prime moduli, for which
   % division is possible, and others, for which it possibly is not.
   % The code should really distinguish prime powers and composites as
   % well.
   begin scalar dmode!*;
      if not atom u then u := car u;   % Since setmod is a psopfn.
      u := reval u;  % dmode* is NIL, so this won't be reduced wrt
                     % current modulus.
      if fixp u and u>0
        then <<if primep u then flag('(!:mod!:),'field)
                else remflag('(!:mod!:),'field);
               return set!-general!-modulus u>>
      else if u=0 or null u then return current!-modulus
       else typerr(u,"modulus")
   end;
+++ setmod compiled, 58 + 52 bytes
setmod

put('setmod, 'psopfn, 'setmod);setmod

% A more general definition of general-modular-number.

%symbolic procedure general!-modular!-number m;
   % Returns normalized M.
%   (lambda n; %if n<0 then n+current!-modulus else n)
%   if atom m then remainder(m,current!-modulus)
%    else begin scalar x;
%       x := dcombine(m,current!-modulus,'divide);
%        return cdr x
%     end;

% Support for "mod" as an infix operator.

infix mod;nil

precedence mod,over;nil

put('mod,'psopfn,'evalmod);evalmod

symbolic procedure evalmod u;
  begin scalar dm,cp,m,mm,w,!*rounded,!*modular;
    if !*complex then
      <<cp:=t; setdmode('complex,nil); !*complex:=nil>> where !*msg=nil;
    if (dm:=get(dmode!*,'dname)) then setdmode(dm,nil);
    % We need to evaluate the first term before setting any modulus.
    % e.g., a := -8/7; (num a) mod 7;
    w:=aeval!* car u;
    m:=ieval cadr u;
    setdmode('modular,t); !*modular:=t;
    mm:=apply1('setmod,{m});
    w := aeval!* w;
    apply1('setmod,{mm});
    if dm neq 'modular then
     <<setdmode('modular,nil); if dm then setdmode(dm,t)>>;
    if cp then <<setdmode('complex,t); !*complex :=t>> where !*msg=nil;
    return w;
  end;
+++ evalmod compiled, 103 + 64 bytes
evalmod

% Support for function evaluation in the modular domain.
% At present only rational exponentiation, including surds.

put('!:mod!:,'domainvalchk,'mod!-domainvalchk);mod-domainvalchk

symbolic procedure mod!-domainvalchk(fn,u);
   begin scalar w;
    w:=if fn='expt then mod!-expt!-fract(car u,cadr u)
       else nil;
    return if w='failed then nil else w ./1;
   end;
+++ mod!-domainvalchk redefined
+++ mod!-domainvalchk compiled, 19 + 24 bytes
mod-domainvalchk

symbolic procedure mod!-expt!-fract(u,x);
 % Modular u**x where x is a rational number n/m. Compute a solution of
 % q^n=u^m. If *precise on, expressions with non-unique are not
 % simplified. Non existing surds are mapped to an error message.
  begin scalar n,m,w;
    if denr u =1 then u:=numr u else go to done;
    if eqcar(u,'!:mod!:) then t
      else if fixp u then u:= '!:mod!: . u else go to done;
    if u='(!:mod!: . 1) then return 1;
    n:=numr x; m:=denr x;
    if not fixp n or not fixp m then go to done;
    if m=1 then return exptmod!:(u,n);
    load!-package 'modsr;
    w := msolve {{'equal,{'expt,'x,m},{'expt,cdr u,n}}};
    if w eq 'failed then return w else w := cdr w;
    if null w then mod!-error({'expt,u,{'quotient,n,m}});
    if null cdr w or null !*precise then return caddr cadr car w;
      % value is not unique - prevent the default integer
      % handling that would compute an incorrect value.
      % e.g. sqrt(4) mod 9 is not 2 but {2,7}.
    return !*k2f car fkern {'expt,cdr u,{'quotient,n,m}};
 done:
    return if null w or cdr w then 'failed else caddr car w;
 end;
+++ mod!-expt!-fract compiled, 139 + 72 bytes
mod-expt-fract

symbolic procedure mod!-error u;
   typerr(u, {"expression mod", current!-modulus});
+++ mod!-error compiled, 9 + 20 bytes
mod-error

endmodule;nil

end;nilmodule facform;nil  % Factored form representation for standard form polys.

% Author: Anthony C. Hearn.

% Modifications by: Francis J. Wright.

% Copyright (c) 1990 The RAND Corporation. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% Integer factors?

% Shouldn't symmetric tests etc be run recursively?

fluid '(!*exp !*ezgcd !*factor !*force!-prime !*gcd !*ifactor !*nopowers
        !*kernreverse !*limitedfactors !*sqfree !*trfac current!-modulus
        dmode!* m!-image!-variable ncmp!*);nil

switch limitedfactors,nopowers;nil

% switch sqfree;

put('sqfree,'simpfg,'((t (rmsubs) (setq !*exp nil))
                      (nil (rmsubs) (setq !*exp t))));((t (rmsubs) (setq *exp
nil)) (nil (rmsubs) (setq *exp t)))

COMMENT In this module, we consider the manipulation of factored forms.
    These have the structure

       <monomial> . <form-power-list>

        where the monomial is a standard form (with numerator and
        denominator satisfying the KERNLP test) and a form-power is a
        dotted pair whose car is a standard form and cdr an integer>0.
        We have thus represented the form as a product of a monomial
        quotient and powers of non-monomial factors;

symbolic procedure fac!-merge(u,v);
   % Returns the merge of the factored forms U and V.
   multf(car u,car v) . append(cdr u,cdr v);
+++ fac!-merge redefined
+++ fac!-merge compiled, 12 + 12 bytes
fac-merge

symbolic procedure factorize u;
   % Factorize the polynomial u, returning the factors found.
   (begin scalar x,y;
      x := simp!* u;
      y := denr x;
      if not domainp y then typerr(u,"polynomial");
      u := numr x;
      if u = 1 then return
         {'list, if !*nopowers then 1 else {'list,1,1}} % FJW
       else if fixp u then !*ifactor := t;   % Factor an integer.
      if !*force!-prime and not primep !*force!-prime
        then typerr(!*force!-prime,"prime");
      u := if dmode!* and not(dmode!* memq '(!:rd!: !:cr!:))
         then if get(dmode!*,'factorfn)
                 then begin scalar !*factor;
                        !*factor := t;
                         return fctrf u
                      end
           else rerror(poly,14,
                       list("Factorization not supported over domain",
                       get(dmode!*,'dname)))
       else fctrf u;
      return facform2list(u,y)
   end) where !*ifactor = !*ifactor;
+++ factorize compiled, 124 + 100 bytes
factorize

symbolic procedure facform2list(x,y);
   % x is a factored form.
   % y is a possible numerical (domain) denominator.
   begin scalar factor!-count,z;
      if null car x and null cdr x then return list 'list
      % car x is now expected to be a number.
       else if null !*nopowers then z := facform2list2 x
        else <<
         z:= (0 . car x) . nil;
         x := reversip!* cdr x;  % This puts factors in better order.
         factor!-count:=0;
         for each fff in x do
         for i:=1:cdr fff do
            z := ((factor!-count:=factor!-count+1) .
                    mk!*sq(car fff ./ 1)) . z;
         z := multiple!-result(z,nil);
         if atom z then typerr(z,"factor form")  % old style input.
          else if numberp cadr z and cadr z<0 and cddr z
           then z := car z .
                           (- cadr z) . mk!*sq negsq simp caddr z
                           . cdddr z;
         % make numerical coefficient positive.
         z := cdr z;
         if car z = 1 then z := cdr z
          else if not fixp car z then z := prepd car z . cdr z
          else if !*ifactor
              then z := append(pairlist2list reversip zfactor car z,
                            cdr z)>>;
      if y neq 1 then z := list('recip,prepd y) . z;
      return 'list . z
  end;
+++ facform2list compiled, 173 + 76 bytes
facform2list

symbolic procedure facform2list2 u;
   begin scalar bool,x;
      if !:minusp(x := car u) then <<bool := t; x := !:minus x>>;
      u := cdr u;
      if x neq 1
        then if !*ifactor and fixp x
               then u := append(reversip zfactor x,u)
              else u := (x . 1) . u;
      % Adjust for negative sign.
      x := nil;
      for each j in u do
         if bool and not evenp cdr j
           then <<bool := nil; x := (negf car j . cdr j) . x>>
          else x := j . x;
      % Convert terms to list form.
      u := nil;
      for each j in x do
         if fixp car j then u := {'list,car j,cdr j} . u
          else u := {'list,mk!*sq(car j ./ 1),cdr j} . u;
      return if bool then '(list -1 1) . u else u
   end;
+++ facform2list2 compiled, 128 + 48 bytes
facform2list2

symbolic procedure old_factorize u; factorize u where !*nopowers=t;
+++ old_factorize compiled, 11 + 24 bytes
old_factorize

symbolic procedure factorize!-mod!-p(u, p);
  begin
     scalar r, s1, s2;
     s1 := setmod p;
     s2 := !*modular;
     if not s2 then setdmode('modular, t);
     r := factorize u;
     if not s2 then setdmode('modular, nil);
     setmod s1;
     return r;
  end;
+++ factorize!-mod!-p compiled, 22 + 32 bytes
factorize-mod-p

flag('(factorize old_factorize factorize!-mod!-p),'opfn);nil

symbolic procedure pairlist2list u;
   for each x in u conc nlist(car x,cdr x);
+++ pairlist2list compiled, 41 + 16 bytes
pairlist2list

% The name "factorf" is one that coders can naturally think is the
% main entrypoint for them to use, so I will ensure that it is even
% though historically one should call "fctrf".

% The function that  used to be called factorf will now be called
% internal!-factorf instead.

symbolic procedure factorf u;
  fctrf u;
+++ factorf compiled as link to fctrf
factorf

symbolic procedure fctrf u;
   % U is a standard form. Value is a factored form.
   % The function FACTORF is an assumed entry point to a more complete
   % factorization module.  It returns a form power list.
   (begin scalar !*ezgcd,!*gcd,denom,x,y;
      if domainp u then return list u
       else if ncmp!* and not noncomfp u then ncmp!* := nil;
      !*gcd := t;
      if null !*limitedfactors and null dmode!* then !*ezgcd := t;
      if null !*mcd
        then rerror(poly,15,"Factorization invalid with MCD off")
       else if null !*exp
        then <<!*exp := t; u := !*q2f resimp !*f2q u>>;
      % Convert rationals to integers for factorization.
      if dmode!* eq '!:rn!:
        then <<dmode!* := nil; alglist!* := nil . nil;
               x := simp prepf u;
               if atom denr x then <<denom := denr x; u := numr x>>
                else denom := 1>>;
      % Check for homogeneous polynomials.  This can't be done with
      % current code though if non-commuting objects occur.
      if null ncmp!*
        then <<x := sf2ss u;
               if homogp x
                 then <<if !*trfac
                        then prin2t
                    "This polynomial is homogeneous - variables scaled";
                        y := caaar x . listsum caaadr x;
                        x := fctrf1 ss2sf(car(x)
                                . (reverse subs0 cadr x . 1));
                        x := rconst(y,x);
                        return car x . sort!-factors cdr x>>>>;
      u := fctrf1 u;
      if denom
        then <<alglist!* := nil . nil;
               dmode!* := '!:rn!:; car u := quotf!*(car u,denom)>>;
      return  car u . sort!-factors cdr u
   end) where !*exp = !*exp, ncmp!* = ncmp!*;
+++ fctrf redefined
+++ fctrf compiled, 225 + 148 bytes
fctrf

symbolic procedure fctrf1 u;
   begin scalar x,y,z;
      if domainp u then return list u;  % Do this again just in case.
      if flagp(dmode!*,'field) and ((z := lnc u) neq 1)
         then u := multd(!:recip z,u)
       else if dmode!* and (y := get(dmode!*,'unitsfn))
         then <<x := apply2(y,1 . u,lnc u);
                u := cdr x;
                z := !:recip car x>>;
      x := comfac u;
      u := quotf(u,comfac!-to!-poly x);
      y := fctrf1 cdr x;   % factor the content.
      if car x then y := car y . (!*k2f caar x . cdar x) . cdr y;
      if z and (z neq 1) then y := multd(z,car y) . cdr y;
      if domainp u then return multf(u,car y) . cdr y
       else if minusf u
        then <<u := negf u; y := negf car y . cdr y>>;
      return fac!-merge(factor!-prim!-f u,y)
   end;
+++ fctrf1 redefined
+++ fctrf1 compiled, 130 + 68 bytes
fctrf1

symbolic procedure factorize!-form!-recursion u;
   fctrf1 u;
+++ factorize!-form!-recursion compiled as link to fctrf1
factorize-form-recursion

symbolic procedure factor!-prim!-f u;
   % U is a non-trivial form which is primitive in all its variables
   % and has a positive leading numerical coefficient. Result is a
   % form power list.
   begin scalar v,w,x,y;
      if ncmp!* then return list(1,u . 1);
      if dmode!* and (x := get(dmode!*,'sqfrfactorfn))
        then if !*factor then v := apply1(x,u) else v := list(1,u . 1)
       else if flagp(dmode!*,'field) and ((w := lnc u) neq 1)
        then v := w . sqfrf multd(!:recip w,u)
       else if (w := get(dmode!*,'units)) and (w := assoc(y := lnc u,w))
        then v := y . sqfrf multd(cdr w,u)
       else v := 1 . sqfrf u;
      if x and (x eq get(dmode!*,'factorfn))
        then return v;   % No point in re-factorizing.
      w := list car v;
      for each x in cdr v
         do w := fac!-merge(factor!-prim!-sqfree!-f x,w);
      return w
   end;
+++ factor!-prim!-f redefined
+++ factor!-prim!-f compiled, 136 + 56 bytes
factor-prim-f

symbolic procedure factor!-prim!-sqfree!-f u;
   % U is of the form <square free poly> . <power>. Result is a factored
   % form.
   % Modified to work properly in rounded (real or complex),
   % rational and complex modes. SLK.
   begin scalar x,y,!*msg,r;
      r := !*rounded;
      % It's probable that lc numr u and denr u will always be 1 if
      % u is univariate.
      if r and univariatep numr u and lc numr u=1 and denr u=1
        then return unifactor u
       else if r or !*complex or !*rational then
         <<if r then on rational;
           u := numr resimp !*f2q car u . cdr u>>;
      if null !*limitedfactors
        then <<if null dmode!* then y := 'internal!-factorf
                else <<x := get(dmode!*,'sqfrfactorfn);
                       y := get(dmode!*,'factorfn);
                       if x and not(x eq y) then y := 'internal!-factorf
% The "factorfn" property of something is permited to be factorf but that
% is treated as meaning the internal function...
                       else if y = 'factorf then y := 'internal!-factorf>>;
               if y
                 then <<y := apply1(y,car u);
                        u := (exptf(car y,cdr u) . for each j in cdr y
                                           collect(car j . cdr u));
                        go to ret>>>>;
      u := factor!-prim!-sqfree!-f!-1(car u,cdr u);
 ret: if r then
      <<on rounded;
        u := car u . for each j in cdr u collect
           (numr resimp !*f2q car j . cdr j)>>;
      return u
   end;
+++ factor!-prim!-sqfree!-f redefined
+++ factor!-prim!-sqfree!-f compiled, 225 + 88 bytes
factor-prim-sqfree-f

symbolic procedure unifactor u;
   if not eqcar(u := root_val list mk!*sq u,'list)
     then errach {"unifactor1",u}
    else 1 . for each j in cdr u collect
                 if not eqcar(j,'equal) then errach{"unifactor2",u}
                  else addsq(!*k2q cadr j,negsq simp caddr j);
+++ unifactor compiled, 115 + 56 bytes
unifactor

symbolic procedure distribute!.multiplicity(factorlist,n);
   % Factorlist is a simple list of factors of a square free primitive
   % multivariate poly and n is their multiplicity in a square free
   % decomposition of another polynomial. result is a list of form:
   %  ((f1 . n),(f2 . n),...) where fi are the factors.
   for each w in factorlist collect (w . n);
+++ distribute!.multiplicity redefined
+++ distribute!.multiplicity compiled, 36 + 8 bytes
distribute.multiplicity

symbolic procedure internal!-factorf u;
   % NOTE: This is not an entry point to be used by novice programmers.
   % Please used FCTRF instead. That is why its name is "internal!-factorf"
   % and the plain name factorf is just a synonym for fctrf.
   % There is an inefficiency in this procedure relating to ordering.
   % There is a final reordering done at every recursive level in order
   % to make sure final result has the right order.  However, this only
   % need be done once at the top level, probably in fctrf.  Since some
   % programmers still use this function however, it's safer for it to
   % return results in the correct order.
  (begin scalar m!-image!-variable,new!-korder,old!-korder,sign,v,w,d;
      if domainp u then return list u;
      new!-korder:=kernord(u,nil);
      if !*kernreverse then new!-korder:=reverse new!-korder;
      old!-korder:=setkorder new!-korder;
      u := reorder u; % Make var of lowest degree the main one.
      if minusf u then <<sign := not sign; u := negf u>>;
      v := comfac u;   % Since new order may reveal more factors.
      u := quotf1(u,comfac!-to!-poly v);
      % The original u has now been split into possible 3 parts:
      % car v is nil or a power of the main variable of the original u
      % cdr v is the GCD of all the coefficients from the original u
      % u is what is left when the above two have been divided out.
      % In addition the variable sign is set if the there is a negation
      % pending.
      % Now take u and turn it into a list of factors each tagged with a
      % multipliciy, as in ((u1 . m1) (u2 . m2) ...). The variable d is
      % set to any multiplier that is just a domain element. I think that
      % usually when comfac!-to!-poly comfac u is divided out this should
      % only ever be 1, but perhaps in odd cases it may end up as some other
      % unit?
      if domainp u then <<
        d := u;
        u := nil >>
      else <<
        d := 1;
        m!-image!-variable := mvar u;
        u := distribute!.multiplicity(factorize!-primitive!-polynomial u,1) >>;
      % In almost all cases where internal!-factorf is called via fctrf the
      % earlier square free decomposition etc will ensure that there is
      % no simple power of any variable present, and so car v will be nil.
      % However it seems that that is not guaranteed, and that the example
      % "on rounded; solve(df(e^x/(e^(2*x)+1)^1.5,x),{x});" shows car v
      % can be non-nil.
      w := car v;                   % nil or mvar^k
      % factorize the content.
      v := fctrf1 cdr v;            % returns (domain (poly . count) ...)
      % put back a power of the main variable if needbe.
      if w then v := car v . (!*k2f car w . cdr w) . cdr v;
      % Put back any sign and merge all the parts of the result.
      if sign then d := negf d;
      u := fac!-merge(v, d . u);
      % Now restore original variable ordering.
      setkorder old!-korder;
      % car u should be a domain element and so does not need to be re-ordered.
      % But re-ordering a polynial can flip it between being "positive" and
      % "negative"... So I adjust things here so that all the genuine factors
      % are returned as positive and the sign ends up just in the domain
      % element stuck on the front of the list.
      v := for each p in cdr u collect
         (if minusf (d := reorder car p) then <<
            sign := not sign; negf d >>
          else d) . cdr p;
      return (if sign neq minusf car u then negf car u else car u) . v
   end) where current!-modulus = current!-modulus;
+++ internal!-factorf redefined
+++ internal!-factorf compiled, 261 + 88 bytes
internal-factorf

symbolic procedure factor!-prim!-sqfree!-f!-1(u,n);
   (exptf(car x,n) . for each j in cdr x collect (j . n))
      where x = prsqfrfacf u;
+++ factor!-prim!-sqfree!-f!-1 compiled, 51 + 16 bytes
factor-prim-sqfree-f-1

symbolic procedure sqfrf u;
   % U is a non-trivial form which is primitive in all its variables
   % and has an overall numerical coefficient which should be a unit.
   % SQFRF performs square free factorization on U and returns a
   % form power list.
   % Modified to work properly in rounded (real or complex) modes. SLK.
   begin integer n; scalar !*gcd,units,v,w,x,y,z,!*msg,r;
      !*gcd := t;
      if (r := !*rounded) then
         <<on rational; u := numr resimp !*f2q u>>;
      n := 1;
      x := mvar u;
      % With ezgcd off, some sqrts can take a long, long time.
      v := gcdf(u,diff(u,x)) where !*ezgcd = t;
      u := quotf!-fail(u,v);
      % If domain is a field, or has non-trivial units, v can have a
      % spurious numerical factor.
      if flagp(dmode!*,'field) and ((y := lnc u) neq 1)
        then <<u := multd(!:recip y,u); v := multd(y,v)>>
      % The following check for units can result in the loss of such
      % a unit.
%      else if (units := get(dmode!*,'units))
%         and (w := assoc(y:= lnc u,units))
%       then <<u := multd(cdr w,u); v := multd(y,v)>>;
      ;
      while degr(v,x)>0 do
       <<w := gcdf(v,u);
         if u neq w then z := (quotf(u,w) . n) . z;
              % Don't add units to z.
         v := quotf(v,w);
         u := w;
         n := n + 1>>;
         if r then
            <<on rounded;
              u := numr resimp !*f2q u;
              z := for each j in z
                       collect numr resimp !*f2q car j . cdr j>>;
      if v neq 1 and assoc(v,units) then v := 1;
      if v neq 1 then if n=1 then u := multf(v,u)
       else if (w := rassoc(1,z)) then rplaca(w,multf(v,car w))
       else if null z and ((w := rootxf(v,n)) neq 'failed)
        then u := multf(w,u)
       else if not domainp v then z := aconc(z,v . 1)
       else errach {"sqfrf failure",u,n,z};
      return (u . n) . z
   end;
+++ sqfrf redefined
+++ sqfrf compiled, 317 + 132 bytes
sqfrf

symbolic procedure square_free u;
   'list . for each v in sqfrf !*q2f simp!* u
              collect {'list,mk!*sq(car v . 1),cdr v};
+++ square_free compiled, 60 + 32 bytes
square_free

flag('(square_free),'opfn);nil

symbolic procedure diff(u,v);
   % A polynomial differentation routine which does not check
   % indeterminate dependencies.
   if domainp u then nil
    else addf(addf(multpf(lpow u,diff(lc u,v)),
        multf(lc u,diffp1(lpow u,v))),
          diff(red u,v));
+++ diff redefined
+++ diff compiled, 52 + 24 bytes
diff

symbolic procedure diffp1(u,v);
   if not( car u eq v) then nil
    else if cdr u=1 then 1
    else multd(cdr u,!*p2f(car u .** (cdr u-1)));
+++ diffp1 redefined
+++ diffp1 compiled, 26 + 20 bytes
diffp1

endmodule;nil

end;nilmodule homog;nil % Procedures for factorization of homogeneous polynomials.

% Authors: Shuichi Moritsugu <y31046@tansei.cc.u-tokyo.ac.jp>
%          and Eiichi Goto.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%



symbolic procedure homogp s;
   % Confirmation of homogeneous polynomials.
      if domainp s or domainp car s then nil
        else if null cdadr s then nil
        else if domainp cdr lastnondomain cadr s then nil
        else if listsum caaadr s=listsum caar lastnondomain cadr s
         then t
        else nil;
+++ homogp redefined
+++ homogp compiled, 54 + 20 bytes
homogp

symbolic procedure subs0 nm;
   %Substitution of 0 into exponent list.
      if null nm then nil
        else ((0 . cdaar nm) . cdar nm) . subs0 cdr nm;
+++ subs0 compiled, 20 + 16 bytes
subs0

symbolic procedure varss(v,d);
   % Ss of single variable.
      ((v . nil) . 1) . ((((d . nil) . 1) . nil) . 1);
+++ varss compiled, 18 + 12 bytes
varss

symbolic procedure rconstnm(nm,nv,td);
   % Reconstruction of numerator.
      if null nm then nil
        else if domainp nm then ((td . mkzl(nv+1)) . nm) . nil
        else (((td-listsum caar nm) . caar nm) . cdar nm)
             . rconstnm(cdr nm,nv,td);
+++ rconstnm compiled, 45 + 20 bytes
rconstnm

symbolic procedure rconst1(s,v,td);
   % Reconstruction of one factor.
      if homogp s then s
        else ((v . caar s) . (cdar s+1))
             . (reverse rconstnm(cadr s,cdar s,td) . cddr s);
+++ rconst1 compiled, 32 + 16 bytes
rconst1

symbolic procedure rconst(p,fctrlis);
   % Reconstruction of factors.
   begin scalar v,d,td,fs,fcf,ffl,x;
      v := car p; d := cdr p; fcf := car fctrlis;
      for i:=2:length fctrlis do
          <<x := nth(fctrlis,i);
            fs := sf2ss car x; td := listsum caaadr fs;
            fs := rconst1(fs,v,td);
            d := d-cdr x*td;
            ffl := aconc(ffl,ss2sf fs . cdr x)>>;
      ffl := fcf . ffl;
      if d>0 then ffl := aconc(ffl,ss2sf varss(v,1) . d);
      return ffl;
   end;
+++ rconst compiled, 89 + 48 bytes
rconst

endmodule;nil

end;nilmodule tdconv;nil % Procedures for conversion of internal & external
               % expressions defined with total degree ordering.

% Authors: Shuichi Moritsugu <y31046@tansei.cc.u-tokyo.ac.jp>
%          and Eiichi Goto.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%

symbolic procedure setunion(l1,l2);
   % Union of two sets.
      if null l2 then l1
        else if member(car l2,l1) then setunion(l1,cdr l2)
        else setunion(append(l1,car l2 . nil),cdr l2);
+++ setunion redefined
+++ setunion compiled, 24 + 8 bytes
setunion

symbolic procedure searchtm term;
   % Search for variables in a term.
      if domainp term then nil
        else caar term . searchpl cdr term;
+++ searchtm redefined
+++ searchtm compiled, 14 + 12 bytes
searchtm

symbolic procedure searchpl poly;
   % Search for variables in a polynomial.
      if domainp poly then nil
        else setunion(searchtm car poly,searchpl cdr poly);
+++ searchpl redefined
+++ searchpl compiled, 28 + 16 bytes
searchpl

symbolic procedure qsort l;
   % Quick sort of variables with lexicographic ordering.
      begin scalar a,l1,l2,ll;
            if null l then return nil;
            a:=car l; ll:=cdr l;
            loop : if null ll then go to exit;
   % We need ORDOP rather than ORDERP in next line to be consistent
   % with the way that REDUCE orders expressions.
                   if ordop(a,car ll) then l2:=car ll . l2
                                       else l1:=car ll . l1;
                   ll:=cdr ll; go to loop;
            exit : return append(qsort l1,a . qsort l2);
      end;
+++ qsort redefined
+++ qsort compiled, 44 + 12 bytes
qsort

symbolic procedure mapins(ep,cfl);
   % Insert of exponent into coefficient list.
      if null cfl then nil
        else ((ep . caar cfl) . cdar cfl) . mapins(ep,cdr cfl);
+++ mapins redefined
+++ mapins compiled, 19 + 12 bytes
mapins

symbolic procedure mkzl n;
   % Making of zero-list (length = n-1).
      if n=1 then nil else 0 . mkzl(n-1);
+++ mkzl redefined
+++ mkzl compiled, 16 + 20 bytes
mkzl

symbolic procedure sq2sstm(sqtm,vd);
   % Transformation of term from sq to ss.
      begin scalar ep,cf,cfl;
            if caar sqtm=caar vd
              then <<cf:=cdr sqtm; ep:=cdar sqtm;
                     if domainp cf
                       then return ((ep . mkzl cdr vd) . cf) . nil
                       else cfl:=sq2sscfpl(cf,cdar vd . sub1 cdr vd)>>
              else <<cfl:=sq2sscfpl(sqtm . nil,cdar vd . sub1 cdr vd);
                     ep:=0>>;
            return mapins(ep,cfl);
      end;
+++ sq2sstm redefined
+++ sq2sstm compiled, 61 + 24 bytes
sq2sstm

symbolic procedure sq2sscfpl(cfpl,vd);
   % Transformation of coefficient polynomial from sq to ss.
      if null cfpl then nil
        else if domainp cfpl then (mkzl(cdr vd+1) . cfpl) . nil
        else append(sq2sstm(car cfpl,vd),sq2sscfpl(cdr cfpl,vd));
+++ sq2sscfpl redefined
+++ sq2sscfpl compiled, 27 + 16 bytes
sq2sscfpl

symbolic procedure sq2sspl(sqpl,vd);
   % Transformation of polynomial from sq to ss.
      if domainp sqpl then sqpl
        else append(sq2sstm(car sqpl,vd),sq2sspl(cdr sqpl,vd));
+++ sq2sspl redefined
+++ sq2sspl compiled, 30 + 12 bytes
sq2sspl

symbolic procedure sdlist nm;
   % Classification of ss by the degree of main variable.
      begin scalar anslist,partlist,n,rnm;
            rnm:=nm;
            init : n:=caaar rnm; partlist:= car rnm . nil;
            loop : rnm:=cdr rnm;
                   if null rnm
                     then <<anslist:=append(anslist,partlist . nil);
                            go to exit>>;
                   if domainp rnm
                     then <<anslist:=append(append(anslist,
                                                   partlist . nil),
                                            rnm);
                            go to exit>>;
                   if n=caaar rnm
                     then <<partlist:=append(partlist,car rnm . nil);
                            go to loop>>
                     else <<anslist:=append(anslist,partlist . nil);
                            go to init>>;
            exit : return anslist;
      end;
+++ sdlist compiled, 66 + 8 bytes
sdlist

symbolic procedure univsdl2sq(var,sdl);
   % Transformation from univariate ss to sq.
      if domainp sdl then sdl
        else if zerop caaaar sdl then cdaar sdl
        else ((var . caaaar sdl) . cdaar sdl) . univsdl2sq(var,cdr sdl);
+++ univsdl2sq compiled, 35 + 8 bytes
univsdl2sq

symbolic procedure mapdel sdl;
   % Deletion of the exponent of main variable from ss.
      if null sdl then nil
        else (cdaar sdl . cdar sdl) . mapdel cdr sdl;
+++ mapdel compiled, 18 + 12 bytes
mapdel

symbolic procedure mulvsdl2sq(vd,sdl);
   % Transformation from multivariate ss to sq.
      if domainp sdl then sdl
        else if zerop caaaar sdl
               then if domainp cdr sdl and cdr sdl
                      then append(sdl2sq(cdar vd . sub1 cdr vd,
                                         sdlist mapdel car sdl),
                                  cdr sdl)
                      else sdl2sq(cdar vd . sub1 cdr vd,
                                  sdlist mapdel car sdl)
               else ((caar vd . caaaar sdl)
                      . sdl2sq(cdar vd . sub1 cdr vd,
                               sdlist mapdel car sdl))
                    . mulvsdl2sq(vd,cdr sdl);
+++ mulvsdl2sq compiled, 97 + 20 bytes
mulvsdl2sq

symbolic procedure sdl2sq(vd,sdl);
   % Transformation from classified ss to sq.
      if cdr vd=1 then univsdl2sq(caar vd,sdl)
                   else mulvsdl2sq(vd,sdl);
+++ sdl2sq compiled, 12 + 20 bytes
sdl2sq

symbolic procedure termorder1(term1,term2);
   % Comparison of ordering between two terms (purely lexicographic
   % ordering).
      if null term1 then 0
        else if zerop term1 and zerop term2 then 0
        else if zerop term1 then -1
        else if zerop term2 then 1
        else if car term1<car term2 then -1
        else if car term1>car term2 then 1
        else termorder1(cdr term1,cdr term2);
+++ termorder1 redefined
+++ termorder1 compiled, 46 + 20 bytes
termorder1

symbolic procedure listsum l;
   % Total degree.
      if null l then 0 else car l+listsum cdr l;
+++ listsum redefined
+++ listsum compiled, 24 + 12 bytes
listsum

symbolic procedure termorder(term1,term2);
   % Comparison of ordering between two terms (total degree and
   % lexicographic ordering).
      begin scalar s1,s2;
            if null term1 then 0
              else if zerop term1 and zerop term2 then 0
              else if zerop term1 then -1
              else if zerop term2 then 1;
              s1:=listsum term1; s2:=listsum term2;
              return if s1=s2 then termorder1(term1,term2)
                       else if s1<s2 then -1 else 1;
      end;
+++ termorder redefined
+++ termorder compiled, 44 + 24 bytes
termorder

symbolic procedure xxsort l;
   sort(l,function(lambda (a, b); termorder(car a,car b)<0));
+++ xxsort redefined
+++ lambda_blpbtnkikuos compiled, 6 + 12 bytes
+++ xxsort compiled, 4 + 16 bytes
xxsort


% symbolic procedure xxsort l;
%  %Sort of terms with present ordering.
%     begin scalar a,l1,l2,ll;
%           if null l then return nil;
%           a:=car l; ll:=cdr l;
%           loop : if null ll then go to exit;
%                  if termorder(car a,caar ll)<0
%                    then l1:=car ll . l1
%                    else l2:=car ll . l2;
%                  ll:=cdr ll; go to loop;
%           exit : return append(xxsort l1,a . xxsort l2);
%     end;

symbolic procedure lxsort l;
   sort(l,function(lambda (a, b); termorder1(car a,car b)<0));
+++ lambda_ea8nsl2wlbc42 compiled, 6 + 12 bytes
+++ lxsort compiled, 4 + 16 bytes
lxsort

% symbolic procedure lxsort l;
%  % Sort of terms with purely lexicographic ordering.
%     begin scalar a,l1,l2,ll;
%           if null l then return nil;
%           a:=car l; ll:=cdr l;
%           loop : if null ll then go to exit;
%                  if termorder1(car a,caar ll)<0
%                    then l1:=car ll . l1
%                    else l2:=car ll . l2;
%                  ll:=cdr ll; go to loop;
%           exit : return append(lxsort l1,a . lxsort l2);
%     end;

symbolic procedure delet(a,l);
   %Deletion from list.
      if null a then l
        else if null l or a=l then nil
        else if a=car l then cdr l
        else car l . delet(a,cdr l);
+++ delet redefined
+++ delet compiled, 32 + 12 bytes
delet

symbolic procedure lx2xx ss;
   % Transformation from lex. to another normal ordering.
      begin scalar nm,ct;
            if domainp ss or domainp car ss then return ss;
            nm:=cadr ss; ct:=cdr lastnondomain nm;
            return car ss . (append(xxsort delet(ct,nm),ct) . cddr ss);
      end;
+++ lx2xx redefined
+++ lx2xx compiled, 32 + 20 bytes
lx2xx

symbolic procedure lastnondomain u;
   % Return the last non-domain pair of the list u.
   if domainp u then errach list("non-domain",u)
    else if domainp cdr u then u
    else lastnondomain cdr u;
+++ lastnondomain redefined
+++ lastnondomain compiled, 22 + 16 bytes
lastnondomain

symbolic procedure xx2lx ss;
   % Transformation from normal ordering to lex.
      begin scalar nm,ct;
            if domainp ss or domainp car ss then return ss;
            nm:=cadr ss; ct:=cdr lastnondomain nm;
            return car ss . (append(lxsort delet(ct,nm),ct) . cddr ss);
      end;
+++ xx2lx compiled, 32 + 20 bytes
xx2lx

symbolic procedure sf2ss f;
   % Transformation from sf to ss (with denominator 1).
      begin scalar vl,vd;
            if domainp f then return f;
            vl:=searchpl f; vd:=qsort vl . length vl;
            return lx2xx(vd . (sq2sspl(f,vd) . 1));
      end;
+++ sf2ss redefined
+++ sf2ss compiled, 26 + 28 bytes
sf2ss

symbolic procedure ss2sf s;
   % Transformation from ss to sf (neglecting the denominator).
      if domainp s then s
        else sdl2sq(car s , sdlist cadr xx2lx s );
+++ ss2sf compiled, 16 + 20 bytes
ss2sf

endmodule;nil

end;nilmodule primfac;nil   % Primitive square free polynomial factorization.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*intfac !*surds dmode!* intvar kernlist!* knowndiscrimsign);nil

symbolic procedure prsqfrfacf u;
   % U is a non-trivial form which is primitive in all its variables,
   % is square free, and has a positive leading numerical coefficient.
   % Result is a list of factors of u, the first a monomial.
   % We order kernels in increasing powers unless kernlist!* has a
   % non-NIL value in which case we use that order (needed by SOLVE).
   % NOTE: For the time being, we bypass this code if the coefficient
   % domain is other than integer.
   begin scalar bool,knowndiscrimsign,v,w;
      if dmode!* then return list(1,u);
      v := if intvar then list intvar           % Integration in effect.
            else if kernlist!* then kernlist!*
            else reverse kernord!-sort powers u;
      % order highest power first.
      % Note: if this procedure ever fails, the korder is then incorrect.
      w := setkorder v;
      u := reorder u;
      if minusf u then <<bool := t; u := negf u>>;
      u := factor!-ordered!-sqfree!-prim!-f u;
      setkorder w;
%     w := resimp car u;
      u := for each x in u collect
              begin
                 v := reorder x;
                 if bool and minusf v
                   then <<v := negf v; bool := nil>>;
                 return v
              end;
      if bool then u := negf car u . cdr u;
      % We couldn't fold the minus sign.
      return u
   end;
+++ prsqfrfacf compiled, 142 + 64 bytes
prsqfrfacf

symbolic procedure factor!-ordered!-sqfree!-prim!-f pol;
   % U is a non-trivial form which is primitive in all its variables,
   % is square free, has a positive leading numerical coefficient,
   % and has a main variable of lowest degree in the form.
   % Result is a list of factors of u, the first a monomial.
   begin integer n; scalar q,res,w;
      if ldeg pol = 1 then return factor!-coeffs pol
       else if univariatep pol
        then <<while car(q := linfacf pol) do
                <<res := car q . res; pol := cdr q>>;
               while car(q := quadfacf pol) do
                <<res := car q . res; pol := cdr q>>>>;
      if null pol then return 1 . res
       else if length(w := special!-case!-factor pol)>2
        then <<res := car w . res;   % constant.
               for each j in cdr w
                  do res:=fac!-merge(factor!-ordered!-sqfree!-prim!-f j,
                                     res);
               return res>>
       else if ldeg pol < 4 or (n := degreegcd pol) = 1
          then return 1 . pol . res;
      w := cdr sort(dfactors n,function lessp);
      % 1 is always first factor.
      knowndiscrimsign := 'negative;
   a: if null w then <<knowndiscrimsign := nil;
                       return 1 . pol . res>>
       else if length (q := factor!-ordered!-sqfree!-prim!-f
                               downpower(pol,car w))>2
        then <<res := car q . res;
               for each j in cdr q
                  do res := fac!-merge(factor!-ordered!-sqfree!-prim!-f
                                        uppower(j,mvar pol,car w),
                                     res);
               knowndiscrimsign := nil;
               return res>>;
      w := cdr w;
      go to a
   end;
+++ factor!-ordered!-sqfree!-prim!-f compiled, 175 + 80 bytes
factor-ordered-sqfree-prim-f

symbolic procedure downpower(pol,n);
    % Reduce the power of each term in pol wrt main variable by factor
    % n.
   downpower1(pol,mvar pol,n);
+++ downpower compiled, 7 + 12 bytes
downpower

symbolic procedure downpower1(pol,mv,n);
   if domainp pol or not(mvar pol eq mv) then pol
    else (mv .** (ldeg pol/n)) .* lc pol .+ downpower1(red pol,mv,n);
+++ downpower1 compiled, 36 + 12 bytes
downpower1

symbolic procedure uppower(pol,var,n);
    % Raise the power of each term in pol wrt var by factor n.
   if mvar pol = var then uppower1(pol,var,n) else uppower2(pol,var,n);
+++ uppower compiled, 17 + 16 bytes
uppower

symbolic procedure uppower1(pol,mv,n);
   if domainp pol or not(mvar pol eq mv) then pol
    else (mv .** (ldeg pol*n)) .* lc pol .+ uppower1(red pol,mv,n);
+++ uppower1 compiled, 35 + 12 bytes
uppower1

symbolic procedure uppower2(pol,var,n);
   if domainp pol then pol
    else if mvar pol = var
     then (mvar pol .** (ldeg pol*n)) .* lc pol
                .+ uppower2(red pol,var,n)
    else lpow pol .* uppower2(lc pol,var,n) .+ uppower2(red pol,var,n);
+++ uppower2 compiled, 52 + 12 bytes
uppower2

symbolic procedure univariatep pol;
   % True if pol is not a domain element and is univariate with respect
   % to its main variable.
   not domainp pol and univariatep1(pol,mvar pol);
+++ univariatep compiled, 12 + 12 bytes
univariatep

symbolic procedure univariatep1(pol,mv);
   domainp pol
      or mvar pol eq mv and domainp lc pol and univariatep1(red pol,mv);
+++ univariatep1 compiled, 27 + 12 bytes
univariatep1

symbolic procedure special!-case!-factor pol;
   % When integrator calls this, it doesn't want to use the quadratic
   % code.
%  (if degree = 2 and (null !*surds or clogflag) then quadraticf pol
   (if degree = 2 and null !*intfac then quadraticf pol
     else if degree= 3 then cubicf pol
       else if degree = 4 then quarticf pol
       else list(1,pol))
    where degree = ldeg pol;
+++ special!-case!-factor compiled, 31 + 40 bytes
special-case-factor

symbolic procedure degreegcd pol;
   % Returns gcd of degrees of pol with respect to main variable.
   begin integer n; scalar mv;
      mv := mvar pol;
      n := ldeg pol;
      while n>1 and not domainp(pol := red pol) and mvar pol eq mv
         do n := gcdn(n,ldeg pol);
      return n
   end;
+++ degreegcd compiled, 43 + 20 bytes
degreegcd

symbolic procedure factor!-coeffs u;
   % factor the primitive, square free polynomial U wrt main variable.
   % dummy for now.
   list(1,u);
+++ factor!-coeffs compiled, 4 + 12 bytes
factor-coeffs

endmodule;nil

end;nilmodule specfac;nil   % Splitting of low degree polynomials.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 RAND. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*keepsqrts !*sub2 !*surds knowndiscrimsign kord!* zlist);nil

% switch surds;

exports cubicf,quadraticf,quarticf;nil

symbolic procedure coeffs pol;
% Extract coefficients of polynomial wrt its main variable and leading
% degree. Result is a list of coefficients.
    begin integer degree,deg1; scalar cofs,mv;
      mv := mvar pol;
      degree := ldeg pol;
      while not domainp pol and mvar pol eq mv do
       <<deg1 := ldeg pol;
         for i:= 1:(degree-deg1-1) do cofs := nil . cofs;
         cofs := lc pol . cofs;
         pol := red pol;
         degree := deg1>>;
      for i:=1:degree-1 do cofs := nil . cofs;
      return reversip(pol . cofs)
   end;
+++ coeffs redefined
+++ coeffs compiled, 84 + 16 bytes
coeffs

symbolic procedure shift!-pol pol;
% Shifts main variable, mv, of square free nth degree polynomial pol so
% that coefficient of mv**(n-1) is zero.
% Does not assume pol is univariate.
   begin scalar lc1,ld,mv,pol1,redp,shift,x;
      mv := mvar pol;
      ld := ldeg pol;
      redp := red pol;
      if domainp redp or not(mvar redp eq mv) or ldeg redp<(ld-1)
        then return list(pol,1,nil ./ 1);
      lc1 := lc pol;
      x := lc redp;
      shift := quotsq(!*f2q x,!*f2q multd(ld,lc1));
      pol1 := subf1(pol,list(mv . mk!*sq addsq(!*k2q mv,negsq shift)));
      return list(numr pol1,denr pol1,shift)
   end;
+++ shift!-pol compiled, 94 + 40 bytes
shift-pol

symbolic procedure quadraticf!*(pol,var);
   if domainp pol then errach "invalid quadratic to factr"
    else if mvar pol = var then quadraticf pol
    else begin scalar kord,w;
        kord := kord!*;
        kord!* := list var;
        w := coeffs !*q2f resimp(pol ./ 1);
        kord!* := kord;
        w := quadraticf1(car w,cadr w,caddr w);
        if w eq 'failed then return list(1,pol);
        var := !*k2f var;
        return list(if car w neq 1 then mkrn(1,car w) else 1,
                    addf(multf(var,cadr w),caddr w),
                         addf(multf(var,cadddr w),car cddddr w))
     end;
+++ quadraticf!* compiled, 94 + 64 bytes
quadraticf*

symbolic procedure quadraticf pol;
   % Finds factors of square free quadratic polynomial pol (if they
   % exist).  Does not assume pol is univariate.
   (if x eq 'failed then list(1,pol)
    else if not domainp car x then list(1,pol)
            % Answer would be rational.
    else list(if car x neq 1 then mkrn(1,car x) else 1,
              y .* cadr x .+ caddr x,y .* cadddr x .+ car cddddr x)
       where y = (mvar pol .** 1))
    where x = quadraticf1(car w,cadr w,caddr w) where w = coeffs pol;
+++ quadraticf compiled, 68 + 32 bytes
quadraticf

symbolic procedure quadraticf1(a,b,c);
   begin scalar a1,denom,discrim,w;
      if null b and minusf c and not minusf a
       then <<a := rootxf(a,2);
              c := rootxf(negf c,2);
              return if a eq 'failed or c eq 'failed then 'failed
                      else list(1,a,c,a,negf c)>>;
      discrim := powsubsf addf(exptf(b,2),multd(-4,multf(a,c)));
      % A null discriminator can arise from a polynomial such as
      % 16x^2+(32i-8)*x-8i-15;
      if null discrim then nil
       else <<if knowndiscrimsign
                then <<if knowndiscrimsign eq 'negative
                         then return 'failed>>
      %        else if not clogflag and minusf discrim
      %         then return 'failed;
               else if minusf discrim then return 'failed;
             discrim:=rootxf(discrim,2);
             if discrim='failed then return discrim>>;
      denom := multd(4,a);
      a := a1 := multd(2,a);
      w := addf(b,discrim);
      c := addf(b,negf discrim);
      b := w;
      if (w := gcdf(a,b)) neq 1
        then <<a1 := quotf!-fail(a,w); b := quotf!-fail(b,w);
               denom := quotf!-fail(denom,w)>>;
      if (w := gcdf(a,denom)) neq 1 and (w := gcdf(c,denom))
        then <<a := quotf!-fail(a,w);
               c := quotf!-fail(c,w);
               denom := quotf!-fail(denom,w)>>;
      return list(denom,a1,b,a,c)
    end;
+++ quadraticf1 compiled, 180 + 84 bytes
quadraticf1

symbolic procedure rootxf(u,n);
   % Return either polynomial nth root of u or "failed".
   begin scalar x,y,z,w;
      if domainp u
        then return if minusf u then 'failed
                     else if atom u and (y := irootn(u,n))**n=u then y
                     else if not atom u and (x := get(car u,'rootfn))
                      then apply2(x,u,n)
                     else if !*surds and not(u member zlist)
                      then nrootn!*(u,n)
                     else 'failed;
      x := comfac u;
      u := quotf(u,comfac!-to!-poly x);
      z := 1;
      if car x then if cdr(y := divide(cdar x,n)) = 0
                      then z := multpf(caar x .** car y,z)
                     else if !*surds
                      then <<z := multf(mkrootf(caar x,n,cdr y),z);
                             if car y neq 0
                               then z := multpf(caar x .** car y,z)>>
       else return 'failed;
      x := cdr x;
      if domainp x
        then if minusf x then return 'failed
              else if fixp x and (y := irootn(x,n))**n=x
               then z := multd(y,z)
              else if !*surds and fixp x
               then z := multf(nrootn!*(x,n),z)
              else if not atom x and (w := get(car x,'rootfn))
               then apply2(w,x,n)
              else return 'failed
       else if (y := rootxf(x,n)) eq 'failed then return y
       else z := multf(y,z);
      if u=1 then return z;
      x := sqfrf u;
   c: if null x then return z
       else if cdr(y := divide(cdar x,n)) = 0
        then <<z := multf(exptf(caar x,car y),z); x := cdr x>>
       else if !*surds
        then <<z := multf(mkrootf(prepf caar x,n,cdr y),
                          multf(exptf(caar x,car y),z));
          % It's possible to get things like sqrt(-3-9) in z. An "eval"
          % before the prepf fixes this, but it's not worth it.
               x := cdr x>>
       else return 'failed;
      go to c
   end;
+++ rootxf compiled, 260 + 84 bytes
rootxf

symbolic procedure mkrootf(u,m,n);
   if m neq 2 or null !*keepsqrts
     then !*p2f mksp(list('expt,u,list('quotient,1,m)),n)
    else if n neq 1 then errach 'mkrootf
    else !*q2f simpsqrt list u;
+++ mkrootf compiled, 42 + 44 bytes
mkrootf

symbolic procedure nrootn!*(u,n);
   % Returns a standard form representation of the nth root of u.
   begin scalar x;
      if null u then return nil;
      u := nrootn(u,n);
      x := cdr u;         % surd part.
      u := car u;         % rational part.
      if x=1 then return x;
      x := mkrootf(prepf x,n,1);
      return powsubsf multf(u,x)
   end;
+++ nrootn!* compiled, 30 + 32 bytes
nrootn*

symbolic procedure cubicf pol;
   % Split the cubic pol if a change of origin puts it in the form
   % (x-a)**3-b=0.
   begin scalar a,a0,a1,b,neg,p;
      p := shift!-pol pol;
      a := coeffs car p;
      if cadr a then return list(1,pol)
      % Cadr a non nil probably means there are some surds in the
      % coefficients that don't reduce to 0.
       else if caddr a then return list(1,pol);
      % Factorization not possible by this method.
      a0 := cadddr a;
      a := car a;
      if minusf a0 then <<neg := t; a0 := negf a0>>;
      if (a := rootxf(a,3)) eq 'failed
         or (a0 := rootxf(a0,3)) eq 'failed
        then return list(1,pol);
      if neg then a0 := negf a0;
      a := !*f2q a;
      a0 := !*f2q a0;
      p := addsq(!*k2q mvar pol,caddr p);
      % Now numr (a*(mv+shift)+a0) is a factor of pol.
      a1 := numr addsq(multsq(a,p),a0);
      % quotf(pol,a) is quadratic factor. However, the surd division may
      % not work properly, so we calculate factor directly.
      b := multsq(a0,a0);
      b := addsq(b,multsq(negsq multsq(a,a0),p));
      b := numr addsq(b,multsq(multsq(a,a),exptsq(p,2)));
      return aconc!*(quadraticf b,a1)
   end;
+++ cubicf compiled, 132 + 76 bytes
cubicf

symbolic procedure powsubsf u;
   % We believe that the result of this operation must be a polynomial.
   % If subs2q returns a rational, it must be because there are
   % unsimplified surds.  Hopefully rationalizesq can fix those.
   begin scalar !*sub2;
      u := subs2q !*f2q u;
      if denr u neq 1
        then <<u := rationalizesq u;
               if denr u neq 1 then errach list('powsubsf,u)>>;
      return numr u
   end;
+++ powsubsf compiled, 28 + 32 bytes
powsubsf

symbolic procedure quarticf pol;
  % Splits quartics that can be written in the form
  % (x-a)**4+b*(x-a)**2+c.
  % Note that any call of rootxf can lead to a result "failed."
   begin scalar !*sub2,a,a2,a0,b,dsc,p,p1,p2,q,shift,var;
      var := mvar pol;
      p := shift!-pol pol;
      a := coeffs car p;
      shift := caddr p;
      if cadr a    % pol not correctly shifted, possibly due to sqrt.
      % e.g., 729para^4*be^4 - 81para^3*sqrt(27*be^2*para^2 - 8cte1^3)*
      % sqrt(3)*be^3 - 216para^2*be^2*cte1^3 + 12para*sqrt(27be^2*para^2
      %  - 8*cte1^3)*sqrt(3) *be*cte1^3 + 8*cte1^6.
         or cadddr a then return list(1,pol);
       % Factorization not possible by this method.
      a2 := cddr a;
      a0 := caddr a2;
      a2 := car a2;
      a := car a;
      q := quadraticf1(a,a2,a0);
      if not(q eq 'failed)
        then <<a2 := car q; q := cdr q;
               a := exptsq(addsq(!*k2q mvar pol,shift),2);
               b := numr subs2q quotsq(addsq(multsq(!*f2q car q,a),
                                             !*f2q cadr q),
                                       !*f2q cadr p);
               a := numr subs2q quotsq(addsq(multsq(!*f2q caddr q,a),
                                             !*f2q cadddr q),
                                       !*f2q cadr p);
               a := quadraticf!*(a,var);
               b := quadraticf!*(b,var);
               return multf(a2,multf(car a,car b))
                         . nconc!*(cdr a,cdr b)>>
       else if null !*surds or denr shift neq 1
        then return list(1,pol);
       % Factorization not possible by this method.
      shift := numr shift;
      if knowndiscrimsign eq 'negative then go to complex;
      dsc := powsubsf addf(exptf(a2,2),multd(-4,multf(a,a0)));
      p2 := minusf a0;
      if not p2 and minusf dsc then go to complex;
      p1 := not a2 or minusf a2;
      if not p1 then if p2 then p1 := t else p2 := t;
      p1 := if p1 then 'positive else 'negative;
      p2 := if p2 then 'negative else 'positive;
      a := rootxf(a,2);
      if a eq 'failed then return list(1,pol);
      dsc := rootxf(dsc,2);
      if dsc eq 'failed then return list(1,pol);
      p := invsq !*f2q addf(a,a);
      q := multsq(!*f2q addf(a2,negf dsc),p);
      p := multsq(!*f2q addf(a2,dsc),p);
      b := multf(a,exptf(addf(!*k2f mvar pol,shift),2));
      a := powsubsf addf(b,q);
      b := powsubsf addf(b,p);
      knowndiscrimsign := p1;
      a := quadraticf!*(a,var);
      knowndiscrimsign := p2;
      b := quadraticf!*(b,var);
      knowndiscrimsign := nil;
      return multf(car a,car b) . nconc!*(cdr a,cdr b);
      % Complex case.
   complex:
      a := rootxf(a,2);
      if a eq 'failed then return list(1,pol);
      a0 := rootxf(a0,2);
      if a0 eq 'failed then return list(1,pol);
      a2 := powsubsf addf(multf(2,multf(a,a0)),negf a2);
      a2 := rootxf(a2,2);
      if a2 eq 'failed then return list(1,pol);
      % Now a*(x+shift)**2 (+/-) b*(x+shift) + c is a factor.
      p := addf(!*k2f mvar pol,shift);
      q := addf(multf(a,exptf(p,2)),a0);
      p := multf(a2,p);
      a := powsubsf addf(q,p);
      b := powsubsf addf(q,negf p);
      knowndiscrimsign := 'negative;
      a := quadraticf!*(a,var);
      b := quadraticf!*(b,var);
      knowndiscrimsign := nil;
      return multf(car a,car b) . nconc!*(cdr a,cdr b)
   end;
+++ quarticf compiled, 570 + 132 bytes
quarticf

endmodule;nil

end;nilmodule kronf;nil   % Kronecker factorization of univariate forms.

% Author: Anthony C. Hearn.

% Based on code first written by Mary Ann Moore and Arthur C. Norman.

% Copyright (c) 1987 The RAND Corporation. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% exports linfacf,quadfacf;

% imports zfactor;

% Note that only linear and quadratic factors are found here.

symbolic procedure linfacf u; trykrf(u,'(0 1));
+++ linfacf compiled, 4 + 16 bytes
linfacf

symbolic procedure quadfacf u; trykrf(u,'(-1 0 1));
+++ quadfacf compiled, 4 + 16 bytes
quadfacf

symbolic procedure trykrf(u,points);
   % Look for factor of u by evaluation at points and interpolation.
   % Return (fac . cofac), with fac = nil if none found,
   % and cofac = nil if nothing worthwhile is left.
   begin scalar attempt,mv,values;
      if null u then return nil . nil
       else if length points > ldeg u then return nil . u;
      % Degree is too small to find factors.
      mv := mvar u;
      values := for each j in points collect subuf(j,u);
      if 0 member values
        then <<attempt := ((mv .** 1) .* 1) . -1;   % mv - 1
               return attempt . quotf(u,attempt)>>;
      values := for each j in values collect dfactors j;
      values := for each j in values
                   collect append(j,for each k in j collect !:minus k);
      attempt := search4facf(u,values,nil);
      if null attempt then attempt := nil . u;
      return attempt
   end;
+++ trykrf compiled, 257 + 44 bytes
trykrf

symbolic procedure subuf(u,v);
   % Substitute integer u for main variable in univariate polynomial v.
   % Return an integer or a structured domain element.
   begin scalar z;
      if u=0 then u := nil;
      z := nil;
      while v do
         if domainp v then <<z := adddm!*(v,z); v := nil>>
          else <<if u then z := adddm!*(multdm!*(u**ldeg v,lc v),z);
                 % we should do better here.
                 v := red v>>;
      return if null z then 0 else z
   end;
+++ subuf compiled, 45 + 20 bytes
subuf

symbolic procedure adddm!*(u,v);
   % Adds two domain elements u and v, returning a standard form.
   if null u then v else if null v then u else adddm(u,v);
+++ adddm!* compiled, 9 + 12 bytes
adddm*

symbolic procedure multdm!*(u,v);
   % Multiplies two domain elements u and v, returning a standard form.
   if null u or null v then nil else multdm(u,v);
+++ multdm!* compiled, 8 + 12 bytes
multdm*

symbolic procedure dfactors n;
   % Produces a list of all (positive) factors of the domain element n.
   begin scalar x;
      if n=0 then return list 0
       else if n=1 then return list 1
       else if !:minusp n then n := !:minus n;
      return if not atom n
        then if (x := get(car n,'factorfn))
               then combinationtimes apply1(x,n)
              else list n
       else combinationtimes zfactor n
   end;
+++ dfactors compiled, 39 + 36 bytes
dfactors

symbolic procedure combinationtimes fl;
   if null fl then list 1
    else begin scalar n,c,res,pr;
        n := caar fl;
        c := cdar fl;
        pr := combinationtimes cdr fl;
        while c>=0 do <<res := putin(expt(n,c),pr,res); c := c-1>>;
        return res
    end;
+++ combinationtimes compiled, 37 + 20 bytes
combinationtimes

symbolic procedure putin(n,l,w);
   if null l then w else putin(n,cdr l,(n*car l) . w);
+++ putin compiled, 16 + 8 bytes
putin

symbolic procedure search4facf(u,values,cv);
   % combinatorial search for factors. cv gets current value set.
   if null values then tryfactorf(u,cv)
    else begin scalar q,w;
      w := car values;
 loop: if null w then return nil;   % no factor found
      q := search4facf(u,cdr values,car w . cv);
      if null q then <<w := cdr w; go to loop>>;
      return q
    end;
+++ search4facf redefined
+++ search4facf compiled, 32 + 12 bytes
search4facf

symbolic procedure tryfactorf(u,cv);
   % Tests if cv represents a factor of u.
   % For the time being, does not work on structured domain elements.
   begin scalar w;
      if null atomlis cv then return nil;
      if null cddr cv then w := linethroughf(cadr cv,car cv,mvar u)
       else w := quadthroughf(caddr cv,cadr cv,car cv,mvar u);
      if w eq 'failed or null (u := quotf(u,w)) then return nil
       else return w . u
   end;
+++ tryfactorf compiled, 51 + 28 bytes
tryfactorf

symbolic procedure linethroughf(y0,y1,mv);
   begin scalar x;
      x := y1-y0;
      if x=0 then return 'failed
       else if x<0 then <<x:= -x; y0 := -y0>>;
       return if y0 = 0 or gcdn(x,y0) neq 1 then 'failed
               else (mv .** 1) .* x .+ y0
   end;
+++ linethroughf compiled, 39 + 24 bytes
linethroughf

symbolic procedure quadthroughf(ym1,y0,y1,mv);
   begin scalar x,y,z;
      x := divide(ym1+y1,2);
      if cdr x=0 then x := car x-y0 else return 'failed;
      if x=0 then return 'failed;
      z := y0;
      y := divide(y1-ym1,2);
      if cdr y=0 then y := car y else return 'failed;
      if gcdn(x,gcdn(y,z)) neq 1 then return 'failed;
      if x<0 then <<x := -x; y := -y; z := -z>>;
      if z=0 then return 'failed
       else if y=0 then return ((mv .** 2) .* x) .+ z
       else return ((mv .** 2) .* x) .+ (((mv .** 1) .* y) .+ z)
   end;
+++ quadthroughf compiled, 101 + 28 bytes
quadthroughf

endmodule;nil

end;nilmodule conj;nil  % Rationalize denoms of standard quotients by conjugate
              % computation.

% Author: Anthony C. Hearn.

% Modifications by: Eberhard Schruefer.

% Copyright (c) 1992 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*algint !*rationalize !*structure dmode!* kord!* powlis!*);nil

put('rationalize,'simpfg,'((t (rmsubs)) (nil (rmsubs))));((t (rmsubs)) (nil (
rmsubs)))

symbolic inline procedure subtrf(u,v);
   % Returns u - v for standard forms u and v.
   addf(u,negf v);
+++ Record new inline definition:
(de subtrf (u v) (addf u (negf v)))
(progn (de subtrf (u v) (addf u (negf v))) (put (quote subtrf) (quote
number!-of!-args) 2) (put (quote subtrf) (quote procedure_type) (quote (arrow (
times general general) general))) (putc (quote subtrf) (quote inline) (quote (
lambda (u v) (addf u (negf v))))))
+++ subtrf compiled, 8 + 16 bytes
(lambda (u v) (addf u (negf v)))

symbolic procedure rationalizesq u;
   % Rationalize the standard quotient u.
   begin scalar !*structure,!*sub2,v,x;  % Modified by R. Liska.
      % We need structure off to form rationalized denominator properly
      % in subs2f1.
      % ACH had hoped that the cost of having GCD on here was small,
      % since the consequences can be large (e.g., df(log((sqrt(a^2+x^2)
      % +2*sqrt(sqrt(a^2+x^2)*a+a*x)+a+x)/(sqrt(a^2+x^2) - a + x)),x)).
      % However, limit((sqrt(x^(2/5) +1) - x^(1/3)-1)/x^(1/3),x,0) takes
      % too long.
      if x := get(dmode!*,'rationalizefn) then u := apply1(x,u);
      % We need the following in case we are in sparse_bareiss.
      powlis!* := '(i 2 (nil . t) -1 nil) . powlis!*;
      v := subs2q u;
      powlis!* := cdr powlis!*;
      % We need the subs2 to get rid of surd powers.
      % We also need to check if u has changed from the example
      % df((1/x)**(2/3),x).
      return if domainp denr v then v
              else if (x := rationalizef denr v) neq 1
               then <<v := multf(numr v,x) ./ multf(denr v,x);
                      % We need the gcdchk so that df((1/x)**(2/3),x)
                      % is not in a loop.  However, algint needs all
                      % factors for some reason.
                      if null !*algint and null !*rationalize
                        then v := gcdchk v;
                      % There used to be an exptchk here, but that led
                      % to loops (e.g., in df(int(1/(3*x**4+7),x),x)).
                      % We need to suppress following to avoid a non-
                      % terminating evaluation of df(tan((sqrt(1-x^2)
                      %   *asin acos x + 2*sqrt(1-x^2)*x)/x),x).
%                     v := subs2q v;
%                     if not domainp numr quotsq(u,v)
%                       then rationalizesq v else v>>
                      subs2q v>>
             else u
   end;
+++ rationalizesq redefined
+++ rationalizesq compiled, 80 + 64 bytes
rationalizesq

symbolic procedure lowertowerp(u,v);
   % True if v is potentially an algebraic component of a member of v.
   if null u then nil
    else if atom car u or cdar u = v then lowertowerp(cdr u,v)
    else if caar u eq 'expt
       and eqcar(caddar u,'quotient)
       and cadr caddar u = cadr cadr v  % numerator of quotient.
       and fixp caddr caddar u and fixp caddr cadr v
       and cdr divide(caddr caddar u,caddr cadr v) = 0  % denominator.
       and lowertowerp1(cadar u,car v)
     then car u
    else lowertowerp(cdr u,v);
+++ lowertowerp compiled, 74 + 24 bytes
lowertowerp

symbolic procedure lowertowerp1(u,v);
   % This procedure decides if u can be an algebraic extension of v.
   % The = case is decidedly heuristic at the moment.
   % We could think of this as a membership test (including =).
   % However, different SQRT representations complicate things.
   (if x>y then t
     else if numberp u and numberp v then not(gcdn(u,v)=1)
     else x=y)
    where x=exprsize u,y=exprsize v;
+++ lowertowerp1 compiled, 30 + 24 bytes
lowertowerp1

symbolic procedure exprsize u;
   % Get size of u.  Iterative to avoid excessive recursion.
   begin integer n;
   a: if null u then return n else if atom u then return n+1;
      n := exprsize car u + n;
      u := cdr u;
      go to a
   end;
+++ exprsize compiled, 20 + 12 bytes
exprsize

symbolic procedure rationalizef u;
   % Look for I and sqrts, cbrts, quartics at present.
   % I'm not sure I in the presence of (-1)^(1/4) say is handled
   % properly.
   % It is assumed that any surd powers have been reduced before
   % entering this procedure.
   begin scalar x,y,z;
      x := z := kernels u;
   a: if null x then return 1;
      y := car x;
      if eqcar(y,'expt) and eqcar(caddr y,'quotient)
          and lowertowerp(z,cdr y)
        then nil
       else if y eq 'i or eqcar(y,'expt) and caddr y = '(quotient 1 2)
          or eqcar(y,'sqrt)
        then return conjquadratic(mkmain(u,y),y)
       else if eqcar(y,'expt) and caddr y = '(quotient 1 3)
        then return conjcubic(mkmain(u,y),y)
       else if eqcar(y,'expt) and caddr y = '(quotient 1 4)
        then return conjquartic(mkmain(u,y),y);
      x := cdr x;
      go to a
   end;
+++ rationalizef redefined
+++ rationalizef compiled, 86 + 64 bytes
rationalizef

symbolic procedure conjquadratic(u,v);
   if ldeg u = 1
      then subtrf(multf(!*k2f v,reorder lc u),reorder red u)
    else errach list(ldeg u,"invalid power in rationalizef");
+++ conjquadratic compiled, 34 + 40 bytes
conjquadratic

symbolic procedure conjcubic(u,v);
   begin scalar c1,c2,c3,w;
     if ldeg u = 2 then <<c1 := reorder lc u;
                           if degr(red u,v) = 1
                              then <<c2 := reorder lc red u;
                                     c3 := reorder red red u>>
                            else c3 := reorder red u>>
      else <<c2 := reorder lc u;
             c3 := reorder red u>>;
     w := conj2 v;
     if w eq 'failed then return u;
     v := !*k2f v;
     return addf(multf(exptf(v,2),subtrf(exptf(c2,2),multf(c1,c3))),
                 addf(multf(v,subtrf(multf(w,exptf(c1,2)),
                                     multf(c2,c3))),
                      subtrf(exptf(c3,2),multf(w,multf(c1,c2)))))
  end;
+++ conjcubic compiled, 126 + 52 bytes
conjcubic

symbolic procedure conj2 u;
%  (if not domainp denr v then errach list("conj2",u)
   (if not domainp denr v then 'failed
     else if denr v neq 1 then multd(!:recip denr v,numr v)
     else numr v)
   where v = simp cadr u;
+++ conj2 compiled, 23 + 28 bytes
conj2

symbolic procedure conjquartic(u,v);
   begin scalar c1,c3,c4,q1,q2,q3,q4,w;
     if ldeg u = 3
        then <<c1 := reorder lc u;
               if degr(red u,v) = 1
                  then <<c3 := reorder lc red u;
                         c4 := reorder red red u>>
                else c4 := reorder red u>>
      else if ldeg u = 1
              then <<c3 := reorder lc u;
                     c4 := reorder red u>>;
     w := conj2 v;
     if w eq 'failed then return u;
     v := !*k2f v;
     q1 := subtrf(addf(exptf(c3,3),multf(c1,exptf(c4,2))),
                  multf(w,multf(c3,exptf(c1,2))));
     q2 := negf addf(multf(w,multf(c4,exptf(c1,2))),
                     multf(exptf(c3,2),c4));
     q3 := addf(multf(c3,exptf(c4,2)),
                subtrf(multf(exptf(w,2),exptf(c1,3)),
                       multf(w,multf(c1,exptf(c3,2)))));
     q4 := subtrf(multf(w,multf(multd(2,c1),multf(c3,c4))),exptf(c4,3));
     return addf(multf(exptf(v,3),q1),
                 addf(multf(exptf(v,2),q2),addf(multf(v,q3),q4)))
    end;
+++ conjquartic compiled, 223 + 60 bytes
conjquartic

symbolic procedure mkmain(u,var);
   % Make kernel var the main variable of u.
   begin scalar kord!*; kord!* := list var; return reorder u end;
+++ mkmain compiled, 12 + 20 bytes
mkmain

endmodule;nil

end;nilmodule diff;nil % Differentiation package.

% Author: Anthony C. Hearn.

% Modifications by: Francis J. Wright.

% Copyright (c) 2000 Anthony C. Hearn.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*depend frlis!* powlis!* subfg!* wtl!* depl!*);nil

fluid '(!*allowdfint !*dfint !*expanddf !*intflag!* !*df_partial);nil

global '(mcond!* !!fleps1);nil

% Contains a reference to RPLACD (a table update), commented out.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Turning on the switch `allowdfint' allows "differentiation under the
% integral sign", i.e. df(int(y, x), v) -> int(df(y, v), x), if this
% results in a simplification.  If the switch `dfint' is also turned
% on then this happens regardless of whether the result simplifies.
% Both switches are off by default.

switch allowdfint, dfint;nil

deflist('((dfint ((t (rmsubs))))
   (allowdfint ((t (progn (put 'int 'dfform 'dfform_int) (rmsubs)))
                (nil (remprop 'int 'dfform))))), 'simpfg);(dfint allowdfint)
   % There is no code to reverse the df-int commutation,
   % so no reason to call rmsubs when the switch is turned off.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Consider df(u,x,y,z).

% If none of x,y,z are equal to u then the order of differentiation is
% commuted into a canonical form, unless the switch `nocommutedf' is
% turned on, in which case the order of differentiation is not
% commuted at all.  The switch `nocommutedf' is off by default.

% If one (or more) of x,y,z is equal to u then the order of
% differentiation is NOT commuted and the derivative is NOT simplified
% to zero, unless the switch `commutedf' is turned on.  It is off by
% default.  (CRACK needs to turn it on!)

% The new default behaviour should match the behaviour of REDUCE 3.6.
% Turning on the switch `commutedf' should reproduce the default
% behaviour of REDUCE 3.7.

% If `commutedf' is off and the switch `simpnoncomdf' is on then
% simplify df(u,x,u) -> df(u,x,2)/df(u,x), df(u,x,n,u) ->
% df(u,x,n+1)/df(u,x), as suggested by Alain Moussiaux, PROVIDED u
% depends only on the one variable x.  This simplification removes the
% non-commutative aspect of the derivative.

switch commutedf, nocommutedf, simpnoncomdf;nil
% Turning either `commutedf' or `nocommutedf' on turns the other off.
% Turning commutation on or noncommutation off, or turning
% simplification of noncommutative derivatives on, causes
% resimplification.
deflist('((commutedf ((t (off1 'nocommutedf) (rmsubs))))
   (nocommutedf ((t (off1 'commutedf)) (nil (rmsubs))))
      (simpnoncomdf ((t (rmsubs))))), 'simpfg);(commutedf nocommutedf
simpnoncomdf)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% If the switch `expanddf' is turned on then REDUCE uses the chain
% rule to expand symbolic derivatives of indirectly dependent
% variables provided the result is unambiguous, i.e. provided there is
% no direct dependence.  It is off by default.  Thus, for example,
% given
% depend f, u, v; depend {u, v}, x;
% then, if `expanddf' is on,
% df(f,x) -> df(f,u)*df(u,x) + df(f,v)*df(v,x)
% whereas after
% depend f, x;
% df(f,x) does not expand at all (since the result would be ambiguous
% and the algorithm would loop).

% For similar handling in the case of explicit dependence,
% e.g. df(f(u(x),v(x)),x), please use the standard package `DFPART' by
% Herbert Melenk.

switch expanddf;nil
deflist('((expanddf ((t (rmsubs))))), 'simpfg);(expanddf)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% !*df_partial is for interfacing with the odesolve package that needs
% for its internal operation the symbolic partial derivative of an
% algebraic operator u(a(v),b(v),...) via the chain rule, expressed as:
%    df(u(v),v) = u_1(a(v),b(v),...)*df(a,v) + ...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

symbolic procedure simpdf u;
   % U is a list of forms, the first an expression and the remainder
   % kernels and numbers.
   % Value is derivative of first form wrt rest of list.
   begin scalar v,x,y,z;
      if null subfg!* then return mksq('df . u,1);
      v := cdr u;
      u := simp!* car u;
  a:  if null v or null numr u then return u;
      x := if null y or y=0 then simp!* car v else y;
      if denr x neq 1 or atom numr x
        then typerr(prepsq x,"kernel or integer")
       else (if domainp z
               then if get(car z,'domain!-diff!-fn)
                       then begin scalar dmode!*,alglist!*;
                              x := prepf z;
                              if null prekernp x
                                then typerr(x,"kernel")
                            end
                     else typerr(prepf z,"kernel")
              else if null red z and lc z = 1 and ldeg z = 1
                      then x := mvar z
              else typerr(prepf z,"kernel")) where z = numr x;
      v := cdr v;
      if null v then <<u := diffsq(u,x); go to a>>;
      y := simp!* car v;
      % At this point, y must be a kernel or equivalent to an integer.
      % Any other value is an error.
      if null numr y then <<v := cdr v; y := nil; go to a>>
       else if not(z := d2int y) then <<u := diffsq(u,x); go to a>>;
      v := cdr v;
      for i:=1:z do u := diffsq(u,x);
      y := nil;
      go to a
   end;
+++ simpdf redefined
+++ simpdf compiled, 176 + 80 bytes
simpdf

symbolic procedure d2int u;
   if denr u neq 1 then nil
    else if numberp(u := numr u) then u
    else if not domainp u or not(car u eq '!:rd!:) then nil
    else (if abs(float x - u)<!!fleps1 then x else nil)
          where x=fix u where u=rd2fl u;
+++ d2int redefined
+++ d2int compiled, 40 + 24 bytes
d2int

put('df,'simpfn,'simpdf);simpdf

symbolic procedure prekernp u;
   if atom u then idp u
    else idp car u
         and null((car u memq '(plus minus times quotient recip))
                   or ((car u eq 'expt) and fixp caddr u));
+++ prekernp compiled, 29 + 20 bytes
prekernp

symbolic procedure diffsq(u,v);
   % U is a standard quotient, V a kernel.
   % Value is the standard quotient derivative of U wrt V.
   % Algorithm: df(x/y,z)= (x'-(x/y)*y')/y.
   multsq(addsq(difff(numr u,v),negsq multsq(u,difff(denr u,v))),
          1 ./ denr u);
+++ diffsq redefined
+++ diffsq compiled, 24 + 28 bytes
diffsq

symbolic procedure difff(u,v);
   %U is a standard form, V a kernel.
   %Value is the standard quotient derivative of U wrt V.
   % Allow for differentiable domains.
   if atom u then nil ./ 1
    else if atom car u
     then (if diff!-fn then apply2(diff!-fn,u,v) else nil ./ 1)
        where (diff!-fn =  get(car u,'domain!-diff!-fn))
    else addsq(addsq(multpq(lpow u,difff(lc u,v)),
                        multsq(diffp(lpow u,v),lc u ./ 1)),
               difff(red u,v));
+++ difff redefined
+++ difff compiled, 62 + 28 bytes
difff

symbolic procedure diffp(u,v);
   % U is a standard power, V a kernel.
   % Value is the standard quotient derivative of U wrt V.
   begin scalar n,w,x,y,z; integer m;
        n := cdr u;     % integer power.
        u := car u;     % main variable.
        % Take care with noncommuting expressions.
        if n>1 and noncomp u
          then return addsq(multsq(simpdf {u,v},simpexpt {u,n - 1}),
                            multpq(u .** 1,diffp(u . (n - 1),v)))
         else if u eq v and (w := 1 ./ 1) then go to e
         else if atom u then go to f
         %else if (x := assoc(u,dsubl!*)) and (x := atsoc(v,cdr x))
%               and (w := cdr x) then go to e   % deriv known.
             % DSUBL!* not used for now.
         else if (not atom car u and (w:= difff(u,v)))
                  or (car u eq '!*sq and (w:= diffsq(cadr u,v)))
          then go to c  % extended kernel found.
         else if x := get(car u,'dfform) then return apply3(x,u,v,n)
         else if (x := get(car u,dfn_prop u))
%  The following condition not used as it doesn't work properly
%           % The following takes care of implicit dependencies of known kernels
%           % like "depend cos(y),x; df(cos(y),x);"
%                 and not(depends(u,v) and not smember(v,u))
       	  then nil
         else if car u eq 'plus and (w := diffsq(simp u,v))
          then go to c
         else go to h;  % unknown derivative.
        y := x;
        z := cdr u;
    a:  w := diffsq(simp car z,v) . w;
        if caar w and null car y then go to h;  % unknown deriv.
        y := cdr y;
        z := cdr z;
        if z and y then go to a
         else if z or y then go to h;  % arguments do not match.
        y := reverse w;
        z := cdr u;
        w := nil ./ 1;
        % computation of kernel derivative.
        repeat <<
          if caar y
            then w := addsq(multsq(car y,simp subla(pair(caar x,z),
                                                    cdar x)),
                            w);
          x := cdr x;
          y := cdr y >>
         until null y;
    c:  % save calculated deriv in case it is used again.
        % if x := atsoc(u,dsubl!*) then go to d
        %  else x := u . nil;
        % dsubl!* := x . dsubl!*;
  % d:   rplacd(x,xadd(v . w,cdr x,t));
    e:  % allowance for power.
        % first check to see if kernel has weight.
        if (x := atsoc(u,wtl!*))
          then w := multpq('k!* .** (-cdr x),w);
        m := n-1;
        % Evaluation is far more efficient if results are rationalized.
        return rationalizesq if n=1 then w
                else if flagp(dmode!*,'convert)
                     and null(n := int!-equiv!-chk
                                           apply1(get(dmode!*,'i2d),n))
                 then nil ./ 1
                else multsq(!*t2q((u .** m) .* n),w);
    f:  % Check for possible unused substitution rule.
        if not depends(u,v)
           and (not (x:= atsoc(u,powlis!*))
                 or not depends(cadddr x,v))
           and null !*depend
          then return nil ./ 1;
        % Derivative of a dependent identifier; maybe apply chain
        % rule.  Suppose u(v) = u(a(v),b(v),...), i.e. given
        % depend {u}, a, b, {a, b}, v;
        % then (essentially) depl!* = ((b v) (a v) (u b a))
        if !*expanddf
           and (not (x := atsoc(u,powlis!*)) or not depends(cadddr x,v))
           and (x := atsoc(u, depl!*)) and not(v memq (x:=cdr x)) then <<
           w := df!-chain!-rule(u, v, x);
           go to e
        >>;
        w := list('df,u,v);
        w := if x := opmtch w then simp x else mksq(w,1);
        go to e;
    h:  % Final check for possible kernel deriv.
        if car u eq 'df then <<         % multiple derivative
           if cadr u eq v then <<
              % (df (df v x y z ...) v) ==> 0 if commutedf
              if !*commutedf and null !*depend then return nil ./ 1
              else if !*simpnoncomdf and (w:=atsoc(v, depl!*))
                 and null cddr w % and (cadr w eq (x:=caddr u))
              then
                 % (df (df v x) v) ==> (df v x 2)/(df v x) etc.
                 % if single independent variable
                 <<
                    x := caddr u;
                    % w := simp {'quotient, {'df,u,x}, {'df,v,x}};
                    w := quotsq(simp{'df,u,x},simp{'df,v,x});
                    go to e
                 >>
              >>
           else if eqcar(cadr u, 'int) then
              % (df (df (int F x) A) v) ==> (df (df (int F x) v) A) ?
              % Commute the derivatives to differentiate the integral?
              if caddr cadr u eq v then
                 % Evaluating (df u v) where u = (df (int F v) A)
                 % Just return (df F A) - derivative absorbed
                 << w := 'df . cadr cadr u . cddr u;  go to j >>
              else if !*allowdfint and
                 % Evaluating (df u v) where u = (df (int F x) A)
                 % (If dfint is also on then this will not arise!)
                 % Commute only if the result simplifies:
                 not_df_p(w := diffsq(simp!* cadr cadr u, v))
              then <<
                 % Generally must re-evaluate the integral (carefully!)
                 w := 'df . reval{'int, mk!*sq w, caddr cadr u} . cddr u;
                 go to j >>;  % derivative absorbed
           %
           % Try chain rule for nested derivatives:
           % (df (df v x y z ...) a) where v depends on a
           %
           if !*expanddf and depends(cadr u,v)
              and (not (x := atsoc(cadr u,powlis!*)) or not depends(cadddr x,v))
             then <<
                if not smember(v, cadr u)
                 then <<
                  % first check for declared dependency of kernel cadr u on v
                  x := assoc(cadr u, depl!*);
                  % then if cadr u is not a simple symbol,
                  %  check whether anything in cdr cadr u has an explicit
                  %  dependency on v by collecting all kernels in cdr cadr u
                  y := (not atom cadr u and cdr cadr u and get!-all!-kernels cdr cadr u);
                  % but take care to exclude the kernel v when checking dependencies
		  if x and y and ldepends(delete(v,y),v) then <<
               	  % possible inconsistent dependencies, do not apply chain rule
%                   msgpri("Possible inconsistent dependencies in",u,
%                         nil,nil,nil);
                    nil >>
                   else if x and not(v memq (x:=cdr x))
                    % declared indirect dependency, 
                    then << w := df!-chain!-rule(u, v, x); go to e>>
                   else if y and not smember(v,y)
                    % possible indirect dependency of kernel arglist on v
                    then << w := df!-chain!-rule(u, v, y); go to e>>
                  >>
              >>;
           if (x := find_sub_df(w:= cadr u . merge!-ind!-vars(u,v),
                                           get('df,'kvalue)))
                          then <<w := simp car x;
                                 for each el in cdr x do
                                    for i := 1:cdr el do
                                        w := diffsq(w,car el);
                                 go to e>>
                       else w := 'df . w
        >> else if !*df_partial and !*expanddf and not atom cadr u then <<
           % Derivative of an algebraic operator u(a(v),...) via the
           % chain rule: df(u(v),v) = u_1(a(v),b(v),...)*df(a,v) + ...
           x := intern compress nconc(explode car u, '(!! !! !_));
           y := cdr u;  w := nil ./ 1;  m := 0;
           for each a in y do
           begin scalar b;
              m:=m+1;
              if numr(b:=simp{'df,a,v}) then <<
                 z := mkid(x, m);
                 put(z, 'simpfn, 'simpiden);
                 w := addsq(w, multsq(simp(z . y), b))
              >>
           end;
           go to e
        >> else w := {'df,u,v};
   j:   if (x := opmtch w) then w := simp x
         % At this point nested df's may have been collapsed, so
         % we have to consider all dependencies on all variables
         % and be very careful about returning zero.
         else if not depends(u,v)
                 and (not (x:= atsoc(u:=cadr w,powlis!*))
                       or not dependsl(cadddr x,cddr w))
                 and null !*depend then return nil ./ 1
         % do not try to apply the chain rule to cases that are handled earlier
         % (i.e. for nested/multiple derivatives, or differentiation of integrals)
         % or that may come from inconsistent dependencies, e.g. after
         %  depend u(v),a;
         % do not replace df(u(v),v) by df(u(v),a)*df(a,v) 
         else if !*expanddf and not atom u and null cdddr w
                 and not(car u memq '(df int)) and not smember(v,u)
                 and (not (x:= atsoc(u,powlis!*)) or not depends(cadddr x,v))
          then <<
            % first check for declared dependency of kernel u on v
            x := assoc(u, depl!*);
            % then check whether anything in cdr u has an explicit
            % dependence on v by collecting all kernels in cdr u
            y := (cdr u and get!-all!-kernels cdr u);
            % but take care to exclude the kernel v when checking dependencies
            if x and y and ldepends(delete(v,y),v) then <<
               % possible inconsistent dependencies, do not apply chain rule
               msgpri("Possible inconsistent dependencies in",u,
                      nil,nil,nil);
               w := mksq(w,1) >>
             else if x then
                % declared dependency
                if (v memq (x:=cdr x))
                  then w := mksq(w,1)
                 else w := df!-chain!-rule(u, v, x)
             else if y then
              % possible dependency of kernel arglist on v
              w := if smember(v,y) then mksq(w,1) else df!-chain!-rule(u, v, y)
             else w := mksq(w,1)
           >>
         else w := mksq(w,1);
      go to e
   end;
+++ diffp redefined
+++ diffp compiled, 989 + 224 bytes
diffp

symbolic procedure get!-all!-kernels(plis);
   % plis is a list of expressions in prefix form
   % result is a list of all kernels in the simplified expressions
   if atom plis then nil
    else union((union(kernels numr sq,kernels denr sq)
                  where sq := simp car plis),
               get!-all!-kernels(cdr plis));
+++ get!-all!-kernels redefined
+++ get!-all!-kernels compiled, 35 + 20 bytes
get-all-kernels

symbolic procedure df!-chain!-rule(u, v, klis);
   % compute the derivative of u w.r.t. v with intermediate
   %  variables from klis, via the chain rule
   % returns a s.q.
   begin scalar w;
     w := nil ./ 1;
     for each krnl in klis do
       w := addsq(w, multsq(simp{'df,u,krnl},simp{'df,krnl,v}));
     return w;
   end;
+++ df!-chain!-rule redefined
+++ df!-chain!-rule compiled, 42 + 28 bytes
df-chain-rule

symbolic procedure dfform_int(u, v, n);
   % Simplify a SINGLE derivative of an integral.
   % u = '(int y x) [as main variable of SQ form]
   % v = kernel
   % n = integer power
   % Return SQ form of df(u**n, v) = n*u**(n-1)*df(u, v)
   % This routine is called by diffp via the hook
   % "if x := get(car u,'dfform) then return apply3(x,u,v,n)".
   % It does not necessarily need to use this hook, but it needs to be
   % called as an alternative to diffp so that the linearity of
   % differentiation has already been applied.
   begin scalar result, x, y, dx!/dv;
      y := simp!* cadr u;  % SQ form integrand
      x := caddr u;  % kernel
      result :=
      if v eq x then y
         % Special case -- just differentiate the integral:
         % df(int(y,x), x) -> y  replacing the let rule in INT.RED
      else if not !*intflag!* and       % not in the integrator
         % If used in the integrator it can cause infinite loops,
         % e.g. in df(int(int(f,x),y),x) and df(int(int(f,x),y),y)
         !*allowdfint and               % must be on for dfint to work
         <<
            % Compute PARTIAL df(y, v), where y must depend on x, so
            % if x depends on v, temporarily replace x:
            result := if numr(dx!/dv:=diffp(x.**1,v)) then
               %% (Subst OK because all kernels.)
               subst(x, xx, diffsq(subst(xx, x, y), v)) where
                  xx = gensym()
            else diffsq(y, v);
            !*dfint or not_df_p result
         >>
      then
         % Differentiate under the integral sign:
         % df(int(y,x), v) -> df(x,v)*y + int(df(y,v), x)
         addsq(
            multsq(dx!/dv, y),
            simp{'int, mk!*sq result, x})  % MUST re-simplify it!!!
            % (Perhaps I should use prepsq -
            % kernels are normally true prefix?)
      else !*kk2q{'df, u, v};  % remain unchanged
      if not(n=1) then
         result := multsq( (((u .** (n-1)) .* n) .+ nil) ./ 1, result);
      return result
   end;
+++ dfform_int compiled, 124 + 76 bytes
dfform_int

symbolic procedure not_df_p y;
   % True if the SQ form y is not a df kernel.
   not(denr y eq 1 and
       not domainp (y := numr y) and eqcar(mvar y, 'df));
+++ not_df_p compiled, 29 + 24 bytes
not_df_p

% Compute a dfn-property name corresponding to the argument number
% of an operator expression. Here we assume that most functions
% will have not more than 3 arguments.

symbolic procedure dfn_prop(w);
  (if n=1 then 'dfn else if n=2 then 'dfn2 else if n=3 then 'dfn3
    else mkid('dfn,n))
     where n=length cdr w;
+++ dfn_prop redefined
+++ dfn_prop compiled, 22 + 36 bytes
dfn_prop

% The following three functions, and the hooks to this code above, were
% suggested by Gerhard Post and Marcel Roelofs.

symbolic procedure find_sub_df(df_args,df_values);
   df_values and
      (is_sub_df(df_args,car df_values) or
       find_sub_df(df_args,cdr df_values));
+++ find_sub_df redefined
+++ find_sub_df compiled, 13 + 12 bytes
find_sub_df

symbolic procedure is_sub_df(df_args,df_value);
   begin scalar df_set,kernel,n,entry;
     if car(df_args) neq cadar(df_value) then return nil;  % check fns.
     df_args := dot_df_args cdr df_args;
     df_set  := cddar df_value;
     while df_set and df_args do              % Check differentiations.
       <<kernel := car df_set;
         if cdr df_set and fixp(n := cadr df_set)
           then df_set := cdr df_set else n := 1;
         if (entry := atsoc(kernel,df_args))
                 and (n := cdr entry-n) geq 0
           then rplacd(entry,n) else df_args:=nil;
         df_set := cdr df_set>>;
     return if df_args then (cadr(df_value) . df_args);
   end;
+++ is_sub_df compiled, 72 + 20 bytes
is_sub_df

symbolic procedure dot_df_args l;
   begin scalar kernel,n,df_args;
     while l do
       <<kernel := car l;
         if cdr l and fixp(n := cadr l) then l := cdr l else n := 1;
         df_args := (kernel . n) . df_args;
         l := cdr l>>;
     return df_args;
   end;
+++ dot_df_args compiled, 31 + 12 bytes
dot_df_args

symbolic procedure merge!-ind!-vars(u,v);
   % Consider (df u v) where u = (df a b c d ...)
   % It is non-commuting if a = v or if a in (b c d ...)
   % i.e. if a in (v b c d ...)
   if !*nocommutedf or
      (not !*commutedf and (cadr u memq (v . cddr u)))
   then derad!*(v,cddr u) else derad(v,cddr u);
+++ merge!-ind!-vars redefined
+++ merge!-ind!-vars compiled, 28 + 24 bytes
merge-ind-vars

symbolic procedure derad!*(u,v);        % Non-commuting derad
   %% Return the canonical list of differentiation variables
   %% equivalent to v,u, where v is a LIST of previus differentiation
   %% variables, when df(df(f(v,u), v), u) is simplified to
   %% df(f(v,u), v, u).  Essentially just cons u onto v.
   reverse
      if u eq car(v:=reverse v) then   % x,y, y
         2 . v
      else if numberp car v and u eq cadr v then % x,y,n, y
         (car v + 1) . cdr v
      else u . v;
+++ derad!* compiled, 35 + 12 bytes
derad*                       % x,y, z

symbolic procedure derad(u,v);
   if null v then list u
    else if numberp car v then car v . derad(u,cdr v)
    else if u=car v then if cdr v and numberp cadr v
                           then u . (cadr v + 1) . cddr v
                          else u . 2 . cdr v
    else if ordp(u,car v) then u . v
    else car v . derad(u,cdr v);
+++ derad redefined
+++ derad compiled, 81 + 16 bytes
derad

symbolic procedure letdf(u,v,w,x,b);
   begin scalar y,z,dfn;
        if atom cadr x then go to b
         else if not idp caadr x then typerr(caadr x,"operator")
         else if not get(caadr x,'simpfn)
          then <<redmsg(caadr x,"operator"); mkop caadr x>>;
        rmsubs();
        dfn := dfn_prop cadr x;
        if not(mcond!* eq 't)
                or not frlp cdadr x
                or null cddr x
                or cdddr x
                or not frlp cddr x
                or not idlistp cdadr x
                or repeats cdadr x
                or not(caddr x member cdadr x)
         then go to b;
        z := lpos(caddr x,cdadr x);
        if not get(caadr x,dfn)
            then put(caadr x,
                     dfn,
                     nlist(nil,length cdadr x));
        w := get(caadr x,dfn);
        if length w neq length cdadr x
          then rerror(poly,17,
                      list("Incompatible DF rule argument length for",
                            caadr x));
   a:   if null w or z=0 then return errpri1 u
         else if z neq 1
          then <<y := car w . y; w := cdr w; z := z-1; go to a>>
         else if null b then y := append(reverse y,nil . cdr w)
         else y := append(reverse y,(cdadr x . v) . cdr w);
        return put(caadr x,dfn,y);
   b:   %check for dependency;
        if smemqlp(frlis!*,caddr x) then return nil
         else if idp cadr x and not(cadr x memq frlis!*)
           then depend1(cadr x,caddr x,t)
         else if not atom cadr x and idp caadr x and frlp cdadr x
          then depend1(caadr x,caddr x,t);
        return nil
   end;
+++ letdf compiled, 258 + 108 bytes
letdf

symbolic procedure frlp u;
   null u or (car u memq frlis!* and frlp cdr u);
+++ frlp redefined
+++ frlp compiled, 14 + 16 bytes
frlp

symbolic procedure lpos(u,v);
   if u eq car v then 1 else lpos(u,cdr v)+1;
+++ lpos redefined
+++ lpos compiled, 11 + 12 bytes
lpos


endmodule;nil


end;nilmodule polyop;nil % Functions for algebraic mode operations on polynomials.

% Author: Anthony C. Hearn.

% Modified by: F. Kako, F.J. Wright.

% Copyright (c) 1995 RAND. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% This code has been modified to be consistent with the rules

%      lterm(f,x) = lcof(f,x)*lpower(f,x)
%      f = lterm(f,x) + reduct(f,x)

fluid '(!*ratarg gdmode!*);nil

symbolic procedure deg(u,kern);
   <<u := simp!* u; tstpolyarg2(u,kern); numrdeg(numr u,kern)>>
     where dmode!* = gdmode!*;
+++ deg redefined
+++ deg compiled, 19 + 32 bytes
deg

% totaldeg(u, kernlist) find the total degree of the polynomial u in
% the variables in kernlist. If kernlist is not a list it is treated
% as a simple single variable.
% The denominator of u is ignored, and "degree" here does not may attention
% to fractional powers. Mentions of a kernel within the argument to any
% operator or function (eg sin, cos, log, sqrt) are ignored. Really u is
% expected to be just a polynomial.
%
% Eg:
%   totaldeg(a*x^2+b*x+c, x)  => 2
%   totaldeg(a*x^2+b*x+c, {a,b,c})  => 1
%   totaldeg(a*x^2+b*x+c, {x, a})  => 3
%   totaldeg(a*x^2+b*x+c, {x,b})  => 2
%   totaldeg(a*x^2+b*x+c, {p,q,r})  => 0

symbolic procedure totaldeg(u,kernlist);
  begin
    scalar n;
    u := numr simp!* u;
    kernlist := prepsq simp!* kernlist;
    if eqcar(kernlist, 'list) then kernlist := cdr kernlist
    else kernlist := list kernlist;
    n := totaldeg1(u, kernlist, 0);
    return n;
  end;
+++ totaldeg compiled, 27 + 28 bytes
totaldeg

symbolic procedure totaldeg1(u, kernlist, above);
  begin
    scalar r;
    r := above;
    while not domainp u do <<
      if member(mvar u, kernlist) then
        r := max2(r, totaldeg1(lc u, kernlist, above+ldeg u))
      else r := max2(r, totaldeg1(lc u, kernlist, above));
      u := red u >>;
    return r
  end;
+++ totaldeg1 compiled, 54 + 8 bytes
totaldeg1

symbolic procedure tstpolyarg2(u,kern);
 <<for each j in kernels numr u do
      if j neq kern and depends(j,kern)
        then typerr(prepsq u,"polynomial");
   for each j in kernels denr u do
      if depends(j,kern) then typerr(prepsq u,"polynomial")>>;
+++ tstpolyarg2 compiled, 60 + 28 bytes
tstpolyarg2

symbolic procedure numrdeg(u,kern);
   begin scalar x;
      kern := !*a2k kern;
      if domainp u then return 0
       else if mvar u eq kern then return !*f2a ldeg u;
      x := updkorder kern;
      u := reorder u;
      if not(mvar u eq kern) then u := 0 else u := ldeg u;
      setkorder x;
%     return !*f2a u
      return u
   end;
+++ numrdeg compiled, 42 + 32 bytes
numrdeg

symbolic procedure lcofeval u;
   begin scalar kern,x,y;
      if null u or null cdr u or not null cddr u
        then rerror(poly,280,
                    "LCOF called with wrong number of arguments");
      kern := !*a2k cadr u;
      u := simp!* car u;
      y := denr u;
      tstpolyarg(y,u);
      u := numr u;
%     if domainp u then return if null u then 0 else mk!*sq (u . 1)
      if domainp u then return if null u then 0 else !*ff2a(u,y)
       else if mvar u eq kern then return !*ff2a(lc u,y);
      x := updkorder kern;
      u := reorder u;
      if mvar u eq kern then u := lc u;
      setkorder x;
      return if null u then 0 else !*ff2a(u,y)
   end;
+++ lcofeval compiled, 82 + 56 bytes
lcofeval

put('lcof,'psopfn,'lcofeval);lcofeval

% Note. This is an older definition still used by some packages.

symbolic procedure lcof(u,kern);
   begin scalar x,y;
      u := simp!* u;
      y := denr u;
      tstpolyarg(y,u);
      u := numr u;
      kern := !*a2k kern;
      if domainp u then return 0
       else if mvar u eq kern then return !*ff2a(lc u,y);
      x := updkorder kern;
      u := reorder u;
      if mvar u eq kern then u := lc u;
      setkorder x;
      return if null u then 0 else !*ff2a(u,y)
   end;
+++ lcof compiled, 57 + 40 bytes
lcof

symbolic procedure lpower(u,kern);
   begin scalar x,y;
      u := simp!* u;
      y := denr u;
      tstpolyarg(y,u);
      u := numr u;
      kern := !*a2k kern;
%     if domainp u then return 1
      if domainp u then return !*ff2a(1,y)
       else if mvar u eq kern then return !*ff2a(lpow u.*1 .+ nil,y);
      x := updkorder kern;
      u := reorder u;
      if mvar u eq kern then u := lpow u.*1 .+ nil else u := 1;
      setkorder x;
      return !*ff2a(u,y)
   end;
+++ lpower compiled, 63 + 40 bytes
lpower

symbolic procedure lterm(u,kern);
   begin scalar x,y;
      u := simp!* u;
      y := denr u;
      tstpolyarg(y,u);
      u := numr u;
      kern := !*a2k kern;
%     if domainp u then return if null u then 0 else u
      if domainp u then return if null u then 0 else !*ff2a(u,y)
       else if mvar u eq kern then return !*ff2a(lt u .+ nil,y);
      x := updkorder kern;
      u := reorder u;
%     if mvar u eq kern then u := lt u .+ nil else u := nil;
      if mvar u eq kern then u := lt u .+ nil;
      setkorder x;
      u := reorder u;
      return !*ff2a(u,y)
   end;
+++ lterm compiled, 60 + 40 bytes
lterm

% symbolic procedure !*lterm u; lt u .+ nil;

symbolic procedure mainvar u;
   if domainp(u := numr simp!* u) then 0
    else sfchk(u := mvar u);
+++ mainvar compiled, 26 + 24 bytes
mainvar

symbolic procedure sfchk u; if sfp u then prepf u else u;
+++ sfchk redefined
+++ sfchk compiled, 11 + 16 bytes
sfchk

symbolic procedure reduct(u,kern);
   begin scalar x,y;
      u := simp!* u;
      y := denr u;
      tstpolyarg(y,u);
      u := numr u;
      kern := !*a2k kern;
%     if domainp u then return !*ff2a(u,y)
      if domainp u then return 0
       else if mvar u eq kern then return !*ff2a(cdr u,y);
      x := updkorder kern;
      u := reorder u;
%     if mvar u eq kern then u := cdr u;
      if mvar u eq kern then u := cdr u else u := nil;
      setkorder x;
      u := reorder u;
      return !*ff2a(u,y)
   end;
+++ reduct compiled, 56 + 40 bytes
reduct

symbolic procedure tstpolyarg(y,u);
   null !*ratarg and y neq 1 and typerr(prepsq u,"polynomial");
+++ tstpolyarg compiled, 15 + 28 bytes
tstpolyarg

% symbolic operator deg,totaldeg,lpower,lterm,mainvar,reduct;

flag('(deg totaldeg lpower lterm mainvar reduct),'opfn);nil % This way for booting.

endmodule;nil

end;nilmodule decompos;nil % Decomposition of polynomials f(x) = g(h(x)).

% Author: Herbert Melenk <melenk@sc.zib-berlin.de>.

% Algorithms: 1. univariate case:
%            V.S. Alagar, M.Tanh: Fast Polynomial Decomposition
%            Algorithms, EUROCAL 1985, pp 150-153 (Springer).
%
%             2. multivariate lifting:
%            J. von zur Gathen: Functional Decomposition of Polynomials:
%            the Tame Case, J. Symbolic Computation (1990) 9, 281-299.

% Copyright (c) 1990 ZIB.
%
%     1-July-93  Replaced gensym calls by local name generator.
%                Otherwise decompose may produce different results
%                for identical input.
%    29-Apr.-93: completed normalization of multivariate results:
%                shifting sign and content (field: leading coefficient)
%                and absolute term to the 1st form.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


global '(decomposegensym!*);nil

put('decompose,'psopfn,'decomposesf);decomposesf

symbolic procedure decomposesf f;
  'list . reverse decomposef2(simp reval car f,t)
        where !*factor=nil,!*exp=t;
+++ decomposesf compiled, 26 + 40 bytes
decomposesf

symbolic procedure decomposef1(f,msg);
    decomposef2(f ./ 1 ,msg);
+++ decomposef1 compiled, 6 + 16 bytes
decomposef1

symbolic procedure decomposef2(f,msg);
   begin scalar hvars,r,rr,x,y,u,vars,newvars,d;
      decomposegensym!*:=1000;
      vars := decomposesfvars(numr f,nil);
      newvars := for each x in vars collect decomposegensym();
      d := denr f;
      if not domainp d
        then rerror(poly,18,typerr(prepsq f,"polynomial"));
      f := numr subf(numr f,pair(vars,newvars));
      if length vars = 1 then r := decomposesfuni0 f
       else r := decomposesfmulti(f,newvars);
      hvars := '(u v w a b c d e);
      for each x in vars do hvars := delete (x,hvars);
      while r do
       <<if cdr r
           then <<y := x; x := nil;
                  while null x do
                     if hvars then <<x := car hvars; hvars := cdr hvars;
                                     if not(x=reval x) then x := nil>>
                      else x:=decomposegensym();
                  u := prepsq subsq(car r,list(mvar numr car r . x));
                  if d neq 1 then<<u:=list('quotient,u,prepf d);d:=1>>;
                  rr := (if y then list('equal,y,u) else u) . rr>>
          else <<u := prepsq car r;
                 y := x;
                 rr := (if y then list('equal,y,u) else u) . rr>>;
         r := cdr r>>;
      rr := subla(pair(newvars,vars),car rr) . cdr rr;
      return rr
   end;
+++ decomposef2 compiled, 237 + 92 bytes
decomposef2

symbolic procedure decomposesfvars(f,v);
    % Select the kernels from a standard form.
      if domainp f then v else
        decomposesfvars(red f,
            decomposesfvars(lc f,
                if not member(mvar f,v)
                 then append(v,list mvar f) else v));
+++ decomposesfvars compiled, 37 + 8 bytes
decomposesfvars

symbolic procedure decomposesfuni0 f;
    for each p in decomposesfuni f collect (p ./ 1);
+++ decomposesfuni0 compiled, 37 + 16 bytes
decomposesfuni0

symbolic procedure decomposesfuni f;
    % Univariate variant.
   begin scalar x,y,res,ddfl,h,testf;
      integer n;
     n := ldeg f;
     if primep n then return list f;
     x := mvar f; y := decomposegensym();
     ddfl := decomposefctrf decomposedf(f,x);
    if length ddfl > 1 then
     for each d in ddfl do
      if null res and 0=remainder(n , (ldeg d + 1)) then
      <<h := numr decomposeint(d,x);
          if null testf then
               testf := addf(f,negf numr subf(f,list(x . y)));
          if quotf (testf,
                    addf(h,negf numr subf(h,list(x . y)))) then
          res := list(decomposebacksubstuni(f,h,x),h);
          if res and ldeg car res<2 then res:=nil;
      >>;
      if null res then return list f else
          return for each u in res join decomposesfuni u
   end;
+++ decomposesfuni compiled, 177 + 64 bytes
decomposesfuni

symbolic procedure decomposefctrf f;
    % Generate all factors of f by combining the prime factors.
   begin scalar u,w,q;
       q := fctrf f; u:= cdr q;
       if length u = 1 and cdar u=1 then return list f;
          % eliminate the two trivial factors.
       w := delete(quotf(f,car q),decomposefctrf1 u);
       w := delete(1,w);
       return w;
   end;
+++ decomposefctrf compiled, 32 + 24 bytes
decomposefctrf

symbolic procedure decomposefctrf1 v;
    % Collect all possible crossproducts from v.
    if null v then '(1) else
    begin scalar r,c,q;
     c:=car v;
     r:=decomposefctrf1 cdr v;
     q:=for i:=1:cdr c collect exptf(car c,i);
     return
      append(r,
       for each u in q join
         for each p in r collect
             multf(u,p)  );
    end;
+++ decomposefctrf1 compiled, 177 + 28 bytes
decomposefctrf1

symbolic procedure decomposebacksubstuni(f,h,x);
  begin scalar c,g,n,p,pars,ansatz,eqs;
     p := 1; n := ldeg f/ldeg h;
     for i:=0:n do
     <<c := mkid('coeff,i);
       pars := c . pars;
       ansatz := addf(multf(numr simp c,p) , ansatz);
       p := multf(p,h);
     >>;
     pars := reverse pars;
     ansatz := addf(f , negf ansatz);
     eqs := decomposecoeff(ansatz,list x);
     eqs := solveeval list('list . for each u in eqs collect prepf u,
                       'list . pars);
     eqs := cdr cadr eqs; % select the only solution.
     for i:= 0:n do
       g := addf(g,numr simp list('times,list('expt,x,i),
                                  caddr nth(eqs,i+1)));
     return g
   end;
+++ decomposebacksubstuni compiled, 172 + 68 bytes
decomposebacksubstuni

symbolic procedure decomposedf(f,x);
   % Differentiate a polynomial wrt top-level variable x.
   % Returns a standard form.
    if domainp f or not(mvar f = x) then nil else
    if ldeg f = 1 then lc f else
    mvar f .** (ldeg f - 1) .* multf(lc f,ldeg f)
           .+ decomposedf(red f,x);
+++ decomposedf compiled, 46 + 24 bytes
decomposedf

symbolic procedure decomposeint(f,x);
   % Integrate a polynomial (standard form) wrt the (main-)variable x.
   % Returns a standard quotient.
    if null f then nil ./ 1 else
    if domainp f then (x .** 1 .* f .+ nil) ./ 1 else
    addsq(multsq((x .** (ldeg f + 1) .* 1 .+ nil)./ 1 ,
                 multsq(lc f./1,1 ./ldeg f+1))
          ,  decomposeint(red f,x));
+++ decomposeint compiled, 64 + 24 bytes
decomposeint

symbolic procedure decomposecoeff(f,vars);
   % Select the coefficients of f wrt vars.
     begin scalar o;
       o := setkorder vars;
       f := reorder f;
       setkorder o;
       return decomposecoeff1(f,vars)
     end;
+++ decomposecoeff compiled, 12 + 20 bytes
decomposecoeff

symbolic procedure decomposecoeff1(f,vars);
     if domainp f then nil else
     if not member(mvar f,vars) then list f else
     nconc(decomposecoeff1(lc f,vars),decomposecoeff1(red f,vars));
+++ decomposecoeff1 compiled, 27 + 8 bytes
decomposecoeff1

symbolic procedure decomposetdg f;
    % calculate total degree
    if domainp f then 0 else
    max(ldeg f + decomposetdg lc f, decomposetdg red f);
+++ decomposetdg compiled, 34 + 16 bytes
decomposetdg

symbolic procedure  decomposedegr(f,vl);
   if domainp f then vl else
   <<if ldeg f > cdr v then cdr v := ldeg f;
     decomposedegr(lc f,vl);
     decomposedegr(red f,vl);
     vl>> where v = assoc(mvar f,vl);
+++ decomposedegr compiled, 30 + 12 bytes
decomposedegr

symbolic procedure compose (u,v);
    % Calculate f(x)=u(v(x)) for standard forms u,v.
    if domainp u then u else
         numr subf(u,list(mvar u . prepf v));
+++ compose compiled, 22 + 16 bytes
compose

% Multivariate polynomial decomposition.
%
% Technique:
%    select a field as domain (rational),
%      map f to a strongly monic polynomial by variable transform,
%        map f to a univariate image,
%            decompose the univariate polynomial,
%        lift decomposition to multivariate,
%      convert back to original variables,
%    transform back to original domain (if possible).

symbolic procedure decomposesfmulti(f,vars);
   % Multivariant case: map to field (rationals).
    begin scalar dm,ft,r,rr,a,q,c,p1,p2;
      if null dmode!* or not flagp(dmode!*,'field) then
     <<setdmode('rational,t) where !*msg=nil; dm := t;
       ft := !*q2f resimp !*f2q f>> else ft := f;
     r := decomposesfmulti1(ft,vars);
     if dm then setdmode('rational,nil) where !*msg=nil;
     if null cdr r then return list(f./1);
 %   if null dm then return
 %      for each p in r collect (p ./ 1);
       % Convert back to integer polynomials.
     rr := for each p in reverse r collect simp prepf p;
     r := nil;
     while rr and cdr rr do
     <<p1 := car rr; p2 := cadr rr;
          % Propagate absolute term and content from p1 to p2.
       q := denr p1; a := numr p1;
       while not domainp a do a := red a;
       p1 := addf(numr p1,negf a);
       c := decomposenormfac p1;
       p1 := multsq(p1 ./ 1, 1 ./ c);
       p2 := subsq(p2,list(mvar numr p2 .
              list('quotient,
                   list('plus,list('times,decomposegensym(),prepf c),
                              prepf a),
                     prepf q)));
       r := p1 . r; rr := p2 . cddr rr>>;
     return car rr . r;
   end;
+++ decomposesfmulti compiled, 218 + 92 bytes
decomposesfmulti

symbolic procedure decomposesfmulti1(f,vars);
  % Multivariate case: map to strongly monic polynomial.
    begin scalar lvars,ft,rt,x1,a0,kord,u,sigma;
     integer n,m;
       % get the variable with highest degree as main variable.
     u :=  decomposedegr(f,for each x in vars collect (x. 0));
     n := -1;
     for each x in u do
       if n<cdr x then <<n:=cdr x; x1 := car x>>;
     if n<2 then return list f;
     vars := x1 . delete(x1,vars);
     kord := setkorder vars;
     f := reorder f;
       % Convert f to a strongly monic polynomial.
     n := decomposetdg f;
     x1 := car vars;
     lvars := for each x in cdr vars collect (x . decomposegensym());
    again:
     if m>10 then << rt := list f; goto ret>>;
       % construct transformation sigma
     sigma := for each x in lvars collect x . random 1000;
     ft := numr subf(f,for each x in sigma collect
           (caar x . list('plus,cdar x,list('times,x1,cdr x))));
     if not domainp lc ft then <<m:=m+1; goto again>>;
     a0 := lc ft; ft := quotf(ft,a0);
     rt := decomposesfmnorm(ft,n,sublis(lvars,vars));
     if cdr rt then
      % Transform result back.
     <<rt := reverse rt;
       rt := numr subf(car rt,for each x in sigma collect
           (cdar x . list('difference,caar x,list('times,cdr x,x1))))
           . multf(a0,cadr rt) . cddr rt;
     >> else rt := list f;
   ret:
     setkorder kord;
     rt := for each p in rt collect reorder p;
        % try further decomposition of central polynomial.
     return if cdr rt and decomposetdg car rt>1 then
         append(reverse cdr rt,decomposesfmulti1(car rt,vars))
           else reverse rt;
   end;
+++ decomposesfmulti1 compiled, 526 + 84 bytes
decomposesfmulti1

symbolic procedure decomposelmon f;
   % Extract the variables of the leading monomial.
     if domainp f then nil else
     mvar f . decomposelmon lc f;
+++ decomposelmon compiled, 19 + 12 bytes
decomposelmon

symbolic procedure decomposenormfac p1;
  if null dmode!* or not flagp(dmode!*,'field) then
     multf(numr mkabsfd decomposecont p1,decomposesign p1)
    else <<while not domainp p1 do p1:=lc p1; p1>>;
+++ decomposenormfac compiled, 31 + 28 bytes
decomposenormfac

symbolic procedure decomposecont f;
   % Calculate the content of f if the domain is a ring.
      if domainp f then f else
      gcdf(decomposecont lc f, decomposecont red f);
+++ decomposecont compiled, 29 + 12 bytes
decomposecont

symbolic procedure decomposesign f;
   % Compute a unit factor c such that the leading coefficient of
   % f/c is a positive integer.
   if domainp f then numr quotsq(f ./ 1,mkabsfd f)
        else decomposesign lc f;
+++ decomposesign compiled, 21 + 20 bytes
decomposesign

symbolic procedure decomposesfmnorm(f,n,vars);
   % Multivariate case: map strongly monic polynomial to univariate
   % and lift result.
   begin scalar x,x1,f0,g,u,abort,h,k,tt,q,v;
      integer r,s;
     x1 := car vars;
    % Step 1.
     f0 := numr subf(f,for each y in cdr vars collect (y . 0));
     u := decomposesfuni f0;
        % For multivariate we accept degree=1 polynomials as nontrivial
        % but inhibit recursion.
     if null cdr u then <<u:=append(u,list !*k2f x1)>>;
     x := decomposegensym();
     g := numr subf(car u,list (x1 . x));
     r := ldeg g;
     h := cadr u; u := cddr u;
     while u do
     <<v := car u; u:= cdr u; h := numr subf(h,list(x1 . x));
       h := compose(h,v); >>;
      % Step 2.
     s := divide(n,r);
     if not(cdr s=0) then goto fail else s := car s;
     k := h;
     tt := compose(decomposedf(g,x),h);
      % Step 3: Hensel lifting in degree steps.
     for i:=1:s do
       if not abort then
        % Step 4: loop step.
       <<u := decomposehomog(addf(f,negf compose(g,k)),x1,i);
         q := quotf(u,tt);
         if u and null q then abort:=t else<<h:=q; k:=addf(k,h)>>
       >>;
      if abort then goto fail;
      % Step 5: test result and loop for lower part.
      h := k;
      if f = compose(g,h) then return list(g,h);
  fail:  % Exit: no decomposition found.
     return list f;
   end;
+++ decomposesfmnorm compiled, 234 + 60 bytes
decomposesfmnorm

symbolic procedure decomposehomog(f,x,d);
   % F is a polynomial (standard form) in x and some other
   % variables. Select that part of f, where the coefficients
   % of x are monomials in total degree d.
   % Result is the sum (standard form) of these monomials.
   begin scalar u,v;
      u := decomposehomog1(f,x,d);
      for each m in u do v := addf(v,m);
      return v;
  end;
+++ decomposehomog compiled, 26 + 16 bytes
decomposehomog

symbolic procedure decomposehomog1(f,x,d);
   % Select the monomials.
   if d<0 or null f then nil else
   if domainp f then (if d=0 then list f else nil)
   else begin scalar u1,u2;
     u1:= decomposehomog1(lc f,x,if mvar f = x then d
                                  else d-ldeg f);
     u2:= decomposehomog1(red f,x,d);
     return
        nconc(
         for each v in u1 collect
              multf(mvar f .** ldeg f .*1 .+ nil , v),
           u2);
  end;
+++ decomposehomog1 compiled, 107 + 24 bytes
decomposehomog1

symbolic procedure decomposegensym();
   compress(append('(!! !D !! !c !! !.),
            explode2(decomposegensym!*:=decomposegensym!*+1)));
+++ decomposegensym compiled, 13 + 16 bytes
decomposegensym

endmodule;nil

end;nilmodule interpol;nil % polynomial interpolation (Aitken & Neville).

% Author: Herbert Melenk <melenk@sc.zib-berlin.de>.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


symbolic procedure interpol(fc,x,pts);
   % find a polynomial f(x) such that holds:
   %   f(part(pts,i)) = part(fc,i)  for all i <= lenth pts.
   % The Aitken-Neville schema is used; it is stable for
   % symbolic and numeric values.
 begin scalar d,q,s,p1,p2,x1,x2,f1,f2,fnew;
    if not eqcar(fc,'list) or not eqcar(pts,'list)
       or not(length fc=length pts)
      then rerror(poly,19,"Illegal parameters for interpol");
   s:=for each p in pair(cdr fc,cdr pts) collect
       simp car p . simp cdr p . simp cdr p;
   x:= simp x;
       % outer loop as long as there is more than 1 element.
   while cdr s do
   <<q:= nil;
       % inner loop for all adjacent pairs of polynomials.
     while cdr s do
     <<p1:=car s; s:=cdr s; p2:=car s;
       f1:=car p1; f2:=car p2; x1:=cadr p1; x2:=cddr p2;
       d:=subtrsq(x1,x2);
       if null numr d then rerror(poly,20,
         "Interpolation impossible if two points are equal");
       fnew:=
         quotsq(
          subtrsq(multsq(subtrsq(x,x2),f1),
                  multsq(subtrsq(x,x1),f2)),
          d);
       q:=(fnew.x1.x2).q;
     >>;
      s:=reversip q;
   >>;
   return prepsq caar s;
 end;
+++ interpol compiled, 193 + 64 bytes
interpol

% We can't do following for bootstrapping reasons.

% symbolic operator interpol;

flag('(interpol),'opfn);nil

endmodule;nil

end;nilmodule subs2q;nil  % Routines for substituting for powers.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 The RAND Corporation. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*exp !*mcd !*structure !*sub2 alglist!* dmode!* frlis!*);nil

fluid '(powlis!* powlis1!*);nil

global '(!*resubs simpcount!* simplimit!*);nil

COMMENT If STRUCTURE is ON, then expressions like (a**(b/2))**2 are not
simplified, to allow some attempt at a structure theorem use, especially
in the integrator;

symbolic procedure subs2q u;
   % Perform power substitutions on u. Check whether substitions
   % on numerator and denominator change these before doing
   % quotient (to avoid undoing rationalization of denominator).
   ((if denr x=1 and denr y=1
        then if  numr x=v and numr y=w then u
              else quotsq(x,y)
   % If the substitution in the numerator or the denominator of u
   % yields non trivial denominators in the quotients x or y then
   % another pass through subs2q after forming the quotient is 
   % necessary as it might contain new potential matchable powers.  
      else subs2q quotsq(x,y))
     where x=subs2f v, y=subs2f w)
    where v=numr u, w=denr u;
+++ subs2q redefined
+++ subs2q compiled, 33 + 20 bytes
subs2q

symbolic procedure subs2f u;
   begin scalar x;
        if simpcount!*>simplimit!*
         then <<simpcount!* := 0;
                rerror(poly,21,"Simplification recursion too deep")>>;
        simpcount!* := simpcount!*+1;
        !*sub2 := nil;
        x := subs2f1 u;
        if (!*sub2 or powlis1!*) and !*resubs
           then if numr x=u and denr x=1 then !*sub2 := nil
                else x := subs2q x;
        simpcount!* := simpcount!*-1;
        return x
   end;
+++ subs2f redefined
+++ subs2f compiled, 57 + 60 bytes
subs2f

symbolic procedure subs2f1 u;
   if domainp u then !*d2q u
    else begin scalar kern,v,w,x,y,z,stack;
    s:  v := w := x := y := nil;
        kern := mvar u;
        z := nil ./ 1;
    a:  if null u or degr(u,kern)=0 then go to a1;
        y := lt u .+ y;
        u := red u;
        go to a;
    a1: x := powlis!*;
    a2: if null x then go to b
         else if caaar y = caar x
          then <<w := subs2p(caar y,cadar x,cadddr car x); go to e1>>
%        else if eqcar(kern,'sqrt) and cadr kern = caar x
%         then <<w := raddsq(subs2p(cadr kern . cdaar y,
%                            cadar x,cadddr car x),2);% go to e1>>;
         else if eqcar(kern,'expt)
                and cadr kern = caar x
                and eqcar(caddr kern,'quotient)
                and cadr caddr kern = 1
                and numberp caddr caddr kern
          then <<v := divide(cdaar y,caddr caddr kern);
%       if car v neq 0 then w := mksq(cadr kern,car v)
        % Use simp/exptsq to make sure I converted in complex mode.
        if car v neq 0 then w := exptsq(simp cadr kern,car v)
                  else w := 1 ./ 1;
                 if cdr v neq 0
                   then <<begin scalar alglist!*,dmode!*;
                          % We must do exponent arithmetic in integer
                          % mode.
                             v := cancel(cdr v.caddr caddr kern)
                          end;
                         w := multsq(raddsq(subs2p(cadr kern . car v,
                                        cadar x,cadddr car x),
                                cdr v),w)>>;
                 go to e1>>;
        x := cdr x;
        go to a2;
    b:  x := powlis1!*;
    l2: if null x then go to l3
         else if w:= mtchp(caar y,caar x,caddar x,caadar x,cdadar x)
          then go to e1;
        x := cdr x;
        go to l2;
    l3: if eqcar(kern,'expt) and not !*structure then go to l1;
        z := addsq(multpq(caar y,subs2f1 cdar y),z);
    c:  y := cdr y;
        if y then go to a1;
    d:  if domainp u then <<
          y := !*d2q u;
          go to x >>;
        stack := z . stack;
        go to s;
    x:  % mkprod checks structure in "constant" term.
        if null !*exp then y := mkprod numr y ./ mkprod denr y;
        y := addsq(z,y);
        if stack then <<
          z := car stack;
          stack := cdr stack;
          go to x >>; 
        return y;
    e1: z := addsq(multsq(w,subs2f1 cdar y),z);
        go to c;
    l1: if cdaar y=1 and not eqcar(cadr kern,'expt)     % ONEP
          then w := mksq(kern,1)
         else w := simpexpt list(cadr kern,
                                 list('times,caddr kern,cdaar y));
        z := addsq(multsq(w,subs2f1 cdar y),z);
        y := cdr y;
        if y then go to l1 else go to d;
    end;
+++ subs2f1 redefined
+++ subs2f1 compiled, 341 + 108 bytes
subs2f1

symbolic procedure subs2p(u,v,w);
   % U is a power, V an integer, and W an algebraic expression, such
   % that CAR U**V=W. Value is standard quotient for U with this
   % substitution.
   begin
      if not fixp cdr u or car(v := divide(cdr u,v))=0
        then return !*p2q u;
      w := exptsq(simp w,car v);
      return if cdr v=0 then w else multpq(car u .** cdr v,w)
   end;
+++ subs2p redefined
+++ subs2p compiled, 40 + 32 bytes
subs2p

symbolic procedure raddsq(u,n);
   %U is a standard quotient, N and integer. Value is sq for U**(1/N);
   simpexpt list(mk!*sq u,list('quotient,1,n));
+++ raddsq compiled, 14 + 24 bytes
raddsq

symbolic procedure mtchp(u,v,w,flg,bool);
   %U is a standard power, V a power to be matched against.
   %W is the replacement expression.
   %FLG is a flag which is T if an exact power match required.
   %BOOL is a boolean expression to be satisfied for substitution.
   %Value is the substitution standard quotient if a match found,
   %NIL otherwise;
   begin scalar x;
        x := mtchp1(u,v,flg,bool);
    a:  if null x then return nil
         else if lispeval subla(car x,bool) then go to b;
        x := cdr x;
        go to a;
    b:  v := divide(cdr u,subla(car x,cdr v));
        w := exptsq(simp subla(car x,w),car v);
        if cdr v neq 0 then w := multpq(car u .** cdr v,w);
        return w
   end;
+++ mtchp redefined
+++ mtchp compiled, 66 + 40 bytes
mtchp

symbolic procedure mtchp1(u,v,flg,bool);
   %U is a standard power, V a power to be matched against.
   %FLG is a flag which is T if an exact power match required.
   %BOOL is a boolean expression to be satisfied for substitution.
   %Value is a list of possible free variable pairings which
   %match conditions;
   begin scalar x;
        if u=v then return list nil
         else if not (x:= mchk!*(car u,car v)) then return nil
         else if cdr v memq frlis!*
             % do not match a free power to 1 or a conflicting match.
          then if cdr u=1 or not(x:= powmtch(cdr v,x,cdr u))
                 then return nil
                else return mapcons(x,cdr v . cdr u)
         else if (flg and not(cdr u=cdr v))
                or not numberp cdr v or not numberp cdr u
                or (if !*mcd then cdr u<cdr v
                     else (cdr u*cdr v)<0 or
                        %implements explicit sign matching;
                            abs cdr u<abs cdr v)
          then return nil
         else return x
   end;
+++ mtchp1 redefined
+++ mtchp1 compiled, 84 + 32 bytes
mtchp1

symbolic procedure powmtch(u,v,w);
   % Match a free power u against list of pairings v for value w.
   % Note from ACH:  I have not yet found a case where this process
   % results in a match, even if a non-NIL value is returned.  An
   % example with this procedure being necessary would be appreciated.
   if null v then nil
    else (if null x or cdr x=w then car v . powmtch(u,cdr v,w)
           else powmtch(u,cdr v,w))
        where x=atsoc(u,car v);
+++ powmtch compiled, 32 + 8 bytes
powmtch

symbolic procedure mchk!*(u,v);
   begin scalar x;
      if x := mchk(u,v) then return x
       else if !*mcd or not (sfp u and sfp v) then return nil
       else return mchk(prepf u,prepf v)
   end;
+++ mchk!* redefined
+++ mchk!* compiled, 26 + 24 bytes
mchk*

endmodule;nil

end;nilmodule subs3q;nil % Routines for matching products.

% Author: Anthony C. Hearn.

% Copyright (c) 1992 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*mcd powlis1!* !*sub2 subfg!*);nil

global '(!*match !*resubs mchfg!*);nil

symbolic procedure subs3q u;
   %U is a standard quotient.
   %Value is a standard quotient with all product substitutions made;
   begin scalar x;
        x := mchfg!*;   %save value in case we are in inner loop;
        mchfg!* := nil;
        u := quotsq(subs3f numr u,subs3f denr u);
        mchfg!* := x;
        return u
   end;
+++ subs3q redefined
+++ subs3q compiled, 17 + 20 bytes
subs3q

symbolic procedure subs3f u;
   %U is a standard form.
   %Value is a standard quotient with all product substitutions made;
   subs3f1(u,!*match,t);
+++ subs3f redefined
+++ subs3f compiled, 6 + 20 bytes
subs3f

symbolic procedure subs3f1(u,l,bool);
   %U is a standard form.
   %L is a list of possible matches.
   %BOOL is a boolean variable which is true if we are at top level.
   %Value is a standard quotient with all product substitutions made;
   begin scalar x,z;
        z := nil ./ 1;
    a:  if null u then return z
         else if domainp u then return addsq(z,u ./ 1)
         else if bool and domainp lc u then go to c;
        x := subs3t(lt u,l);
        if not bool                             %not top level;
         or not mchfg!* then go to b;           %no replacement made;
        mchfg!* := nil;
        if numr x = u and denr x = 1 then <<x := u ./ 1; go to b>>
         % also shows no replacement made (sometimes true with non
         % commuting expressions)
         else if null !*resubs then go to b
         else if !*sub2 or powlis1!* then x := subs2q x;
           %make another pass;
        x := subs3q x;
    b:  z := addsq(z,x);
        u := cdr u;
        go to a;
    c:  x := list lt u ./ 1;
        go to b
   end;
+++ subs3f1 redefined
+++ subs3f1 compiled, 91 + 44 bytes
subs3f1

symbolic procedure subs3t(u,v);
   % U is a standard term, V a list of matching templates.
   % Value is a standard quotient for the substituted term.
   begin scalar bool,w,x,y,z;
        x := mtchk(car u,if domainp cdr u then sizchk(v,1) else v);
        if null x then go to a                  %lpow doesn't match;
         else if null caar x then go to b;      %complete match found;
        y := subs3f1(cdr u,x,nil);              %check tc for match;
        if mchfg!* then return multpq(car u,y);
    a:  return list u . 1;                      %no match;
    b:  x := cddar x;           %list(<subst value>,<denoms>);
        z := caadr x;           %leading denom;
        mchfg!* := nil;         %initialize for tc check;
        y := subs3f1(cdr u,!*match,nil);
        mchfg!* := t;
        if car z neq caar u then go to e
         else if z neq car u    %powers don't match;
          then y := multpq(caar u .** (cdar u-cdr z),y);
    b1: y := multsq(simpcar x,y);
        x := cdadr x;
        if null x then return y;
        z := 1;                 %unwind remaining denoms;
    c:  if null x then go to d;
        w:= if atom caar x or sfp caar x then caar x else
             ((lambda ww;
                if kernp ww and eqcar(ww := mvar numr ww,car caar x)
                  then ww
                 else revop1 caar x)
               (simp caar x) where subfg!* = nil);
        % In the non-commutative case we have to be very careful about
        % order of terms in a product. Introducing negative powers
        % solves this problem.
        if noncomp w or not !*mcd then bool := t;
%       z := multpf(mksp(w,if null bool then cdar x else -cdar x),z);
%       original line
        z := multf(z,!*p2f mksp(w,
                                if null bool then cdar x else -cdar x));
        % kernel CAAR X is not unique here. Earlier versions used just
        % CAAR X, but this leads to sums of terms in the wrong order.
        % The code here is probably still not correct in all cases, and
        % may lead to unbounded calculations. Maybe SIMP should be used
        % instead of REVOP1, with appropriate adjustments in the code
        % to construct Z.
        x := cdr x;
        go to c;
    d:  return if not bool then car y . multf(z,cdr y)
                else multf(z,car y) . cdr y;
    e:  if simp car z neq simp caar u then errach list('subs3t,u,x,z);
        %maybe arguments were in different order, otherwise it's fatal;
        if cdr z neq cdar u
          then y:= multpq(caar u .** (cdar u-cdr z),y);
        go to b1
   end;
+++ subs3t redefined
+++ subs3t compiled, 274 + 100 bytes
subs3t

symbolic procedure sizchk(u,n);
   if null u then nil
    else if length caar u>n then sizchk(cdr u,n)
    else car u . sizchk(cdr u,n);
+++ sizchk redefined
+++ sizchk compiled, 24 + 12 bytes
sizchk

symbolic procedure mtchk(u,v);
   %U is a standard power, V a list of matching templates.
   %If a match is made, value is of the form:
   %list list(NIL,<boolean form>,<subst value>,<denoms>),
   %otherwise value is an updated list of templates;
   begin scalar flg,v1,w,x,y,z, lastpairz;
        flg := noncomp car u;
    a0: if null v then return z;
        v1 := car v;
        w := car v1;
    a:  if null w then go to d;
        x := mtchp1(u,car w,caadr v1,cdadr v1);
    b:  if null x then go to c
         else if car (y := subla(car x,delete(car w,car v1))
                                . list(subla(car x,cadr v1),
                                      subla(car x,caddr v1),
                                      subla(car x,car w)
                                          . cadddr v1))
          then << z := y . z;
                  if null lastpairz then lastpairz := z >>
         else if lispeval subla(car x,cdadr v1) then return list y;
        x := cdr x;
        go to b;
    c:  if null flg then <<w := cdr w; go to a>>
         else if cadddr v1 and nocp w then go to e;
    d:  % z :=aconc(z,v1);   % Could also be append(z,list v1).
% The above use of nconc tended to be painful when list of matching
% templates was long, so I now track the end of the list and tack items
% on without any need to scan what is already there.
        if null z then z := lastpairz := list v1
        else << rplacd(lastpairz, list v1);
                lastpairz := cdr lastpairz >>;
    e:  v := cdr v;
        go to a0
   end;
+++ mtchk redefined
+++ mtchk compiled, 138 + 24 bytes
mtchk

symbolic procedure nocp u;
   null u or (noncomp caar u and nocp cdr u);
+++ nocp redefined
+++ nocp compiled, 12 + 16 bytes
nocp

endmodule;nil

end;nilmodule subs4q;nil % Routines for matching quotients.

% Author: Anthony C. Hearn.
%         modification to more general quotient matching: Herbert Melenk

% Copyright (c) 1992 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


symbolic procedure subs4q u;
   % U is a standard quotient,
   % Value is a standard quotient with all quotient substitutions made.
   begin scalar x,w,q,d;
      if null(x:=get('slash,'opmtch)) then return u;
      w := prepsq u;
      remprop('slash,'opmtch); % to prevent endless recursion.
      put('slash!*,'opmtch,x);
      while w and eqcar(q:=w,'quotient) do
          <<w:=opmtch ('slash!* . cdr w) or
               smemq('minus,caddr w) and
                  opmtch{'slash!*,reval{'minus,cadr w},
                                  reval{'minus,caddr w}};
            d:=d or w>>;
      u:= if d then simp!* q else u;
      put('slash,'opmtch,x);
      return u;
   end;
+++ subs4q redefined
+++ subs4q compiled, 86 + 44 bytes
subs4q

endmodule;nil

end;nilmodule horner;nil % Convert an expression into a nested Horner product.

% Author: Herbert Melenk.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*exp !*div);nil

symbolic procedure hornersq u;
  if !*div and null dmode!* and numberp denr u and denr u neq 1 then
   <<setdmode('rational,t);
     u:=hornerf quotf(numr u, denr u);
     setdmode('rational,nil);
     u ./ 1>>
   else hornerf numr u . hornerf denr u;
+++ hornersq compiled, 40 + 40 bytes
hornersq

symbolic procedure hornerf u;
  <<u:=expnd u where !*exp=t; hornerf1 u where !*exp=nil>>;
+++ hornerf compiled, 21 + 28 bytes
hornerf

symbolic procedure hornerf1 u;
  begin scalar x,a,b,c; integer n,m;
   if domainp u then return u;
   if domainp red u then goto q;

      % Identify the pattern
      %      x^n*a + x^m*b + c with n>m
      % and transform it into
      %      x^m(x^(n-m)*a + b) + c
      % calling hornerf1 again for folding x^m with powers of
      % x in c. Also a and b are folded recursively.
      % The term x^n*a may have the form (x^k*f+g)*x^n*h
      % by recursion; in that case a is (x^k*f+g)*h.

   if (x:=mvar u) = mvar red u then
   << n:=ldeg u; a:=hornerf1 lc u; u:=red u; m:=ldeg u;
      b:=hornerf1 lc u; c:=red u >>
   else if sfp mvar u and not domainp lc u and (x:=mvar lc u)=mvar red u
     and (n:=ldeg lc u)>(m:=ldeg red u) then
   << a:=multf(mvar u,lc lc u); u:=red u; b:=hornerf1 lc u; c:=red u >>
   else goto q;
   return hornerf1
       addf(multf(exptf(!*k2f x,m),
                  addf(multf(exptf(!*k2f x,n-m),a),
                       b)), c);
q: return addf(multf(!*p2f lpow u,hornerf1 lc u),hornerf1 red u);
   end;
+++ hornerf1 compiled, 166 + 36 bytes
hornerf1

put('horner,'polyfn,'hornerf);hornerf

endmodule;nil

end;nilmodule heugcd;nil

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


%Authors: James Davenport & Julian Padget

% For full details of the algorithms see first Char et al. from the
% Proceedings of EUROSAM 84 (Springer LNCS #174), then Davenport and
% Padget in the Proceedings of EUROCAL 85 (Springer LNCS #204) and
% Davenport and Padget in the proceedings of Calcul Formel (Homage a
% Noel Gastinel) published by Masson-Wiley (France).

%exports heu!-gcd, heu!-gcd!-list;

%imports to be determined

%internal-functions
%       univariatep, univariatep1, htc, kontent, kontent1,
%       horner!-eval!-rat, horner!-eval!-rat!-and!-gcdl,
%       horner!-eval!-rat!-and!-gcdl1, heu!-quotfl, heu!-quotfl1,
%       heu!-quotf, xceiling, next!-even!-value, next!-odd!-value,
%       heu!-gcdl, analyse!-polynomials, negshiftz, gen!-poly,
%       gen!-poly!-forward, gen!-poly!-backward, gcdlist2, gcdf2

% create!-package('(heugcd),nil);

fluid '(!*heugcd reduction!-count);nil

global '(!!ee);nil


% ****************** Various polynomial utilities **********************

% The following two procedures are defined differently in primfac.red.
% Those below overwrite the latter now that this file has been moved
% into poly and added to the end of the poly create!-package list.
% Those below break roots.tst and groebner.tst, so I have commented
% them out for now, which fixes roots and groebner (but might break
% heugcd!).  FJW, 26/06/2019.

% symbolic inline procedure univariatep p; univariatep1(p,mvar p);

% symbolic procedure univariatep1(p,v);
% % checks that p is univariate in v;
%    if atom p then t
%    else if mvar p neq v then nil
%    else if atom lc p then univariatep1(red p,v)
%    else nil;

symbolic procedure htc p;
   if atom p then p
   else if null red p then lc p
   else htc red p;
+++ htc compiled, 13 + 8 bytes
htc

symbolic procedure kontent p;
% extract integer content of polynomial p
   if domainp p then
           if numberp p then p
      else if null p then 1
      else rederr "HEUGCD(kontent): unsupported domain element"
   else if domainp red p then
           if numberp red p then gcdn(lc p,red p)
      else if null red p then lc p
      else rederr "HEUGCD(kontent): unsupported domain element"
  else kontent1(red red p,gcdn(lc p,lc red p));
+++ kontent compiled, 61 + 24 bytes
kontent

symbolic procedure kontent1(p,a);
   if a=1 then 1
   else if domainp p then
      if numberp p then gcdn(p,a)
      else if null p then a
      else rederr "HEUGCD(kontent1): unsupported domain element"
   else kontent1(red p,gcdn(remainder(lc p,a),a));
+++ kontent1 compiled, 40 + 20 bytes
kontent1

symbolic procedure horner!-eval!-rat(p,v);
% evaluate the (sparse univariate) polynomial p at a rational v using
% Horner's scheme.  Denominators are cleared by in fact calculating the
% following:
%
%    for i:=min:max sum (a[i] * n**(i-min) * d**(max-min-i))
%
% note that if the polynomial does not end in a non-zero constant
% the routine it return the evaluation of p/(trailing exponent)
%        s accumulates d**(max-min-i)
%        ans accumulates the sum
%        m is degree difference between current and previous term
% See specific routines below for further detail
   if (numr v)=1 then horner!-eval!-integer(p,denr v,1,0)
   else if (denr v)=1 then horner!-eval!-reciprocal(p,numr v,0,0)
   else horner!-eval!-rational(p,numr v,denr v,0,1,0);
+++ horner!-eval!-rat compiled, 49 + 28 bytes
horner-eval-rat

symbolic procedure horner!-eval!-rational(p,n,d,m,s,ans);
% general case of an arbitrary rational
   if domainp p then
      if p then ans*n**m+s*p else ans
   else (lambda mp;
           horner!-eval!-rational(red p,n,d,mp,s*d**mp,ans*n**m+s*lc p))
         (ldeg p)-(if domainp red p then 0 else ldeg red p);
+++ horner!-eval!-rational compiled, 92 + 12 bytes
horner-eval-rational

symbolic procedure horner!-eval!-integer(p,d,s,ans);
% simple sub case of an integer (n/1)
   if domainp p then
      if p then ans+s*p else ans
   else horner!-eval!-integer(red p,d,
           s*d**((ldeg p)-(if domainp red p then 0 else ldeg red p)),
           ans+s*lc p);
+++ horner!-eval!-integer compiled, 69 + 12 bytes
horner-eval-integer

symbolic procedure horner!-eval!-reciprocal(p,n,m,ans);
% simpler sub case of a straight reciprocal of an integer (1/n)
   if domainp p then
      if p then ans*n**m+p else ans
   else horner!-eval!-reciprocal(red p,n,
           (ldeg p)-(if domainp red p then 0 else ldeg red p),
           ans*n**m+lc p);
+++ horner!-eval!-reciprocal compiled, 66 + 12 bytes
horner-eval-reciprocal

symbolic procedure horner!-eval!-rat!-and!-gcdl(l,v);
% l is a list of polynomials to be evaluated at the point v
% and then take the GCD of these evaluations.  We use an auxiliary
% routine with an accumulator variable to make the computation
% tail-recursive
   if null cdr l then horner!-eval!-rat(car l,v)
   else if null cddr l then
      gcdn(horner!-eval!-rat(car l,v),horner!-eval!-rat(cadr l,v))
   else horner!-eval!-rat!-and!-gcdl1(cddr l,v,
          gcdn(horner!-eval!-rat(car l,v),horner!-eval!-rat(cadr l,v)));
+++ horner!-eval!-rat!-and!-gcdl compiled, 46 + 16 bytes
horner-eval-rat-and-gcdl

symbolic procedure horner!-eval!-rat!-and!-gcdl1(l,v,a);
   if a=1 then 1
   else if null l then a
   else horner!-eval!-rat!-and!-gcdl1(cdr l,v,
           gcdn(horner!-eval!-rat(car l,v),a));
+++ horner!-eval!-rat!-and!-gcdl1 compiled, 22 + 16 bytes
horner-eval-rat-and-gcdl1

%*********** Polynomial division utilities and extensions *************

symbolic procedure heu!-quotfl(l,d);
% test division of each of a list of SF's (l) by the SF d
   if null cdr l then heu!-quotf(car l,d)
   else heu!-quotfl1(cdr l,d,heu!-quotf(car l,d));
+++ heu!-quotfl compiled, 20 + 16 bytes
heu-quotfl

symbolic procedure heu!-quotfl1(l,d,flag);
   if null flag then nil
   else if null cdr l then heu!-quotf(car l,d)
   else heu!-quotfl1(cdr l,d,heu!-quotf(car l,d));
+++ heu!-quotfl1 compiled, 21 + 12 bytes
heu-quotfl1

symbolic procedure heu!-quotf(p,q);
   if domainp q then
      if domainp p then
         if null p then nil
         else if null q then
            rederr "HEUGCD(heu-quotf): division by zero"
         else (lambda temp; if cdr temp=0 then car temp else nil)
               divide(p,q)
      else quotf(p,q)
   else if domainp p then nil
   else if ldeg p<ldeg q then nil
   else if (cdr divide(lc p,lc q)) neq 0 then nil
   else if p=q then 1
   else (lambda qv;
           if qv=0 then quotf(p,q)
           else if remainder(horner!-eval!-rat(p,'(2 . 1)),qv)=0 then
              quotf(p,q)
           else nil)
         horner!-eval!-rat(q,'(2 . 1));
+++ heu!-quotf compiled, 90 + 36 bytes
heu-quotf

%****************** Z-adic polynomial GCD routines ********************

symbolic inline procedure xceiling(n,d); (n+d-1)/d;
+++ Record new inline definition:
(de xceiling (n d) (quotient (plus n (difference d 1)) d))
(progn (de xceiling (n d) (quotient (plus n (difference d 1)) d)) (put (quote
xceiling) (quote number!-of!-args) 2) (put (quote xceiling) (quote
procedure_type) (quote (arrow (times general general) general))) (putc (quote
xceiling) (quote inline) (quote (lambda (n d) (quotient (plus n (difference d 1)
) d)))))
+++ xceiling compiled, 10 + 8 bytes
(lambda (n d) (quotient (plus n (difference d 1)) d))

symbolic inline procedure force!-even x;
   if evenp x then x else x+1;
+++ Record new inline definition:
(de force!-even (x) (cond ((evenp x) x) (t (plus x 1))))
(progn (de force!-even (x) (cond ((evenp x) x) (t (plus x 1)))) (put (quote
force!-even) (quote number!-of!-args) 1) (put (quote force!-even) (quote
procedure_type) (quote (arrow general general))) (putc (quote force!-even) (
quote inline) (quote (lambda (x) (cond ((evenp x) x) (t (plus x 1)))))))
+++ force!-even compiled, 8 + 8 bytes
(lambda (x) (cond ((evenp x) x) (t (plus x 1))))

symbolic inline procedure force!-odd x;
   if evenp x then x+1 else x;
+++ Record new inline definition:
(de force!-odd (x) (cond ((evenp x) (plus x 1)) (t x)))
(progn (de force!-odd (x) (cond ((evenp x) (plus x 1)) (t x))) (put (quote
force!-odd) (quote number!-of!-args) 1) (put (quote force!-odd) (quote
procedure_type) (quote (arrow general general))) (putc (quote force!-odd) (quote
inline) (quote (lambda (x) (cond ((evenp x) (plus x 1)) (t x))))))
+++ force!-odd compiled, 8 + 8 bytes
(lambda (x) (cond ((evenp x) (plus x 1)) (t x)))

symbolic inline procedure next!-even!-value x;
   if (denr x)=1 then force!-even fix(numr x * !!ee) ./ 1
    else 1 ./ force!-even fix(denr x * !!ee);
+++ Record new inline definition:
(de next!-even!-value (x) (cond ((equal (cdr x) 1) (cons ((lambda (x) (cond ((
evenp x) x) (t (plus x 1)))) (fix (times (car x) !!ee))) 1)) (t (cons 1 ((lambda
(x) (cond ((evenp x) x) (t (plus x 1)))) (fix (times (cdr x) !!ee)))))))
(progn (de next!-even!-value (x) (cond ((equal (cdr x) 1) (cons ((lambda (x) (
cond ((evenp x) x) (t (plus x 1)))) (fix (times (car x) !!ee))) 1)) (t (cons 1 (
(lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (fix (times (cdr x) !!ee)))))))
(put (quote next!-even!-value) (quote number!-of!-args) 1) (put (quote
next!-even!-value) (quote procedure_type) (quote (arrow general general))) (putc
(quote next!-even!-value) (quote inline) (quote (lambda (x) (cond ((equal (cdr x
) 1) (cons ((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (fix (times (car x)
!!ee))) 1)) (t (cons 1 ((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (fix (
times (cdr x) !!ee))))))))))
+++ next!-even!-value compiled, 44 + 16 bytes
(lambda (x) (cond ((equal (cdr x) 1) (cons ((lambda (x) (cond ((evenp x) x) (t (
plus x 1)))) (fix (times (car x) !ee))) 1)) (t (cons 1 ((lambda (x) (cond ((
evenp x) x) (t (plus x 1)))) (fix (times (cdr x) !ee)))))))

symbolic inline procedure next!-odd!-value x;
   if (denr x)=1 then force!-odd fix(numr x * !!ee) ./ 1
    else 1 ./ force!-odd fix(denr x * !!ee);
+++ Record new inline definition:
(de next!-odd!-value (x) (cond ((equal (cdr x) 1) (cons ((lambda (x) (cond ((
evenp x) (plus x 1)) (t x))) (fix (times (car x) !!ee))) 1)) (t (cons 1 ((lambda
(x) (cond ((evenp x) (plus x 1)) (t x))) (fix (times (cdr x) !!ee)))))))
(progn (de next!-odd!-value (x) (cond ((equal (cdr x) 1) (cons ((lambda (x) (
cond ((evenp x) (plus x 1)) (t x))) (fix (times (car x) !!ee))) 1)) (t (cons 1 (
(lambda (x) (cond ((evenp x) (plus x 1)) (t x))) (fix (times (cdr x) !!ee)))))))
(put (quote next!-odd!-value) (quote number!-of!-args) 1) (put (quote
next!-odd!-value) (quote procedure_type) (quote (arrow general general))) (putc
(quote next!-odd!-value) (quote inline) (quote (lambda (x) (cond ((equal (cdr x)
1) (cons ((lambda (x) (cond ((evenp x) (plus x 1)) (t x))) (fix (times (car x)
!!ee))) 1)) (t (cons 1 ((lambda (x) (cond ((evenp x) (plus x 1)) (t x))) (fix (
times (cdr x) !!ee))))))))))
+++ next!-odd!-value compiled, 44 + 16 bytes
(lambda (x) (cond ((equal (cdr x) 1) (cons ((lambda (x) (cond ((evenp x) (plus x
1)) (t x))) (fix (times (car x) !ee))) 1)) (t (cons 1 ((lambda (x) (cond ((evenp
x) (plus x 1)) (t x))) (fix (times (cdr x) !ee)))))))

symbolic inline procedure first!-value(inp,inq,lcp,lcq,tcp,tcq);
   % Initial evaluation is based on Cauchy's inequality.
   if lcp<tcp then
      if lcq<tcq then
         if (inp*tcq)<(inq*tcp) then 1 . (2+2*xceiling(inp,tcp))
         else 1 . (2+2*xceiling(inq,tcq))
      else if (inp*lcq)<(inq*tcp) then 1 . (2+2*xceiling(inp,tcp))
         else (2+2*xceiling(inq,lcq)) . 1
   else if lcq<tcq then
         if (inp*tcq)<(inq*lcp) then (2+2*xceiling(inp,lcp)) . 1
         else 1 . (2+2*xceiling(inq,tcq))
      else if (inp*lcq)<(inq*lcp) then (2+2*xceiling(inp,lcp)) . 1
         else (2+2*xceiling(inq,lcq)) . 1;
+++ Record new inline definition:
(de first!-value (inp inq lcp lcq tcp tcq) (cond ((lessp lcp tcp) (cond ((lessp
lcq tcq) (cond ((lessp (times inp tcq) (times inq tcp)) (cons 1 (plus 2 (times 2
(quotient (plus inp (difference tcp 1)) tcp))))) (t (cons 1 (plus 2 (times 2 (
quotient (plus inq (difference tcq 1)) tcq))))))) ((lessp (times inp lcq) (times
inq tcp)) (cons 1 (plus 2 (times 2 (quotient (plus inp (difference tcp 1)) tcp))
))) (t (cons (plus 2 (times 2 (quotient (plus inq (difference lcq 1)) lcq))) 1))
)) ((lessp lcq tcq) (cond ((lessp (times inp tcq) (times inq lcp)) (cons (plus 2
(times 2 (quotient (plus inp (difference lcp 1)) lcp))) 1)) (t (cons 1 (plus 2 (
times 2 (quotient (plus inq (difference tcq 1)) tcq))))))) ((lessp (times inp
lcq) (times inq lcp)) (cons (plus 2 (times 2 (quotient (plus inp (difference lcp
1)) lcp))) 1)) (t (cons (plus 2 (times 2 (quotient (plus inq (difference lcq 1))
lcq))) 1))))
(progn (de first!-value (inp inq lcp lcq tcp tcq) (cond ((lessp lcp tcp) (cond (
(lessp lcq tcq) (cond ((lessp (times inp tcq) (times inq tcp)) (cons 1 (plus 2 (
times 2 (quotient (plus inp (difference tcp 1)) tcp))))) (t (cons 1 (plus 2 (
times 2 (quotient (plus inq (difference tcq 1)) tcq))))))) ((lessp (times inp
lcq) (times inq tcp)) (cons 1 (plus 2 (times 2 (quotient (plus inp (difference
tcp 1)) tcp))))) (t (cons (plus 2 (times 2 (quotient (plus inq (difference lcq 1
)) lcq))) 1)))) ((lessp lcq tcq) (cond ((lessp (times inp tcq) (times inq lcp))
(cons (plus 2 (times 2 (quotient (plus inp (difference lcp 1)) lcp))) 1)) (t (
cons 1 (plus 2 (times 2 (quotient (plus inq (difference tcq 1)) tcq))))))) ((
lessp (times inp lcq) (times inq lcp)) (cons (plus 2 (times 2 (quotient (plus
inp (difference lcp 1)) lcp))) 1)) (t (cons (plus 2 (times 2 (quotient (plus inq
(difference lcq 1)) lcq))) 1)))) (put (quote first!-value) (quote
number!-of!-args) 6) (put (quote first!-value) (quote procedure_type) (quote (
arrow (times general general general general general general) general))) (putc (
quote first!-value) (quote inline) (quote (lambda (inp inq lcp lcq tcp tcq) (
cond ((lessp lcp tcp) (cond ((lessp lcq tcq) (cond ((lessp (times inp tcq) (
times inq tcp)) (cons 1 (plus 2 (times 2 (quotient (plus inp (difference tcp 1))
tcp))))) (t (cons 1 (plus 2 (times 2 (quotient (plus inq (difference tcq 1)) tcq
))))))) ((lessp (times inp lcq) (times inq tcp)) (cons 1 (plus 2 (times 2 (
quotient (plus inp (difference tcp 1)) tcp))))) (t (cons (plus 2 (times 2 (
quotient (plus inq (difference lcq 1)) lcq))) 1)))) ((lessp lcq tcq) (cond ((
lessp (times inp tcq) (times inq lcp)) (cons (plus 2 (times 2 (quotient (plus
inp (difference lcp 1)) lcp))) 1)) (t (cons 1 (plus 2 (times 2 (quotient (plus
inq (difference tcq 1)) tcq))))))) ((lessp (times inp lcq) (times inq lcp)) (
cons (plus 2 (times 2 (quotient (plus inp (difference lcp 1)) lcp))) 1)) (t (
cons (plus 2 (times 2 (quotient (plus inq (difference lcq 1)) lcq))) 1)))))))
+++ first!-value compiled, 236 + 16 bytes
(lambda (inp inq lcp lcq tcp tcq) (cond ((lessp lcp tcp) (cond ((lessp lcq tcq)
(cond ((lessp (times inp tcq) (times inq tcp)) (cons 1 (plus 2 (times 2 (
quotient (plus inp (difference tcp 1)) tcp))))) (t (cons 1 (plus 2 (times 2 (
quotient (plus inq (difference tcq 1)) tcq))))))) ((lessp (times inp lcq) (times
inq tcp)) (cons 1 (plus 2 (times 2 (quotient (plus inp (difference tcp 1)) tcp))
))) (t (cons (plus 2 (times 2 (quotient (plus inq (difference lcq 1)) lcq))) 1))
)) ((lessp lcq tcq) (cond ((lessp (times inp tcq) (times inq lcp)) (cons (plus 2
(times 2 (quotient (plus inp (difference lcp 1)) lcp))) 1)) (t (cons 1 (plus 2 (
times 2 (quotient (plus inq (difference tcq 1)) tcq))))))) ((lessp (times inp
lcq) (times inq lcp)) (cons (plus 2 (times 2 (quotient (plus inp (difference lcp
1)) lcp))) 1)) (t (cons (plus 2 (times 2 (quotient (plus inq (difference lcq 1))
lcq))) 1))))

symbolic inline procedure
   second!-value(inp,inq,lcp,lcq,lgcd,tcp,tcq,tgcd);
   % The second evaluation point is from a modified Mignotte bound.
   (lambda (inp,inq,lcp,lcq,tcp,tcq);
      if lcp<tcp then
         if lcq<tcq then
            if (inp*tcq)<(inq*tcp) then
               1 . force!-even (2+xceiling(inp,tcp))
            else
               1 . force!-even (2+xceiling(inq,tcq))
         else if (inp*lcq)<(inq*tcp) then
                 1 . force!-even (2+xceiling(inp,tcp))
            else force!-even (2+xceiling(inq,lcq)) . 1
      else if lcq<tcq then
            if (inp*tcq)<(inq*lcp) then
               force!-even (2+xceiling(inp,lcp)) . 1
            else 1 . force!-even (2+xceiling(inq,tcq))
         else if (inp*lcq)<(inq*lcp) then
            force!-even (2+xceiling(inp,lcp)) . 1
         else force!-even (2+xceiling(inq,lcq)) . 1)
    (inp,inq,max(2,lcp/lgcd),max(2,lcq/lgcd),
             max(2,tcp/tgcd),max(2,tcq/tgcd));
+++ Record new inline definition:
(de second!-value (inp inq lcp lcq lgcd tcp tcq tgcd) ((lambda (inp inq lcp lcq
tcp tcq) (cond ((lessp lcp tcp) (cond ((lessp lcq tcq) (cond ((lessp (times inp
tcq) (times inq tcp)) (cons 1 ((lambda (x) (cond ((evenp x) x) (t (plus x 1))))
(plus 2 (quotient (plus inp (difference tcp 1)) tcp))))) (t (cons 1 ((lambda (x)
(cond ((evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus inq (difference tcq
1)) tcq))))))) ((lessp (times inp lcq) (times inq tcp)) (cons 1 ((lambda (x) (
cond ((evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus inp (difference tcp
1)) tcp))))) (t (cons ((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (plus 2
(quotient (plus inq (difference lcq 1)) lcq))) 1)))) ((lessp lcq tcq) (cond ((
lessp (times inp tcq) (times inq lcp)) (cons ((lambda (x) (cond ((evenp x) x) (t
(plus x 1)))) (plus 2 (quotient (plus inp (difference lcp 1)) lcp))) 1)) (t (
cons 1 ((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus
inq (difference tcq 1)) tcq))))))) ((lessp (times inp lcq) (times inq lcp)) (
cons ((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus
inp (difference lcp 1)) lcp))) 1)) (t (cons ((lambda (x) (cond ((evenp x) x) (t
(plus x 1)))) (plus 2 (quotient (plus inq (difference lcq 1)) lcq))) 1)))) inp
inq (max 2 (quotient lcp lgcd)) (max 2 (quotient lcq lgcd)) (max 2 (quotient tcp
tgcd)) (max 2 (quotient tcq tgcd))))
(progn (de second!-value (inp inq lcp lcq lgcd tcp tcq tgcd) ((lambda (inp inq
lcp lcq tcp tcq) (cond ((lessp lcp tcp) (cond ((lessp lcq tcq) (cond ((lessp (
times inp tcq) (times inq tcp)) (cons 1 ((lambda (x) (cond ((evenp x) x) (t (
plus x 1)))) (plus 2 (quotient (plus inp (difference tcp 1)) tcp))))) (t (cons 1
((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus inq (
difference tcq 1)) tcq))))))) ((lessp (times inp lcq) (times inq tcp)) (cons 1 (
(lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus inp (
difference tcp 1)) tcp))))) (t (cons ((lambda (x) (cond ((evenp x) x) (t (plus x
1)))) (plus 2 (quotient (plus inq (difference lcq 1)) lcq))) 1)))) ((lessp lcq
tcq) (cond ((lessp (times inp tcq) (times inq lcp)) (cons ((lambda (x) (cond ((
evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus inp (difference lcp 1)) lcp
))) 1)) (t (cons 1 ((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (plus 2 (
quotient (plus inq (difference tcq 1)) tcq))))))) ((lessp (times inp lcq) (times
inq lcp)) (cons ((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (plus 2 (
quotient (plus inp (difference lcp 1)) lcp))) 1)) (t (cons ((lambda (x) (cond ((
evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus inq (difference lcq 1)) lcq
))) 1)))) inp inq (max 2 (quotient lcp lgcd)) (max 2 (quotient lcq lgcd)) (max 2
(quotient tcp tgcd)) (max 2 (quotient tcq tgcd)))) (put (quote second!-value) (
quote number!-of!-args) 8) (put (quote second!-value) (quote procedure_type) (
quote (arrow (times general general general general general general general
general) general))) (putc (quote second!-value) (quote inline) (quote (lambda (
inp inq lcp lcq lgcd tcp tcq tgcd) ((lambda (inp inq lcp lcq tcp tcq) (cond ((
lessp lcp tcp) (cond ((lessp lcq tcq) (cond ((lessp (times inp tcq) (times inq
tcp)) (cons 1 ((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (plus 2 (
quotient (plus inp (difference tcp 1)) tcp))))) (t (cons 1 ((lambda (x) (cond ((
evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus inq (difference tcq 1)) tcq
))))))) ((lessp (times inp lcq) (times inq tcp)) (cons 1 ((lambda (x) (cond ((
evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus inp (difference tcp 1)) tcp
))))) (t (cons ((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (plus 2 (
quotient (plus inq (difference lcq 1)) lcq))) 1)))) ((lessp lcq tcq) (cond ((
lessp (times inp tcq) (times inq lcp)) (cons ((lambda (x) (cond ((evenp x) x) (t
(plus x 1)))) (plus 2 (quotient (plus inp (difference lcp 1)) lcp))) 1)) (t (
cons 1 ((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus
inq (difference tcq 1)) tcq))))))) ((lessp (times inp lcq) (times inq lcp)) (
cons ((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus
inp (difference lcp 1)) lcp))) 1)) (t (cons ((lambda (x) (cond ((evenp x) x) (t
(plus x 1)))) (plus 2 (quotient (plus inq (difference lcq 1)) lcq))) 1)))) inp
inq (max 2 (quotient lcp lgcd)) (max 2 (quotient lcq lgcd)) (max 2 (quotient tcp
tgcd)) (max 2 (quotient tcq tgcd)))))))
+++ second!-value compiled, 336 + 20 bytes
(lambda (inp inq lcp lcq lgcd tcp tcq tgcd) ((lambda (inp inq lcp lcq tcp tcq) (
cond ((lessp lcp tcp) (cond ((lessp lcq tcq) (cond ((lessp (times inp tcq) (
times inq tcp)) (cons 1 ((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (plus
2 (quotient (plus inp (difference tcp 1)) tcp))))) (t (cons 1 ((lambda (x) (cond
((evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus inq (difference tcq 1))
tcq))))))) ((lessp (times inp lcq) (times inq tcp)) (cons 1 ((lambda (x) (cond (
(evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus inp (difference tcp 1))
tcp))))) (t (cons ((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (plus 2 (
quotient (plus inq (difference lcq 1)) lcq))) 1)))) ((lessp lcq tcq) (cond ((
lessp (times inp tcq) (times inq lcp)) (cons ((lambda (x) (cond ((evenp x) x) (t
(plus x 1)))) (plus 2 (quotient (plus inp (difference lcp 1)) lcp))) 1)) (t (
cons 1 ((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus
inq (difference tcq 1)) tcq))))))) ((lessp (times inp lcq) (times inq lcp)) (
cons ((lambda (x) (cond ((evenp x) x) (t (plus x 1)))) (plus 2 (quotient (plus
inp (difference lcp 1)) lcp))) 1)) (t (cons ((lambda (x) (cond ((evenp x) x) (t
(plus x 1)))) (plus 2 (quotient (plus inq (difference lcq 1)) lcq))) 1)))) inp
inq (max 2 (quotient lcp lgcd)) (max 2 (quotient lcq lgcd)) (max 2 (quotient tcp
tgcd)) (max 2 (quotient tcq tgcd))))

symbolic procedure heu!-gcd!-list l;
   if null cdr l then car l
   else if null cddr l then heu!-gcd(car l,cadr l)
   else heu!-gcdl sort(l,function (lambda (p1,p2); ldeg p1<ldeg p2));
+++ lambda_o02u58l5praf3 compiled, 6 + 8 bytes
+++ heu!-gcd!-list compiled, 21 + 24 bytes
heu-gcd-list

symbolic procedure heu!-gcdl l;
% Heuristic univariate polynomial GCD after Davenport & Padgets'
% extensions of Geddes' algorithm (EUROSAM 84) for a list of polynomials
begin scalar k,value,dval,d,xsx,inp,inq,lcp,lcq,lgcd,tcp,tcq,tgcd,tmp;
      % check if first one is linear (input is sorted by leading degree)
   if (ldeg car l=1) then return
      (lambda pcarl; if heu!-quotfl(cdr l,pcarl) then pcarl else 1)
      quotf(car l,kontent car l);
      % general case - compute GCD of all of them at Cauchy's bound
   tmp:=analyse!-polynomial car l;
   if tmp then <<
      inp:=car tmp; lcp:=lc car l; xsx:=cadr tmp; tcp:=caddr tmp;
      tmp:=analyse!-polynomial cadr l;
      if tmp then <<
         inq:=car tmp; lcq:=lc cadr l;
         xsx:=min(xsx,cadr tmp); tcq:=caddr tmp>>
      else return nil>>
   else return nil;
   value:=first!-value(inp,inq,lcp,lcq,tcp,tcq);
      % first check for trivial GCD
   d:=gen!-poly(horner!-eval!-rat!-and!-gcdl(l,value),
                value,mvar car l,xsx);
   if heu!-quotfl(l,d) then return d;
      % since that failed we pick a much higher evaluation point
      % courtesy of a modified Mignotte inequality and just work on the
      % first two
   lgcd:=gcdn(lcp,lcq);
   for each x in cddr l do lgcd:=gcdn(lc x,lgcd);
   tgcd:=gcdn(tcp,tcq);
   for each x in cddr l do tgcd:=gcdn(htc x,tgcd);
   value:=second!-value(inp,inq,lcp,lcq,lgcd,tcp,tcq,tgcd);
loop:
   d:=gen!-poly(horner!-eval!-rat!-and!-gcdl(l,value),
                value,mvar car l,xsx);
   if heu!-quotfl(l,d) then return d;
   value:=next!-odd!-value value;
   k:=k+1;
   d:=gen!-poly(horner!-eval!-rat!-and!-gcdl(l,value),
                value,mvar car l,xsx);
   if heu!-quotfl(l,d) then return d;
   value:=next!-even!-value value;
   k:=k+1;
   if k < 10 then goto loop;
   print "(HEUGCD):heu-gcd-list fails";
   return nil
end;
+++ heu!-gcdl compiled, 968 + 64 bytes
heu-gcdl

symbolic procedure heu!-gcd(p,q);
% Heuristic univariate polynomial GCD after Davenport & Padgets'
% extensions of Geddes' algorithm (EUROSAM 84)
% the method of choosing the evaluation point is quite complex (but not
% as general as it ought to be).  It is
%
%    min(infinity!-norm p/lc p, infinity!-norm p/htc p,
%        infinity!-norm q/lc q, infinity!-norm q/htc q)
%
begin scalar k,value,d,dval,xsx,inp,inq,lcp,lcq,lgcd,tcp,tcq,tgcd,tmp;
      % check if one of p and q is linear
   if (ldeg q=1) or (ldeg p=1) then return
      if univariatep p and univariatep q then
         (lambda (pp,pq);
           if (ldeg pq)=1 then
              (lambda h; if null h then 1 else pq) heu!-quotf(pp,pq)
           else
              (lambda h; if null h then 1 else pp) heu!-quotf(pq,pp))
          (quotf(p, kontent p), quotf(q, kontent q))
      else nil;
      % general case
   if (ldeg p)>(ldeg q) then return heu!-gcd(q,p);
   tmp:=analyse!-polynomial p;
   if tmp then <<
      inp:=car tmp; lcp:=lc p; xsx:=cadr tmp; tcp:=caddr tmp;
      tmp:=analyse!-polynomial q;
      if tmp then <<
         inq:=car tmp; lcq:=lc q; xsx:=min(xsx,cadr tmp); tcq:=caddr tmp>>
      else return nil>>
   else return nil;
   value:=first!-value(inp,inq,lcp,lcq,tcp,tcq);
      % first check for trivial GCD
   dval:=gcdn(horner!-eval!-rat(p,value),horner!-eval!-rat(q,value));
   d:=gen!-poly(dval,value,mvar p,xsx);
   if heu!-quotf(p,d) and heu!-quotf(q,d) then return d;
      % if that failed we pick a much higher evaluation point
   lgcd:=gcdn(lcp,lcq);
   tgcd:=gcdn(lcp,lcq);
   value:=second!-value(inp,inq,lcp,lcq,lgcd,tcp,tcq,tgcd);
   k:=0;
loop:
   dval:=gcdn(horner!-eval!-rat(p,value),horner!-eval!-rat(q,value));
   d:=gen!-poly(dval,value,mvar p,xsx);
   if heu!-quotf(p,d) and heu!-quotf(q,d) then return d;
   value:=next!-odd!-value value;
   k:=k+1;
   dval:=gcdn(horner!-eval!-rat(p,value),horner!-eval!-rat(q,value));
   d:=gen!-poly(dval,value,mvar p,xsx);
   if heu!-quotf(p,d) and heu!-quotf(q,d) then return d;
   value:=next!-even!-value value;
   k:=k+1;
   if k < 10 then goto loop;

   if !*ezgcd then
     rederr "heu-gcd failed -- EZGCD ON"
   else <<
      lprie "heu-gcd failed -- EZGCD OFF";
      return nil;
   >>;
end;
+++ heu!-gcd compiled, 1021 + 84 bytes
heu-gcd

symbolic procedure analyse!-polynomial p;
% Determine the infinity norm of p and take note of the trailing
% coefficient, simultaneously check that p is univariate and take note
% of any trailing powers of the main variable. The result is a triple
% of (infinity-norm,excess powers,trailing coefficient)
   analyse!-polynomial1(p,1,lc p,0,mvar p);
+++ analyse!-polynomial compiled, 15 + 20 bytes
analyse-polynomial

symbolic procedure analyse!-polynomial1 (p,inp,tcp,xsxp,mvarp);
   if domainp p then
      if p then list(max(inp,abs p),0,abs p)
      else list(inp,xsxp,abs tcp)
   else if ((mvar p) neq mvarp) then nil
   else if domainp lc p then
      analyse!-polynomial1(red p,max(inp,abs lc p),lc p,ldeg p,mvarp)
   else nil;
+++ analyse!-polynomial1 compiled, 78 + 16 bytes
analyse-polynomial1

%********** Reconstruction from the Z-adic representation *************

% given a number in [0,modulus), return the equivalent
% member of [-modulus/2,modulus/2)
% LAMBDA to ensure only one evaluation of arguments;
symbolic inline procedure negshiftz(n,modulus);
   (lambda (nn,mmodulus);
      if nn>quotient(mmodulus,2) then nn-mmodulus else nn)
    (n,modulus);
+++ Record new inline definition:
(de negshiftz (n modulus) ((lambda (nn mmodulus) (cond ((greaterp nn (quotient
mmodulus 2)) (difference nn mmodulus)) (t nn))) n modulus))
(progn (de negshiftz (n modulus) ((lambda (nn mmodulus) (cond ((greaterp nn (
quotient mmodulus 2)) (difference nn mmodulus)) (t nn))) n modulus)) (put (quote
negshiftz) (quote number!-of!-args) 2) (put (quote negshiftz) (quote
procedure_type) (quote (arrow (times general general) general))) (putc (quote
negshiftz) (quote inline) (quote (lambda (n modulus) ((lambda (nn mmodulus) (
cond ((greaterp nn (quotient mmodulus 2)) (difference nn mmodulus)) (t nn))) n
modulus)))))
+++ negshiftz compiled, 19 + 12 bytes
(lambda (n modulus) ((lambda (nn mmodulus) (cond ((greaterp nn (quotient
mmodulus 2)) (difference nn mmodulus)) (t nn))) n modulus))

symbolic procedure gen!-poly(dval,value,var,xsx);
   if (numr value)=1 then gen!-poly!-backward(dval,denr value,var,xsx)
   else if (denr value)=1 then gen!-poly!-forward(dval,numr value,var,xsx)
   else rederr "HEUGCD(gen-poly):point must be integral or reciprocal";
+++ gen!-poly compiled, 38 + 28 bytes
gen-poly

symbolic procedure gen!-poly!-forward(dval,value,var,xsx);
% generate a new polynomial in var from the value-adic representation
% provided by dval
begin scalar i,d,val,val1,kont;
   kont:=0;
   val:=dval;
   i:=xsx;
   if zerop i then <<
      % an x**0 term is represented specially;
      val1:=negshiftz(remainder(val,value),value);
      if not zerop val1 then kont:=d:=val1;
      val:=quotient(val-val1,value);
      i:=1
   >>;
   while not zerop val do <<
      val1:=negshiftz(remainder(val,value),value);
      if not zerop val1 then <<
         kont:=gcdn(val1,kont);
         d:=var .** i .* val1 .+ d
      >>;
      val:=quotient(val-val1,value);
      i:=1+i
   >>;
   return quotf(d,kont)
end;
+++ gen!-poly!-forward compiled, 113 + 28 bytes
gen-poly-forward

symbolic procedure gen!-poly!-backward(dval,value,var,xsx);
% generate a new polynomial in var from the 1/value-adic representation
% provided by dval
begin scalar i,d,ans,val,val1,kont;
   kont:=0;
   val:=dval;
   % because we are at the 1/value representation
   % we need the implicit REVERSE that the two-loop strategy here
   % provides;
   while not zerop val do <<
      val1:=negshiftz(remainder(val,value),value);
      d:=val1 . d;
      val:=quotient(val-val1,value)
   >>;
   i:=xsx;
   if (zerop i and not zerop car d) then <<
      % Handle x**0 term specially;
      kont:=ans:=car d;
      d:=cdr d;
      i:=1
   >>;
   while d do <<
      if not zerop car d then <<
         kont:=gcdn(car d,kont);
         ans:= var .** i .* car d .+ ans
      >>;
      d:=cdr d;
      i:=i+1
   >>;
   return quotf(ans,kont)
end;
+++ gen!-poly!-backward compiled, 97 + 28 bytes
gen-poly-backward

endmodule;nil

end;nil
nil


(load!-package!-sources 'alg 'alg)module alg;nil  % Header module for alg package.

% Author: Anthony C. Hearn.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


create!-package('(alg alg!-form intro general farith numsup genmod
                  random smallmod zfactor sort reval algbool simp
                  exptchk simplog logsort sub order forall eqn rmsubs
                  algdcl opmtch prep extout depend str coeff weight
                  linop elem showrule nestrad maxmin nssimp part map
                  spcfnint),
                nil);
+++ Creating a package: alg
alg

flag('(alg),'core_package);nil

put('alglist!*,'initvalue!*,'(cons nil nil));(cons nil nil)

% Some renamings so that no user operations in algebraic mode need an
% asterisk.

deflist('((eval_mode !*mode)
          (cardno!* card_no)
          (fortwidth!* fort_width)
          (high_pow hipow!*)
          (low_pow lowpow!*)
          (root_multiplicities multiplicities!*)),
        'newnam);(eval_mode cardno* fortwidth* high_pow low_pow
root_multiplicities)

endmodule;nil

end;nilmodule alg!-form;nil   % Some particular algebraic mode analysis functions.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


global '(inputbuflis!* resultbuflis!* ws);nil

symbolic procedure forminput(u,vars,mode);
   begin scalar x;
      if length cdr u neq 1
        then rerror('alg,1,list("input called with",
                                length cdr u,
                                "arguments instead of 1"));
      u := cadr u; if eqcar(u,'!:int!:) then u := cadr u;
      if null(x := assoc(u,inputbuflis!*))
        then rerror(alg,1,list("Entry",u,"not found"));
      return caddr x
   end;
+++ forminput compiled, 52 + 44 bytes
forminput

put('input,'formfn,'forminput);forminput

symbolic procedure formws(u,vars,mode);
   begin scalar x;
      if length cdr u neq 1
        then rerror('alg,1,list("ws called with",
                                length cdr u,
                                "arguments instead of 1"));
      u := cadr u; if eqcar(u,'!:int!:) then u := cadr u;
      if x := assoc(u,resultbuflis!*) then return mkquote cdr x
       else rerror(alg,2,list("Entry",u,"not found"))
   end;
+++ formws compiled, 56 + 52 bytes
formws

put('ws,'formfn,'formws);formws

endmodule;nil

end;nilmodule intro;nil  % Introductory material for algebraic mode.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*cref !*exp !*factor !*fort !*ifactor !*intstr !*lcm !*mcd
        !*msg !*mode !*nat !*nero !*period !*precise !*pri !*protfg
        !*rationalize !*reduced !*sub2 !*varopt !*wsm posn!* subfg!*);nil

global '(!*resubs
         !*val
         erfg!*
         exlist!*
         initl!*
         nat!*!*
         ofl!*
         simpcount!*
         simplimit!*
         tstack!*);nil

% Non-local variables needing top level initialization.

!*exp := t;t             % expansion control flag;
!*lcm := t;t             % least common multiple computation flag;
!*mcd := t;t             % common denominator control flag;
!*mode := 'symbolic;symbolic    % current evaluation mode;
!*msg := t;t             % flag controlling message printing;
!*nat := t;t             % specifies natural printing mode;
!*period := t;t          % prints a period after a fixed coefficient
                        % when FORT is on;
!*precise := t;t         %  Specifies more precise handling of surds.
!*resubs := t;t          % external flag controlling resubstitution;
!*val := t;t             % controls operator argument evaluation;
!*varopt := t;t          % Used by SOLVE, etc.
exlist!* := '((!*));((*))    % property list for standard forms used as
                        %  kernels;
initl!* := append('(subfg!* !*sub2 tstack!*),initl!*);(subfg* *sub2 tstack*
fname* outl*)
simpcount!* := 0;0       % depth of recursion within simplifier;
simplimit!* := 2000;2000    % allowed recursion limit within simplifier;
subfg!* := t;t           % flag to indicate whether substitution
                        % is required during evaluation;
tstack!* := 0;0          % stack counter in SIMPTIMES;

% Initial values of some global variables in BEGIN1 loops.

put('subfg!*,'initl,t);t

put('tstack!*,'initl,0);0


% Description of some non-local variables used in algebraic mode.

% alglist!* := nil . nil; %association list for previously simplified
                        %expressions;
% asymplis!* := nil;    %association list of asymptotic replacements;
% cursym!*              current symbol (i. e. identifier, parenthesis,
%                       delimiter, e.t.c,) in input line;
% dmode!* := nil;       %name of current polynomial domain mode if not
                        %integer;
% domainlist!* := nil;  %list of currently supported poly domain modes;
% dsubl!* := nil;       %list of previously calculated derivatives of
                        % expressions;
% exptl!* := nil;       %list of exprs with non-integer exponents;
% frlis!* := nil;       %list of renamed free variables to be found in
                        %substitutions;
% kord!* := nil;        %kernel order in standard forms;
% kprops!* := nil;      %list of active non-atomic kernel plists;
% mchfg!* := nil;       %indicates that a pattern match occurred during
                        %a cycle of the matching routines;
% mul!* := nil;         %list of additional evaluations needed in a
                        %given multiplication;
% nat!*!* := nil;       %temporary variable used in algebraic mode;
% ncmp!* := nil;        %flag indicating non-commutative multiplication
                        %mode;
% ofl!* := nil;         %current output file name;
% posn!* := nil;        %used to store output character position in
                        %printing functions;
% powlis!* := nil;      %association list of replacements for powers;
% powlis1!* := nil;     %association list of conditional replacements
                        %for powers;
% subl!* := nil;        %list of previously evaluated expressions;
% wtl!* := nil;         %tells that a WEIGHT assignment has been made;
% !*ezgcd := nil;       %ezgcd calculation flag;
% !*float := nil;       %floating arithmetic mode flag;
% !*fort := nil;        %specifies FORTRAN output;
% !*gcd := nil;         %greatest common divisor mode flag;
% !*group := nil;       %causes expressions to be grouped when EXP off;
% !*intstr := nil;      %makes expression arguments structured;
% !*int                 indicates interactive system use;
% !*match := nil;       %list of pattern matching rules;
% !*nero := nil;        %flag to suppress printing of zeros;
% !*nosubs := nil;      %internal flag controlling substitution;
% !*numval := nil;      %used to indicate that numerical expressions
                        %should be converted to a real value;
% !*outp := nil;        %holds prefix output form for extended output
                        %package;
% !*pri := nil;         %indicates that fancy output is required;
% !*reduced := nil;     %causes arguments of radicals to be factored.
                        %E.g., sqrt(-x) --> i*sqrt(x);
% !*sub2 := nil;        %indicates need for call of RESIMP;


% ***** UTILITY FUNCTIONS *****.

symbolic procedure reversip2(a, b);
  begin
    scalar w;
    while a do <<
      w := cdr a;
      rplacd(a, b);
      b := a;
      a := w >>;
    return b
  end;
*** reversip2 not defined (LOSE flag) 
nil 

symbolic procedure mkid(x,y);
  % creates the ID XY from identifier X and (evaluated) object Y.
  if not idp x then typerr(x,"MKID root")
   else if atom y and (idp y or fixp y and not minusp y)
    then intern compress nconc(explode get!-print!-name x,
                               explode get!-print!-name y)
   else typerr(y,"MKID index");
+++ mkid redefined
+++ mkid compiled, 48 + 28 bytes
mkid

flag('(mkid),'opfn);nil

symbolic procedure multiple!-result(z,w);
   % Z is a list of items (n . prefix-form), in ordering in descending
   % order wrt n, which must be non-negative.  W is either an array
   % name, another id, a template for a multi-dimensional array or NIL.
   % Elements of Z are accordingly stored in W if it is non-NIL, or
   % returned as a list otherwise.
   begin scalar x,y;
        if null w then return 'list . reversip!* fillin z;
        x := getrtype w;
        if x and not(x eq 'array) then typerr(w,"array or id");
        lpriw("*****",
              list(if x eq 'array then "ARRAY" else "ID",
                   "fill no longer supported --- use lists instead"));
        if atom w then (if not arrayp w
           then (if numberp(w := reval w) then typerr(w,'id)))
         else if not arrayp car w then typerr(car w,'array)
         else w := car w . for each x in cdr w
                            collect if x eq 'times then x else reval x;
        x := length z-1;  % don't count zeroth element;
        if not((not atom w and atom car w
                         and (y := dimension car w))
             or ((y := dimension w) and null cdr y))
         then <<y := explode w;
                w := nil;
                for each j in z do
                   <<w := intern compress append(y,explode car j) . w;
                     setk1(car w,cdr j,t)>>;
                lprim if length w=1 then list(car w,"is non zero")
                       else aconc!*(reversip!* w,"are non zero");
                return x>>
         else if atom w
          then <<if caar z neq (car y-1)
                   then <<y := list(caar z+1);
                          % We don't use put!-value here.
                          put(w,'avalue,
                              {'array,mkarray1(y,'algebraic)});
                          put(w,'dimension,y)>>;
                 w := list(w,'times)>>;
        y := pair(cdr w,y);
        while y and not smemq('times,caar y) do y := cdr y;
        if null y then errach "MULTIPLE-RESULT";
        y := cdar y-reval subst(0,'times,caar y)-1;
           %-1 needed since DIMENSION gives length, not highest index;
        if caar z>y
          then rerror(alg,3,list("Index",caar z,"out of range"));
        repeat
           if null z or y neq caar z
             then setelv(subst(y,'times,w),0)
            else <<setelv(subst(y,'times,w),cdar z); z := cdr z>>
          until (y := y-1) < 0;
        return x
   end;
+++ multiple!-result compiled, 364 + 160 bytes
multiple-result

symbolic procedure fillin u;
   % fills in missing terms in multiple result argument list u
   % and returns list of coefficients.
   if null u then nil else fillin1(u,caar u);
+++ fillin redefined
+++ fillin compiled, 7 + 12 bytes
fillin

symbolic procedure fillin1(u,n);
   if n<0 then nil
    else if u and caar u=n then cdar u . fillin1(cdr u,n-1)
    else 0 . fillin1(u,n-1);
+++ fillin1 compiled, 35 + 16 bytes
fillin1


% ***** FUNCTIONS FOR PRINTING DIAGNOSTIC AND ERROR MESSAGES *****

symbolic procedure msgpri(u,v,w,x,y);
   begin integer posn!*; scalar nat1,z,pline!*;
        if null y and null !*msg then return;
        nat1 := !*nat;
        !*nat := nil;
        if ofl!* and (!*fort or not nat1) then go to c;
    a:  terpri();
        lpri ((if null y then "***" else "*****")
                 . if u and atom u then list u else u);
        posn!* := posn();
        maprin v;
        prin2 " ";
        lpri if w and atom w then list w else w;
        posn!* := posn();
        maprin x;
        terpri!*(t); % if not y or y eq 'hold then terpri();
        if null z then go to b;
        wrs cdr z;
        go to d;
    b:  if null ofl!* then go to d;
    c:  z := ofl!*;
        wrs nil;
        go to a;
    d:  !*nat := nat1;
        if y then if y eq 'hold then erfg!* := y else error1()
   end;
*** local variable pline* in procedure msgpri not used 
+++ msgpri compiled, 123 + 76 bytes
msgpri

symbolic procedure errach u;
   begin
        terpri!* t;
        lprie "CATASTROPHIC ERROR *****";
        printty u;
        lpriw(" ",nil);
        rerror(alg,4,
   "Please report output and input listing on the sourceforge bug tracker")
   end;
+++ errach compiled, 19 + 52 bytes
errach

symbolic procedure errpri1 u;
   msgpri("Substitution for",u,"not allowed",nil,t);
+++ errpri1 compiled, 13 + 24 bytes
errpri1  % was 'HOLD

symbolic procedure errpri2(u,v);
   msgpri("Syntax error:",u,"invalid",nil,v);
+++ errpri2 compiled, 13 + 20 bytes
errpri2

symbolic procedure redmsg(u,v);
   if null !*wsm and !*msg and v member '("operator" "predicate") then
      if terminalp() then
      	 yesp list("Declare",get!-print!-name u,v,"?") or error1()
      else
      	 lprim list(get!-print!-name u,"declared",v);
+++ redmsg redefined
+++ redmsg compiled, 48 + 56 bytes
redmsg

symbolic procedure typerr(u,v);
   % Note this replaces definition in rlisp/lpri. If outputhandler!* is
   % non-nil I go back to the simple old version, which may be less
   % pretty but that does not end up with messages getting lost so often!
   if outputhandler!*
     then rerror('rlisp,6,
                 if not atom u and atom car u and cdr u and atom cadr u
                    and null cddr u
                   then list(car u,cadr u,"invalid as",v)
                  else list(u,"invalid as",v))
   else
   <<if not !*protfg
      then  <<terpri!* t;
              prin2!* "***** ";
              if not atom u and atom car u and cdr u and atom cadr u
                 and null cddr u
                then <<prin2!* car u; prin2!* " "; prin2!* cadr u>>
               else if null u then prin2!* u
               else maprin u;
              prin2!* " invalid as "; prin2!* v;
              terpri!* nil>>;
     errmsg!* := list(u,"invalid as",v);
     erfg!* := t; error1()>>;
+++ typerr redefined
+++ typerr compiled, 113 + 76 bytes
typerr


%                 ***** ALGEBRAIC MODE DECLARATIONS *****

flag ('(aeval cond getel go prog progn prog2 return
        reval setq setk setel assgnpri !*s2i),'nochange);nil

flag ('(or and not member memq equal neq eq geq greaterp leq
        fixp lessp numberp ordp freeof),'boolean);nil

flag ('(or and not),'boolargs);nil

deflist ('((exp ((nil (rmsubs)) (t (rmsubs))))
        (factor ((nil (setq !*exp t) (rmsubs))
                 (t (setq !*exp nil) (rmsubs))))
        (fort ((nil (setq !*nat nat!*!*)) (t (setq !*nat nil))))
        (gcd ((t (rmsubs))))
        (intstr ((nil (rmsubs)) (t (rmsubs))))
        (mcd ((nil (rmsubs)) (t (rmsubs))))
        (nat ((nil (setq nat!*!* nil)) (t (setq nat!*!* t))))
        (numval ((t (rmsubs))))
        (rationalize ((t (rmsubs))))
        (reduced ((t (rmsubs))))
        (val ((t (rmsubs))))),'simpfg);(exp factor fort gcd intstr mcd nat
numval rationalize reduced val)

switch exp,cref,factor,fort,gcd,ifactor,intstr,lcm,mcd,nat,nero,numval,
       period,precise,pri,rationalize,reduced,varopt;nil   % resubs, val.

endmodule;nil

end;nilmodule general;nil   % General functions for the support of REDUCE.

% Author: Anthony C. Hearn.

% Copyright (c) 1999 Anthony C. Hearn.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


global '(!!arbint);nil

!!arbint := 0;0 % Index for arbitrary constants.

symbolic procedure atomlis u;
   null u or (atom car u and atomlis cdr u);
+++ atomlis redefined
+++ atomlis compiled, 11 + 12 bytes
atomlis

symbolic procedure carx(u,v);
   if not null u and null cdr u then car u
    else rerror(alg,5,list("Wrong number of arguments to",v));
+++ carx compiled, 18 + 24 bytes
carx

symbolic procedure eqexpr u;
   % Returns true if U is an equation or similar structure
   % (e.g., a rule).
   not atom u
      and flagp(car u,'equalopr) and cddr u and null cdddr u;
+++ eqexpr redefined
+++ eqexpr compiled, 18 + 12 bytes
eqexpr

flag('(eq equal),'equalopr);nil

symbolic procedure evenp x; remainder(x,2)=0;
*** evenp not defined (LOSE flag) 
nil

flag('(evenp),'opfn);nil  % Make a symbolic operator.

symbolic procedure makearbcomplex;
   begin scalar ans;
      !!arbint := !!arbint+1;
      ans := car(simp!*(list('arbcomplex, !!arbint)));
      % This CAR is NUMR, which is not yet defined.
      return ans
   end;
+++ makearbcomplex compiled, 11 + 20 bytes
makearbcomplex

symbolic procedure mapcons(u,v);
   for each j in u collect v . j;
+++ mapcons redefined
+++ mapcons compiled, 36 + 8 bytes
mapcons

symbolic procedure mappend(u,v);
   for each j in u collect append(v,j);
+++ mappend compiled, 38 + 8 bytes
mappend

symbolic procedure nlist(u,n);
   if n=0 then nil else u . nlist(u,n-1);
+++ nlist redefined
+++ nlist compiled, 16 + 16 bytes
nlist

symbolic procedure nth(u,n);
   car pnth(u,n);
+++ nth redefined
+++ nth compiled, 4 + 12 bytes
nth

symbolic procedure pnth(u,n);
   if null u then rerror(alg,6,"Index out of range")
    else if n=1 then u
    else pnth(cdr u,n-1);
+++ pnth redefined
+++ pnth compiled, 19 + 28 bytes
pnth

symbolic procedure permp(u,v);
   % This used to use EQ.  However, SUBST use requires =.
   if null u then t
    else if car u=car v then permp(cdr u,cdr v)
    else not permp(cdr u,subst(car v,car u,cdr v));
+++ permp redefined
+++ permp compiled, 27 + 16 bytes
permp

symbolic procedure permutations u;
   %  Returns list of all permutations of the list u.
   if null u then list u
    else for each j in u join mapcons(permutations delete(j,u),j);
+++ permutations compiled, 54 + 16 bytes
permutations

symbolic procedure posintegerp u;
   % True if U is a positive (non-zero) integer.
   fixp u and u>0;
+++ posintegerp compiled, 10 + 12 bytes
posintegerp

symbolic procedure remove(x,n);
   % Returns X with Nth element removed;
   if null x then nil
    else if n=1 then cdr x
    else car x . remove(cdr x,n-1);
+++ remove compiled, 25 + 16 bytes
remove

symbolic procedure repasc(u,v,w);
   % Replaces value of key U by V in association list W.
   if null w then rerror(alg,7,list("key",u,"not found"))
    else if u = caar w then (u . v) . cdr w
    else car w . repasc(u,v,cdr w);
+++ repasc redefined
+++ repasc compiled, 45 + 28 bytes
repasc

symbolic procedure repeats x;
   if null x then nil
    else if car x member cdr x then car x . repeats cdr x
    else repeats cdr x;
+++ repeats redefined
+++ repeats compiled, 23 + 12 bytes
repeats

symbolic procedure revpr u;
   cdr u . car u;
+++ revpr redefined
+++ revpr compiled, 4 + 8 bytes
revpr

symbolic procedure smember(u,v);
   %determines if S-expression U is a member of V at any level;
   if u=v then t
    else if atom v then nil
    else smember(u,car v) or smember(u,cdr v);
+++ smember redefined
+++ smember compiled, 18 + 12 bytes
smember

symbolic procedure smemql(u,v);
   %Returns those members of id list U contained in V at any
   %level (excluding quoted expressions);
   if null u then nil
    else if smemq(car u,v) then car u . smemql(cdr u,v)
    else smemql(cdr u,v);
+++ smemql redefined
+++ smemql compiled, 23 + 12 bytes
smemql

symbolic procedure smemqlp(u,v);
   %True if any member of id list U is contained at any level
   %in V (exclusive of quoted expressions);
   if null v or numberp v then nil
    else if atom v then v memq u
    else if car v eq 'quote then nil
    else smemqlp(u,car v) or smemqlp(u,cdr v);
+++ smemqlp redefined
+++ smemqlp compiled, 27 + 12 bytes
smemqlp

symbolic procedure spaces n; for i := 1:n do prin2 " ";
*** spaces not defined (LOSE flag) 
nil

symbolic procedure subla(u,v);
   % Substitutes the atom u in v. Retains previous structure where
   % possible.
   if null u or null v then v
    else if atom v then (if x then cdr x else v) where x=atsoc(v,u)
    else (if y=v then v else y) where y=subla(u,car v) . subla(u,cdr v);
*** subla not defined (LOSE flag) 
nil

symbolic procedure xnp(u,v);
   %returns true if the atom lists U and V have at least one common
   %element;
   u and (car u memq v or xnp(cdr u,v));
+++ xnp redefined
+++ xnp compiled, 14 + 8 bytes
xnp

% In earlier versions of Reduce there were various functions where the
% definition were replicated in several places. When these are pure
% duplicates it seems good to lift the definitions to here so that they
% are included just once. So some of the functions defined here may be
% a little specialist and not used in very many places.

inline procedure !*k2pf u;
   u .* (1 ./ 1) .+ nil;
+++ Record new inline definition:
(de !*k2pf (u) (cons (cons u (cons 1 1)) nil))
(progn (de !*k2pf (u) (cons (cons u (cons 1 1)) nil)) (put (quote !*k2pf) (quote
number!-of!-args) 1) (put (quote !*k2pf) (quote procedure_type) (quote (arrow
general general))) (putc (quote !*k2pf) (quote inline) (quote (lambda (u) (cons
(cons u (cons 1 1)) nil)))))
+++ !*k2pf compiled, 7 + 12 bytes
(lambda (u) (cons (cons u (cons 1 1)) nil))

inline procedure negpf u;
   multpfsq(u,(-1) ./ 1);
+++ Record new inline definition:
(de negpf (u) (multpfsq u (cons (minus 1) 1)))
(progn (de negpf (u) (multpfsq u (cons (minus 1) 1))) (put (quote negpf) (quote
number!-of!-args) 1) (put (quote negpf) (quote procedure_type) (quote (arrow
general general))) (putc (quote negpf) (quote inline) (quote (lambda (u) (
multpfsq u (cons (minus 1) 1))))))
+++ negpf compiled, 9 + 20 bytes
(lambda (u) (multpfsq u (cons (minus 1) 1)))

inline procedure lowerind u;
   list('minus,u);
+++ Record new inline definition:
(de lowerind (u) (list (quote minus) u))
(progn (de lowerind (u) (list (quote minus) u)) (put (quote lowerind) (quote
number!-of!-args) 1) (put (quote lowerind) (quote procedure_type) (quote (arrow
general general))) (putc (quote lowerind) (quote inline) (quote (lambda (u) (
list (quote minus) u)))))
+++ lowerind compiled, 4 + 12 bytes
(lambda (u) (list (quote minus) u))

% The next two are from excalc.

inline procedure get!*fdeg u;
   (if x then car x else nil) where x = get(u,'fdegree);
+++ Record new inline definition:
(de get!*fdeg (u) ((lambda (x) (cond (x (car x)) (t nil))) (get u (quote fdegree
))))
(progn (de get!*fdeg (u) ((lambda (x) (cond (x (car x)) (t nil))) (get u (quote
fdegree)))) (put (quote get!*fdeg) (quote number!-of!-args) 1) (put (quote
get!*fdeg) (quote procedure_type) (quote (arrow general general))) (putc (quote
get!*fdeg) (quote inline) (quote (lambda (u) ((lambda (x) (cond (x (car x)) (t
nil))) (get u (quote fdegree)))))))
+++ get!*fdeg compiled, 9 + 8 bytes
(lambda (u) ((lambda (x) (cond (x (car x)) (t nil))) (get u (quote fdegree))))

inline procedure get!*ifdeg u;
   (if x then cdr x else nil)
    where x = assoc(length cdr u,get(car u,'ifdegree));
+++ Record new inline definition:
(de get!*ifdeg (u) ((lambda (x) (cond (x (cdr x)) (t nil))) (assoc (length (cdr
u)) (get (car u) (quote ifdegree)))))
(progn (de get!*ifdeg (u) ((lambda (x) (cond (x (cdr x)) (t nil))) (assoc (
length (cdr u)) (get (car u) (quote ifdegree))))) (put (quote get!*ifdeg) (quote
number!-of!-args) 1) (put (quote get!*ifdeg) (quote procedure_type) (quote (
arrow general general))) (putc (quote get!*ifdeg) (quote inline) (quote (lambda
(u) ((lambda (x) (cond (x (cdr x)) (t nil))) (assoc (length (cdr u)) (get (car u
) (quote ifdegree))))))))
+++ get!*ifdeg compiled, 15 + 8 bytes
(lambda (u) ((lambda (x) (cond (x (cdr x)) (t nil))) (assoc (length (cdr u)) (
get (car u) (quote ifdegree)))))

% The next is from fmprint.red/tmprint.red. I rather suspect that fmprint.red
% should be discarded in favour of tmprint.red since they are really the same
% code... but until that happens I will try a little tidy-up job here.

symbolic macro procedure fancy!-level u;
 % unwind-protect for special output functions.
  {'prog,'(pos tpos fl w),
      '(setq pos fancy!-pos!*),
      '(setq tpos fancy!-texpos),
      '(setq fl fancy!-line!*),
      {'setq,'w,cadr u},
      '(cond ((eq w 'failed)
              (setq fancy!-line!* fl)
              (setq fancy!-texpos tpos)
              (setq fancy!-pos!* pos))),
       '(return w)};
+++ fancy!-level_t6944tskcdpd2 compiled, 31 + 56 bytes
fancy-level

fluid '(ints!-as!-symbols!*);nil
ints!-as!-symbols!* := mkvect 15;[nil nil nil nil nil nil nil nil nil nil nil
nil nil nil nil nil]
for i := 0:15 do putv(ints!-as!-symbols!*, i,
                      intern compress ('!! . explode i));nil

% Make a symbols whose name is the sequence of digits from the
% number u. This (!*num2id 37) will give !37.
 
symbolic procedure !*num2id u;
   if u <= 15 and u >= 0 then getv(ints!-as!-symbols!*, u)
   else intern compress('!! . explode u);
+++ !*num2id compiled, 27 + 24 bytes
*num2id

symbolic procedure add!+vector!+to!+list(vector1, vectorlist);
% returns a list of vectors consisting of vectorlist with vector1
% added at the end. Used in symmetry and linalg packages.
   append(vectorlist, list vector1);
+++ add!+vector!+to!+list compiled, 8 + 8 bytes
add+vector+to+list

symbolic procedure adomainp u;
 % numberp test in an algebraic form.
   numberp u or (pairp u and idp car u and get(car u,'dname))
             or eqcar(u,'minus) and adomainp cadr u;
+++ adomainp compiled, 28 + 16 bytes
adomainp

symbolic procedure adomainpx(u,num);
  % extended algebraic domainp test:
  % num = t: u is a domain element;
  % num = inf: u is a domain element or inf or (minus inf)
  % num = nil: u is arbitrary.
    null num or adomainp u or num='infinity
                and member(u,'(infinity (minus infinity)));
+++ adomainpx compiled, 18 + 24 bytes
adomainpx

symbolic procedure revalnuminterval(u,num);
 % Evaluate u as interval; numeric bounds required if num=T.
  begin scalar l;
    if not eqcar(u,'!*interval!*) then typerr(u,"interval");
    l:={reval cadr u,reval caddr u};
    if adomainpx(car l,num) and adomainpx(cadr l,num) then return l;
    typerr(u,"numeric interval");
  end;
+++ revalnuminterval compiled, 35 + 32 bytes
revalnuminterval

symbolic procedure alistp l;
   null l or (pairp l and pairp car l and alistp cdr l);
+++ alistp redefined
+++ alistp compiled, 18 + 12 bytes
alistp

symbolic procedure greaterpcar(u, v);
  car u > car v;
+++ greaterpcar compiled, 4 + 8 bytes
greaterpcar

symbolic procedure lesspcar(u, v);
  car u < car v;
+++ lesspcar redefined
+++ lesspcar compiled, 4 + 8 bytes
lesspcar

symbolic procedure greaterpcdr(a, b);
  cdr a > cdr b;
+++ greaterpcdr redefined
+++ greaterpcdr compiled, 4 + 8 bytes
greaterpcdr

symbolic procedure lesspcdr(u, v);
  cdr u < cdr v;
+++ lesspcdr redefined
+++ lesspcdr compiled, 4 + 8 bytes
lesspcdr

symbolic procedure identity!-function x;
  x;
+++ identity!-function compiled, 1 + 8 bytes
identity-function

symbolic procedure ordpcar(u, v);
  ordp(car u, car v);
+++ ordpcar compiled, 4 + 12 bytes
ordpcar

symbolic procedure ordpcadr(u, v);
  ordp(cadr u, cadr v);
+++ ordpcadr compiled, 6 + 12 bytes
ordpcadr

symbolic procedure ordopcadr(u, v);
  ordop(cadr u, cadr v);
+++ ordopcadr compiled, 6 + 12 bytes
ordopcadr

symbolic procedure arg1of2(u, v); u;
*** local variable v in procedure arg1of2 not used 

+++ arg1of2 redefined
+++ arg1of2 compiled, 1 + 8 bytes
arg1of2

symbolic procedure arg2of2(u, v); v;
*** local variable u in procedure arg2of2 not used 

+++ arg2of2 redefined
+++ arg2of2 compiled, 1 + 8 bytes
arg2of2
endmodule;nil

end;nilmodule farith;nil  % Operators for fast arithmetic.

% Authors: A. C. Norman and P. M. A. Moore, 1981.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


symbolic procedure iplus2(u,v); u+v;
*** iplus2 not defined (LOSE flag) 
nil

symbolic procedure itimes2(u,v); u*v;
*** itimes2 not defined (LOSE flag) 
nil

symbolic procedure isub1 a; a-1;
*** isub1 not defined (LOSE flag) 
nil

symbolic procedure iadd1 a; a+1;
*** iadd1 not defined (LOSE flag) 
nil

remprop('iminus,'infix);nil

symbolic procedure iminus a; -a;
*** iminus not defined (LOSE flag) 
nil

symbolic procedure idifference(a,b); a-b;
*** idifference not defined (LOSE flag) 
nil

symbolic procedure iquotient(a,b); a/b;
*** iquotient not defined (LOSE flag) 
nil

symbolic procedure iremainder(a,b); remainder(a,b);
*** iremainder not defined (LOSE flag) 
nil

symbolic procedure igreaterp(a,b); a>b;
*** igreaterp not defined (LOSE flag) 
nil

symbolic procedure ilessp(a,b); a<b;
*** ilessp not defined (LOSE flag) 
nil

symbolic procedure iminusp a; a<0;
*** iminusp not defined (LOSE flag) 
nil

symbolic procedure iequal(u,v); eqn(u,v);
*** iequal not defined (LOSE flag) 
nil

newtok '((!#) hash);nil
newtok '((!# !+) iplus2);nil
newtok '((!# !-) idifference);nil
newtok '((!# !*) itimes2);nil
newtok '((!# !/) iquotient);nil
newtok '((!# !>) igreaterp);nil
newtok '((!# !<) ilessp);nil
newtok '((!# !=) iequal);nil

infix #+,#-,#*,#/,#>,#<,#=;nil

precedence #+,+;nil
precedence #-,-;nil
precedence #*,*;nil
precedence #/,/;nil
precedence #>,>;nil
precedence #<,<;nil
precedence #=,=;nil

deflist('((idifference iminus)),'unary);(idifference)

deflist('((iminus iminus)),'unary);(iminus)

deflist('((iminus iplus2)), 'alt);(iminus)

endmodule;nil

end;nilmodule numsup;nil   % Numerical support for basic algebra package.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


%  Numerical greatest common divisor.

symbolic procedure gcdn(u,v);
%  U and v are integers. Value is absolute value of gcd of u and v.
   if v = 0 then abs u else gcdn(v,remainder(u,v));
*** gcdn not defined (LOSE flag) 
nil


% Interface to rounded code.

% Only needed if package ARITH is autoloaded.

% switch rounded;

% put('rounded,'package!-name,'arith);

% put('rounded,'simpfg,
%             '((t (load!-package 'arith) (setdmode 'rounded t))));
    % Enough for now.

endmodule;nil

end;nilmodule genmod;nil % Modular arithmetic where the modulus may be any size.

% Authors: A. C. Norman and P. M. A. Moore, 1981.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% Modifications by: John Abbott.

% Note: when balanced_mod is on, the results here are not always in
% range. *modular2f is used to correct this. However, these routines
% should be updated to give balanced results.

fluid '(!*balanced_mod current!-modulus modulus!/2);nil

global '(largest!-small!-modulus);nil

symbolic procedure set!-general!-modulus p;
  if not numberp p or p=0 then current!-modulus
   else begin
     scalar previous!-modulus;
     previous!-modulus:=current!-modulus;
     current!-modulus:=p;
     modulus!/2 := p/2;
% Allow for use of small moduli where appropriate. What this bit is about is
% that CSL supports "set-small-modulus" setting a general potentially bignum
% modulus, and modular-plus and related functions then handle the big cases
% gracefully, meaning that the functions here like general-modular-plus are
% basically redundant. I am now making Jlisp do the same. But rather than
% checking the identity of the Lisp system I now see if set!-small!-modulus
% will accept an argument that is rather large. I test at 2^64 because I
% expect that to be above any reasonable "small" range.
% The re-binding of !*protfg is to prevent rederr from displaying a message
% if things fail.
#if (errorp (errorset
      '((lambda (!*protfg) (set!-small!-modulus (expt 2 64))) t)
      nil nil))
     if p <= largest!-small!-modulus then
#endif
        set!-small!-modulus p;
     return previous!-modulus
  end;
+++ set!-general!-modulus redefined
+++ set!-general!-modulus compiled, 24 + 24 bytes
set-general-modulus

symbolic procedure general!-modular!-plus(a,b);
  begin scalar result;
     result:=a+b;
     if result >= current!-modulus then result:=result-current!-modulus;
     return result
  end;
+++ general!-modular!-plus redefined
+++ general!-modular!-plus compiled, 13 + 12 bytes
general-modular-plus

symbolic procedure general!-modular!-difference(a,b);
  begin scalar result;
     result := a - b;
     if result < 0 then result:=result+current!-modulus;
     return result
  end;
+++ general!-modular!-difference redefined
+++ general!-modular!-difference compiled, 12 + 12 bytes
general-modular-difference

symbolic procedure general!-modular!-number a;
  begin
     a:=remainder(a,current!-modulus);
     if a < 0 then a:=a+current!-modulus;
     return a
  end;
+++ general!-modular!-number redefined
+++ general!-modular!-number compiled, 13 + 12 bytes
general-modular-number

symbolic procedure general!-modular!-times(a,b);
  begin scalar result;
     result:=remainder(a*b,current!-modulus);
     if result<0
       then result := result+current!-modulus;  %can this happen?
     return result
  end;
+++ general!-modular!-times redefined
+++ general!-modular!-times compiled, 15 + 12 bytes
general-modular-times

symbolic procedure general!-modular!-reciprocal a;
   % Note this returns a positive result.
   if !*balanced_mod and a<0
     then general!-reciprocal!-by!-gcd(current!-modulus,
                                       a + current!-modulus,0,1)
    else general!-reciprocal!-by!-gcd(current!-modulus,a,0,1);
+++ general!-modular!-reciprocal redefined
+++ general!-modular!-reciprocal compiled, 35 + 28 bytes
general-modular-reciprocal

symbolic procedure general!-modular!-quotient(a,b);
    general!-modular!-times(a,general!-modular!-reciprocal b);
+++ general!-modular!-quotient redefined
+++ general!-modular!-quotient compiled, 8 + 16 bytes
general-modular-quotient

symbolic procedure general!-modular!-minus a;
    if a=0 then a else current!-modulus - a;
+++ general!-modular!-minus redefined
+++ general!-modular!-minus compiled, 8 + 16 bytes
general-modular-minus

%symbolic procedure general!-reciprocal!-by!-gcd(a,b,x,y);
%%On input A and B should be coprime. This routine then
%%finds X and Y such that A*X+B*Y=1, and returns the value Y
%%on input A > B;
%   if b=0 then rerror(alg,8,"Invalid modular division")
%   else if b=1 then if y < 0 then y+current!-modulus else y
%   else begin scalar w;
%%N.B. Invalid modular division is either:
%% a)  attempt to divide by zero directly
%% b)  modulus is not prime, and input is not
%%     coprime with it;
%     w:=quotient(a,b); %Truncated integer division;
%     return general!-reciprocal!-by!-gcd(b,a-b*w,y,x-y*w)
%   end;

% Now a version that does not rely on tail-recursion elimination.
% For reasons I do not quite understand CSL leaves the above using
% tail calls in the bytecodes but it may still use too much stack.

symbolic procedure general!-reciprocal!-by!-gcd(a,b,x,y);
%On input A and B should be coprime. This routine then
%finds X and Y such that A*X+B*Y=1, and returns the value Y
%on input A > B;
  begin
   scalar w, tmp;
top:
   if b=0 then return rerror(alg,8,"Invalid modular division")
   else if b=1 then return (if y < 0 then y+current!-modulus else y);
%N.B. Invalid modular division is either:
% a)  attempt to divide by zero directly
% b)  modulus is not prime, and input is not
%     coprime with it;
    w := quotient(a,b); %Truncated integer division;
    tmp := a;
    a := b;
    b := tmp - b*w;
    tmp := x;
    x := y;
    y := tmp - y*w;
    go to top
  end;
+++ general!-reciprocal!-by!-gcd redefined
+++ general!-reciprocal!-by!-gcd compiled, 56 + 36 bytes
general-reciprocal-by-gcd

% The next two functions compute the "reverse" of a binary number.
% This is the number obtained when writing down the binary expansion
% in reverse order.  If 2^r divides n (but 2^(r+1) does not) then
% reverse-num(reverse-num(n)) = abs(n)/2^r. r can be computed using
% height2.

symbolic procedure reverse!-num(n);
   if n = 0 then n
    else if n<0 then -reverse!-num1(-n,ilog2(-n)+1)
    else reverse!-num1(n,ilog2(n)+1);
+++ reverse!-num redefined
+++ reverse!-num compiled, 33 + 20 bytes
reverse-num

global '(reverse!-num!-table!*);nil

reverse!-num!-table!* := mkvect 16;[nil nil nil nil nil nil nil nil nil nil nil
nil nil nil nil nil nil]
putv(reverse!-num!-table!*,1,8);8
putv(reverse!-num!-table!*,2,4);4
putv(reverse!-num!-table!*,3,12);12
putv(reverse!-num!-table!*,4,2);2
putv(reverse!-num!-table!*,5,10);10
putv(reverse!-num!-table!*,6,6);6
putv(reverse!-num!-table!*,7,14);14
putv(reverse!-num!-table!*,8,1);1
putv(reverse!-num!-table!*,9,9);9
putv(reverse!-num!-table!*,10,5);5
putv(reverse!-num!-table!*,11,13);13
putv(reverse!-num!-table!*,12,3);3
putv(reverse!-num!-table!*,13,11);11
putv(reverse!-num!-table!*,14,7);7
putv(reverse!-num!-table!*,15,15);15

symbolic procedure reverse!-num1(n,bits);
   if n = 0 then 0
    else if bits = 1 then n
    else if bits = 2 then getv(reverse!-num!-table!*,4*n)
    else if bits = 3 then getv(reverse!-num!-table!*,2*n)
    else if bits = 4 then getv(reverse!-num!-table!*,n)
    else begin scalar shift,qr;
       shift := 2**(bits/2);
       qr := divide(n,shift);
       if not evenp bits then shift := shift*2;
       return reverse!-num1(cdr qr,bits/2)*shift +
           reverse!-num1(car qr,(bits+1)/2)
   end;
+++ reverse!-num1 redefined
+++ reverse!-num1 compiled, 91 + 32 bytes
reverse-num1

% Interface to algebraic mode.

flag('(reverse!-num),'integer);nil

deflist('((reverse!-num rnreverse!-num!*)),'!:rn!:);(reverse-num)

%put('fibonacci,'!:rn!:,'rnfibonacci!*);

put('reverse!-num,'number!-of!-args,1);1

put('reverse!-num,'simpfn,'simpiden);simpiden

symbolic procedure rnreverse!-num!*(x);
   (if fixp y then reverse!-num(y)
    else !*p2f mksp(list('reverse!-num,y),1))
    where y=rnfixchk x;
+++ rnreverse!-num!* compiled, 19 + 24 bytes
rnreverse-num*

% Interface to algebraic mode.

put('reverse!-num, 'simpfn, 'simpreverse!-num);simpreverse-num

symbolic procedure simpreverse!-num(u);
   begin scalar arg;
      if length(u) neq 1 then typerr(u,"integer");
      arg := simpcar u;
      if denr(arg) neq 1 or not fixp(numr(arg))
        then rederr("reverse!-num: argument should be an integer");
      return reverse!-num(numr(arg)) ./ 1
   end;
+++ simpreverse!-num compiled, 28 + 36 bytes
simpreverse-num

% This is an iterative version of general!-modular!-expt.
% Its principal advantage over the (simpler) recursive implementation
% is that it avoids excessive memory consumption when both n and the
% modulus are quite large -- try primep(2^10007-1) if you don't believe
% it!

symbolic procedure general!-modular!-expt(a,n);
   % Computes a**n modulo current-modulus.  Uses Fermat's Little
   % Theorem where appropriate for a prime modulus.
    if a=0 then if n=0 then rerror(alg,101,"0^0 formed") else 0
    else if n=0 then 1
    else if n=1 then a
    else if n>=current!-modulus-1 and primep current!-modulus
     then general!-modular!-expt(a,remainder(n,current!-modulus-1))
    else begin scalar x, revn;
      while evenp n do <<n := n/2; a := general!-modular!-times(a,a)>>;
      revn := reverse!-num n;
      x := 1;
      while revn>0 do
      <<x := general!-modular!-times(x,x);
        if not evenp(revn) then x := general!-modular!-times(x,a);
        revn := revn/2>>;
      return x
    end;
+++ general!-modular!-expt redefined
+++ general!-modular!-expt compiled, 99 + 52 bytes
general-modular-expt

endmodule;nil

end;nilmodule random;nil  % Random Number Generator.

% Author: C.J. Neerdaels, with adjustments by A.C. Norman.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% Entrypoints:
%     random_new_seed n Re-seed the random number generator
%     random n          return next value (range 0 <= r < n)
%     next!-random!-number()
%                       return next value in range 0<=r<randommodulus!*

% Note that random_new_seed is automatically called with argument 1 if
% the user does not explicitly call it with some other argument, and
% that resetting the seed in the generator is a fairly expensive
% business. % The argument to random() may be integer or floating, large
% or small, but should be strictly positive.


global '(unidev_vec!* randommodulus!*);nil
global '(unidev_fac!* unidev_next!* unidev_nextp!* unidev_mj!*);nil
global '(randomseed!*);nil

unidev_vec!* := mkvect(54)$[nil nil nil nil nil nil nil nil nil nil nil nil nil
nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
nil nil]
randommodulus!* := 100000000;100000000 % This is a fixnum in PSL and CSL (10^8).
unidev_fac!* :=  1.0/randommodulus!*;1.0e-08

% The following two lines are for speed fanatics - they should be OK
% with both PSL and CSL (as of June 1993).  They can be removed with no
% serious effect to code that is not random-number intensive.

% compiletime on fastfor;
% compiletime flag('(randommodulus!* unidev_fac!*), 'constant!?);

flag('(random random_new_seed),'opfn);nil % Make symbolic operators.

symbolic procedure random_new_seed offset;
% Sets the unidev seed to offset
  begin scalar mj, mk, ml, ii;
    if not fixp offset or offset <= 0
      then typerr(offset,"positive integer");
    mj := remainder(offset, randommodulus!*);
    putv(unidev_vec!*, 54, mj);
    mk := mj + 1;          % This arranges that one entry in the vector
                           % will end up with '1' in it, and that is
                           % enough to ensure we get a long cycle.
    for i:= 1:54 do <<
      ml := mk #- mj;
      if iminusp ml then ml := ml #+ randommodulus!*;
      ii := remainder(21*i,55);
      putv(unidev_vec!*, ii #- 1, ml);
      mk := mj;
      mj := ml >>;
    for k:=1:4 do <<      % Cycle generator a few times to pre-scramble.
      for i:=0:54 do <<
        ml := getv(unidev_vec!*, i) #-
              getv(unidev_vec!*, remainder(i #+ 31,55));
        if iminusp ml then ml := ml #+ randommodulus!*;
        putv(unidev_vec!*, i, ml) >> >>;
    unidev_next!* := 0;
    unidev_nextp!* := 31;
    return nil
  end;
+++ random_new_seed redefined
+++ random_new_seed compiled, 151 + 60 bytes
random_new_seed

%*************************UNIDEV****************************************

symbolic procedure next!-random!-number;
% Returns a uniform random deviate between 0 and randommodulus!*-1.
  begin scalar mj;
    if unidev_next!* = 54 then unidev!_next!* := 0
     else unidev!_next!* := unidev!_next!* #+ 1;
    if unidev!_nextp!* = 54 then unidev!_nextp!* := 0
     else unidev!_nextp!* := unidev!_nextp!* #+ 1;
    mj := getv(unidev_vec!*, unidev_next!*) #-
          getv(unidev_vec!*, unidev_nextp!*);
    if iminusp mj then mj := mj #+ randommodulus!*;
    putv(unidev_vec!*, unidev_next!*, mj);
    return mj
  end;
+++ next!-random!-number redefined
+++ next!-random!-number compiled, 50 + 32 bytes
next-random-number

symbolic procedure random size;
% Returns a random value in the range 0 <= r < size.
  begin scalar m, r;
    if not numberp size or size <= 0
      then typerr(size,"positive number");
    if floatp size then <<
% next!-random!-number() returns just under 27 bits of randomness, and
% for a properly random double precision (IEEE) value I need 52 or 53
% bits.  So I just call next!-random!-number() twice and glue the bits
% together.
      r := float next!-random!-number() * unidev_fac!*;
      return (float next!-random!-number() + r) * unidev_fac!* * size >>
    else <<
% I first generate a random variate over a range that is some power of
% randommodulus!*.  Then I select from this to restrict my range to be
% an exact multiple of size.  The worst case for this selection is when
% the power of randommodulus!* is just less than twice size, in which
% case on average two trials are needed.  In the vast majority of cases
% the cost of making the selection will be much less.  With a value
% uniform over some multiple of my range I can use simple remaindering
% to get the result.
      repeat <<
        r := next!-random!-number();
        m := randommodulus!*;
        while m < size do <<
          m := m * randommodulus!*;
          r := randommodulus!* * r + next!-random!-number() >>;
        >> until r < m - remainder(m, size);
      return remainder(r, size) >>
  end;
+++ random redefined
+++ random compiled, 83 + 32 bytes
random

random_new_seed 1;nil    % Ensure that code is set up ready for use.

endmodule;nil

end;nilmodule smallmod;nil % Small integer modular arithmetic used in factorizer.

% Author: Arthur C. Norman.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% Note: when balanced_mod is on, the results here are not always in
% range. *modular2f is used to correct this.

fluid '(!*balanced_mod current!-modulus modulus!/2);nil

global '(largest!-small!-modulus);nil

symbolic procedure set!-modulus p; set!-general!-modulus p;
+++ set!-modulus compiled as link to set-general-modulus
set-modulus

symbolic procedure set!-small!-modulus p;
  begin
    scalar previous!-modulus;
    if p>largest!-small!-modulus
      then rerror(alg,9,list("Overlarge modulus",p,"being used"));
    previous!-modulus:=current!-modulus;
    current!-modulus:=p;
    modulus!/2 := p/2;
    return previous!-modulus
  end;
*** set-small-modulus not defined (LOSE flag) 
nil


inline procedure modular!-plus(a,b);
  begin scalar result;
     result:=a #+ b;
     if not(result #< current!-modulus) then
            result:=result #- current!-modulus;
     return result
  end;
*** modular-plus not defined (LOSE flag) 
nil

inline procedure modular!-difference(a,b);
  begin scalar result;
     result:=a #- b;
     if iminusp result then result:=result #+ current!-modulus;
     return result
  end;
*** modular-difference not defined (LOSE flag) 
nil

symbolic procedure modular!-number a;
  begin
     if not atom a then typerr(a,"integer in modular-number");
     a:=remainder(a,current!-modulus);
     if iminusp a then a:=a #+ current!-modulus;
     return a
  end;
*** modular-number not defined (LOSE flag) 
nil

inline procedure modular!-times(a,b);
    remainder(a*b,current!-modulus);
*** modular-times not defined (LOSE flag) 
nil

symbolic procedure modular!-reciprocal a;
   if !*balanced_mod and a<0
     then reciprocal!-by!-gcd(current!-modulus,
                              a #+ current!-modulus,0,1)
    else reciprocal!-by!-gcd(current!-modulus,a,0,1);
*** modular-reciprocal not defined (LOSE flag) 
nil

symbolic procedure reciprocal!-by!-gcd(a,b,x,y);
%On input A and B should be coprime. This routine then
%finds X and Y such that A*X+B*Y=1, and returns the value Y
%on input A > B;
   if b=0 then rerror(alg,10,"Invalid modular division")
   else if b=1 then if iminusp y then y #+ current!-modulus else y
   else begin scalar w;
%N.B. Invalid modular division is either:
% a)  attempt to divide by zero directly
% b)  modulus is not prime, and input is not
%     coprime with it;
     w:= a #/ b; %Truncated integer division;
     return reciprocal!-by!-gcd(b,a #- b #* w,
                                y,x #- y #* w)
   end;
+++ reciprocal!-by!-gcd compiled, 60 + 36 bytes
reciprocal-by-gcd

symbolic procedure safe!-modular!-reciprocal a;
   if !*balanced_mod and a<0
     then safe!-reciprocal!-by!-gcd(current!-modulus,
                              a #+ current!-modulus,0,1)
    else safe!-reciprocal!-by!-gcd(current!-modulus,a,0,1);
*** safe-modular-reciprocal not defined (LOSE flag) 
nil

symbolic procedure safe!-reciprocal!-by!-gcd(a,b,x,y);
%On input A and B should be coprime. This routine then
%finds X and Y such that A*X+B*Y=1, and returns the value Y
%on input A > B. If a and b are not coprime return NIL not an error; 
   if b=0 then nil
   else if b=1 then if iminusp y then y #+ current!-modulus else y
   else begin scalar w;
%N.B. Invalid modular division is either:
% a)  attempt to divide by zero directly
% b)  modulus is not prime, and input is not
%     coprime with it;
     w:= a #/ b; %Truncated integer division;
     return safe!-reciprocal!-by!-gcd(b,a #- b #* w,
                                      y,x #- y #* w)
   end;
+++ safe!-reciprocal!-by!-gcd compiled, 52 + 20 bytes
safe-reciprocal-by-gcd

inline procedure modular!-quotient(a,b);
    modular!-times(a,modular!-reciprocal b);
*** modular-quotient not defined (LOSE flag) 
nil


inline procedure modular!-minus a;
    if a=0 then a else current!-modulus #- a;
*** modular-minus not defined (LOSE flag) 
nil

symbolic procedure modular!-expt(a,n);
   % Computes a**n modulo current-modulus.  Uses Fermat's Little
   % Theorem where appropriate for a prime modulus.
    if n=0 then 1
    else if n=1 then a
    else if n>=current!-modulus-1 and primep current!-modulus
     then modular!-expt(a,remainder(n,current!-modulus-1))
    else begin scalar x;
     x:=modular!-expt(a,n/2);
     x:=modular!-times(x,x);
     if not(remainder(n,2)=0) then x:=modular!-times(x,a);
     return x
    end;
*** modular-expt not defined (LOSE flag) 
nil

symbolic set!-modulus(1) ;nil % forces everything into a standard state.

endmodule;nil

end;nilmodule zfactor;nil  % Integer factorization.

% Author: Julian Padget.
% Modifications by: Fran Burstall, John Abbott, Herbert Melenk,
%                   Arthur Norman.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


exports nextprime, primep, zfactor, zfactor1, nrootnn;nil

% nextprime - returns the next prime GREATER than its argument;
% primep - determines whether argument is prime or not;
% zfactor - returns an alist of factors dotted with their multiplicities

imports evenp, gcdn, general!-modular!-expt, general!-modular!-times,
idifference, igreaterp, ilessp, iplus2, iroot, isqrt, leq,
modular!-expt, modular!-times, neq, prepf, prin2t, random, reversip,
set!-general!-modulus, set!-modulus, set!-small!-modulus, typerr;nil

% needs bigmod,smallmod;
%
% internal-functions add-factor, general-primep, mcfactor!*,
% internal-primep, mcfactor, small-primep;

% Parameters to this module are:
%
%    !*maxtrys!* - controls the maximum number of attempts to be made
%        at factorisation (using mcfactor) whilst varying the polynomial
%        used as part of the Monte-Carlo technique.  When !*maxtrys!* is
%        exceeded assumes n is prime (case will most likely occur when
%        primality test fails).
%
%    !*mod!* - controls the modulus of the numbers emitted by the random
%        number generator.  It is important that the number being tested
%        for primality should lie in [0,!*mod!*].
%
% Globals private to this module are:
%
%    !*primelist!* - a list of the first xxx prime numbers used in the
%        first part of the factorization where trial division is
%        employed.
%
%    !*last!-prime!-in!-list!* - the largest prime in the !*primelist!*

fluid '(!*maxtrys!*);nil

!*maxtrys!*:=10;10

global '(!*last!-prime!-squared!* !*primelist!*
         !*last!-prime!-in!-list!* largest!-small!-modulus);nil

!*primelist!*:='(
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191
193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283
293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401
409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509
521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631
641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751
757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877
881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009
1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093
1097 1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187 1193 1201
1213 1217 1223 1229 1231 1237 1249 1259 1277 1279 1283 1289 1291 1297
1301 1303 1307 1319 1321 1327 1361 1367 1373 1381 1399 1409 1423 1427
1429 1433 1439 1447 1451 1453 1459 1471 1481 1483 1487 1489 1493 1499
1511 1523 1531 1543 1549 1553 1559 1567 1571 1579 1583 1597 1601 1607
1609 1613 1619 1621 1627 1637 1657 1663 1667 1669 1693 1697 1699 1709
1721 1723 1733 1741 1747 1753 1759 1777 1783 1787 1789 1801 1811 1823
1831 1847 1861 1867 1871 1873 1877 1879 1889 1901 1907 1913 1931 1933
1949 1951 1973 1979 1987 1993 1997 1999 2003 2011 2017 2027 2029 2039
2053 2063 2069 2081 2083 2087 2089 2099 2111 2113 2129 2131 2137 2141
2143 2153 2161 2179 2203 2207 2213 2221 2237 2239 2243 2251 2267 2269
2273 2281 2287 2293 2297 2309 2311 2333 2339 2341 2347 2351 2357 2371
2377 2381 2383 2389 2393 2399 2411 2417 2423 2437 2441 2447 2459 2467
2473 2477 2503 2521 2531 2539 2543 2549 2551 2557 2579 2591 2593 2609
2617 2621 2633 2647 2657 2659 2663 2671 2677 2683 2687 2689 2693 2699
2707 2711 2713 2719 2729 2731 2741 2749 2753 2767 2777 2789 2791 2797
2801 2803 2819 2833 2837 2843 2851 2857 2861 2879 2887 2897 2903 2909
2917 2927 2939 2953 2957 2963 2969 2971 2999 3001 3011 3019 3023 3037
3041 3049 3061 3067 3079 3083 3089 3109 3119 3121 3137 3163 3167 3169
3181 3187 3191 3203 3209 3217 3221 3229 3251 3253 3257 3259 3271 3299
3301 3307 3313 3319 3323 3329 3331 3343 3347 3359 3361 3371 3373 3389
3391 3407 3413 3433 3449 3457 3461 3463 3467 3469 3491 3499 3511 3517
3527 3529 3533 3539 3541 3547 3557 3559 3571 )$(2 3 5 7 11 13 17 19 23 29 31 37
41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149
151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257
263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379
383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499
503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631
641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761
769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907
911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031
1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129
1151 1153 1163 1171 1181 1187 1193 1201 1213 1217 1223 1229 1231 1237 1249 1259
1277 1279 1283 1289 1291 1297 1301 1303 1307 1319 1321 1327 1361 1367 1373 1381
1399 1409 1423 1427 1429 1433 1439 1447 1451 1453 1459 1471 1481 1483 1487 1489
1493 1499 1511 1523 1531 1543 1549 1553 1559 1567 1571 1579 1583 1597 1601 1607
1609 1613 1619 1621 1627 1637 1657 1663 1667 1669 1693 1697 1699 1709 1721 1723
1733 1741 1747 1753 1759 1777 1783 1787 1789 1801 1811 1823 1831 1847 1861 1867
1871 1873 1877 1879 1889 1901 1907 1913 1931 1933 1949 1951 1973 1979 1987 1993
1997 1999 2003 2011 2017 2027 2029 2039 2053 2063 2069 2081 2083 2087 2089 2099
2111 2113 2129 2131 2137 2141 2143 2153 2161 2179 2203 2207 2213 2221 2237 2239
2243 2251 2267 2269 2273 2281 2287 2293 2297 2309 2311 2333 2339 2341 2347 2351
2357 2371 2377 2381 2383 2389 2393 2399 2411 2417 2423 2437 2441 2447 2459 2467
2473 2477 2503 2521 2531 2539 2543 2549 2551 2557 2579 2591 2593 2609 2617 2621
2633 2647 2657 2659 2663 2671 2677 2683 2687 2689 2693 2699 2707 2711 2713 2719
2729 2731 2741 2749 2753 2767 2777 2789 2791 2797 2801 2803 2819 2833 2837 2843
2851 2857 2861 2879 2887 2897 2903 2909 2917 2927 2939 2953 2957 2963 2969 2971
2999 3001 3011 3019 3023 3037 3041 3049 3061 3067 3079 3083 3089 3109 3119 3121
3137 3163 3167 3169 3181 3187 3191 3203 3209 3217 3221 3229 3251 3253 3257 3259
3271 3299 3301 3307 3313 3319 3323 3329 3331 3343 3347 3359 3361 3371 3373 3389
3391 3407 3413 3433 3449 3457 3461 3463 3467 3469 3491 3499 3511 3517 3527 3529
3533 3539 3541 3547 3557 3559 3571)

!*last!-prime!-in!-list!* := car reverse !*primelist!*;3571

!*last!-prime!-squared!* := !*last!-prime!-in!-list!*^2;12752041

symbolic procedure add!-factor(n,l);
   (lambda (p); if p then << rplacd(p,add1 cdr p); l>> else (n . 1) . l)
      if pairp l then if n>(caar l) then nil else assoc(n,l) else nil;
+++ add!-factor redefined
+++ add!-factor compiled, 35 + 12 bytes
add-factor

symbolic procedure zfactor n; zfactor1(n,t);
+++ zfactor redefined
+++ zfactor compiled, 4 + 16 bytes
zfactor

symbolic procedure zfactor1(n,bool);
   % If bool is NIL, mcfactor!* isn't used.
   if n<0 then ((-1) . 1) . zfactor1(-n,bool)
    else if n<4 then list(n . 1)
    else begin scalar primelist,factor!-list,p,qr;
       primelist := !*primelist!*;
       factor!-list := nil;
       while primelist do
        <<p := car primelist; primelist := cdr primelist;
          while cdr(qr := divide(n, p)) = 0 do
            <<n:= car qr; factor!-list:= add!-factor(p,factor!-list)>>;
       if n neq 1 and p*p>n
         then <<primelist := nil;
                factor!-list:=add!-factor(n,factor!-list);
                n := 1>>>>;
       return if n=1 then factor!-list
               else if null bool then (n . 1) . factor!-list
               else mcfactor!*(n,factor!-list)
     end;
+++ zfactor1 redefined
+++ zfactor1 compiled, 110 + 36 bytes
zfactor1

symbolic procedure mcfactor!*(n,factors!-so!-far);
   if internal!-primep n then add!-factor(n,factors!-so!-far)
    else <<n:=(lambda (p,tries); <<
         while (atom p) and (tries<!*maxtrys!*) do <<
            tries:=tries+1;
            p:=mcfactor(n,tries)>>;
         if tries>!*maxtrys!* then <<
            prin2 "ZFACTOR(mcfactor!*): Assuming ";
            prin2 n; prin2t " is prime";
            p:=list n>>
         else p>>)
          (mcfactor(n,1),1);
   if atom n then add!-factor(n,factors!-so!-far)
   else if car n < cdr n then
      mcfactor!*(cdr n,mcfactor!*(car n,factors!-so!-far))
   else mcfactor!*(car n,mcfactor!*(cdr n,factors!-so!-far))>>;
+++ mcfactor!* compiled, 86 + 44 bytes
mcfactor*

symbolic procedure mcfactor(n,p);
% Based on "An Improved Monte-Carlo Factorisation Algorithm" by
% R.P.Brent in BIT 20 (1980) pp 176-184.  Argument n is the number to
% factor, p specifies the constant term of the polynomial.  There are
% supposed to be optimal p's for each n, but in general p=1 works well.
begin scalar gg,k,m,q,r,x,y,ys;
   m := 20;
   y:=0; r:=q:=1;
outer:
   x:=y;
   for i:=1:r do y:=remainder(y*y+p,n);
   k:=0;
inner:
   ys:=y;
   for i:=1:(if m<(r-k) then m else r-k) do <<
      y:=remainder(y*y+p,n);
      q:=remainder(q*abs(x-y),n)
   >>;
   gg:=gcdn(q,n);
   k:=k+m;
   if (k<r) and (gg leq 1) then goto inner;
   r:=2*r;
   if gg leq 1 then goto outer;
   if gg=n then begin
   loop:
      ys:=remainder(ys*ys+p,n);
      gg:=gcdn(abs(x-ys),n);
      if gg leq 1 then goto loop
   end;
   return if gg=n then n else gg . (n/gg)
end;
+++ mcfactor compiled, 162 + 24 bytes
mcfactor

global '(has!-primep64!*);nil
has!-primep64!* := not null getd 'primep64;t

symbolic procedure primep n;
% Returns T if n is prime (an integer that is not zero or a unit).
   if not fixp n then typerr(n,"integer")
    else if n<0 then primep(-n)
% CSL now has a built-in function primep64 that can test any integer up to
% 64-bits (unsigned)...
    else if has!-primep64!* and n < 0x10000000000000000 then primep64 n
    else if n <= 0xffffffff and
            n <= largest!-small!-modulus then primep32 n
    else if evenp n or
       remainder(n,3) = 0 or
       remainder(n,5) = 0 or
       remainder(n,7) = 0 then nil
% I will always start with a test using base 2.
    else if not general!-miller!-rabin(2, n) then nil
% If n < 2^64 one can guarantee correct results by using a special set of 7
% witness values determined by Sinclair in 2011. In a while I intend to
% replace this with a hashed version using a smaller number of bases.
% but providing a correct version first seems good, even though in this
% form the BPSW general case might in fact be faster.
    else if n < 0x10000000000000000 then
      general!-miller!-rabin(325, n) and
      general!-miller!-rabin(9375, n) and
      general!-miller!-rabin(28178, n) and
      general!-miller!-rabin(450775, n) and
      general!-miller!-rabin(9780504, n) and
      general!-miller!-rabin(1795265022, n)
% For yet larger cases I use BPSW, which follows up the base 2 Miller Rabin
% with a Strong Lucas test. This is certainly known to give correct answers
% up to 2^64, and while it is expected that there will be BPSW-pseudoprimes
% there are (at the time of writing) no known ones at all, and some estimates
% that the smallest may be greater than 10^10000
% (http://mathworld.wolfram.com/Baillie-PSWPrimalityTest.html).
    else lucas_test n;
+++ primep compiled, 125 + 92 bytes
primep

flag('(primep),'boolean);nil

symbolic procedure internal!-primep n;
   primep n;
+++ internal!-primep compiled as link to primep
internal-primep

% The next few functions are ones that could be implemented within the
% Lisp system (at least if its bignum representation was in binary!) in
% rather easy ways. The code here can serve as an explanation and a
% reference implementation.

% My initial idea here had been that if there were functions that might
% be built in to SOME but not ALL of the Lisp system then I could guard
% portable definitions with "#if (not (getd 'foo))". That is a good idea,
% but if fails when a bootstrap bersion of Reduce is built (thereby
% defining the function) and that is then used to build the final version
% of the module. To cope with that I arrange that when I define a portable
% version of a function I flag its name with 'rlisp, and then during the
% final definitive build I will see that and understand that I need to
% instate it.

#if (or (not (getd 'lsd)) (flagp 'lsd 'rlisp))

% Find least significant bit of an integer. c.f. msd and integer!-length,
% and before using any of these check whether counting treats the lowest bit
% of a number as "bit 0" or as "bit 1". This function and msd treat it as
% "bit 1" which is what Reduce historically wanted. But logbitp uses a
% zero-based bit labelling.

symbolic procedure lsd n;
  begin
    scalar r;
    if n = 0 then return 0;
    r := 1;
    while land(n, 0xffffffffffffffff) = 0 do <<
      n := lshift(n, -64);
      r := r + 64 >>;
    if land(n, 0xffffffff) = 0 then << n := lshift(n, -32); r := r + 32 >>;
    if land(n, 0xffff) = 0 then << n := lshift(n, -16); r := r + 16 >>;
    if land(n, 0xff) = 0 then << n := lshift(n, -8); r := r + 8 >>;
    if land(n, 0xf) = 0 then << n := lshift(n, -4); r := r + 4 >>;
    if land(n, 0x3) = 0 then << n := lshift(n, -2); r := r + 2 >>;
    if land(n, 0x1) = 0 then r := r + 1;
    return r;
  end;

flag('(lsd), 'rlisp);

#endif

#if (or (not (getd 'logbitp)) (flagp 'logbitp 'rlisp))

% Test if bit i is set in the binary representation of n. I rather expect
% that for large i this will yield true when n is negative, as one would
% expect if the notional representation of a negative number (in 2s
% complement representation) has an unending sequence of leading 1 bits.

symbolic procedure logbitp(i, n);
  not zerop land(n, lshift(1, i));

flag('(logbitp), 'rlisp);

#endif

#if (or (not (getd 'integer!-length)) (flagp 'integer!-length 'rlisp))

% Determine the number of bits needed to represent an integer in binary. For
% negative numbers this is the number of bits not counting the sign bit... a
% convention adopted by Common Lisp. Thus the results should be
%        integer!-length -6  =>  3
%        integer!-length -5  =>  3
%        integer!-length -4  =>  2
%        integer!-length -3  =>  2
%        integer!-length -2  =>  1
%        integer!-length -1  =>  0
%        integer!-length 0   =>  0
%        integer!-length 1   =>  1
%        integer!-length 2   =>  2
%        integer!-length 3   =>  2
%        integer!-length 4   =>  3
%        integer!-length 5   =>  3
%        integer!-length 6   =>  3

symbolic procedure integer!-length n;
  begin
    scalar r;
    if n < 0 then n := -n-1;
    if n = 0 then return 0;
    r := 1;
% I shift in chunks of 64 first
    while n >= 0x10000000000000000 do <<
       n := lshift(n, -64);
       r := r + 64 >>;
    if n >= 0x100000000 then << n := lshift(n, -32), r := r + 32 >>;
    if n >= 0x10000 then << n := lshift(n, -16), r := r + 16 >>;
    if n >= 0x100 then << n := lshift(n, -8), r := r + 8 >>;
    if n >= 0x10 then << n := lshift(n, -4), r := r + 4 >>;
    if n >= 0x4 then << n := lshift(n, -2), r := r + 2 >>;
    if n >= 0x2 then r := r + 1;
    return r
  end;

flag('(integer!-length), 'rlisp);

#endif

global '(witness!-table oddprime!-bitmap);nil

% This is a table of 64 32-bit integers, so 2048 bits in all, reporting
% whioch of the odd numbers up to 4096 are prime using a simple bitmap
% lookup.

oddprime!-bitmap := list!-to!-vector
  '(0x64b4cb6e  0x816d129a  0x864a4c32  0x2196820d  0x5a0434c9  0xa4896120 
    0x29861144  0x4a2882d1  0x32424030  0x08349921  0x4225064b  0x148a4884 
    0x6c304205  0x0b40b408  0x125108a0  0x65048928  0x804c3098  0x80124496 
    0x41124221  0xc02104c9  0x00982d32  0x08044900  0x82689681  0x220825b0 
    0x40a28948  0x90042659  0x30434006  0x69009244  0x08088210  0x12410da4 
    0x2400c060  0x086122d2  0x821b0484  0x0110d301  0xc044a002  0x14916022 
    0x04a6400c  0x092094d2  0x00522094  0x4ca21008  0x51018200  0xa48b0810 
    0x44309a25  0x034c1081  0x80522502  0x20844908  0x18003250  0x241140a2 
    0x01840128  0x0a41a001  0x36004512  0x29260008  0xc0618283  0x10100480 
    0x4822006d  0xc20c2658  0x24894810  0x45205820  0x19002488  0x10c02502 
    0x01140868  0x802832ca  0x264b0400  0x60901300);[1689570158 2171409050
2253016114 563511821 1510225097 2760466720 696652100 1244168913 843202608
137664801 1109722699 344606852 1815101957 188789768 307300512 1694796072
2152476824 2148680854 1091715617 3223389385 9973042 134498560 2187892353
570959280 1084393800 2416191065 809713670 1761645124 134775312 306253220
604029024 140583634 2182808708 17879809 3225722882 345071650 78004236 153130194
5382292 1285689352 1359053312 2760574992 1144035877 55316609 2152867074
545540360 402666064 605110434 25428264 172072961 905987346 690356232 3227615875
269485184 1210187885 3255576152 612976656 1159747616 419439752 281027842
18090088 2150118090 642450432 1620054784] 

% All the values in this table are in fact 16-bit unsigned integers. See
% the directory csl/cslbase/mr in the Reduce source tree for further
% commentary and explanation.

witness!-table := list!-to!-vector
  '(17490   5756   7143  10476  13223   5143  54949  46324  11327  21776 
       14  11348   1837  11945  17130    814  24668  27778  29292  12320 
    27999  24665    217   2136    370  15513  11577  11464   9734   5117 
     4796  11231   1760   9541  13930   1807  10976  11212  46077  10885 
    13981    148    415   4031  26689   9236   2257  14300    183   6148 
    31088   7970   6283    556   2674   6442   3501  17049  20938  44337 
     7812   4627  21294   6768   5134  40093   4662    774  12178  10453 
    16975  20017   3405  32346  11745    294  14936  20713   3371  13471 
     3728   4090  40339  57759  22007   1115  24211  10564  13850  11754 
     2278   5745  16753  51913  13076   1160   2581  13858  13147   1072 
    44224   5022   1417  19493  39737   6276   6792   4207   6345  40285 
    23786  51941   4542   3302   9249   6428  35246   4981   9628   9231 
    23685  15481   2335  34333  27605  11926   6602   6167   2161   6073 
    10601   4248  46263   2678   6247   8332   5569   4439  50964   2326 
    17596   1511  43893  11640   2691  40811   4676  32329   3214  18961 
     9118   3713  41097   4067   9690   8901   3074     67   3153    985 
    33378   8698  16533  41199  47465  47912  21939  21286    652  21348 
    12998   3723   1294   8768   7897  60772   9880  25647   5644   1481 
    16626   1608  16379  25558    176   5553  17031   9330   6323   2764 
     5798   4108   6234  51499  19125   1845  22910   9111   5817  55318 
     2221   7784  13964  46759   3442  14692   6748   6657   7293   1576 
      330  27166   1625  10388  16052   6421);[17490 5756 7143 10476 13223 5143
54949 46324 11327 21776 14 11348 1837 11945 17130 814 24668 27778 29292 12320
27999 24665 217 2136 370 15513 11577 11464 9734 5117 4796 11231 1760 9541 13930
1807 10976 11212 46077 10885 13981 148 415 4031 26689 9236 2257 14300 183 6148
31088 7970 6283 556 2674 6442 3501 17049 20938 44337 7812 4627 21294 6768 5134
40093 4662 774 12178 10453 16975 20017 3405 32346 11745 294 14936 20713 3371
13471 3728 4090 40339 57759 22007 1115 24211 10564 13850 11754 2278 5745 16753
51913 13076 1160 2581 13858 13147 1072 44224 5022 1417 19493 39737 6276 6792
4207 6345 40285 23786 51941 4542 3302 9249 6428 35246 4981 9628 9231 23685 15481
2335 34333 27605 11926 6602 6167 2161 6073 10601 4248 46263 2678 6247 8332 5569
4439 50964 2326 17596 1511 43893 11640 2691 40811 4676 32329 3214 18961 9118
3713 41097 4067 9690 8901 3074 67 3153 985 33378 8698 16533 41199 47465 47912
21939 21286 652 21348 12998 3723 1294 8768 7897 60772 9880 25647 5644 1481 16626
1608 16379 25558 176 5553 17031 9330 6323 2764 5798 4108 6234 51499 19125 1845
22910 9111 5817 55318 2221 7784 13964 46759 3442 14692 6748 6657 7293 1576 330
27166 1625 10388 16052 6421]

fluid '(!*trace_primep);nil
!*trace_primep := nil;nil

symbolic procedure primep32 n;
  begin integer l,m,x,y,w,save; scalar result;
% First deal with any input up to 4096 using simple table look-up. That
% should be very fast!
    if n < 0 then n := -n; % sShould not arise, but done here to be safe.
    if n <= 4096 then <<
      if !*trace_primep then
        printf("%fTesting %w. <= 4096 so use table lookup%n", n);
      if evenp n then return (n = 2)
      else return logbitp(remainder(n/2, 32), getv(oddprime!-bitmap,n/64)) >>
% Now if I look at the number modulo 42 I can detect cases where the
% input is a multiple of 2, 3 or 7. logbitp uses the "magic" integer constant
% here as a vector of bits to look up the result in.
    else if logbitp(remainder(n, 42), 0x000001df5d75d7dd) then return nil
% In a similar way multiples of 5 and 11 can be filtered out.
    else if logbitp(remainder(n, 55), 0x0004310a42508c21) then return nil;
% Now I have a value over 4096 that does not have any factors lower than 13.
% The next 3 lines compute a hash function and use it to extract a
% witness from a carefully pre-computed table so that the Miller Rabin test
% will be reliable on all integers up to 2^32 that have not already been
% sorted out by special cases above.
% The next line has as its intent "multiply n but the given 64-bit
% constant and only keep the low 64 bits of the result".
    w := 0x8bd03fd5cb49666b*n;
% I now have a 64-bit intermediate value. I shift it right by 31 bits to
% discard low order bits and then take the remainder by my table size. I
% need to do the mask operation here to ger results that match the C code,
% because a case ti (unsigned int) has effects that were in fact not what I
% had probably first intended! But that are what the hash table is built
% to work with.
    w := land(lshift(w, -31), 0xffffffff); % Leaves a positive result.
    w := remainder(w, 216);
    if !*trace_primep then printf("%fTesting %w which hashes to %w,", n, w);
    w := getv(witness!-table, w);
    if !*trace_primep then printf(" so use base %w%n", w);
% Start implementation of Miller-Rabin... which will only be use on
% numbers up to largest!-small!-modulus.
    save := set!-small!-modulus n;
    m := n-1;
% Express n-1 = (2^l)*m
%      l:=0;
%      while evenp m do <<m := m/2; l := l+1>>;
    l := sub1 lsd m;
    m := m / lshift(1, l);
    x := modular!-expt(w, m);
    if !*trace_primep then printf("%w = %w * %w, and %w^%w = %w%n",
       n-1, m, lshift(1, l), w, m, x);
    result:=t;
    if x neq 1 then <<
      for k:=1:l do <<
        y := modular!-times(x,x);
        if !*trace_primep then <<
          m := 2*m;
          printf("%w^%w = %w%n", w, m, y) >>;
        if y=1 and x neq (n-1) and x neq 1 then result := nil
        else x := y >>;
      if x neq 1 then result := nil >>;
    set!-small!-modulus save;
    if !*trace_primep then printf("result is %w%n", result);
    return result
  end;
*** primep32 not defined (LOSE flag) 
nil

% This is a version of primep written by FEB for inclusion in zfactor.
% It has been updated by ACN.

% Test n for primality using Miller-Rabin with base w. This version of the
% code is for used with arbitrarily large inputs, and will in fact just
% be needed when n is at least largest!-small!-modulus.

symbolic procedure general!-miller!-rabin(w, n);
  begin
    scalar m, save, l, result, x, y;
    if !*trace_primep then
      printf("%fGeneral M-R test on %w using base %w%n", m, w);
    m := n-1;
    save := set!-general!-modulus n;
% Express n-1 = (2^l)*m
    l:=0;
    while evenp m do << m := m/2; l := l+1 >>;
    result := t;
% Raise to the odd power.
    x := general!-modular!-expt(w, m);
    if !*trace_primep then
      printf("%w^%w = %w%n", w, m, x);
% From here I can complete the calculation of w^(n-1) by doing a
% sequence of squaring operations.  While I do that I check to see if I
% come across a non-trivial square root of 1, and if I do then I know n
% could not have been prime.
    if x neq 1 then <<
      for k:=1:l do <<
        y := general!-modular!-times(x,x);
        if !*trace_primep then <<
          m := 2*m;
          printf("%w^%w = %w%n", w, m, y) >>;
% It is tolerable to continue round the loop after setting result=nil
% because I will then be repeating a squaring of 1, which is cheap.
        if y=1 and x neq (n-1) and x neq 1 then result := nil
        else x := y >>;
% Also if I do not get to 1 at the end then the number is composite.
         if x neq 1 then result := nil >>;
    set!-general!-modulus save;
    if !*trace_primep then printf("result = %w%n", result);
    return result
  end;
+++ general!-miller!-rabin compiled, 133 + 56 bytes
general-miller-rabin

symbolic procedure general!-primep n;
% Based on an algorithm of M.Rabin published in the Journal of Number
% Theory Vol 12, pp 128-138 (1980).
  begin
    if n < 0 then n := -n;
% Filter out some easy cases first
    if evenp n or
       remainder(n,3) = 0 or
       remainder(n,5) = 0 or
       remainder(n,7) = 0 then return nil;
% I will always start with a test using base 3.
    if not general!-miller!-rabin(2, n) then return nil;
% If n < 2^64 one can guarantee correct results by using a special set of 7
% witness values determined by Sinclair in 2011:
    if n < 0x10000000000000000 then <<
% I will be able to improve on this using hashing, but for now I want
% a version of this code that I dare to check-in.
      if not general!-miller!-rabin(325, n) then return nil;
      if not general!-miller!-rabin(325, n) then return nil;
      if not general!-miller!-rabin(9375, n) then return nil;
      if not general!-miller!-rabin(28178, n) then return nil;
      if not general!-miller!-rabin(9780504, n) then return nil;
      if not general!-miller!-rabin(1795265022, n) then return nil;
      return t >>;
% For yet larger cases I use BPSW, which follows up the base 2 Miller Rabin
% with a Strong Lucas test. This is certainly known to give correct answers
% up to 2^64, and while it is expected that there will be BPSW-pseudoprimes
% there are (at the time of writing) no known ones at all, and some estimates
% that the smallest may be greater than 10^10000
% (http://mathworld.wolfram.com/Baillie-PSWPrimalityTest.html).
    return lucas_test n
  end;
+++ general!-primep compiled, 90 + 64 bytes
general-primep

% The implementation of primep is:
%   up to 2^32     a single Miller-Rabin test with witness selected using
%                  a hash table.
%   up to 2^64     4 Miller-Rabin tests, where the first 3 used fixed bases
%                  but the fourth uses one selected using a hash table.
%                  (at present I use a deterministic set of 7 bases, because
%                  I have not merged in the hashing code).
% The above cases should be 100% reliable.
%   over 2^64      one Miller-Rabin using base 2, followed by one Strong
%                  Lucas test. At the time of writing this (June 2017) I
%                  believe that there are no known cases where this fails,
%                  but it is expected that for large enough numbers there
%                  will be some pseudoprimes. This is the Baillie-PSW test,
%                  and the Lucas part of it is sufficiently more expensive
%                  than a few extra Miller-Rabin rounds that it is not the
%                  scheme of choice for up to 2^64.
% For heavy-duty security-related applications I see suggestions of
% a modest number of Miller-Rabin rounds using reliable random bases,
% followed by a single Lucas test. But current predictions are that the
% code I give here yields correct judgements on all integer inputs with
% up to at least 10000 digits.



% This computes the Jacobi symbol. As in the number theory function
% related to Legendre Symbols and perhaps quadratic residues.

#if (or (not (getd 'jacobi!-symbol)) (flagp 'jacobi!-symbol 'rlisp))

symbolic procedure jacobi!-symbol(a, b);
  if b <= 0 or evenp b then 0
  else begin
    scalar j, r;
    j := 1;
    if a < 0 then <<
      a := -a;
      if land(b, 3) = 3 then j := -j >>;
% a and b are both positive here, so the use of REMAINDER lower down is safe.
    while not zerop a do <<
      while evenp a do <<
        a := a/2;
        if (r := land(b, 7)) = 3 or r = 5 then j := -j >>;
      r := a;
      a := b;
      b := r;
      if land(a, 3) = 3 and land(b, 3) = 3 then j := -j;
      a := remainder(a, b) >>;
    if b = 1 then return j
    else return 0
  end;
+++ jacobi!-symbol compiled, 95 + 36 bytes
jacobi-symbol

flag('(jacobi!-symbol), 'rlisp);nil

#endif

#if (or (not (getd 'is!-perfect!-square)) (flagp 'is!-perfect!-square 'rlisp))

% I expect that this can be be implemented better within the Lisp, among
% other things using the representation of a bignum to generate an initial
% estimate for the square root and folding the final test into the
% square root iteration. But this portable version is neat and concise!

symbolic procedure is!-perfect!-square n;
  n = r*r where r = isqrt n;
+++ is!-perfect!-square compiled, 11 + 12 bytes
is-perfect-square

flag('(is!-perfect!-square), 'rlisp);nil

#endif

% This  code for the Lucas test will only be invoked if small factors
% for c have been rules out. In particular c will certainly be odd. It
% returns true if c is a Lucas probable-prime.

symbolic procedure lucas_test c;
  begin
    scalar d, j, k, kk, u, v, q, qk, l, ll, tmp, savemod;
% Find a proper value for D such that jacobi(d,c)=-1. This is achieved
% by trying the sequence 5, -7, 9, -11, 13, -15, 17, -19, 21, -23,....
% until one works (note that 9 and 25 can not work because they are perfect
% squares, but they are included in the test sequence anyway. It is very much
% expected that almost always a suitable d will be found within the first
% couple of tries. If the input c had been a perfect square then there will
% never be a valid d, so if I am searching for longer than expected I will
% divert and check for that. At present the world believe that even for the
% biggest inputs one could envisage here that the value of d found will be
% small.
    d := 5;
    while (j := jacobi!-symbol(d, c)) > 0 and
          (d neq 21 or not is!-perfect!-square c) do
      if d > 0 then d := -d - 2
      else d := -d + 2;
    if !*trace_primep then printf("%fTest %w using D=%w, j=%w%n", c, d, j);
% j would be zero if d and c had a non-trivial gcd (and hence unless
% |d|=c and d is a prime c is certainly composite. Well in the big picture
% I will only be using this when c > 2^64 and for d to get that large would
% take more time than could possibly be feasible.
% j would be 1 if I exited because c was a perfect square, and again that
% means it is not prime. Well if c = |d| then c might still be a prime!
    if j >= 0 then return (c=abs d and primep32 c);
% The sequence of values for d that are tried guarantee that the divison
% by 4 here is always exact.
    q := (1-d)/4;
    if !*trace_primep then printf("will use P=1, Q=%w%n", q);
% Another cheap test for easy cases that could detect c being composite, and
% where c > 2^24 and d having been found by checking in an arithmetic
% progression means I can not have q prime and q = c.
    if gcdn(c, q) neq 1 then return nil;
    k := c+1;
    savemod := set!-general!-modulus c;
% I now set up a Lucas sequence with initial values u_0=1, v_0=2, u_1=1, v_1=1
% and the general iteration u_{n} = u_{n-1} - q u_{n-2}. In terms of articles
% about Lucas sequences this is the special case where p=1.
    u := 1;
    v := 1;
%-- % For small examples I can compute the Lucas sequence in a naive manner
%-- % and display all the values. This is intended to be useful for comparison
%-- % with the values calculated below using the more sophisticated method.
%-- % The cut-off at 500 is entirely arbitrary, but tabulating more than 500
%-- % lines of sequence would start to get clumsy.
%--     if !*trace_primep then begin
%--       scalar nn, w, u0, u1, ut, v0, v1, vt;
%--       w := c+1;
%-- % I will tabulate the values of k that the doubling method will go via..
%--       while w neq 0 do <<
%--         nn := w . nn;
%--         if evenp w then w := w/2 else w := w-1 >>;
%--       u0 := 0; u1 := 1;
%--       v0 := 2; v1 := 1;
%--       for i := 1:(c+1) do <<
%--         ut := u1 - q*u0;
%--         vt := v1 - q*v0;
%--         u0 := u1; u1 := ut;
%--         v0 := v1; v1 := vt;
%-- % I display k, u_k, v_k and then those two values modulo c, just in the
%-- % cases that should arise in the cleverer doubling code. I will display the
%-- % exact integer values if they are small enough to fit on the line, otherwise
%-- % the annotation "<huge>"
%--         if abs u0 <= 99999999999999999999999999 then ut := u0
%--         else ut := "<huge>";
%--         if abs v0 <= 99999999999999999999999999 then vt := v0
%--         else vt := "<huge>";
%--         if i member nn then printf("%f%w:%t[%w, %w]%t%w %t%w%n",
%--                i, 7, mod(u0, c), mod(v0, c), 24, ut, 51, vt)  >>
%--     end;
% For subsequent arithmetic to work properly I must ensure that even if
% q starts off negative I have a version of it reduced to the range [0,c) to
% work with. Similarly d. The variable qk will hold q^k where k is an index
% into the Lucas sequence. 
    qk := q := general!-modular!-number q;
    d := general!-modular!-number d;
% I will iterate downwards over bits in a binary representation of (c+1).
% well to implement a Strong Lucas Test I need to iterate down until I
% have no more below bits set in k.
    l := sub1 integer!-length k;
    ll := sub1 lsd k;
    if !*trace_primep then
      printf("k=%w uses %w bits and has %w trailing zero bits%n",
             k, add1 l, ll);
% I will first do the part of the Lucas sequence up to where it will have
% used up all the nonzero bits in the representation of k. kk will track how
% far I have gone, and is only needed for trace output but tracking it is
% cheap.
    kk := 1;
    if !*trace_primep then printf "1:     [1, 1]%n"; % Always the start-line!
    while (l := l-1) >= ll do <<
% I can double a subscript in the Lucas sequence using:
%    u_{2k} := u_{k} v_{k}
%    v_{2k} := v_{k}^2 - 2 qk_{k}
%    qk_{2k}:= qk_{k} qk_{k}
% and happily I can do those updates sequentially.
      u := general!-modular!-times(u, v);
      v := general!-modular!-difference(general!-modular!-times(v, v),
                                        general!-modular!-times(2, qk));
      kk := 2*kk;
      qk := general!-modular!-times(qk, qk);
      if !*trace_primep then printf("%f%w: %t[%w, %w] q^k=%w%n", kk, 7, u, v, qk);
if !*trace_primep then printf("(A) l=%w ll=%w k=%w logbit=%w%n", l, ll, k, logbitp(l, k));
% Now I need to do a step whenever there is a "1" bit in the binary
% representation of k.
      if logbitp(l, k) then <<
% The rule used here is:
%    u_{k+1} = (u_{k} + v_{k})/2
%    v_{k+1} = (d u_{k} + v_{k})/2
%    qk_{k+1}= q qk_{k}
% and again all the arithmetic is to be done modulo c. I need a temporary
% veriable when updating u and v since each depends on the other.
        tmp := general!-modular!-plus(u, v);
        v := general!-modular!-plus(general!-modular!-times(d, u), v);
        u := tmp;
% Dividing by 2 when I have an even modulus is something I can write out
% in-line here rather easily, and I expect this to be nicer than using
% general!-modular!-quotient or even that having computed a modular reciprocal of 2
% and doing a modular multiplication by it.
        if not evenp u then u := u + c;
        u := u/2;
        if not evenp v then v := v + c;
        v := v/2;
        kk := kk+1;
        qk := general!-modular!-times(q, qk);
        if !*trace_primep then printf("%f%w: %t[%w, %w] q^k=%w%n", kk, 7, u, v, qk)
      >>
    >>;
% From now on I will only do doubling operations, and they are of the form
%      u := u*v;
% so if u is zero now I can be certain that it will be at the end, and the
% Regular (as distinct from Strong) Lucas test will be passed.
    if u = 0 then <<
      if !*trace_primep then printf("u=0 so value is probably prime%n");
      set!-general!-modulus savemod;
      return t >>; % Probably prime!
% Now all the rest of the Lucas sequence is done using just the "doubling"
% process. But I am no longer interested in u.
    if !*trace_primep then <<
      printf("After final non-doubling step u = %w%n", u);
      printf("Will just do doubling steps from now on...%n") >>;
    while v neq 0 and (l := l-1) >= 0 do <<
% I can again double a subscript in the Lucas sequence using:
%    v_{2k} := v_{k}^2 - 2 qk_{k}
%    qk_{2k}:= qk_{k} qk_{k}
      v := general!-modular!-difference(general!-modular!-times(v, v),
                                        general!-modular!-times(2, qk));
      kk := 2*kk;
      qk := general!-modular!-times(qk, qk);
% I do not compute u here because at each stage I just multiply u by v. If
% I have a prime then this is a field multiplication and u can only end up zero
% if some v is zero.
      if !*trace_primep then printf("%f%w: %t[??, %w] qk=%w%n", kk, 7, v, qk);
if !*trace_primep then printf("(B) l=%w ll=%w k=%w logbit=%w%n", l, ll, k, logbitp(l, k));
    >>;
if !*trace_primep then printf("exit loop with l = %w and v = %w%n", l, v);
% If at this point v=0 then c is a Strong Lucas Probable-prime using the
% values p=1 and q as derived here.
    set!-general!-modulus savemod;
    return (v = 0)
  end;
+++ lucas_test compiled, 458 + 148 bytes
lucas_test



% The next function comes from J.H. Davenport.

symbolic procedure nextprime p;
   % Returns the next prime number bigger than p.
   if null p or p=0 or p=1 or p=-1 or p=-2 then 2
    else if p=-3 then -2
    else if not fixp p then typerr(!*f2a p,"integer")
    else begin
       if evenp p then p:=p+1 else p:=p+2;
       while not primep p do p:=p+2;
       return p
   end;
+++ nextprime compiled, 70 + 48 bytes
nextprime

put('nextprime,'polyfn,'nextprime);nextprime

% The following definition has been added by Herbert Melenk.

symbolic procedure nrootnn(n,x);
   % N is an integer, x a positive integer. Value is a pair
   % of integers r,s such that r*s**(1/x)=n**(1/x). The decomposition
   % may be incomplete if the number is too big. The extraction of
   % the members of primelist* is complete.
   begin scalar pl,signn,qr,w; integer r,s,p,q;
     r := 1; s := 1;
     if n<0 then <<n := -n; if evenp x then signn := t else r := -1>>;
     pl:= !*primelist!*;
loop:
     p:=car pl; pl:=cdr pl; q:=0;
     while cdr (qr:=divide(n,p))=0 do <<n:=car qr; q:=q #+ 1>>;
     if not (q #< x) then
         <<w:=divide(q,x); r:=r*(p**car w); q:=cdr w>>;
     while q #> 0 do <<s:=s*p; q:=q #- 1>>;
     if car qr < p then << s:=n*s; goto done>>;
     if pl then goto loop;
       % heuristic bound for complete factorization.
     if 10^20 > n then
     <<q:=mcfactor!*(n,nil);
       for each j in q do
         <<w := divide(cdr j,x);
           r := car j**car w*r;
           s := car j**cdr w*s>>;
     >>
      else if (q:=iroot(n,x)) then r:=r*q
      else s:=n*s;
done:
     if signn then s := -s;
     return r . s
   end;
+++ nrootnn redefined
+++ nrootnn compiled, 180 + 44 bytes
nrootnn

endmodule;nil

end;nilmodule sort;nil  % A simple sorting routine.

% Author: Arthur C. Norman.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


symbolic procedure sort(l,pred);
   % Sort the list l according to the given predicate.  If l is a list
   % of numbers then the predicate "lessp" will sort the list into
   % ascending order.  The predicate should be a strict inequality,
   % i.e. it should return NIL if the two items compared are equal.  As
   % implemented here SORT just calls STABLE-SORT, but as a matter of
   % style any use where the ordering of incomparable items in the
   % output matters ought to use STABLE!-SORT directly, thereby
   % allowing the replacement of this code with a faster non-stable
   % method. (Note: the previous REDUCE sort function also happened to
   % be stable, so this code should give exactly the same results for
   % all calls where the predicate is self-consistent and never has
   % both pred(a,b) and pred(b,a) true).
   stable!-sortip(append(l, nil), pred);
*** sort not defined (LOSE flag) 
nil

symbolic procedure stable!-sort(l,pred);
   % Sorts a list, as SORT, but if two items x and y in the input list
   % satisfy neither pred(x,y) nor pred(y,x) [i.e. they are equal so far
   % as the given ordering predicate is concerned] this function
   % guarantees that they will appear in the output list in the same
   % order that they were in the input.
   stable!-sortip(append(l, nil), pred);
*** stable-sort not defined (LOSE flag) 
nil

symbolic procedure stable!-sortip(l, pred);
   % As stable!-sort, but over-writes the input list to make the output.
   % It is not intended that people should call this function directly:
   % it is present just as the implementation of the main sort
   % procedures defined above.
   begin scalar l1,l2,w;
      if null l then return l;    % Input list of length 0
      l1 := l;
      l2 := cdr l;
      if null l2 then return l;   % Input list of length 1
      % Now I have dealt with the essential special cases of lists of
      % length 0 and 1 (which do not need sorting at all).  Since it
      % possibly speeds things up just a little I will now have some
      % fairly ugly code that makes special cases of lists of length 2.
      % I could easily have special code for length 3 lists here (and
      % include it, but commented out), but at present my measurements
      % suggest that the speed improvement that it gives is minimal and
      % the increase in code bulk is large enough to give some pain.
      l := cdr l2;
      if null l then <<           % Input list of length 2
         if apply2(pred, car l2, car l1) then <<
            l := car l1;
            rplaca(l1, car l2);
            rplaca(l2, l) >>;
       return l1 >>;
      % Now I will check to see if the list is in fact in order already
      % Doing so will have a cost - but sometimes that cost will be
      % repaid when I am able to exit especially early.  The result of
      % all this is that I will have a best case behaviour with linear
      % cost growth for inputs that are initially in the correct order,
      % while my average and worst-case costs will increase by a
      % constant factor.
      l := l1;
      % In the input list is NOT already in order then I expect that
      % this loop will exit fairly early, and so will not contribute
      % much to the total cost.  If it exits very late then probably in
      % the next recursion down the first half of the list will be
      % found to be already sorted, and again I have a chance to win.
      while l2 and not apply2(pred, car l2, car l) do
         <<l := l2; l2 := cdr l2 >>;
      if null l2 then return l1;
      l2 := l1;
      l := cddr l2;
      while l and cdr l do << l2 := cdr l2; l := cddr l >>;
      l := l2;
      l2 := cdr l2;
      rplacd(l, nil);
      % The two sub-lists are then sorted.
      l1 := stable!-sortip(l1, pred);
      l2 := stable!-sortip(l2, pred);
      % Now I merge the sorted fragments, giving priority to item from
      % the earlier part of the original list.
      l := w := list nil;
      while l1 and l2 do <<
         if apply2(pred, car l2, car l1) then <<
            rplacd(w, l2); w := l2; l2 := cdr l2 >>
         else <<rplacd(w, l1); w := l1; l1 := cdr l1>>>>;
      if l1 then l2 := l1;
      rplacd(w,l2);
      return cdr l
  end;
*** stable-sortip not defined (LOSE flag) 
nil

symbolic procedure idsort u;
   % lexicographically sort list of ids.
   sort(u,function idcompare);
+++ idsort redefined
+++ idsort compiled, 4 + 16 bytes
idsort

symbolic procedure idcompare(u,v);
   % compare lexicographical ordering of two ids.
   idcomp1(explode2 u,explode2 v);
+++ idcompare compiled, 11 + 12 bytes
idcompare

symbolic procedure idcomp1(u,v);
   if null u then t
    else if null v then nil
    else if car u eq car v then idcomp1(cdr u,cdr v)
    else orderp(car u,car v);
+++ idcomp1 compiled, 22 + 12 bytes
idcomp1

% Comparison functions and special cases for sorting.

% The next two are now provided in alg/general.red

%symbolic procedure lesspcar(u,v); car u < car v;
%symbolic procedure lesspcdr(u,v); cdr u < cdr v;

symbolic procedure lessppair(a,b);
    if car a = car b then cdr a<cdr b else car a<car b;
+++ lessppair redefined
+++ lessppair compiled, 12 + 8 bytes
lessppair

symbolic procedure greaterpcdr(a,b); cdr a > cdr b;
+++ greaterpcdr redefined
+++ greaterpcdr compiled, 4 + 8 bytes
greaterpcdr

symbolic procedure lesspcdadr(a,b); cdadr a < cdadr b;
+++ lesspcdadr redefined
+++ lesspcdadr compiled, 6 + 8 bytes
lesspcdadr

symbolic procedure lesspdeg(a,b);
   if domainp b then nil else if domainp a then t else ldeg a<ldeg b;
+++ lesspdeg compiled, 19 + 12 bytes
lesspdeg

symbolic procedure ordopcar(a,b); ordop(car a,car b);
+++ ordopcar redefined
+++ ordopcar compiled, 4 + 12 bytes
ordopcar

symbolic procedure orderfactors(a,b);
   if cdr a = cdr b then ordp(car a,car b) else cdr a < cdr b;
+++ orderfactors compiled, 13 + 12 bytes
orderfactors

symbolic procedure sort!-factors l;
   % Sort factors as found into some sort of standard order.  The order
   % used here is more or less random, but will be self-consistent.
   sort(l,function orderfactors);
+++ sort!-factors redefined
+++ sort!-factors compiled, 4 + 16 bytes
sort-factors

endmodule;nil

end;nilmodule reval;nil % Functions for algebraic evaluation of prefix forms.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*combineexpt !*exp !*intstr !*listargs !*mcd !*resimp alglist!*
        dmode!* subfg!* varstack!* frlis!*);nil

switch listargs;nil

global '(!*resubs !*sqvar!* !*val);nil

symbolic procedure reval u;
   reval1(u,t);
+++ reval redefined
+++ reval compiled, 4 + 16 bytes
reval

symbolic procedure aeval u;
   reval1(u,nil);
+++ aeval redefined
+++ aeval compiled, 4 + 12 bytes
aeval

symbolic procedure aeval!* u;
   % This version clears alglist!* to avoid invalid computation in
   % loops.
   begin % scalar alglist!*; rebinding is not enough.
      alglist!* := nil . nil;
      return reval1(u,nil)
   end;
+++ aeval!* redefined
+++ aeval!* compiled, 7 + 16 bytes
aeval*

remprop('revalp, 'simpfg);nil % While building Reduce rmsubs may not yet exist.

switch revalp;nil

on revalp;nil

put('revalp, 'simpfg, '((t (rmsubs))));((t (rmsubs)))

symbolic procedure reval1(u,v);
   if null !*revalp then u
   else
   (begin scalar x,y;
      if null u then return nil   % This may give trouble.
       else if stringp u then return u
       else if fixp u
        then return if flagp(dmode!*,'convert) then reval2(u,v) else u
       else if atom u
        then if null subfg!* then return u
              else if idp u and (x := get(u,'avalue))
               then if u memq varstack!* then recursiveerror u
                     else <<varstack!* := u . varstack!*;
                            return if y := get(car x,'evfn)
                                     then apply2(y,u,v)
                                    else reval1(cadr x,v)>>
              else nil
       else if not idp car u % or car u eq '!*comma!*
      % Dispatch a function on a tagged item. (e.g. a matrix structure)
        then if (x := get(caar u,'structfn)) then return apply(x,{u})
              else errpri2(u,t)
       else if car u eq '!*sq
        then return if caddr u and null !*resimp
                      then if null v then u else prepsqxx cadr u
                     else reval2(u,v)
       else if flagp(car u,'remember) then return rmmbreval(u,v)
       else if flagp(car u,'opfn) then return reval1(opfneval u,v)
       else if x := get(car u,'psopfn)
         then <<u := apply1(x,cdr u);
                if x := get(x,'cleanupfn) then u := apply2(x,u,v);
                return u>>
          % Note that we assume that the results of such functions are
          % always returned in evaluated form.
       else if arrayp car u then return reval1(getelv u,v);
       return if x := getrtype u then
                  if y := get(x,'evfn) then apply2(y,u,v)
                    else rerror(alg,101,
                                list("Missing evaluation for type",x))
               else if not atom u
                     and not atom cdr u
                     and (y := getrtype cadr u)
                     and null(y eq 'list and cddr u) % Don't pass opr to
                                   % list if there is more than one arg.
                     and (x := get(y,'aggregatefn))
                     and (not(x eq 'matrixmap) or flagp(car u,'matmapfn))
                     and not flagp(car u,'boolean)
                     and not !*listargs and not flagp(car u,'listargp)
                then apply2(x,u,v)
               else reval2(u,v)
   end) where varstack!* := varstack!*;
+++ reval1 redefined
+++ reval1 compiled, 309 + 136 bytes
reval1

% I put "hold" here because its purpose is to default much of what reval
% does! The idea is that hold(expression) will encapsulate the un-evaluated
% form of the given expression. Note that that will mean that variables
% referenced in it will not have their values used, and that predefined
% functions and operators etc do not get simplified. It is rather like the
% Lisp "quote" notation. 

symbolic procedure simphold u;
   if length u neq 1 then rederr "hold needs exactly one argument"
   else mksp(if eqcar(car u, '!*hold) then car u
             else list('!*hold, car u), 1) .* 1 .+ nil ./ 1;
+++ simphold compiled, 28 + 28 bytes
simphold

% put('hold, 'simpfn, 'simphold); This clashes with the pm package...
% So users who need this should use !*hold as their keyword for now.
put('!*hold, 'simpfn, 'simphold);simphold

flagop listargp;nil

symbolic procedure rmmbreval(u,v);
 % The leading operator of u is flagged 'remember.
  begin scalar fn,x,w,u1,u2;
   fn := car u;
   u1:={fn}; u2:={fn};
   for each y in cdr u do
   <<w:=reval1(y,nil); u2:=aconc(u2,w);
     if eqcar(w,'!*sq) then w:=!*q2a(cadr w);
     u1:=aconc(u1,w)>>;
   if (x:=assoc(u1,w:=get(fn,'kvalue))) then return cadr x;
     % Evaluate "algebraic procedure" and "algebraic operator" directly.
   if flagp(fn,'opfn) then x:= reval1(opfneval u2,v)
   else if get(fn,'simpfn) then x:=!*q2a1(simp!* u2,v)
   else % All others are passed to reval.
   << remflag({fn},'remember);
      x:=reval1(u2,v);
      flag({fn},'remember);
   >>;
   if not smember(u1,x) and not smember(u2,x)
        then put!-kvalue(fn,get(fn,'kvalue),(car u)
                . foreach uuu in cdr u collect reval uuu,x);
   return x;
  end;
+++ rmmbreval compiled, 172 + 52 bytes
rmmbreval

symbolic procedure remember u;
  % Remember declaration for operator and procedure names.
 for each fn in u do
  <<if not flagp(fn,'opfn) and null get(fn,'simpfn)
        then <<redmsg(fn,"operator"); mkop fn>>;
    if flagp(fn,'noval) or flagp(fn,'listargp)
        then typerr(fn,"remember operator");
    flag({fn},'remember);
  >>;
+++ remember compiled, 50 + 36 bytes
remember

put('remember,'stat,'rlis);rlis

symbolic procedure recursiveerror u;
   msgpri(nil,u,"improperly defined in terms of itself",nil,t);
+++ recursiveerror compiled, 12 + 20 bytes
recursiveerror

put('quote,'psopfn,'car);car    % Since we don't want this evaluated.

symbolic procedure opfneval1(fname, interm);
  begin
    scalar resul, x;
    if flagp(fname, 'tracealg) then <<
      if posn() neq 0 then terpri();
      printf("+++ Calling %p (%w:%w)%n",
        fname, get(fname, 'defined!-in!-file),
               get(fname, 'defined!-on!-line));
      x := 0;
      for each arg in interm do
        printf("Arg%w = %@p%n", x:=x+1,
          (if eqcar(arg, 'quote) then cadr arg else arg)) >>;
    resul := errorset!*(fname . interm, !*backtrace);
    if errorp resul then <<
      if !*backtrace then <<
        if posn() neq 0 then terpri();
        printf("+++ Error in call to %p (%w:%w)%n",
          fname, get(fname, 'defined!-in!-file),
                 get(fname, 'defined!-on!-line));
        x := 0;
        for each arg in interm do
          printf("Arg%w = %@p%n", x:=x+1,
            (if eqcar(arg, 'quote) then cadr arg else arg)) >>;
      error1() >>
    else <<
      resul := car resul;
      if flagp(fname, 'tracealg) then <<
        if posn() neq 0 then terpri();
        printf("%p => %p%n", fname, resul);  % TEMP
        printf("%p => %@p%n", fname, resul) >>;
      return resul >>;
  end;
+++ opfneval1 redefined
+++ opfneval1 compiled, 173 + 64 bytes
opfneval1

symbolic macro procedure tralg x;
   list('flag, list('quote, cdr x), ''tracealg);
+++ tralg_0jckbbmsd9jl compiled, 10 + 20 bytes
tralg

symbolic macro procedure untralg x;
   list('remflag, list('quote, cdr x), ''tracealg);
+++ untralg_eph7o4q7azpt3 compiled, 10 + 20 bytes
untralg

flag('(tralg untralg),'noform);nil

deflist('((tralg rlis) (tralgst rlis)),'stat);(tralg tralgst)

symbolic procedure opfneval u;
  if flagp(car u ,'remember) then
    begin scalar interm,resul,x;
      interm := for each j in
           (if flagp(car u,'noval) then cdr u else revlis cdr u)
        collect if fixp j then j else mkquote j;
      if (x:=assoc(car u . interm ,get(car u,'kvalue))) then return cadr x;
      resul := opfneval1(car u, interm);
      put!-kvalue(car u,get(car u,'kvalue), car u . interm, resul);
      return resul;
    end
  else opfneval1(car u,
    for each j in (if flagp(car u,'noval) then cdr u else revlis cdr u)
    collect mkquote j);
+++ opfneval redefined
+++ opfneval compiled, 158 + 28 bytes
opfneval

flag('(reval),'opfn);nil   % to make it a symbolic operator.

symbolic procedure reval2(u,v);
   % This test is designed to simplify expressions such as e*e^(2/(2-x))
   % and e^(x+3)*e^(3/(4-3*x))/e^(5*x-3). However, the normform test
   % shows it doesn't work well with non-integer domains.
   if v or null !*combineexpt or dmode!* then !*q2a1(simp!* u,v)
    else !*q2a1((simp!* u where !*mcd = nil),v);
+++ reval2 redefined
+++ reval2 compiled, 27 + 32 bytes
reval2

symbolic procedure getrtype u;
   % Returns overall algebraic type of u (or NIL is expression is a
   % scalar). Analysis is incomplete for efficiency reasons.
   % Type conflicts will later be resolved when expression is evaluated.
   begin scalar x,y;
    return
    if null u then nil   % Suggested by P.K.H. Gragert to avoid the
                         % loop caused if NIL has a share flag.
     else if atom u
      then if not idp u then not numberp u and getrtype1 u
            else if flagp(u,'share) % then getrtype lispeval u
             then if (x := eval u) eq u then nil else getrtype x
            else if (x := get(u,'avalue)) and
                       not(car x memq '(scalar generic))
                    or (x := get(u,'rtype)) and (x := list x)
                    then if y := get(car x,'rtypefn) then apply1(y,nil)
                          else car x
                  else nil
     else if not idp car u then nil
     else if getrtype car u eq 'array and not smemqlp(frlis!*,cdr u)
      then getrtype getelv u 
     else if (x := get(car u,'avalue)) and (x := get(car x,'rtypefn))
      then apply1(x,cdr u)
     % Special case handling for the SUB operator.
     else if car u eq 'sub then 'yetunknowntype
     else getrtype2 u
   end;
+++ getrtype redefined
+++ getrtype compiled, 110 + 48 bytes
getrtype

symbolic procedure getrtype1 u;
   % Placeholder for packages that use vectors.
   nil;
*** local variable u in procedure getrtype1 not used 

+++ getrtype1 redefined
+++ getrtype1 compiled, 1 + 8 bytes
getrtype1

symbolic procedure getrtype2 u;
   % Placeholder for packages that key expression type to the operator.
   begin scalar x;
     % Next line is maybe only needed by EXCALC.
      return if (x := get(car u,'rtype)) and (x := get(x,'rtypefn))
               then apply1(x,cdr u)
              else if x := get(car u,'rtypefn) then apply1(x,cdr u)
              else if flagp(car u,'matmapfn) and cdr u
                 and getrtype cadr u eq 'matrix
               then 'matrix
              else nil
   end;
+++ getrtype2 redefined
+++ getrtype2 compiled, 39 + 20 bytes
getrtype2

remprop('rtypecar,'stat);nil

symbolic procedure rtypecar u;
   for each j in u do put(j,'rtypefn,'getrtypecar);
+++ rtypecar compiled, 19 + 20 bytes
rtypecar

deflist('((rtypecar rlis)),'stat);(rtypecar)

rtypecar difference,expt,minus,plus,recip;nil

deflist('
  ((quotient getrtypeor)
   (times getrtypeor)
   (!*sq (lambda (x) nil))
 ),'rtypefn);(quotient times *sq)

symbolic procedure getrtypecar u; getrtype car u;
+++ getrtypecar redefined
+++ getrtypecar compiled, 3 + 12 bytes
getrtypecar

symbolic procedure getrtypeor u;
   u and (getrtype car u or getrtypeor cdr u);
+++ getrtypeor redefined
+++ getrtypeor compiled, 11 + 12 bytes
getrtypeor

symbolic procedure !*eqn2a u;
   % If u is an equation a=b, it is converted to an equivalent equation
   % a-b=0, or if a=0, b=0.  Otherwise u is returned converted to true
   % prefix form.
   if not eqexpr u then prepsqyy u
    else if null cdr u or null cddr u or cdddr u
     then typerr(u,"equation")
    else (if rh=0 then lh else if lh=0 then rh else{'difference,lh,rh})
          where lh=prepsqyy cadr u,rh=prepsqyy caddr u;
+++ !*eqn2a compiled, 48 + 32 bytes
*eqn2a

symbolic procedure prepsqyy u;
   if eqcar(u,'!*sq) then prepsqxx cadr u else u;
+++ prepsqyy redefined
+++ prepsqyy compiled, 10 + 16 bytes
prepsqyy

symbolic procedure getelv u;
   % Returns the value of the array element U.
%  getel(car u . for each x in cdr u collect ieval x);
   getel(car u . for each x in cdr u collect reval_without_mod x);
+++ getelv redefined
+++ getelv compiled, 46 + 16 bytes
getelv

symbolic procedure setelv(u,v);
%  setel(car u . for each x in cdr u collect ieval x,v);
   setel(car u . for each x in cdr u collect reval_without_mod x,v);
+++ setelv redefined
+++ setelv compiled, 47 + 16 bytes
setelv

symbolic procedure reval_without_mod u;
   % Evaluate u without a modulus.
   if dmode!* eq '!:mod!: then (reval u where dmode!* = nil)
    else reval u;
+++ reval_without_mod redefined
+++ reval_without_mod compiled, 17 + 24 bytes
reval_without_mod

symbolic procedure revlis u; for each j in u collect reval j;
+++ revlis redefined
+++ revlis compiled, 34 + 12 bytes
revlis

symbolic procedure revop1 u;
   if !*val then car u . revlis cdr u else u;
+++ revop1 compiled, 12 + 16 bytes
revop1

symbolic procedure mk!*sq u;
   % Modified by Francis J. Wright to return a list correctly.
%  if null numr u then 0
%   else if atom numr u and denr u=1 then numr u
%   else '!*sq . expchk u . if !*resubs then !*sqvar!* else list nil;
  (if null numr u then 0
    else if atom numr u and denr u=1 then numr u
    else if kernp u and eqcar(mvar numr u,'list) then mvar numr u
    else '!*sq . u . if !*resubs then !*sqvar!* else list nil)
   where u=expchk u;
+++ mk!*sq redefined
+++ mk!*sq compiled, 46 + 40 bytes
mk*sq

symbolic macro procedure !*sq u;
   % Provide an interface to symbolic mode.
   prepsq cadr u;
+++ !*sq_limqvr4eskjk2 compiled, 6 + 12 bytes
*sq

symbolic procedure expchk u; if !*exp then u else offexpchk u;
+++ expchk redefined
+++ expchk compiled, 6 + 16 bytes
expchk

symbolic procedure lengthreval u;
   begin scalar v,w,x;
      if length u neq 1
        then rerror(alg,11,
                    "LENGTH called with wrong number of arguments");
      u := car u;
      if idp u and arrayp u then return 'list . get(u,'dimension);
      v := aeval u;
      if (w := getrtype v) and (x := get(w,'lengthfn))
        then return apply1(x,v)
       else if atom v then return 1
       else if not idp car v or not(x := get(car v,'lengthfn))
        then if w
          then lprie list("LENGTH not defined for argument of type",w)
         else typerr(u,"LENGTH argument")
       else return apply1(x,cdr v)
   end;
+++ lengthreval redefined
+++ lengthreval compiled, 82 + 72 bytes
lengthreval

put('length,'psopfn,'lengthreval);lengthreval


% Code for evaluation of expressions whose type can only be
% infered after partial evaluation.

symbolic procedure yetunknowntypeeval(u,v);
   % Assumes that only psopfn's can produce yet unknown types.
   reval1(eval!-yetunknowntypeexpr(u,v),v);
+++ yetunknowntypeeval redefined
+++ yetunknowntypeeval compiled, 6 + 16 bytes
yetunknowntypeeval

symbolic procedure eval!-yetunknowntypeexpr(u,v);
   if atom u
      then ((if w then eval!-yetunknowntypeexpr(cadr w,v)
              else u)
            where w = get(u,'avalue))
    else if car u eq '!*sq or get(car u,'dname) or car u eq '!:dn!:
     then u
    else ((if x and (getrtype u eq 'yetunknowntype)
              then apply1(x,cdr u)
            else car u . for each j in cdr u collect
                             eval!-yetunknowntypeexpr(j,v))
          where x = get(car u,'psopfn));
+++ eval!-yetunknowntypeexpr redefined
+++ eval!-yetunknowntypeexpr compiled, 87 + 24 bytes
eval-yetunknowntypeexpr

put('yetunknowntype,'evfn,'yetunknowntypeeval);yetunknowntypeeval

endmodule;nil

end;nilmodule algbool;nil % Evaluation functions for algebraic boolean operators.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


symbolic procedure evalequal(u,v);
   begin scalar x;
      return if (x := getrtype u) neq getrtype v then nil
              else if null x
               then numberp(x := reval list('difference,u,v))
                       and zerop x
              else u=v
   end;
+++ evalequal redefined
+++ evalequal compiled, 30 + 20 bytes
evalequal

put('equal,'boolfn,'evalequal);evalequal

% symbolic procedure equalreval u; 'equal . revlis u;  % defined in eqn.

% put('equal,'psopfn,'equalreval);

put('equal,'rtypefn,'quoteequation);quoteequation

symbolic procedure quoteequation u; 'equation;
*** local variable u in procedure quoteequation not used 

+++ quoteequation redefined
+++ quoteequation compiled, 2 + 12 bytes
quoteequation

symbolic procedure evalgreaterp(u,v);
   (lambda x;
    if not atom denr x or not domainp numr x
      then typerr(mk!*sq if minusf numr x then negsq x else x,"number")
     else numr x and !:minusp numr x)
        simp!* list('difference,v,u);
+++ evalgreaterp redefined
+++ evalgreaterp compiled, 36 + 40 bytes
evalgreaterp

put('greaterp,'boolfn,'evalgreaterp);evalgreaterp

symbolic procedure evalgeq(u,v); not evallessp(u,v);
+++ evalgeq redefined
+++ evalgeq compiled, 5 + 16 bytes
evalgeq

put('geq,'boolfn,'evalgeq);evalgeq

symbolic procedure evallessp(u,v); evalgreaterp(v,u);
+++ evallessp redefined
+++ evallessp compiled, 3 + 12 bytes
evallessp

put('lessp,'boolfn,'evallessp);evallessp

symbolic procedure evalleq(u,v); not evalgreaterp(u,v);
+++ evalleq redefined
+++ evalleq compiled, 5 + 16 bytes
evalleq

put('leq,'boolfn,'evalleq);evalleq

symbolic procedure evalneq(u,v); not evalequal(u,v);
+++ evalneq redefined
+++ evalneq compiled, 5 + 16 bytes
evalneq

put('neq,'boolfn,'evalneq);evalneq

symbolic procedure evalnumberp u;
   (if atom x then numberp x
     else if not(car x eq '!*sq) or not atom denr cadr x then nil
     else (atom y or flagp(car y,'numbertag)) where y=numr cadr x)
    where x=aeval u;
+++ evalnumberp redefined
+++ evalnumberp compiled, 30 + 24 bytes
evalnumberp

put('numberp,'boolfn,'evalnumberp);evalnumberp

% Number tags.

flag('(!:rd!: !:cr!: !:rn!: !:crn!: !:mod!: !:gi!:),'numbertag);nil

symbolic procedure ratnump x;
   % Returns T iff any prefix expression x is a rational number.
   (atom numr(x := simp!* x) or car numr x eq '!:rn!:) and atom denr x;
+++ ratnump redefined
+++ ratnump compiled, 17 + 16 bytes
ratnump


flag ('(ratnump), 'boolean);nil

endmodule;nil

end;nilmodule simp;nil % Functions to convert prefix forms into canonical forms.

% Author: Anthony C. Hearn.

% Modifications by: J.H. Davenport, F. Kako, S. Kameny, E. Schruefer and
%                   Francis J. Wright.

% Copyright (c) 1998, Anthony C. Hearn.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*allfac !*div);nil

fluid '(!*asymp!* !*complex !*exp !*gcd !*ifactor !*keepsqrts !*mcd
        !*mode !*modular !*notseparate !*numval !*precise !*precise_complex
        !*rationalize !*reduced !*resimp !*sub2 !*uncached alglist!* dmd!*
        dmode!* varstack!* !*combinelogs !*expandexpt !*msg frlis!* subfg!*
        !*norationalgi factorbound!* ncmp!* powlis1!* !*nospurp
        !*ncmp !*inside!-int!*);nil

global '(!*match
         den!*
%        exptl!*   No-one else refers to this variable - just slows us
         initl!*
         mul!*
         simpcount!*
         simplimit!*
         tstack!*
         ws);nil

switch expandexpt;nil % notseparate;

!*expandexpt := t;t

!*inside!-int!* := nil;nil

% The NOTSEPARATE switch inhibits an expression such as x^(4/3) to
% become x*x^(1/3).  At the present time, no one is using this.

factorbound!* := 10000;10000   % Limit for factoring with IFACTOR off.

% !*KEEPSQRTS uses SQRT rather than EXPT for square roots.
% Normally set TRUE in the integrator, false elsewhere.

put('ifactor,'simpfg,'((t (rmsubs))));((t (rmsubs)))

put('alglist!*,'initl,'(cons nil nil));(cons nil nil)

put('simpcount!*,'initl,0);0

initl!* := union('(alglist!* simpcount!*),initl!*);(simpcount* alglist* subfg*
*sub2 tstack* fname* outl*)

simplimit!* := 1000;1000

symbolic procedure noncom u;
   % Declare vars u to be noncom.
   <<rmsubs(); for each j in u do noncom1 j>>;
+++ noncom compiled, 17 + 16 bytes
noncom

symbolic procedure noncom1 u;
   <<!*ncmp := t; flag(list u,'noncom)>>;
+++ noncom1 redefined
+++ noncom1 compiled, 8 + 20 bytes
noncom1

put('noncom,'stat,'rlis);rlis

symbolic procedure simp!* u;
   begin scalar !*asymp!*,x;
        if eqcar(u,'!*sq) and caddr u and null !*resimp
          then return cadr u;
        x := mul!* . !*sub2;    % Save current environment.
        mul!* := nil;
        u:= simp u;
        if !*nospurp then mul!* := union(mul!*,'(isimpq));
        for each j in mul!* do u:= apply1(j,u);
        mul!* := car x;
        u := subs2 u;
        if !*combinelogs then u := clogsq!* u;
        % Must be here, since clogsq!* can upset girationalizesq!:.
        % For defint, it is necessary to turn off girationalizesq - SLK.
        if dmode!* eq '!:gi!: and not !*norationalgi
          then u := girationalize!: u
          else if !*rationalize then u := rationalizesq u
         else u := rationalizei u;
        !*sub2 := cdr x;
        % If any leading terms have cancelled, a gcd check is required.
        if !*asymp!* and !*rationalize then u := gcdchk u;
        return u
   end;
+++ simp!* redefined
+++ simp!* compiled, 110 + 92 bytes
simp*

symbolic procedure rationalizei u;
   % Remove overall factor of i in denominator.
   begin scalar v,w;
      if domainp (v := denr u) or not smemq('i,v) then return u;
      v := reordsq u where kord!* = 'i . kord!*;
      return if lpow (w := denr v) = '(i . 1) and null red w
               then (if not domainp numr v and mvar numr v eq 'i
                       then addf(lc numr v,multf(negf !*k2f 'i,red numr v))
                      else negf(multf(!*k2f 'i,numr v))) ./ lc w
              else u
   end;
+++ rationalizei redefined
+++ rationalizei compiled, 95 + 52 bytes
rationalizei

symbolic procedure subs2 u;
   begin scalar xexp,v,w,x;
    if null subfg!* then return u
     else if !*sub2 or powlis1!* then u := subs2q u;
    u := exptchksq u;
    x := get('slash,'opmtch);
    if null (!*match or x) or null numr u then return u
     else if null !*exp
      then <<xexp:= t; !*exp := t; v := u; w := u := resimp u>>;
    u := subs3q u;
    if xexp then <<!*exp := nil; if u=w then u := v>>;
    if x then u := subs4q u;
    return u
   end;
+++ subs2 redefined
+++ subs2 compiled, 69 + 56 bytes
subs2

% car alglist!* is a table, inspected here in simp and set (only) in
% !*ssave, which in turn is only ever called form here. In forall.red
% there is a call that removes items from the table. The only
% other constraint on it is that NIL must represent an empty table.
% The value stored against a key is always a CONS, and specifically is
% never NIL.
%
% Items should only ever be added to the list if there are not already
% present. This means that the order of items in the table is not
% important. There are, across the Reduce tests, about as many searches
% as there are additions to this table.
%
% The initial implementation was a simple association list. That works
% well provided it remains short! However for instance the liepde test
% script leads to a table with over 4000 entries, so other large calculations
% may be bad too. But of course an over-heavy-handed implementation might
% also cause pain! To help me understand this I will make all access to this
% table abstract via small procedures here.

% Elsewhere I may define stand-in versions of mkhash etc that will work
% (albeit slowly) on platforms where hash tables are not built in. In such
% cases mkhash will have ended up flagged 'rlisp.

#if (and (getd 'mkhash) (not (flagp 'mkhash 'rlisp)))

% With CSL I have hash tables and I am fairly confident both that for
% cases where alglist!* becomes long they are a significant win and that
% in other cases they are as close to cost-neutral as I can measure.

% If I just cache EVERYTHING then alglist can end up huge. This may be
% bad in general since it keep stuff that may be stale in memory forever.
% Also in CSL for HUGE calculations it can lead to exceeding the maximum
% capacity of my hash tables where I believe there is a case that can
% lead to crashes. So when the cache has had a certain number of entries
% inserted I will just clear it. The effect will be to lead to some
% recomputation at that stage. alglist_limit!* sets the limit, and
% I expect that only truly large computations will even trigger it. A
% really keen person wanting to tune behaviour here could go
% "lisp alglist_limit!* := nnnn;" for suitable nnnn and experiment to
% see just what works best for them.

global '(alglist_count!* alglist_limit!*);nil
alglist_count!* := 0;0
alglist_limit!* := 1000000;1000000

inline procedure add_to_alglist(key, val, l);
<<
  if null l or alglist_count!* > alglist_limit!* then begin
     scalar newl;
     alglist_count!* := 0;
     newl := mkhash(10, 3, 2.0);
     puthash(key, newl, val);
     return newl end
  else <<
    puthash(key, l, val);
    alglist_count!* := add1 alglist_count!*;
    l >>
>>;
+++ Record new inline definition:
(de add_to_alglist (key val l) (progn (cond ((or (null l) (greaterp
alglist_count!* alglist_limit!*)) (prog (newl) (setq alglist_count!* 0) (setq
newl (mkhash 10 3 2.0)) (puthash key newl val) (return newl))) (t (progn (
puthash key l val) (setq alglist_count!* (add1 alglist_count!*)) l)))))
(progn (de add_to_alglist (key val l) (progn (cond ((or (null l) (greaterp
alglist_count!* alglist_limit!*)) (prog (newl) (setq alglist_count!* 0) (setq
newl (mkhash 10 3 2.0)) (puthash key newl val) (return newl))) (t (progn (
puthash key l val) (setq alglist_count!* (add1 alglist_count!*)) l))))) (put (
quote add_to_alglist) (quote number!-of!-args) 3) (put (quote add_to_alglist) (
quote procedure_type) (quote (arrow (times general general general) general))) (
putc (quote add_to_alglist) (quote inline) (quote (lambda (key val l) (progn (
cond ((or (null l) (greaterp alglist_count!* alglist_limit!*)) (prog (newl) (
setq alglist_count!* 0) (setq newl (mkhash 10 3 2.0)) (puthash key newl val) (
return newl))) (t (progn (puthash key l val) (setq alglist_count!* (add1
alglist_count!*)) l))))))))
+++ add_to_alglist compiled, 34 + 40 bytes
(lambda (key val l) (progn (cond ((or (null l) (greaterp alglist_count*
alglist_limit*)) (prog (newl) (setq alglist_count* 0) (setq newl (mkhash 10 3
2.0)) (puthash key newl val) (return newl))) (t (progn (puthash key l val) (setq
alglist_count* (add1 alglist_count*)) l)))))

inline procedure search_alglist(key, l);
  if null l then nil
  else gethash(key, l);
+++ Record new inline definition:
(de search_alglist (key l) (cond ((null l) nil) (t (gethash key l))))
(progn (de search_alglist (key l) (cond ((null l) nil) (t (gethash key l)))) (
put (quote search_alglist) (quote number!-of!-args) 2) (put (quote
search_alglist) (quote procedure_type) (quote (arrow (times general general)
general))) (putc (quote search_alglist) (quote inline) (quote (lambda (key l) (
cond ((null l) nil) (t (gethash key l)))))))
+++ search_alglist compiled, 6 + 12 bytes
(lambda (key l) (cond ((null l) nil) (t (gethash key l))))

symbolic procedure delete_from_alglist(key, l);
  if null l then nil
  else << remhash(key, l); l >>;
+++ delete_from_alglist redefined
+++ delete_from_alglist compiled, 7 + 12 bytes
delete_from_alglist

#else

% If genuine hash tables are not available I maintain the previous
% association-list model, albeit now lifted by a level of abstraction.

inline procedure add_to_alglist(key, val, l);
  (key . val) . l;

inline procedure search_alglist(key, l);
  begin
    scalar r;
    r := assoc(key, l);
    if null r then return r
    else return cdr r
  end;

symbolic procedure delete_from_alglist(key, l);
  delasc(key, l);

#endif


symbolic procedure simp u;
   (begin scalar x,y;
    % This case is sufficiently common it is done first.
    if fixp u
      then if u=0 then return nil ./ 1
            else if not dmode!* then return u ./ 1
            else nil
     else if u member varstack!* then recursiveerror u;
    varstack!* := u . varstack!*;
    if simpcount!*>simplimit!*
      then <<simpcount!* := 0;
             rerror(alg,12,"Simplification recursion too deep")>>
     else if eqcar(u,'!*sq) and caddr u and null !*resimp
      then return cadr u
     else if null !*uncached and (x := search_alglist(u,car alglist!*))
      then return <<if car x then !*sub2 := t; cdr x>>;
    simpcount!* := simpcount!*+1; % undone by returning through !*SSAVE.
    if atom u then return !*ssave(simpatom u,u)
     else if not idp car u or null car u
      then if atom car u then typerr(car u,"operator")
            else if idp caar u and (x := get(caar u,'name))
             then return !*ssave(u,u)     %%% not yet correct
            else if eqcar(car u,'mat)
                and numlis(x := revlis cdr u) and length x=2
             then return !*ssave(simp nth(nth(cdar u,car x),cadr x),u)
            else errpri2(u,t)
     else if flagp(car u,'opfn)
      then if null(y := getrtype(x := opfneval u))
             then return !*ssave(simp_without_resimp x,u)
            else if y eq 'yetunknowntype and null getrtype(x := reval x)
             then return simp x
            else typerr(u,"scalar")
     else if x := get(car u,'psopfn)
      then if getrtype(x := apply1(x,cdr argnochk u))
             then typerr(u,"scalar")
        else if x=u then return !*ssave(!*k2q x,u)
        else return !*ssave(simp_without_resimp x,u)
     % Note in above that the psopfn MUST return a *sq form,
     % otherwise an infinite recursion occurs.
     else if x := get(car u,'polyfn)
      then return
        <<argnochk u;
          !*ssave(!*f2q lispapply(x,
                            for each j in cdr u collect !*q2f simp!* j),
                  u)>>
     else if get(car u,'opmtch)
        and not(get(car u,'simpfn) eq 'simpiden)
        and (x := opmtchrevop u)
      then return !*ssave(simp x,u)
     else if x := get(car u,'simpfn)
      then return !*ssave(apply1(x,
                                 if x eq 'simpiden or flagp(car u,'full)
                                   then argnochk u
                                 else cdr argnochk u),
                          u)
     else if (x := get(car u,'rtype)) and (x := get(x,'getelemfn))
      then return !*ssave(simp apply1(x,u),u)
     else if flagp(car u,'boolean) or get(car u,'infix)
      then typerr(if x := get(car u,'prtch) then x else car u,
              "algebraic operator")
     else if flagp(car u,'nochange)
      then return !*ssave(simp lispeval u,u)
     else if get(car u,'psopfn) or get(car u,'rtypefn)
      then typerr(u,"scalar")
     else <<redmsg(car u,"operator");
        mkop car u;
        varstack!* := delete(u,varstack!*);
        return !*ssave(simp u,u)>>;
   end) where varstack!* = varstack!*;
+++ simp redefined
+++ simp compiled, 529 + 212 bytes
simp

symbolic procedure opmtchrevop u;
   % The following structure is designed to make index mu; p1.mu^2;
   % work.  It also introduces a redundant revlis in most cases.
   if null !*val or smemq('cons,u) then opmtch u
    else opmtch(car u . revlis cdr u);
+++ opmtchrevop redefined
+++ opmtchrevop compiled, 21 + 24 bytes
opmtchrevop

symbolic procedure simp_without_resimp u;
   simp u where !*resimp := nil;
+++ simp_without_resimp redefined
+++ simp_without_resimp compiled, 9 + 20 bytes
simp_without_resimp

put('array,'getelemfn,'getelv);getelv

put('array,'setelemfn,'setelv);setelv

symbolic procedure getinfix u;
   %finds infix symbol for U if it exists;
   begin scalar x; return if x := get(u,'prtch) then x else u end;
+++ getinfix compiled, 8 + 8 bytes
getinfix

symbolic procedure !*ssave(u,v);
   % We keep !*sub2 as well, since there may be an unsubstituted
   % power in U.
  begin
    if not !*uncached then
      rplaca(alglist!*, add_to_alglist(v, (!*sub2 . u), car alglist!*));
    simpcount!* := simpcount!*-1;
    return u
  end;
+++ !*ssave redefined
+++ !*ssave compiled, 62 + 56 bytes
*ssave

symbolic procedure numlis u;
   null u or (numberp car u and numlis cdr u);
+++ numlis redefined
+++ numlis compiled, 12 + 12 bytes
numlis

symbolic procedure simpatom u;
%  if null u then typerr("NIL","algebraic identifier")
   if null u then nil ./ 1   % Allow NIL as default 0.
    else if numberp u
     then if u=0 then nil ./ 1
           else if not fixp u then rd!:simp u
             % we assume that a non-fixp number is a float.
           else if dmode!* eq '!:mod!: and current!-modulus = 1
            then nil ./ 1
           else if flagp(dmode!*,'convert) and u neq 1 % Don't convert 1
            then !*d2q apply1(get(dmode!*,'i2d),u)
           else u ./ 1
    else if stringp u then typerr(list("String",u),"identifier")
    else if flagp(u,'share) then
      <<(if x eq u then mksq(u,1) else simp x) where x=lispeval u>>
    else begin scalar z;
      if z := get(u,'idvalfn) then return apply1(z,u)
       else if !*numval and dmode!* and flagp(u,'constant)
          and (z := get(u,dmode!*))
          and not errorp(z := errorset!*(list('lispapply,mkquote z,nil),
                         nil)) and
% Beware Lisp systems that can deliver a native Lisp-level complex
% result given a real argument to some function.
          (not eqcar(z := car z, '!:rd!:) or not complexp cdr z)
        then return !*d2q z
       else if getrtype u then typerr(u,'scalar)
       else return mksq(u,1) end;
+++ simpatom redefined
+++ simpatom compiled, 162 + 100 bytes
simpatom

flag('(e pi),'constant);nil

symbolic procedure mkop u;
   begin scalar x;
    if null u then typerr("Local variable","operator")
     else if u eq 'lambda then typerr("The symbol ""lambda""","operator")
     else if get(u, 'formfn) then typerr("Reserved word", "operator")
     % check for psopfn property added since it cannot yet be included in gettype, messes up assist
     else if (x := gettype u) eq 'operator or get(u,'psopfn)
      then lprim list(u,"already defined as operator")
     else if x eq 'algebraic_procedure
      then lprim list(u,"already defined as algebraic procedure")
    % Allow a scalar to also be an operator.
     else if x and not(x memq '(fluid global procedure scalar))
      then typerr(u,'operator)
%    else if u memq frlis!* then typerr(u,"free variable")
     else put(u,'simpfn,'simpiden)
   end;
+++ mkop compiled, 81 + 76 bytes
mkop

symbolic procedure operatorp u;
    gettype u eq 'operator;
+++ operatorp compiled, 5 + 16 bytes
operatorp

symbolic procedure simpcar u;
   simp car u;
+++ simpcar redefined
+++ simpcar compiled, 3 + 12 bytes
simpcar

put('quote,'simpfn,'simpcar);simpcar

symbolic procedure share u;
   begin scalar y;
      for each v in u do
         if not idp v then typerr(v,"id")
         else if flagp(v,'share) then nil
         else if flagp(v,'reserved) or v eq 't then rsverr v
         else if (y := getrtype v) and y neq 'list
            then rerror(alg,13,list(y,v,"cannot be shared"))
         else
          % if algebraic value exists, transfer to symbolic.
         <<if y then remprop(v,'rtype);
           if y := get(v,'avalue)
             then <<setifngfl(v,cadr y); remprop(v,'avalue)>>
          % if no algebraic value but symbolic value, leave unchanged.
            else if not boundp v then setifngfl(v,v);
          % if previously unset, set symbolic self pointer.
           flag(list v,'share)>>
   end;
+++ share compiled, 107 + 68 bytes
share

symbolic procedure boundp u;
   % Determines if the id u has a value.
   % NB:  this function must be redefined in many systems (e.g., CL).
   null errorp errorset!*(u,nil);
*** boundp not defined (LOSE flag) 
nil

symbolic procedure setifngfl(v,y);
   <<if not globalp v then fluid list v; set(v,y)>>;
+++ setifngfl compiled, 12 + 16 bytes
setifngfl

rlistat '(share);nil

flag('(ws !*mode),'share);nil

flag('(share),'eval);nil


% ***** SIMPLIFICATION FUNCTIONS FOR EXPLICIT OPERATORS - EXP *****

symbolic procedure simpexpon u;
   % Exponents must not use non-integer arithmetic unless NUMVAL is on,
   % in which case DOMAINVALCHK must know the mode.
   simpexpon1(u,'simp!*);
+++ simpexpon redefined
+++ simpexpon compiled, 4 + 16 bytes
simpexpon

symbolic procedure simpexpon1(u,v);
   if !*numval and (dmode!* eq '!:rd!: or dmode!* eq '!:cr!:)
     then apply1(v,u)
    else begin scalar dmode!*,alglist!*; return apply1(v,u) end;
+++ simpexpon1 redefined
+++ simpexpon1 compiled, 27 + 32 bytes
simpexpon1

fluid '(!*qsum!-simpexpt);nil

symbolic procedure simpexpt u;
   if !*qsum!-simpexpt then qsum!-simpexpt u
   else basic!-simpexpt u;
+++ simpexpt redefined
+++ simpexpt compiled, 10 + 20 bytes
simpexpt

fluid '(inside!-qsum!-simpexpt!*);nil

% qsum!-simpexp wants to arrange that when it is first entered it
% resets a range of switches. I make it rebind inside!-qsum!-expt!* so
% that the action there only happens on the outermost call to the function.
% While within it it wants !*exp true and various other simplification
% control flags in a standard state. If it changes some of those then it
% needs to call rmsubs(), so I have two cases here, one for when it indeed
% needs to make chanmges and the other (cheaper and simpler) for when flags
% are already in a state that should leave it happy.

symbolic procedure qsum!-simpexpt u;
  if inside!-qsum!-simpexpt!* then qsum!-simpexpt1 u
  else if not !*exp or !*factor or null !*mcd then
    begin
      scalar w :=
        begin
          scalar inside!-qsum!-expt!*:=t,
                 !*precise,!*factor,!*exp:=t,!*mcd:=t,!*allfac, w;
          rmsubs();
          return qsum!-simpexpt1 u;
          end;
      rmsubs(); % Because !*exp or !*mcd or !*factor has been restored
      return w
    end
  else
    begin
      scalar inside!-qsum!-expt!*:=t,!*precise,!*allfac;
      return qsum!-simpexpt1 u;
    end;
*** local variable w in procedure qsum-simpexpt not used 

+++ qsum!-simpexpt redefined
+++ qsum!-simpexpt compiled, 67 + 52 bytes
qsum-simpexpt

% The logic here attempts to reproduce just what the original code in
% qsum.red would have done.

symbolic procedure qsum!-simpexpt1 u;
  if eqcar(car u, 'minus) then
    multsq(basic!-simpexpt list('(minus 1), cadr u),
           qsum!-simpexpt1 list(cadar u, cadr u))
  else <<
     basic!-simpexpt u where inside!-qsum!-simpexpt!* = nil >>;
+++ qsum!-simpexpt1 redefined
+++ qsum!-simpexpt1 compiled, 31 + 32 bytes
qsum-simpexpt1


symbolic procedure basic!-simpexpt u;
   % We suppress reordering during exponent evaluation, otherwise
   % internal parts (as in e^(a*b)) can have wrong order.
   begin scalar expon;
      expon := simpexpon carx(cdr u,'expt) where kord!*=nil;
      % We still need the right order, else
      % explog := {sqrt(e)**(~x*log(~y)/~z) => y**(x/z/2)};
      % on ezgcd,gcd; let explog; fails.
      expon := simpexpon1(expon,'resimp);
      return simpexpt1(car u,expon,nil)
   end;
+++ basic!-simpexpt redefined
+++ basic!-simpexpt compiled, 25 + 40 bytes
basic-simpexpt

symbolic procedure simpexpt1(u,n,flg);
   % FLG indicates whether we have done a PREPSQ SIMP!* U or not: we
   % don't want to do it more than once.
   begin scalar !*allfac,!*div,m,x,y;
      if onep u then return 1 ./ 1;
      !*allfac := t;
      m := numr n;
      if m=1 and denr n=1 then return simp u;
     % this simplifies e^(n log x) -> x^n  for all n,x.
      if u eq 'e and domainp denr n and not domainp m and ldeg m=1
         and null red m and eqcar(mvar m,'log) then return
            simpexpt1(prepsq!* simp!* cadr mvar m,lc m ./ denr n,nil);
      if not domainp m or not domainp denr n
        then return simpexpt11(u,n,flg);
      x := simp u;
      if null m
        then return if null numr x then rerror(alg,14,"0**0 formed")
                     else 1 ./ 1;
      % We could use simp!* here, except it messes up the handling of
      % gamma matrix expressions.
%     if denr x=1 and not domainp numr x and not(denr n=1)
%       then <<y := sqfrf numr x;
%%      then <<y := fctrf numr x;
%%              if car y=1 then y := cdr y
%%               else if minusp car y then y := {1};
%              if length y>1 then return simpexptfctr(y,n)>>;
      return if null numr x
               then if domainp m and minusf m
                      then rerror(alg,15,"Zero divisor")
                     else nil ./ 1
              else if atom m and denr n=1 and domainp numr x
                 and denr x=1
               then if atom numr x and m>0 then !*d2q(numr x**m)
                     else <<x := !:expt(numr x,m) ./ 1;
                            %remove rationals where possible.
                            if !*mcd then resimp x else x>>
              else if y := domainvalchk('expt,list(x,n)) then y
              else if atom m and denr n=1
               then <<if not(m<0) then exptsq(x,m)
                       else if !*mcd then invsq exptsq(x,-m)
                       else multf(expf(numr x,m),mksfpf(denr x,-m))
                               ./ 1>>     % This uses OFF EXP option.
                      % There may be a pattern matching problem though.
     % We need the subs2 in the next line to take care of power and
     % product simplification left over from the call of simp on u.
              else simpexpt11(if flg then u else prepsq!* subs2!* x,n,t)
   end;
+++ simpexpt1 redefined
+++ simpexpt1 compiled, 297 + 132 bytes
simpexpt1

symbolic procedure simpexptfctr(u,n);
   begin scalar x;
     x := 1 ./ 1;
     for each j in u do
         x:= multsq(simpexpt1(prepf car j,multsq(cdr j ./ 1,n),nil),x);
     return x
   end;
+++ simpexptfctr compiled, 34 + 24 bytes
simpexptfctr

symbolic procedure simpexpt11(u,n,flg);
   % Expand exponent to put expression in canonical form.
   begin scalar x;
      return if !*precise_complex then simpexpt2(u,n,flg)
              else if domainp denr n
                 or not(car(x := qremf(numr n,denr n)) and cdr x)
               then simpexpt2(u,n,flg)
              else multsq(simpexpt1(u,car x ./ 1,flg),
                          simpexpt1(u,cdr x ./ denr n,flg))
   end;
+++ simpexpt11 redefined
+++ simpexpt11 compiled, 52 + 32 bytes
simpexpt11

symbolic procedure simpexpt2(u,n,flg);
   % The "non-numeric exponent" case.  FLG indicates whether we have
   % done a PREPSQ SIMP!* U or not: we don't want to do it more than
   % once.
   begin scalar m,n,x,y;
    if u=1 then return 1 ./ 1;
%  The following is now handled in mkrootsq.
%    else if fixp u and u>0 and (u<factorbound!* or !*ifactor)
%      and (length(x := zfactor u)>1 or cdar x>1)
%     then <<y := 1 ./ 1;
%            for each j in x do
%               y := multsq(simpexpt list(car j,
%                                         prepsq multsq(cdr j ./ 1,n)),
%                           y);
%            return y>>;
    m:=numr n;
    if pairp u then <<
     if car u eq 'expt and null !*precise_complex
      then <<n:=multsq(m:=simp caddr u,n);
             if !*precise
               and numberp numr m and evenp numr m
%               and numberp numr n and not evenp numr n
               then u := list('abs,cadr u)
              else u := cadr u;
             return simpexpt1(u,n,flg)>>
     else if car u eq 'sqrt and not !*keepsqrts
      then return simpexpt2(cadr u, multsq(1 ./ 2,n),flg)
     % We need the !*precise check for, say, sqrt((1+a)^2*y*z).
     else if car u eq 'times and not !*precise and not !*modular
      then <<x := 1 ./ 1;
             for each z in cdr u do x := multsq(simpexpt1(z,n,flg),x);
             return x>>
        % For a product under *precise we isolate positive factors.
     else if car u eq 'times and (y:=split!-sign cdr u) and car y
%             and null !*precise_complex
      then <<x := simpexpt1(retimes append(cadr y,cddr y),n,flg);
             for each z in car y do x := multsq(simpexpt1(z,n,flg),x);
             return x>>
     else if car u eq 'quotient
%    The next lines did not allow, e.g., sqrt(a/b) => sqrt(a)/sqrt(b).
%    when precise is on and there is a risk of
%    E.g., sqrt(a/b) neq sqrt(a)/sqrt(b) when a=1, b=-1.
%    We allow however the denominator to be a positive number.
        and (not !*precise
%               or alg_constant_exptp(cadr u,n)
%               or alg_constant_exptp(caddr u,n)
                or posnump caddr u and posnump prepsq n
            )
      then <<if not flg and !*mcd then
                return simpexpt1(prepsq simp!* u,n,t);
             n := prepsq n;
             return quotsq(simpexpt{cadr u,n},simpexpt{caddr u,n})>>
     % Special case of (-expression)^(1/2).
%    else if car u eq 'minus
%            and (n = '(1 . 2) or n = '((!:rd!: . 0.5) . 1)
%                 or n = '((!:rd!: 5 . -1) . 1)
%                 or n = '((!:rn!: 1 . 2) . 1))
%     then return simptimes list('i,list('expt,cadr u,prepsq n))>>;
%    else if car u eq 'minus and numberp m and denr n=1
%     then return multsq(simpexpt list(-1,m),
%                simpexpt list(cadr u,m))>>;
     else if car u eq 'minus and not !*precise and not(cadr u = 1)
      then return (multsq(simpexpt list(-1,expon),
                 simpexpt list(cadr u,expon))) where expon=prepsq n>>;
    if null flg
      then <<% Don't expand say e and pi, since whole expression is not
             % numerical.
            if null(dmode!* and idp u and get(u,dmode!*))
               then u := prepsq simp!* u;
             return simpexpt1(u,n,t)>>
     else if numberp u and zerop u then return nil ./ 1
     else if not numberp m then m := prepf m;
    n := prepf denr n;
    if m memq frlis!* and n=1 then return list ((u . m) . 1) . 1;
       % "power" is not unique here.
    if !*mcd or not numberp m or n neq 1
      or atom u or denr simp!* u neq 1 then return simpx1(u,m,n)
      else return mksq(u,m)  % To make pattern matching work.
   end;
+++ simpexpt2 redefined
+++ simpexpt2 compiled, 351 + 132 bytes
simpexpt2

symbolic procedure posnump u;
   % True if u is a positive number. Test is naive but correct.
   if atom u then (numberp u and u>0) or u memq '(e pi)
    else if car u memq '(expt plus quotient sqrt times)
     then posnumlistp cdr u
    else nil;
+++ posnump compiled, 27 + 24 bytes
posnump

symbolic procedure posnumlistp u;
   null u or posnump car u and posnumlistp cdr u;
+++ posnumlistp compiled, 12 + 16 bytes
posnumlistp

% symbolic procedure alg_constant_exptp(u,v);
%    % U an expression, v a standard quotient.
%    alg_constantp u and alg_constantp car v and alg_constantp cdr v;

% symbolic procedure alg_constantp u;
%    % True if u is an algebraic constant whose surd is unique.
%    if atom u then numberp u
%    else if car u memq
%        '(difference expt plus minus quotient sqrt times)
%      then alg_constant_listp cdr u
%     else nil;

% symbolic procedure alg_constant_listp u;
%    null u or alg_constantp car u and alg_constant_listp cdr u;

put('expt,'simpfn,'simpexpt);simpexpt

symbolic procedure split!-sign u;
  % U is a list of factors. Split into positive, negative
  % and unknown sign part. Nil if no sign is known.
  begin scalar p,n,w,s;
    for each f in u do
      if 1=(s:=sign!-of f) then p:=f.p else if -1=s then n:=f.n
          else w:=f.w;
    if null p and null n then return nil;
    return p.n.w;
  end;
+++ split!-sign compiled, 50 + 20 bytes
split-sign

symbolic procedure conv2gid(u,d);
   if null u or numberp u or eqcar(u,'!:gi!:) then d
    else if domainp u
     then if eqcar(u,'!:crn!:) then lcm(d,lcm(cdadr u,cdddr u))
           else if eqcar(u,'!:rn!:) then lcm(d,cddr u) else d
    else conv2gid(lc u,conv2gid(red u,d));
+++ conv2gid compiled, 53 + 24 bytes
conv2gid

symbolic procedure conv2gi2 u;
   if null u then u
   else if numberp u then u * den!*
   else if eqcar(u,'!:gi!:) then '!:gi!:.((den!**cadr u).(den!**cddr u))
   else if eqcar(u,'!:crn!:)
    then <<u := cdr u;
           u:= '!:gi!: . ((den!*/cdar u*caar u).(den!*/cddr u*cadr u))>>
   else if eqcar(u,'!:rn!:) then den!*/cddr u*cadr u
   else if domainp u then rerror(alg,16,list("strange domain",u))
   else lpow u .* conv2gi2(lc u) .+ conv2gi2(red u);
+++ conv2gi2 compiled, 130 + 40 bytes
conv2gi2

symbolic procedure simpx1(u,m,n);
   % U,M and N are prefix expressions.
   % Value is the standard quotient expression for U**(M/N).
   % FLG is true if we have seen a "-" in M.
    begin scalar flg,x,z;
      % Check for imaginary result.
      if eqcar(u,'!*minus!*)
         then if m=1 and fixp n and remainder(n,2)=0
             or n=1 and eqcar(m,'quotient) and cadr m=1 and fixp caddr m
               and remainder(caddr m,2)=0
                 then return multsq(simp list('expt,'i,
                                              list('quotient,1,n/2)),
                          simpexpt list(cadr u,list('quotient,m,n)))
      % and for negative result.
                else if m=1 and fixp n          % n must now be odd.
                 then return negsq
                          simpexpt list(cadr u,list('quotient,m,n));
    if numberp m and numberp n
       or null(smemqlp(frlis!*,m) or smemqlp(frlis!*,n))
      then go to a;
    % exptp!* := t;
    return mksq(list('expt,u,if n=1 then m
                   else list('quotient,m,n)),1);
    a:
    if numberp m then
        if minusp m then <<m := -m; go to mns>>
           else if fixp m then
                   if fixp n then <<
                      if flg then m := -m;
                      z := m;
                      if !*mcd and (fixp u or null !*notseparate)
                        then <<z := z-n*(m := m/n);
                               if z<0 then <<m := m-1; z := z+n>>>>
                       else m := 0;
                      x := simpexpt list(u,m);
                      if z=0 then return x
                      else if n=2 and !*keepsqrts
                       then <<x := multsq(x,apply1(get('sqrt,'simpfn),
                                                   list u));
                              % z can be 1 or -1. I'm not sure if other
                              % values can occur.
                              if z<0 then <<x := invsq x; z := -z>>;
                              return exptsq(x,z)>>
      % Note the indirect call: the integrator rebinds this property.
      % JHD understands this interaction - don't change without
      % consulting him.  Note that, since KEEPSQRTS is true, SIMPSQRT
      % won't recurse on SIMPEXPT1.
                      else return
                              multsq(x,exptsq(simprad(simp!* u,n),z))>>
                   else <<z := m; m := 1>>
                else z:=1
     else if atom m then z:=1
     else if car m eq 'minus then <<m := cadr m; go to mns>>
     else if car m eq 'plus and !*expandexpt then <<
         z := 1 ./ 1;
         for each x in cdr m do
             z := multsq(simpexpt list(u,
                         list('quotient,if flg then list('minus,x)
                                               else x,n)),
                           z);
         return z >>
%%   else if car m eq 'times and fixp cadr m and numberp n
%%    then <<
%%      z := gcdn(n,cadr m);
%%      n := n/z;
%%      z := cadr m/z;
%%      m := retimes cddr m >>
%% BEGIN modification by Francis J. Wright:
     else if car m eq 'times and fixp cadr m
      then <<
        if numberp n
          then <<z := gcdn(n,cadr m); n := n/z; z := cadr m/z>>
         else z := cadr m;
        % retimes seems to me to be overkill here, so try just ...
        m := if cdddr m then 'times . cddr m else caddr m>>
%% END   modification by FJW.
     else if car m eq 'quotient and n=1 and !*expandexpt
      then <<n := caddr m; m := cadr m; go to a>>
     else z := 1;
     if idp u and not flagp(u,'used!*) then flag(list u,'used!*);
        if u = '(minus 1)
               and n=1
               and null numr simp list('difference,m,'(quotient 1 2))
         then <<u := simp 'i; return if flg then negsq u else u>>;
    u := list('expt,u,if n=1 then m else list('quotient,m,n));
    return mksq(u,if flg then -z else z); %U is already in lowest terms;
    mns: %if numberp m and numberp n and !*rationalizeflag
     %  then return multsq(simpx1(u,n-m,n),invsq simp u) else
    % return invsq simpx1(u,m,n)
    if !*mcd then return invsq simpx1(u,m,n);
    flg := not flg;
    go to a;
   end;
+++ simpx1 redefined
+++ simpx1 compiled, 520 + 136 bytes
simpx1

symbolic procedure expf(u,n);
   %U is a standard form. Value is standard form of U raised to
   %negative integer power N. MCD is assumed off;
   %what if U is invertable?;
   if null u then nil
    else if u=1 then u
    else if atom u then mkrn(1,u**(-n))
    else if domainp u then !:expt(u,n)
    else if red u then mksp!*(u,n)
    else if ldeg u memq frlis!*
     then car fkern {'expt,mvar u,ldeg u} .** n .* expf(lc u,n) .+ nil
    else (lambda x; if x>0 and sfp mvar u
             then multf(exptf(mvar u,x),expf(lc u,n))
            else mvar u .** x .* expf(lc u,n) .+ nil)
     (ldeg u*n);
+++ expf redefined
+++ expf compiled, 111 + 56 bytes
expf

% ******* The "radical simplifier" section ******

symbolic procedure simprad(u,n);
   % Simplifies radical expressions.
   if !*reduced then multsq(radfa(numr u,n),invsq radfa(denr u,n))
     else begin scalar iflag,x,y,z;
       if !*rationalize then << % Move all radicands into numerator.
          y:=list(denr u,1); % A partitioned expression.
          u:=multf(numr u, exptf(denr u,n-1)) ./ 1 >>
         else y := radf(denr u,n);
       if n=2 and minusf numr u % Should this be 'evenp n'?
         then <<iflag := t; x := radf(negf numr u,n)>>
        else x := radf(numr u,n);
       z := simp list('quotient,retimes cdr x, retimes cdr y);
       if domainp numr z and domainp denr z
      % This test allows transformations like sqrt(2/3)=>sqrt(2)/sqrt(3)
      % whereas we really don't want to do this for symbolic elements
      % since we can introduce paradoxes that way.
         then z := multsq(mkrootsq(prepf numr z,n),
                          invsq mkrootsq(prepf denr z,n))
        else <<if iflag
                 then <<iflag := nil; % Absorb the "i" in square root.
                        z := negsq z>>;
               z := mkrootsq(prepsq z,n)>>;
       z := multsq(multsq(if !*precise and evenp n
                            then car x ./ 1   % mkabsf0 car x
                           else car x ./ 1, 1 ./ car y), z);
       if iflag then z := multsq(z,mkrootsq(-1,2));
       return z
   end;
+++ simprad redefined
+++ simprad compiled, 175 + 96 bytes
simprad

symbolic procedure radfa(u,n);
   begin scalar x,y;
      x := fctrf u;
      if numberp car x then x := append(zfactor car x,cdr x)
       else x := (car x ./ 1) . cdr x;
      y := 1 ./ 1;
      for each j in x do y := multsq(y,radfb(car j,cdr j,n));
      return y
   end;
+++ radfa compiled, 53 + 28 bytes
radfa

symbolic procedure radfb(u,m,n);
   begin scalar x,y;
      x := radf(u,n);
    % if !*precise and evenp n then y := mkabsf0 car x ./ 1 else
      y := exptf(car x,m) ./ 1;
      return multsq(exptsq(mkrootlsq(cdr x,n),m),y)
   end;
+++ radfb compiled, 20 + 32 bytes
radfb

symbolic procedure mkrootlsq(u,n);
   % U is a list of prefix expressions, N an integer.
   % Value is standard quotient for U**(1/N);
   % NOTE we need the REVAL call so that PREPSQXX is properly called on
   % the argument for consistency with the pattern matcher.  Otherwise
   % for all x,y let sqrt(x)*sqrt(y)=sqrt(x*y); sqrt(30*(l+1))*sqrt 5;
   % goes into an infinite loop.
   if null u then !*d2q 1
    else if null !*reduced then mkrootsq(reval retimes u,n)
    else mkrootlsq1(u,n);
+++ mkrootlsq compiled, 20 + 36 bytes
mkrootlsq

symbolic procedure mkrootlsq1(u,n);
   if null u then !*d2q 1
    else multsq(mkrootsq(car u,n),mkrootlsq1(cdr u,n));
+++ mkrootlsq1 compiled, 27 + 24 bytes
mkrootlsq1

symbolic procedure mkrootsq(u,n);
   % U is a prefix expression, N an integer.
   % Value is a standard quotient for U**(1/N).
   if u=1 then !*d2q 1
    else if n=2 and (u= -1 or u= '(minus 1)) then simp 'i
    else if eqcar(u,'expt) and fixp caddr u and null !*precise_complex
     then exptsq(mkrootsq(cadr u,n),caddr u)
    else begin scalar x,y;
            if fixp u and not minusp u
                      and (length(x :=
                            zfactor1(u,u<factorbound!* or !*ifactor))>1
                           or cdar x>1)
              then return mkrootsql(x,n);
            x := if n=2 then mksqrt u
                  else list('expt,u,list('quotient,1,n));
            if y := opmtch x then return simp y
             else return mksq(x,1)
         end;
+++ mkrootsq redefined
+++ mkrootsq compiled, 121 + 80 bytes
mkrootsq

symbolic procedure mkrootsql(u,n);
   if null u then !*d2q 1
    else if cdar u>1
     then multsq(exptsq(mkrootsq(caar u,n),cdar u),mkrootsql(cdr u,n))
    else multsq(mkrootsq(caar u,n),mkrootsql(cdr u,n));
+++ mkrootsql redefined
+++ mkrootsql compiled, 39 + 28 bytes
mkrootsql


COMMENT The following four procedures return a partitioned root
    expression, which is a dotted pair of integral part (a standard
    form) and radical part (a list of prefix expressions). The whole
    structure represents U**(1/N);

symbolic procedure check!-radf!-sign(rad,result,n);
   % Changes the sign of result if result**n = -rad. rad and result are
   % s.f.'s, n is an integer.
   (if evenp n and s = -1 or
       not evenp n and numberp s and
        ((numberp s1 and s neq s1)
           where s1 = reval {'sign,mk!*sq !*f2q rad})
      then negf result
     else result)
    where s = reval{'sign,mk!*sq !*f2q result};
+++ check!-radf!-sign compiled, 54 + 32 bytes
check-radf-sign

symbolic procedure radf(u,n);
   % U is a standard form, N a positive integer. Value is a partitioned
   % root expression for U**(1/N).
   begin scalar ipart,rpart,x,y,z,!*gcd,!*mcd;
      if null u then return list u;
      !*gcd := !*mcd := t;  % mcd cannot be off in this code.
      ipart := 1;
      z := 1;
      while not domainp u do
     <<y := comfac u;
       if car y
         then <<x := if !*precise_complex then 0 . pdeg car y
                      else divide(pdeg car y,n);
            if car x neq 0
              then ipart := multf(
                   if evenp car x
                      then !*p2f(mvar u .** car x)
%                   else if !*precise
%                    then !*p2f mksp(numr
%                    then exptf(numr
%                                    simp list('abs,if sfp mvar u
%                                                     then prepf mvar u
%                                                    else mvar u),
                    else check!-radf!-sign(!*p2f(mvar u .** pdeg car y),
                                           !*p2f(
                             if !*precise and evenp n then mksp({'abs, sfchk mvar u}, car x)
                              else mvar u .** car x),
                                           n),
                    ipart);
            if cdr x neq 0
              then rpart := mkexpt(sfchk mvar u,cdr x) . rpart>>;
       x := quotf(u,comfac!-to!-poly y);   % We need *exp on here.
       u := cdr y;
       if !*reduced and minusf x
         then <<x := negf x; u := negf u>>;
       if flagp(dmode!*,'field) then
          <<y := lnc x;
                if y neq 1 then <<x := quotf(x,y); z := multd(y,z)>>>>;
       if x neq 1
         then <<x := radf1(if !*precise_complex or !*modular then {x .^ 1} 
                            else sqfrf x,n);
                y := car x;
                if y neq 1 then
                   <<if !*precise and evenp n
                       then y := !*kk2f {'abs,prepf y};
                     ipart := multf(y,ipart)>>;
                rpart := append(rpart,cdr x)>>>>;
      if u neq 1
    then <<x := radd(u,n);
           ipart := multf(car x,ipart);
           rpart := append(cdr x,rpart)>>;
      if z neq 1
    then if !*numval
        and (y := domainvalchk('expt,
                       list(!*f2q z,!*f2q !:recip n)))
           then ipart := multd(!*q2f y,ipart)
          else rpart := prepf z . rpart;  % was aconc(rpart,z).
      return ipart . rpart
   end;
+++ radf compiled, 331 + 144 bytes
radf

symbolic procedure radf1(u,n);
   %U is a form_power list, N a positive integer. Value is a
   %partitioned root expression for U**(1/N);
   begin scalar ipart,rpart,x;
      ipart := 1;
      for each z in u do
     <<x := divide(cdr z,n);
       if not(car x=0)
            then ipart := multf(
                 check!-radf!-sign(!*p2f z,exptf(car z,car x),n),ipart);
          if not(cdr x=0)
            then rpart := mkexpt(prepsq!*(car z ./ 1),cdr x)
                   . rpart>>;
      return ipart . rpart
   end;
+++ radf1 compiled, 60 + 36 bytes
radf1

symbolic procedure radd(u,n);
   %U is a domain element, N an integer.
   %Value is a partitioned root expression for U**(1/N);
   begin scalar bool,ipart,x;
      if not atom u then return list(1,prepf u);
%      then if x := integer!-equiv u then u := x
%            else return list(1,prepf u);
      if u<0 and evenp n then <<bool := t; u := -u>>;
      x := nrootnn(u,n);
      if bool then if !*reduced and n=2
             then <<ipart := multd(car x,!*k2f 'i);
                x := cdr x>>
            else <<ipart := car x; x := -cdr x>>
       else <<ipart := car x; x := cdr x>>;
      return if x=1 then list ipart else list(ipart,x)
   end;
+++ radd redefined
+++ radd compiled, 76 + 44 bytes
radd

% symbolic procedure iroot(m,n);
%    %M and N are positive integers.
%   %If M**(1/N) is an integer, this value is returned, otherwise NIL;
%   begin scalar x,x1,bk;
%      if m=0 then return m;
%      x := 10**iroot!-ceiling(lengthc m,n);   %first guess;
%   a: x1 := x**(n-1);
%      bk := x-m/x1;
%      if bk<0 then return nil
%       else if bk=0 then return if x1*x=m then x else nil;
%      x := x - iroot!-ceiling(bk,n);
%      go to a
%   end;

 symbolic procedure iroot(n,r);
    % N, r are integers; r >= 1.  If n is an exact rth power then its
    % rth root is returned, otherwise NIL.
    begin scalar tmp;
       tmp := irootn(n,r);
       return if tmp**r = n then tmp else nil
  end;
+++ iroot compiled, 12 + 12 bytes
iroot

symbolic procedure iroot!-ceiling(m,n);
   %M and N are positive integers. Value is ceiling of (M/N) (i.e.,
   %least integer greater or equal to M/N);
   (lambda x; if cdr x=0 then car x else car x+1) divide(m,n);
+++ iroot!-ceiling compiled, 12 + 12 bytes
iroot-ceiling

symbolic procedure mkexpt(u,n);
   if n=1 then u else list('expt,u,n);
+++ mkexpt redefined
+++ mkexpt compiled, 9 + 16 bytes
mkexpt

% The following definition is due to Eberhard Schruefer.

symbolic procedure nrootn(n,x);
   % N is an integer, x a positive integer. Value is a pair
   % of integers r,s such that r*s**(1/x)=n**(1/x).
   begin scalar fl,r,s,m,signn;
     r := 1;
     s := 1;
     if n<0 then <<n := -n; if evenp x then signn := t else r := -1>>;
     fl := zfactor n;
     for each j in fl do
         <<m := divide(cdr j,x);
           r := car j**car m*r;
           s := car j**cdr m*s>>;
     if signn then s := -s;
     return r . s
   end;
+++ nrootn compiled, 67 + 24 bytes
nrootn

% symbolic procedure nrootn(n,x);
%   % N is an integer, X a positive integer. Value is a pair
%   % of integers I,J such that I*J**(1/X)=N**(1/X).
%   begin scalar i,j,r,signn;
%      r := 1;
%      if n<0 then <<n := -n; if evenp x then signn := t else r := -1>>;
%      j := 2**x;
%      while remainder(n,j)=0 do <<n := n/j; r := r*2>>;
%      i := 3;
%      j := 3**x;
%      while j<=n do
%         <<while remainder(n,j)=0 do <<n := n/j; r := r*i>>;
%           if remainder(i,3)=1 then i := i+4 else i := i+2;
%           j := i**x>>;
%      if signn then n := -n;
%      return r . n
%   end;

switch precise_complex;nil

put('precise_complex,'simpfg,'((t nil) (nil (rmsubs))));((t nil) (nil (rmsubs)))

% ***** simplification functions for other explicit operators *****

symbolic procedure simpiden u;
   % Convert the operator expression U to a standard quotient.
   % Note: we must use PREPSQXX and not PREPSQ* here, since the REVOP1
   % in SUBS3T uses PREPSQXX, and terms must be consistent to prevent a
   % loop in the pattern matcher.
   begin scalar bool,fn,x,y,z;
    fn := car u; u := cdr u;
    % Allow prefix ops with names of symbolic functions.
    if (get(fn,'!:rn!:) or get(fn,'!:rd!:)) and (x := valuechk(fn,u))
      then return x;
    % Keep list arguments in *SQ form.
    if u and eqcar(car u,'list) and null cdr u
      then return mksq(list(fn,aeval car u),1);
    x := for each j in u collect aeval j;
    u := for each j in x collect
              if eqcar(j,'!*sq) then prepsqxx cadr j
               else if numberp j then j
               else <<bool := t; j>>;
%   if u and car u=0 and (flagp(fn,'odd) or flagp(fn,'oddreal))
    if u and car u=0 and flagp(fn,'odd)
         and not flagp(fn,'nonzero)
      then return nil ./ 1;
    u := fn . u;
    if flagp(fn,'noncom) then ncmp!* := t;
    if null subfg!* then go to c
     else if flagp(fn,'linear) and (z := formlnr u) neq u
      then return simp z
     else if z := opmtch u then return simp z;
 %   else if z := get(car u,'opvalfn) then return apply1(z,u);
 %    else if null bool and (z := domainvalchk(fn,
 %                for each j in x collect simp j))
 %     then return z;
    c:  if flagp(fn,'symmetric) then u := fn . ordn cdr u
     else if flagp(fn,'antisymmetric)
      then <<if repeats cdr u then return (nil ./ 1)
          else if not permp(z:= ordn cdr u,cdr u) then y := t;
         % The following patch was contributed by E. Schruefer.
         fn := car u . z;
         if z neq cdr u and (z := opmtch fn)
           then return if y then negsq simp z else simp z;
         u := fn>>;
%    if (flagp(fn,'even) or flagp(fn,'odd))
%       and x and minusf numr(x := simp car x)
%     then <<if flagp(fn,'odd) then y := not y;
%   if (flagp(fn,'even) or flagp(fn,'odd) or flagp(fn,'oddreal)
%          and x and not_imag_num car x)
    if (flagp(fn,'even) or flagp(fn,'odd))
         and x and minusf numr(x := simp car x)
     then <<if not flagp(fn,'even) then y := not y;
        u := fn . prepsqxx negsq x . cddr u;
        if z := opmtch u
          then return if y then negsq simp z else simp z>>;
    u := mksq(u,1);
    return if y then negsq u else u
   end;
+++ simpiden redefined
+++ simpiden compiled, 349 + 116 bytes
simpiden

switch rounded;nil

symbolic procedure not_imag_num a;
 % Tests true if a is a number that is not a pure imaginary number.
 % Rebinds sqrtfn and *keepsqrts to make integrator happy.
 % Note the need to re-bind !*inside!-int!* to nil so that the simplification
 % of square roots behaves in the generic way rather than using the
 % specialist code present in the integrator.
   begin scalar !*keepsqrts,!*msg,!*numval,dmode,!*inside!-int!*;
      dmode := dmode!*;
      !*numval := t;
      on rounded,complex;
      a := resimp simp a;
      a := numberp denr a and domainp numr a and numr repartsq a;
      off rounded,complex;
      if dmode then onoff(get(dmode,'dname),t);
      return a
   end;
+++ not_imag_num compiled, 71 + 68 bytes
not_imag_num

flagop even,odd,nonzero;nil

symbolic procedure domainvalchk(fn,u);
   begin scalar x;
      if (x := get(dmode!*,'domainvalchk)) then return apply2(x,fn,u);
      % The later arguments tend to be smaller ...
      u := reverse u;
  a:  if null u then return valuechk(fn,x)
       else if denr car u neq 1 then return nil;
      x := mk!*sq car u . x;
      u := cdr u;
      go to a
   end;
+++ domainvalchk redefined
+++ domainvalchk compiled, 35 + 24 bytes
domainvalchk

symbolic procedure valuechk(fn,u);
   begin scalar n;
      if (n := get(fn,'number!-of!-args)) and
         length u neq n and
         not flagp(fn, 'variadic)
         or not n and
            u and
            cdr u and
            (get(fn,'!:rd!:) or get(fn,'!:rn!:))
       then <<
          if !*strict_argcount then
              rerror(alg,17,list("Wrong number of arguments to",fn))
          else lprim list("Wrong number of arguments to", fn) >>; 
      u := opfchk!!(fn . u);
      if u then return znumrnil
          ((if eqcar(u,'list) then list((u . 1) . 1) else u) ./ 1)
   end;
+++ valuechk redefined
+++ valuechk compiled, 83 + 60 bytes
valuechk

symbolic procedure znumrnil u; if znumr u then nil ./ 1 else u;
+++ znumrnil redefined
+++ znumrnil compiled, 11 + 16 bytes
znumrnil

symbolic procedure znumr u;
   null (u := numr u) or numberp u and zerop u
   or not atom u and domainp u and
     (y and apply1(y,u) where y=get(car u,'zerop));
+++ znumr compiled, 34 + 12 bytes
znumr

symbolic procedure opfchk!! u;
   begin scalar fn,fn1,sf,sc,int,ce; fn1 := fn := car u; u := cdr u;
     % first save fn and check to see whether fn is defined.
     % Integer functions are defined in !:rn!:,
     % real functions in !:rd!:, and complex functions in !:cr!:.
      fn := if flagp(fn,'integer) then <<int := t; get(fn,'!:rn!:)>>
         else if !*numval and dmode!* memq '(!:rd!: !:cr!:)
            then get(fn,'!:rd!:);
      if not fn then return nil;
      sf := if int then 'simprn
         else if (sf := get(fn,'simparg)) then sf else 'simprd;
     % real function fn is defined.  now check for complex argument.
      if int or not !*complex then go to s; % the simple case.
     % mode is complex, so check for complex argument.
     % list argument causes a slight complication.
      if eqcar(car u,'list)
         then if (sc := simpcr revlis cdar u) and eqcar(sc,nil)
            then go to err else go to s;
      if not (u := simpcr revlis u) then return nil
     % if fn1 = 'expt, then evaluate complex function only; else
     % if argument is real, evaluate real function, but if error
     % occurs, then evaluate complex function.
      else if eqcar(u,nil) or
          fn1 eq 'expt and rd!:minusp caar u then u := cdr u
         else <<ce := cdr u; u := car u; go to s>>;
     % argument is complex or real function failed.
     % now check whether complex fn is defined.
 evc: if fn := get(fn1,'!:cr!:) then go to a;
 err: rerror(alg,18,list(fn1,"is not defined as complex function"));
   s: if not (u := apply1(sf, revlis u)) then return nil;
   a: u := errorset2 list('apply,mkquote fn,mkquote u);
% With any Lisp system that evaluates elementary functions on floating
% inputs and is capable of generating a complex output (rather that raising
% an exception) I need to take care. This would apply to Common Lisp and
% is now the case for CSL.
      if errorp u or (eqcar(u := car u, '!:rd!:) and complexp cdr u) then
         if ce then <<u := ce; ce := nil; go to evc>> else return nil
       else return if int then intconv u else u
   end;
+++ opfchk!! redefined
+++ opfchk!! compiled, 185 + 120 bytes
opfchk!

symbolic procedure intconv x;
   if null dmode!* or dmode!* memq '(!:rd!: !:cr!:) then x
   else apply1(get(dmode!*,'i2d),x);
+++ intconv redefined
+++ intconv compiled, 14 + 16 bytes
intconv

symbolic procedure simpcr x;
 % Returns simprd x if all args are real, else nil . "simpcr" x.
  if atom x then nil else
   <<(<<if not errorp y then z := car y;
        y := simplist x where dmode!* = '!:cr!:;
        if y then z . y else z>>)
   where z=nil,y=errorset2 list('simprd,mkquote x)>>;
+++ simpcr compiled, 37 + 40 bytes
simpcr

symbolic procedure simprd x;
   % Converts any argument list that can be converted to list of rd's.
   if atom x then nil else <<simplist x where dmode!* = '!:rd!:>>;
+++ simprd redefined
+++ simprd compiled, 14 + 24 bytes
simprd

symbolic procedure simplist x;
   begin scalar fl,c; c := get(dmode!*,'i2d);
     x := for each a in x collect (not fl and
        <<if null (a := mconv numr b) then a := 0;
          if numberp a then a := apply1(c,a)
             else if not(domainp a and eqcar(a,dmode!*)) then fl := t;
          if not fl and
             (numberp(b := mconv denr b) and (b := apply1(c,b))
             or domainp b and eqcar(b,dmode!*))
                then apply2(get(dmode!*,'quotient),a,b) else fl := t>>
        where b=simp!* a);
    if not fl then return x
   end;
+++ simplist compiled, 194 + 32 bytes
simplist

symbolic procedure mconv v; <<dmconv0 dmode!*; mconv1 v>>;
+++ mconv redefined
+++ mconv compiled, 7 + 20 bytes
mconv

symbolic procedure dmconv0 dmd;
   dmd!* := if null dmd then '!:rn!:
        else if dmd eq '!:gi!: then '!:crn!: else dmd;
+++ dmconv0 redefined
+++ dmconv0 compiled, 15 + 24 bytes
dmconv0

symbolic procedure dmconv1 v;
   if null v or eqcar(v,dmd!*) then v
   else if atom v then if flagp(dmd!*,'convert)
      then apply1(get(dmd!*,'i2d),v) else v
   else if domainp v then apply1(get(car v,dmd!*),v)
   else lpow v .* dmconv1(lc v) .+ dmconv1(red v);
+++ dmconv1 compiled, 62 + 12 bytes
dmconv1

symbolic procedure mconv1 v;
   if domainp v then drnconv v
   else lpow v .* mconv1(lc v) .+ mconv1(red v);
+++ mconv1 redefined
+++ mconv1 compiled, 26 + 12 bytes
mconv1

symbolic procedure drnconv v;
   if null v or numberp v or eqcar(v,dmd!*) then v else
   <<(if y and atom y then apply1(y,v) else v)
   where y=get(car v,dmd!*)>>;
+++ drnconv redefined
+++ drnconv compiled, 24 + 12 bytes
drnconv

% Absolute Value Function.

symbolic procedure simpabs u;
   if null u or cdr u then mksq('abs . revlis u, 1)  % error?.
    else begin scalar x;
      u := car u;
      if numberp u then return abs u ./ 1
       else if x := sign!-abs u then return x;
      u := simp!* u;
      return if null numr u then nil ./ 1
        else quotsq(simpabs1 numr u, simpabs1 denr u);
    end;
+++ simpabs redefined
+++ simpabs compiled, 53 + 40 bytes
simpabs

symbolic procedure simpabs1 u;
   % Currently abs(sqrt(2)) does not simplify, whereas it clearly
   % should simplify to just sqrt(2).  The facts that abs(i) -> 1 and
   % abs(sqrt(-2)) -> abs(sqrt(2)) imply that REDUCE regards abs as
   % the complex modulus function, in which case I think it is always
   % correct to commute abs and sqrt.  However, I will do this only if
   % the result is a simplification.  FJW, 18 July 1998
   begin scalar x,y,w;
      x:=prepf u; u := u ./ 1;
      if eqcar(x,'minus) then x:=cadr x;
      % FJW: abs sqrt y -> sqrt abs y if abs y simplifies.
      if eqcar(x,'sqrt) then
         return !*kk2q if eqcar(y:=reval('abs.cdr x), 'abs)
         then {'abs, x} else {'sqrt, y};
%%    if eqcar(x,'times) and (y:=split!-sign cdr x) then
%%    <<w:=simp!* retimes car y; u:=quotsq(u,w);
%%      if cadr y then
%%       <<y:=simp!* retimes cadr y; u:=quotsq(u,y);
%%         w:=multsq(negsq y,w)>>
%%    >>;
      if eqcar(x,'times) then
      begin scalar abslist, noabs;
         for each fac in cdr x do
            % FJW: abs sqrt y -> sqrt abs y if abs y simplifies.
            if eqcar(fac,'sqrt)
               and not eqcar(y:=reval('abs.cdr fac), 'abs)
            then noabs := {'sqrt, y} . noabs
            else abslist := fac . abslist;
         abslist := reversip abslist;
         if noabs then
            u := quotsq(u, noabs := simp!*('times . reversip noabs));
         if (y:=split!-sign abslist) then
         <<w:=simp!* retimes car y; u:=quotsq(u,w);
            if cadr y then
            <<y:=simp!* retimes cadr y; u:=quotsq(u,y);
               w:=multsq(negsq y,w)>>;
            if noabs then w := multsq(noabs, w)
         >>
         else w := noabs
      end;
      if numr u neq 1 or denr u neq 1 then
         u:=quotsq(mkabsf1 absf numr u,mkabsf1 denr u);
      if w then u:=multsq(w,u);
      return u
   end;
+++ simpabs1 compiled, 190 + 72 bytes
simpabs1

%symbolic procedure rd!-abs u;
%   % U is a prefix expression.  If it represents a constant, return the
%   % abs of u.
%   (if !*rounded or not constant_exprp u then nil
%    else begin scalar x,y,dmode!*;
%           setdmode('rounded,t) where !*msg := nil;
%           x := aeval u;
%           if evalnumberp x
%             then if null !*complex or 0=reval {'impart,x}
%                    then y := if evalgreaterp(x,0) then u
%                               else if evalequal(x,0) then 0
%                               else {'minus,u};
%           setdmode('rounded,nil) where !*msg := nil;
%           return if y then simp y else nil
%       end) where alglist!*=alglist!*;

symbolic procedure sign!-abs u;
   % Sign based evaluation of abs - includes the above rd!-abs
   % method as sub-branch.
    <<if not numberp n then nil else
      simp if n<0 then {'minus,u} else if n=0 then 0 else u
      >> where n=sign!-of u;
+++ sign!-abs redefined
+++ sign!-abs compiled, 26 + 24 bytes
sign-abs

symbolic procedure constant_exprp u;
   % True if u evaluates to a constant (i.e., number).
   if atom u
     then numberp u or flagp(u,'constant) or u eq 'i and idomainp()
    else (flagp(car u,'realvalued)
             or flagp(car u,'alwaysrealvalued)
             or car u memq '(plus minus difference times quotient)
             or get(car u,'!:rd!:)
             or !*complex and get(car u,'!:cr!:))
          and not atom cdr u
          and constant_expr_listp cdr u;
+++ constant_exprp redefined
+++ constant_exprp compiled, 61 + 48 bytes
constant_exprp

symbolic procedure constant_expr_listp u;
   % True if all members of u are constant_exprp.
   % U can be a dotted pair as well as a list.
   if atom u
     then null u or numberp u or flagp(u,'constant)
        or u eq 'i and idomainp()
    else constant_exprp car u and constant_expr_listp cdr u;
+++ constant_expr_listp redefined
+++ constant_expr_listp compiled, 42 + 20 bytes
constant_expr_listp

symbolic procedure mkabsf0 u; simp{'abs,mk!*sq !*f2q u};
+++ mkabsf0 compiled, 12 + 24 bytes
mkabsf0

symbolic procedure mkabsf1 u;
   if domainp u then mkabsfd u
    else begin scalar x,y,v;
           x := comfac!-to!-poly comfac u;
           u := quotf1(u,x);
           y := split!-comfac!-part x;
           x := cdr y;
           y := car y;
           if positive!-sfp u then <<y := multf(u,y); u := 1>>;
           u := multf(u,x);
           v := lnc y;
           y := quotf1(y,v);
           v := multsq(mkabsfd v,y ./ 1);
           return if u = 1 then v
                   else multsq(v,simpiden list('abs,prepf absf u))
        end;
+++ mkabsf1 compiled, 85 + 64 bytes
mkabsf1

symbolic procedure mkabsfd u;
   if null idomainp() or pairp u and get(car u,'abs) then !:abs u ./ 1
    else (simpexpt list(prepsq nrm,'(quotient 1 2))
          where nrm = addsq(multsq(car us,car us),
                             multsq(cdr us,cdr us))
          where us = splitcomplex u);
+++ mkabsfd compiled, 43 + 48 bytes
mkabsfd

symbolic procedure positive!-sfp u;
   if domainp u
      then if idomainp()
              then !:zerop impartf u and null !:minusp repartf u
            else null !:minusp u
    else positive!-powp lpow u and positive!-sfp lc u
         and positive!-sfp red u;
+++ positive!-sfp compiled, 42 + 32 bytes
positive-sfp

symbolic procedure positive!-powp u;
   not atom car u and caar u memq '(abs norm);
+++ positive!-powp redefined
+++ positive!-powp compiled, 9 + 12 bytes
positive-powp

% symbolic procedure positive!-powp u;
%    % This definition allows for the testing of positive valued vars.
%    if atom car u then flagp(car u, 'positive)
%     else ((if x then apply2(x,car u,cdr u) else nil)
%           where x = get(caar u,'positivepfn));

symbolic procedure split!-comfac!-part u;
   split!-comfac(u,1,1);
+++ split!-comfac!-part redefined
+++ split!-comfac!-part compiled, 6 + 16 bytes
split-comfac-part

symbolic procedure split!-comfac(u,v,w);
   if domainp u then multd(u,v) . w
    else if red u then
       if positive!-sfp u then multf(u,v) . w
        else v . multf(u,w)
    else if mvar u eq 'i then split!-comfac(lc u,v,w)
    else if positive!-powp lpow u
      then split!-comfac(lc u,multpf(lpow u,v),w)
    else split!-comfac(lc u,v,multpf(lpow u,w));
+++ split!-comfac compiled, 74 + 32 bytes
split-comfac

put('abs,'simpfn,'simpabs);simpabs

symbolic procedure simpdiff u;
   <<ckpreci!# u; addsq(simpcar u,simpminus cdr u)>>;
+++ simpdiff redefined
+++ simpdiff compiled, 12 + 24 bytes
simpdiff

put('difference,'simpfn,'simpdiff);simpdiff

symbolic procedure simpminus u;
   negsq simp carx(u,'minus);
+++ simpminus redefined
+++ simpminus compiled, 7 + 24 bytes
simpminus

put('minus,'simpfn,'simpminus);simpminus

symbolic procedure simpplus u;
   begin scalar z;
     if length u=2 then ckpreci!# u;
     z := nil ./ 1;
  a: if null u then return z;
     z := addsq(simpcar u,z);
     u := cdr u;
     go to a
   end;
+++ simpplus redefined
+++ simpplus compiled, 24 + 28 bytes
simpplus

put('plus,'simpfn,'simpplus);simpplus

symbolic procedure ckpreci!# u;
   % Screen for complex number input.
   !*complex
      and (if a and not b then ckprec2!#(cdar u,cadr u)
            else if b and not a then ckprec2!#(cdadr u,car u))
            where a=timesip car u,b=timesip cadr u;
+++ ckpreci!# redefined
+++ ckpreci!# compiled, 31 + 20 bytes
ckpreci#

symbolic procedure timesip x; eqcar(x,'times) and 'i memq cdr x;
+++ timesip redefined
+++ timesip compiled, 10 + 16 bytes
timesip

symbolic procedure ckprec2!#(im,rl);
   % Strip im and rl to domains.
   <<im := if car im eq 'i then cadr im else car im;
     if eqcar(im,'minus) then im := cadr im;
     if eqcar(rl,'minus) then rl := cadr rl;
     if domainp im and domainp rl and not(atom im and atom rl)
        then ckprec3!#(!?a2bf im,!?a2bf rl)>>;
+++ ckprec2!# compiled, 48 + 24 bytes
ckprec2#

remflag('(!?a2bf),'lose);nil   % Until things stabilize.

% This is now in csl.red and psl.red in the support directory.
%symbolic inline procedure make!:ibf (mt, ep);
%   '!:rd!: . (mt . ep);
%
% And i2bf is then in arith.red...
% symbolic inline procedure i2bf!: u; make!:ibf (u, 0);

symbolic procedure !?a2bf a;
   % Convert decimal or integer to bfloat.
   if atom a then if numberp a then i2bf!: a else nil
    else if eqcar(a,'!:dn!:) then a;
+++ !?a2bf compiled, 19 + 16 bytes
?a2bf

symbolic procedure ckprec3!#(x,y);
  % if inputs are valid, check for precision increase.
   if x and y then
   precmsg max(length explode abs cadr x+cddr x,
               length explode abs cadr y+cddr y);
+++ ckprec3!# compiled, 32 + 16 bytes
ckprec3#

symbolic procedure simpquot q;
   (if null numr u
      then if null numr v then rerror(alg,19,"0/0 formed")
            else rerror(alg,20,"Zero divisor")
     else if dmode!* memq '(!:rd!: !:cr!:) and domainp numr u
        and domainp denr u and domainp denr v
            and !:onep denr u and !:onep denr v
      then (if null numr v then nil else divd(numr v,numr u)) ./ 1
     else <<q := multsq(v,simprecip cdr q);
            if !*modular and null denr q
              then rerror(alg,201,"Zero divisor");
            q>>)
   where v=simpcar q,u=simp cadr q;
+++ simpquot redefined
+++ simpquot compiled, 103 + 76 bytes
simpquot

put('quotient,'simpfn,'simpquot);simpquot

symbolic procedure simprecip u;
   if null !*mcd then simpexpt list(carx(u,'recip),-1)
    else invsq simp carx(u,'recip);
+++ simprecip redefined
+++ simprecip compiled, 18 + 36 bytes
simprecip

put('recip,'simpfn,'simprecip);simprecip

symbolic procedure simpset u;
  begin scalar x;
     x := prepsq simp!* car u;
     if null x % or not idp x
       then typerr(x,"set variable");
     let0 list(list('equal,x,mk!*sq(u := simp!* cadr u)));
     return u
  end;
+++ simpset compiled, 26 + 36 bytes
simpset

put ('set, 'simpfn, 'simpset);simpset

symbolic procedure unset u;
  for each j in u do unset1 j;
+++ unset compiled, 15 + 12 bytes
unset

rlistat '(unset);nil

symbolic procedure unset1 u;
  begin scalar x;
    x := if atom u then get(u,'avalue)
          else assoc(u,get(car u,'kvalue));
    if null x or null kernp (x := cadadr x) then return;
    x := numr mvar x;
    if (atom x and null get(x,'avalue)) or
       (null atom x and null assoc(x,get(car x,'kvalue)))
       then clear u
     else clear x
  end;
+++ unset1 compiled, 57 + 16 bytes
unset1 

% sqrt should now have a fixed simpfn - this one - which diverts to
% whatever is actually needed.

symbolic procedure outer!-simpsqrt u;
  if !*inside!-int!* then proper!-simpsqrt u
  else simpsqrt u;
+++ outer!-simpsqrt redefined
+++ outer!-simpsqrt compiled, 10 + 20 bytes
outer-simpsqrt

symbolic procedure simpsqrt u;
   if u=0 then nil ./ 1 else
   if null !*keepsqrts
     then simpexpt1(carx(u,'sqrt), simpexpon '(quotient 1 2), nil)
    else begin scalar x,y;
       x := xsimp carx(u,'sqrt);
       return if null numr x then nil ./ 1
               else if denr x=1 and domainp numr x and !:minusp numr x
                then if numr x=-1 then simp 'i
                      else multsq(simp 'i,
                                  simpsqrt list prepd !:minus numr x)
               else if y := domainvalchk('sqrt,list x) then y
               else simprad(x,2)
     end;
+++ simpsqrt compiled, 94 + 84 bytes
simpsqrt

symbolic procedure xsimp u; expchk simp!* u;
+++ xsimp redefined
+++ xsimp compiled, 5 + 16 bytes
xsimp

symbolic procedure simptimes u;
   begin scalar x,y;
    if null u then return 1 ./ 1;
    if tstack!* neq 0 or null mul!* then go to a0;
    y := mul!*;
    mul!* := nil;
    a0: tstack!* := tstack!*+1;
    x := simpcar u;
    a:    u := cdr u;
    if null numr x then go to c
     else if null u then go to b;
    x := multsq(x,simpcar u);
    go to a;
    b:    if null mul!* or tstack!*>1 then go to c;
    x:= apply1(car mul!*,x);
    alglist!* := nil . nil;   % since we may need MUL!* set again.
    mul!*:= cdr mul!*;
    go to b;
    c:    tstack!* := tstack!*-1;
    if tstack!* = 0 then mul!* := y;
    return x;
   end;
+++ simptimes redefined
+++ simptimes compiled, 72 + 36 bytes
simptimes

put('times,'simpfn,'simptimes);simptimes

symbolic procedure resimp u;
   % U is a standard quotient.
   % Value is the resimplified standard quotient.
   resimp1 u where varstack!*=nil;
+++ resimp redefined
+++ resimp compiled, 9 + 20 bytes
resimp

symbolic procedure resimp1 u;
   begin
      u := quotsq(subf1(numr u,nil),subf1(denr u,nil));
      !*sub2 := t;
      return u
   end;
+++ resimp1 redefined
+++ resimp1 compiled, 14 + 24 bytes
resimp1

symbolic procedure simp!*sq u;
   if cadr u and null !*resimp then car u else resimp1 car u;
+++ simp!*sq redefined
+++ simp!*sq compiled, 11 + 16 bytes
simp*sq

put('!*sq,'simpfn,'simp!*sq);simp*sq

endmodule;nil

end;nilmodule exptchk;nil   % Check expt products for further simplification.

% Author: Anthony C. Hearn.

% Copyright (c) 2005, Anthony C. Hearn.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*combineexpt);nil

switch combineexpt;nil

put('combineexpt,'simpfg,'((t (rmsubs)) (nil (rmsubs))));((t (rmsubs)) (nil (
rmsubs)))

symbolic procedure exptchksq u;
   % U is a standard quotient. Result is u with possible expt
   % simplifications.
   if null !*combineexpt then u
    else multsq(exptchk numr u,invsq exptchk denr u);
+++ exptchksq redefined
+++ exptchksq compiled, 13 + 24 bytes
exptchksq

symbolic procedure exptchk u;
   if domainp u then u ./ 1
    else (if length v<2 then u ./ 1 else exptchk0(u,nil,v)) where v=comm_kernels u;
+++ exptchk redefined
+++ exptchk compiled, 28 + 24 bytes
exptchk

symbolic procedure exptchk0(u,v,w);
   if null u then nil ./ 1
    else if domainp u then exptunwind(u,v)
    else if expttermp(mvar u,w)
     then addsq(exptchk0(lc u,lpow u . v,w),exptchk0(red u,v,w))
    else addsq(multsq(!*p2f lpow u ./ 1,exptchk0(lc u,v,w)),exptchk0(red u,v,w));
+++ exptchk0 compiled, 67 + 28 bytes
exptchk0

symbolic procedure expttermp(u,v);
   if eqcar(u,'expt) then expttermp1(cadr u,v) else expttermp1(u,v);
+++ expttermp redefined
+++ expttermp compiled, 14 + 16 bytes
expttermp

symbolic procedure expttermp1(u,v);
   v and (u=car v or (eqcar(car v,'expt) and u=cadar v)
             or expttermp1(u,cdr v));
+++ expttermp1 redefined
+++ expttermp1 compiled, 25 + 16 bytes
expttermp1

symbolic procedure exptunwind(u,v);
   begin integer n; scalar w,x;
   % U is a standard form, v a list of powers.
   % Result is a standard form of product(v) * u.
   % This function is the key to a better treatment of surds.
      n := 1;
      while v do
   %%%   <<if !*combineexpt and cdr v and (w := meldx(car v,cdr v))
         <<if cdr v and (w := meldx(car v,cdr v))
             then <<x := mergex(car v,w);
                    if fixp x then <<n := x*n; v := delete(w,cdr v)>>
                     else v := x . delete(w,cdr v)>>
            else <<u := multpf(car v, u); v := cdr v>>>>; 
      u := rm_neg_pow u;
      return multsq(n ./ 1,u)
   end;
+++ exptunwind compiled, 68 + 36 bytes
exptunwind

symbolic procedure rm_neg_pow u;
   if domainp u then u ./ 1
    else if minusp ldeg u 
            then addsq(multsq(1 ./ (mvar u .^ (-ldeg u) .* 1 .+ nil),rm_neg_pow lc u),
                       rm_neg_pow red u)
          else addsq(multsq(!*p2f lpow u ./ 1,rm_neg_pow lc u),rm_neg_pow red u);
+++ rm_neg_pow redefined
+++ rm_neg_pow compiled, 65 + 24 bytes
rm_neg_pow

symbolic procedure mergex(u,v);
   if eqcar(car u,'expt)
     then if eqcar(car v,'expt)
              then if cadar u=cadar v
                     then mergey(cadar u,caddar u,caddar v,cdr u,cdr v)
                    else if caddar u=caddar v and cdr u=cdr v
               then mksp({'expt,{'times,cadar u,cadar v},caddar u},cdr u)
                    else rederr 'foo
%           else mergey(cadar u,caddar u,car v,cdr u,cdr v)
           else mergey(cadar u,caddar u,1,cdr u,cdr v)
    else if eqcar(car v,'expt) then mergey(car u,1,caddar v,cdr u,cdr v)
    else rederr {'mergex,u,v};
+++ mergex compiled, 115 + 36 bytes
mergex

symbolic procedure mergey(u,v,w,x,y);
   begin
      x := simp!*{'plus,{'times,v,x},{'times,w,y}};
      if (y:= intcoeff numr x) neq 1 then x := quotf(numr x,y) ./ denr x;
      x := prepsq!* x;
      return if fixp u and fixp x then (u^x)^y else mksp({'expt,u,x},y)
   end;
+++ mergey compiled, 59 + 44 bytes
mergey

symbolic procedure intcoeff u;
   % Returns an integer multiplier of standard form u.
   if domainp u then if fixp u then u else 1
    else (if null red u then n else gcdn(n,intcoeff red u))
             where n = intcoeff lc u;
+++ intcoeff compiled, 28 + 12 bytes
intcoeff

symbolic procedure meldx(u,v);
   if eqcar(car u,'expt)
     then (if w then w
            else if eqcar(caar v,'expt) then meldx1(u,delete(u,v))
            else nil) where w=meldx0(cadar u,delete(u,v))
    else meldx0(car u,delete(u,v));
+++ meldx compiled, 40 + 20 bytes
meldx

symbolic procedure meldx0(u,v);
   if null v then nil
    else if (eqcar(caar v,'expt) and u=cadaar v) or u=caar v then car v
    else meldx0(u,cdr v);
+++ meldx0 compiled, 22 + 12 bytes
meldx0

symbolic procedure meldx1(u,v);
   % Look for equal exponents.
   if null v then nil
    else if eqcar(car v,'expt) and caddar u=caddar car v and cdr u=cdar v
     then car v
    else meldx1(u,cdr v);
+++ meldx1 compiled, 26 + 12 bytes
meldx1

symbolic procedure comm_kernels u;
   % Returns list of commutative kernels in standard form u.
   comm_kernels1(u,nil);
+++ comm_kernels redefined
+++ comm_kernels compiled, 4 + 12 bytes
comm_kernels

symbolic procedure comm_kernels1(u,v);
   % We append to end of list to put kernels in the right order, even
   % though a cons on the front of the list would be faster.
   if domainp u then v
    else comm_kernels1(lc u,
                       comm_kernels1(red u,
                                     if x memq v or noncomp x
                                        then v else append(v,list x)))
         where x=mvar u;
+++ comm_kernels1 redefined
+++ comm_kernels1 compiled, 39 + 12 bytes
comm_kernels1

endmodule;nil

end;nilxmodule simplog;nil  % Simplify logarithms.

% Authors: Mary Ann Moore and Arthur C. Norman.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*intflag!* !*noneglogs !*expandlogs);nil

global '(domainlist!*);nil

exports simplog,simplogb,simplogbi,simplogbsq,simplogi,simplogsq;nil

imports addf,addsq,comfac,quotf,prepf,mksp,simp!*,!*multsq,simptimes,
        minusf,negf,negsq,mk!*sq,carx,multsq,resimp,simpiden,simpplus,
        prepd,mksq,rerror,zfactor,sfchk;nil

%% Rules implemented here:
%%
%% log(e) => 1,
%% log(1) => 0,
%% log(e^~x) => x,
%%
%% log10(1) => 0,
%% log10(10) => 1,
%% log10(10^~x) => x,
%%
%% logb(1,~x) => 0,
%% logb(~x,~x) => 1,
%% logb(~x,e) => log(x),
%% logb(~x,10) => log10(x),
%% logb(~a^~x,~a) => x
%%

symbolic inline procedure get!-log!-base u;
   if car u eq 'log10 then 10 else nil;
+++ Record new inline definition:
(de get!-log!-base (u) (cond ((eq (car u) (quote log10)) 10) (t nil)))
(progn (de get!-log!-base (u) (cond ((eq (car u) (quote log10)) 10) (t nil))) (
put (quote get!-log!-base) (quote number!-of!-args) 1) (put (quote
get!-log!-base) (quote procedure_type) (quote (arrow general general))) (putc (
quote get!-log!-base) (quote inline) (quote (lambda (u) (cond ((eq (car u) (
quote log10)) 10) (t nil))))))
+++ get!-log!-base compiled, 6 + 16 bytes
(lambda (u) (cond ((eq (car u) (quote log10)) 10) (t nil)))

symbolic procedure simplog u;
   if null cdr u then rerror(alg,5,{"Wrong number of arguments to",car u})
    else if !*expandlogs then (resimp simplogbi(aeval cadr u,get!-log!-base u) where !*expandlogs=nil)
   else (if x=0 then rerror(alg,210,{car u,"0 formed"})
    	      % log(1) = 0
    	   else if x=1 then nil ./ 1
    	      % log(e) = 1, log10(10) = 1
    	   else if x eq 'e and not (car u eq 'log10) then 1 ./ 1
    	   else if fixp x and car u eq 'log10 and not(dmode!* and get('log10,dmode!*))
     	   then simplogbn(x,get!-log!-base u,t)
    	      % log(e^x) = x, log10(10^x) = x
    	   else if eqcar(x,'expt) and cadr x = (if car u eq 'log10 then 10 else 'e)
     	   then simp caddr x 
    	   else if eqcar(x,'quotient) and cadr x=1
      	      and (null !*precise or realvaluedp caddr x)
     	   then negsq simpiden(car u . cddr x)
    	   else simpiden u)
    where x=reval cadr u;
+++ simplog compiled, 163 + 116 bytes
simplog

symbolic procedure simplogb u;
   if null cdr u or null cddr u then rerror(alg,5,"Wrong number of arguments to logb")
    else if !*expandlogs then (simplogbi(aeval cadr u,caddr u) where !*expandlogs=nil)
    else (if x=0 then rerror(alg,210,"Logb(0,...) formed")
    % logb(1,x) = 0
    else if x=1 then nil ./ 1
    % logb(x,x) = 1
    else if reval {'difference,x,caddr u} = 0 then 1 ./ 1
    % logb(x,e) = log(x)
    else if caddr u = 'e then simplog {'log,x}
    % logb(x,10) = log10(x)
    else if reval {'difference,10,caddr u} = 0 then simplog {'log10,x}
%    else if fixp x then simplogbn(x,caddr u,nil)
    % logb(a^x,a) = x
    else if eqcar(x,'expt) and reval {'difference,cadr x,caddr u} = 0
     then simp caddr x 
    else if eqcar(x,'quotient) and cadr x=1
      and (null !*precise or realvaluedp caddr x)
     then negsq simpiden {car u, caddr x, caddr u}
    else simpiden u)
    where x=reval cadr u;
+++ simplogb compiled, 148 + 112 bytes
simplogb

put('log,'simpfn,'simplog);simplog

put('log10,'simpfn,'simplog);simplog

put('logb,'simpfn,'simplogb);simplogb

flag('(log log10 logb),'full);nil

put('expandlogs,'simpfg,'((nil (rmsubs)) (t (rmsubs))));((nil (rmsubs)) (t (
rmsubs)))

put('combinelogs,'simpfg,'((nil (rmsubs)) (t (rmsubs))));((nil (rmsubs)) (t (
rmsubs)))

symbolic inline procedure mk!-log!-arg(arg,base);
   if null base or base eq 'e then {'log,arg}
    else if base=10 then {'log10,arg}
    else {'logb,arg,base};
+++ Record new inline definition:
(de mk!-log!-arg (arg base) (cond ((or (null base) (eq base (quote e))) (list (
quote log) arg)) ((equal base 10) (list (quote log10) arg)) (t (list (quote logb
) arg base))))
(progn (de mk!-log!-arg (arg base) (cond ((or (null base) (eq base (quote e))) (
list (quote log) arg)) ((equal base 10) (list (quote log10) arg)) (t (list (
quote logb) arg base)))) (put (quote mk!-log!-arg) (quote number!-of!-args) 2) (
put (quote mk!-log!-arg) (quote procedure_type) (quote (arrow (times general
general) general))) (putc (quote mk!-log!-arg) (quote inline) (quote (lambda (
arg base) (cond ((or (null base) (eq base (quote e))) (list (quote log) arg)) ((
equal base 10) (list (quote log10) arg)) (t (list (quote logb) arg base)))))))
+++ mk!-log!-arg compiled, 21 + 28 bytes
(lambda (arg base) (cond ((or (null base) (eq base (quote e))) (list (quote log)
arg)) ((equal base 10) (list (quote log10) arg)) (t (list (quote logb) arg base)
)))

symbolic procedure simplogi(sq);
   simplogbi(sq,nil);
+++ simplogi compiled, 4 + 12 bytes
simplogi

symbolic procedure simplogbi(sq,base);
   % This version will only expand a log if at most one of the
   % arguments is complex.  Otherwise you can finish up on the wrong
   % sheet.
   if atom sq then simplogbsq(simp!* sq,base)
    else if car sq memq domainlist!* then simpiden mk!-log!-arg(sq,base)
    else if car sq eq 'times
          then if null !*precise or one_complexlist cdr sq
           then simpplus(for each u in cdr sq collect mk!*sq simplogbi(u,base))
          else !*kk2q mk!-log!-arg(sq,base)
    else if car sq eq 'quotient
       and (null !*precise or one_complexlist cdr sq)
     then addsq(simplogbi(cadr sq,base),negsq simplogbi(caddr sq,base))
    else if car sq eq 'expt
     then simptimes list(caddr sq,mk!*sq simplogbi(cadr sq,base))
    else if car sq eq 'nthroot
     then multsq!*(1 ./ caddr sq,simplogbi(cadr sq,base))
    % we had (nthroot of n).
    else if car sq eq 'sqrt then multsq!*(1 ./ 2,simplogbi(cadr sq,base))
    else if car sq = '!*sq then simplogbsq(cadr sq,base)
    else simplogbsq(simp!* sq,base);
+++ simplogbi compiled, 241 + 112 bytes
simplogbi

symbolic procedure one_complexlist u;
   % True if at most one member of list u is complex.
   if null u then t
    else if realvaluedp car u then one_complexlist cdr u
    else null cdr u or realvaluedlist cdr u;
+++ one_complexlist compiled, 25 + 20 bytes
one_complexlist

symbolic procedure multsq!*(u,v);
   if !*intflag!* then !*multsq(u,v) else multsq(u,v);
+++ multsq!* compiled, 10 + 20 bytes
multsq*

symbolic procedure simplogsq sq;
   simplogbsq(sq,nil);
+++ simplogsq compiled, 4 + 12 bytes
simplogsq

symbolic procedure simplogbsq(sq,base);
   % This procedure needs to be reworked to provide for proper sheet
   % handling.
   if null numr sq then rerror(alg,210,"Log 0 formed")
    else begin integer n;
      if denr sq=1 and domainp numr sq
        then <<if !:onep numr sq then return nil ./ 1
                else if (n:=int!-equiv!-chk numr sq) and fixp n then return simplogbn(n,base,nil)
                else if eqcar(numr sq,'!:rn!:) and not !:minusp numr sq
                 then return addsq(simplogb2(cadr numr sq,base),negsq simplogb2(cddr numr sq,base)) >>
       else if fixp denr sq and domainp numr sq
        then <<if (n:=int!-equiv!-chk numr sq) and fixp n
                 then return addsq(simplogbn(n,base,nil),negsq simplogbn(denr sq,base,nil))>>;
      if !*precise then return !*kk2q mk!-log!-arg(prepsq sq,base)
        else return addsq(simplogb2(numr sq,base),negsq simplogb2(denr sq,base));
    end;
+++ simplogbsq compiled, 173 + 96 bytes
simplogbsq

symbolic procedure simplogb2(sf,base);
 if atom sf
   then if null sf then rerror(alg,21,"Log 0 formed")
      else if numberp sf
       then if sf iequal 1 then nil ./ 1
             else if sf iequal 0 then rerror(alg,22,"Log 0 formed")
             else simplogbn(sf,base,nil)
      else formlog(sf,base)
   else if domainp sf then mksq(mk!-log!-arg(prepd sf,base),1)
     else begin scalar form;
        form := comfac sf;
        if not null car form
          then return addsq(formlog(form .+ nil,base),
                            simplogb2(quotf(sf,form .+ nil),base));
        % We have killed common powers.
        form := cdr form;
        if form neq 1
          then return addsq(simplogb2(form,base),simplogb2(quotf(sf,form),base));
        % Remove a common factor from the sf.
        return formlog(sf,base)
     end;
+++ simplogb2 compiled, 138 + 84 bytes
simplogb2

symbolic procedure simplogn u;
   simplogbn(u,nil,nil);
+++ simplogn compiled, 6 + 12 bytes
simplogn


% If base is 10, apply simplification for log10 of an integer:
% after factorization of the integer argument, check if the
% factors 2 and 5 can be combined to a power of 10.

% The third argument flg tells simplogbn to not return a sum of terms.
symbolic procedure simplogbn(u,base,flg);
   if u=1 then nil ./ 1
   % See comments in formlog for an explanation of the code.
    else begin scalar y,z;
      y := zfactor u;
      if base=10 then begin integer twos,fives;
         twos := assoc(2,y);
         fives := assoc(5,y);
         if twos and fives then <<
            y := delete(twos,y);
            y := delete(fives,y);
            if cdr twos = cdr fives then z := cdr twos
             else if cdr twos < cdr fives
              then <<z := cdr twos;
                     y := append(y, list(5 . (cdr fives - cdr twos)))>>
             else <<z := cdr fives;
                     y := append(y, list(2 . (cdr twos - cdr fives)))>>>>
      end;
      if flg then return (if null y then z else !*kk2f mk!-log!-arg(u,base)) ./ 1;
%     if eqcar(y,'(-1 . 1)) and null(y := mergeminus cdr y)
      if not atom y and car y = '(-1 . 1) and null (y := mergeminus cdr y)
       then return !*kk2q mk!-log!-arg(u,base);
      for each x in y do
          z := addf(((mksp(mk!-log!-arg(car x,base),1) .* cdr x) .+ nil),z);
      return z ./ 1
   end;
+++ simplogbn compiled, 232 + 64 bytes
simplogbn

symbolic procedure mergeminus u;
   begin scalar x;
   a: if null u then return nil
       else if remainder(cdar u,2)=1
        then return reversip2(x,((-caar u) . cdar u) . cdr u)
       else <<x := car u . x; u := cdr u; go to a>>
   end;
+++ mergeminus compiled, 33 + 20 bytes
mergeminus

symbolic procedure formlog(sf,base);
   % Minus test commented out. Otherwise, we can get:
   % log(a) + log(-1) => log(a*(-1)) => log(-a).
   % log(a) - log(-1) => log(a/(-1)) => log(-a).
   % I.e., log(-a) can be log(a) + log(-1) or log(a) - log(-1).
   if null red sf then formlogterm(sf,base)
%   else if minusf sf and null !*noneglogs
%    then addf((mksp(list('log,-1),1) .* 1) .+ nil,
%              formlog2(negf sf,base)) ./ 1
    else formlog2(sf,base) ./ 1;
+++ formlog compiled, 12 + 20 bytes
formlog

symbolic procedure formlogterm(sf,base);
   begin scalar u;
      u := mvar sf;
      if not atom u and (car u member '(times sqrt expt nthroot))
         then u := addsq(simplogb2(lc sf,base),
                         multsq!*(simplogbi(u,base),simp!* ldeg sf))
        else if (lc sf iequal 1) and (ldeg sf iequal 1)
         then u := ((mksp(mk!-log!-arg(sfchk u,base),1) .* 1) .+ nil) ./ 1
        else if domainp lc sf and !:minusp lc sf
         then u := ((mksp(mk!-log!-arg(prepf sf,base),1) .* 1) .+ nil) ./ 1
        else u := addsq(simptimes list(mk!-log!-arg(sfchk u,base),ldeg sf),
                        simplogb2(lc sf,base));
      return u
   end;
+++ formlogterm compiled, 182 + 76 bytes
formlogterm

symbolic procedure formlog2(sf,base);
   ((mksp(mk!-log!-arg(prepf sf,base),1) .* 1) .+ nil);
+++ formlog2 compiled, 33 + 40 bytes
formlog2

endmodule;nil

end;nilmodule logsort;nil  % Combine sums of logs.

% Author:  Stanley L. Kameny.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


global '(domainlist!*);nil

fluid '(!*div factors!* !*combinelogs !*noneglogs !*expandlogs
        !*uncached);nil

switch combinelogs,expandlogs;nil

% !*combinelogs := t;   % Default value is ON.

symbolic procedure clogsq!* x;
   begin scalar !*div,!*combinelogs,!*expandlogs;
      !*div := !*expandlogs := t;
      x:= simp prepsq x where !*uncached=t; !*expandlogs := nil;
      return simp!* comblog prepsq!* x end;
+++ clogsq!* redefined
+++ clogsq!* compiled, 39 + 56 bytes
clogsq*

symbolic procedure logsort x; % combines log sums at all levels.
   begin scalar !*div,!*combinelogs,!*expandlogs,!*noneglogs;
      !*div := !*expandlogs := !*noneglogs := t;
      x:= simp x where !*uncached=t; !*expandlogs := nil;
      return comblog prepsq!* x end;
+++ logsort compiled, 42 + 52 bytes
logsort

% symbolic procedure logsorta a; aeval logsort a;

% symbolic operator logsorta;

symbolic procedure comblog x;
   if atom x or car x memq domainlist!* then x
   else if car x eq 'plus
     or car x eq 'times and
         ((not domainp y and eqcar(mvar y,'log))
           where y=numr simp!* x)
       then prepsq!* clogsq simp!* x
   else (comblog car x) . comblog cdr x;
+++ comblog redefined
+++ comblog compiled, 57 + 36 bytes
comblog

symbolic procedure clogsq x; clogf numr x ./ clogf denr x;
+++ clogsq redefined
+++ clogsq compiled, 9 + 12 bytes
clogsq

symbolic procedure clogf u;
   begin scalar x,y;
      x := kernels u;
      for each j in x do if eqcar(j,'log) then y := j . y;
      if null y then return u;
      x := setdiff(x,y);
      x := setkorder nconc(x,y);
      u := clogf1 reorder u;
      setkorder x;
      return reorder u
   end;
+++ clogf compiled, 49 + 32 bytes
clogf

symbolic procedure clogf1 x;
   if domainp x then x
    else if eqcar(mvar x,'log) then clogf2 x
    else addf(multpf(lpow x,clogf1 lc x),clogf1 red x);
+++ clogf1 compiled, 33 + 28 bytes
clogf1
%   else ((if null z then x else
%          addf(if atom y then list lt x else numr simp!* comblog y,z))
%      where y=prepsq!*(list lt x ./ 1),z=clogf1 red x);

symbolic procedure clogf2 x; % does actual log combining.
   begin scalar y,z,r,s,g,a,b,c,d,w,xx; integer k;
      xx := x;
  st: if domainp x then <<w := addf(w,x); go to ret>>
       else if not eqcar(mvar x,'log) or ldeg x neq 1
        then <<w := addf(w,list lt x); x := red x; go to st>>;
      y := list lt x;
      if not domainp(z := red x) then go to lp;
     % g := coefgcd(c := lc y,0); a := quotf(c,g);
     % y := multf(a,numr simp!* list('log,logarg(cadr mvar y,g)));
      go to ret;
     % in this loop, y is a log term, r is a term, and z the reductum.
  lp: if domainp z then go to ret;
      r := list lt z; z := red z;
      if eqcar(mvar r,'log) and ldeg r=1 then go to a2;
  a1: s := addf(r,s); go to lp;
  a2: b := coefgcd(a := lc r,0); a := quotf!-fail(a,b);
      d := coefgcd(c := lc y,0); c := quotf!-fail(c,d);
      g := gcdf(a,c); a := quotf!-fail(a,g); c := quotf!-fail(c,g);
      if not domainp a or not domainp c then go to a1
       else if numberp a and numberp c then go to a3
       else if quotf(a,c)=-1 then
         <<g := multf(a,b) ./ 1;
           k := 1;
           a := list('quotient,cadr mvar r,cadr mvar y);
           go to a4>>
       else go to a1;
  a3: % a := list('times,logarg(cadr mvar r,multf(a,b)),
      %    logarg(cadr mvar y,multf(c,d))); g := g ./ 1;
      b := multf(a,b); d := multf(c,d);
      k := gcdf(k,gcdf(b,d)); b := quotf!-fail(b,k); d := quotf!-fail(d,k);
      % Only combine a log if at most one of the arguments is complex.
      % Otherwise you can finish up on the wrong sheet.
      if !*precise and not one_complexlist {cadr mvar r,cadr mvar y}
        then return xx;
      a := list('times,logarg(cadr mvar r,b),
         logarg(cadr mvar y,d)); g := g ./ 1;
  a4: a := prepsq simp!* a;
      y := numr simp!* list('times,k,
         if eqcar(a,'quotient) and cadr a=1
            then list('minus,list('log,caddr a)) else list('log,a),
         prepsq g);
      go to lp;
 ret: return addf(w,addf(y,addf(z,clogf1 s))) end;
+++ clogf2 compiled, 344 + 96 bytes
clogf2

symbolic procedure logarg(a,c);
   if c=1 then a else list('expt,a,c);
+++ logarg compiled, 9 + 16 bytes
logarg

symbolic procedure coefgcd(u,g);
   if domainp u then gcdf(u,g) else coefgcd(lc u,coefgcd(red u,g));
+++ coefgcd compiled, 20 + 12 bytes
coefgcd

endmodule;nil

end;nilmodule sub;nil % Functions for substituting in standard forms.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*nosqrts asymplis!* dmode!* errmsg!* ncmp!* sublist!* wtl!*);nil

% Evaluation interface.

symbolic procedure subeval u;
   % This baroque definition is needed to handle an infinite loop in
   % expressions like
   % sub(x = root_of(2log(sqrt(y^2 + 1) + 1) + 2log(sqrt(y^2 + 1) - 1)
   %                - 2log(sqrt(y^2 + 1) + 1)*a - a^2 + 4y^2 + 4,y,tag),
   %     2sqrt(x^2 + 1));
   % arising from the rule for root_of in solve/solve1.red.
   begin scalar sublist!*,x;
      put('sub,'psopfn,'subeval0);
      unwind!-protect(x := errorset2{'subeval0,mkquote u},
        put('sub,'psopfn,'subeval));
      if errorp x
        then if errmsg!* then rederr errmsg!* else rederr "Error in sub operator";
      return car x
   end;
+++ subeval compiled, 53 + 56 bytes
subeval

symbolic procedure subeval0 u;
   % This is the general evaluator for SUB forms.  All but the last
   % argument are assumed to be substitutions.  These can either be
   % an explicit rule with a lhs and rhs separated by an equal sign,
   % a list of such rules, or something that evaluates to this.
   begin scalar x,y,z,ns;
   % Check for spurious substitutions.
   while cdr u do <<if not eqcar(car u,'equal) then x := car u . x
                     else if not(cadar u = (y := reval caddar u))
                      then x := {caar u,cadar u,y} . x;
                    u := cdr u>>;
   if null x then return car u else u := reversip2(x,u);
   if (x := assoc(u,sublist!*))
     then return if null cdr x then mk!*sq !*p2q mksp('sub . u,1)
                  else cdr x
    else sublist!* := (u . nil) . sublist!*;
   if null(u and cdr u)
    then rederr "SUB requires at least 2 arguments"; % F.J. Wright.
   % Separate assignments from expression.
      (while cdr u do
          <<x := reval car u;
            if getrtype x eq 'list then u := append(cdr x,cdr u)
             else <<if not eqexpr x then errpri2(car u,t);
                    y := cadr x;
                    if null getrtype y then y := !*a2kwoweight y;
                    if getrtype caddr x then ns := (y . caddr x) . ns
                     else z := (y . caddr x) . z;
                    u := cdr u>>>>) where !*evallhseqp=nil;
      x := aeval car u;
%     Next line only makes sense if an nssubfn existed (which it
%     currently doesn't.  However, subeval2 suffers from the problem
%     that its evaluation is sequential.
%     if ns then x := subeval2(ns,x);
      x := subeval1(append(ns,z),x);
      if null cdar sublist!* then rplacd(car sublist!*,x);
      return x	 
   end;
+++ subeval0 compiled, 177 + 80 bytes
subeval0

symbolic procedure subeval1(u,v);
   begin scalar y,z;
      while u and caar u = cdar u do u := cdr u;
      if null u then return v
       else if y := getrtype v
        then if z := get(y,'subfn) then return apply2(z,u,v)
              else rerror(alg,23,
                            list("No substitution defined for type",y));
        u := subsq(simp v,u);
        u := subs2 u where !*sub2 = t;   % Make sure powers are reduced.
        return mk!*sq u
   end;
+++ subeval1 redefined
+++ subeval1 compiled, 65 + 60 bytes
subeval1

% symbolic procedure subeval2(u,v);
   % This function handles sub rules that have a non *sq rhs.
   % The corresponding substitution functions are keyed by the
   % rtype in an alist stored as a property nssubfn on the rtype
   % of the expression in which the substitutions are to be carried out.
   % Substitutions are made sequentially.
%   begin scalar x,y,z;
%     for each s in u do
%       <<if null(x := getrtype v) then x := '!*sq;
%         y := getrtype cdr s;
%         if (z := get(x,'nssubfn)) and (z := atsoc(y,z))
%            then v := apply2(cdr z,s,v)
%          else v := subeval1(list s,v)>>;
%%         else rerror(alg,23,
%%            {"No substitution defined for type",y," into type ",x})>>;
%     return v
%   end;

put('sub,'psopfn,'subeval);subeval


% Explicit substitution code for scalar expressions.

symbolic procedure subsq(u,v);
   % We need to use subs2!* to avoid say (I^4-2I^2-1)/(I^2-1) => I^2-1
   % instead of a 0/0 error.
      begin scalar x;
      x := subf(numr u,v);
      u := subf(denr u,v);
      if null numr subs2!* u
       then if null numr subs2!* x then rerror(alg,201,"0/0 formed")
             else rerror(alg,201,"Zero divisor");
      return quotsq(x,u)
   end;
+++ subsq redefined
+++ subsq compiled, 38 + 40 bytes
subsq

symbolic procedure subs2!* u;
   (subs2 u) where !*sub2=!*sub2;
+++ subs2!* redefined
+++ subs2!* compiled, 10 + 20 bytes
subs2*

symbolic procedure subf(u,l);
   % In REDUCE 3.4, this procedure used to rebind *nosqrts to T.
   % However, this can introduce two representations of a sqrt in the
   % same calculation.  For now then, this rebinding is removed.
   begin scalar alglist!*,x,y,z;
   % Domain may have changed, so next line uses simpatom.
      if domainp u then return !*d2q u
       else if ncmp!* and noncomexpf u then return subf1(u,l);
      x := reverse intersection(for each y in l collect car y,
                                kernord(u,nil));
      x := setkorder x;
      u := subf1(reorder u,l);
%     if powlis1!* then u := subs2q u;
      % The subf code does not combine expts completely, e.g.,
      % sub(ll=2l,df(1/(1+exp(-z/(2l))),z) - df(1/(1+exp(-z/(ll))),z));
      while not(u member z)
        and (atsoc('expt,kernels numr u) or atsoc('expt,kernels denr u))
        and not((y := prepsq u) member varstack!*)
         do <<z := u . z; u := simp y>>;
      setkorder x;
      return reorder numr u ./ reorder denr u
   end;
+++ subf redefined
+++ subf compiled, 151 + 68 bytes
subf

symbolic procedure noncomexpf u;
   not domainp u
      and (noncomp mvar u or noncomexpf lc u or noncomexpf red u);
+++ noncomexpf redefined
+++ noncomexpf compiled, 21 + 12 bytes
noncomexpf

%%% SUBF1 changed so that domain elements are resimplified during a call
%%%       to RESIMP even if their tags are the same as dmode*.
%%%       This happens only if the domain is flagged

symbolic procedure subf1(u,l);
   % U is a standard form,
   % L an association list of substitutions of the form
   % (<kernel> . <substitution>).
   % Value is the standard quotient for substituted expression.
   % Algorithm used is essentially the straight method.
   % Procedure depends on explicit data structure for standard form.
   if null u then nil ./ 1
    else if domainp u
     then if atom u then if null dmode!* then u ./ 1 else simpatom u
%          else if dmode!* eq car u then !*d2q u
          else if dmode!* eq car u and
                  not flagp(dmode!*, 'resimplify) then !*d2q u
          else simp prepf u
    else begin integer n; scalar kern,l1,m,varstack!*,v,w,x,x1,xexp,y,y1,z;
        % Leaving varstack!* unchanged can make the simplifier think
        % there is a loop.
        z := nil ./ 1;
    a0: kern := mvar u;
        v := nil;
        if assoc(kern,l) and (v := assoc(kern,wtl!*)) then v := cdr v;
        if m := assoc(kern,asymplis!*) then m := cdr m;
    a:  if null u or (n := degr(u,kern))=0 then go to b
         else if null m or n<m then y := wtchk(lt u,v) . y;
        u := red u;
        go to a;
    b:  % Check for trivial substitions.
        l1 := nil;
        while l do
           <<if caar l neq cdar l then l1 := car l . l1; l := cdr l>>;
        l := reversip l1;
        if not atom kern and not atom car kern then kern := prepf kern;
        if null l then xexp := if kern eq 'k!* then 1 else kern
         else if (xexp := subsublis(l,kern)) = kern
                   and not assoc(kern,asymplis!*)
          then go to f;
    c:  w := 1 ./ 1;
        n := 0;
        % Make sure exponent is not a variable at this point.
        if y and minusp cdaar y then go to h;
        if (x := getrtype xexp) eq 'yetunknowntype
          then x:= getrtype(xexp:= eval!-yetunknowntypeexpr(xexp,nil));
        if x and not(x eq 'list)
         then typerr(list(x,xexp),"substituted expression");
        % At this point we are simplifying the expression that is
        % substituted.  Ideally, this should be done in the order
        % environment that existed when entering SUB.  However, to avoid
        % the many code changes that would imply, we make sure
        % substituted expression is evaluated in a standard order.
        % Note also that SIMP!* here causes problem with HE package --
        % We also can't use powlis1!* here, since then match x=0,x^2=1;
        % will match all powers of x to zero!
        v := setkorder nil;
        x := simp xexp;
        setkorder v;
        x := reordsq x;
        % Needed in case substitution variable is in XEXP.
        if null l and kernp x and mvar numr x eq kern then go to f
         else if null numr x then go to e;   %Substitution of 0;
        x1 := x;
        for each j in y do
         <<m := tdeg j;
           if m memq frlis!*
            then <<x := simpexpt list(prepsq x1,m); m := 1>>;
           w := multsq(subs2 exptsq(x,m-n),w);
           n := m;
           z := addsq(multsq(w,subf1(tc j,l)),z)>>;
    e:
        % At this point the current mvar is substituted by 0
        % so that only the constant term of the polynomial remains.
        % The simplest way to do this would be to drop the list of coefficients:
        % y := nil;
	% However, one of the coefficients may depend on mvar, and
        % the substitution mvar-->0 inside this coefficient may be invalid, as in
        %  sub(x=0,x*e^(1/x^2))
        % and an error should be signaled. To achieve this, the substution is tried
        % for all coefficients in the list y, although the resulting values are not
        % needed and therefore discarded.
        while y do << subf1(tc car y,l); y := cdr y >>;
        if null u then return z
         else if domainp u then return addsq(subf1(u,l),z);
        go to a0;
    f:  sub2chk kern;
        for each j in y do z := addsq(multpq(car j,subf1(cdr j,l)),z);
        go to e;
    h:  % Substitution for negative powers.
        x := simprecip list xexp;
    j:  y1 := car y . y1;
        y := cdr y;
        if y and cdaar y<0 then go to j;
    k:  m := -cdaar y1;
        w := multsq(subs2 exptsq(x,m-n),w);
        n := m;
        z := addsq(multsq(w,subf1(cdar y1,l)),z);
        y1 := cdr y1;
        if y1 then go to k else if y then go to c else go to e
     end;
+++ subf1 redefined
+++ subf1 compiled, 539 + 144 bytes
subf1

symbolic procedure wtchk(u,wt);
   % If a weighted variable is substituted for, we need to remove the
   % weight of that variable in an expression.
   if null wt then u
    else (if null x then errach list("weight confusion",u,wt)
           else lt x)
         where x=quotf(u .+ nil ,!*p2f('k!* .**(wt*tdeg u)));
+++ wtchk redefined
+++ wtchk compiled, 32 + 32 bytes
wtchk

symbolic procedure subsublis(u,v);
   % NOTE: This definition assumes that with the exception of *SQ and
   % domain elements, expressions do not contain dotted pairs.
   begin scalar x;
      x := if x := assoc(v,u) then cdr x
              % allow for case of sub(sqrt 2=s2,atan sqrt 2).
              else if eqcar(v,'sqrt)
                 and (x := assoc(list('expt,cadr v,'(quotient 1 2)),u))
               then cdr x
              else if atom v then v
              else if not idp car v
               then for each j in v collect subsublis(u,j)
              else if x := get(car v,'subfunc) then apply2(x,u,v)
              else if get(car v,'dname) then v
              else if car v eq '!*sq then subsublis(u,prepsq cadr v)
              else for each j in v collect subsublis(u,j);
      % Could there be other cases here apart from equal?
      % This code does not seem to be necessary with current
      % subeval0 checks.
%     return if eqcar(x,'equal) then x else prepsq!* simp x
      return x
   end;
+++ subsublis redefined
+++ subsublis compiled, 152 + 36 bytes
subsublis

symbolic procedure subsubf(l,expn);
   % Sets up a formal SUB expression when necessary.
   begin scalar x,y;
      % This code does not seem to be necessary with current
      % subeval0 checks.
%     for each j in l do if car j neq (y := prepsq!* simp!* cdr j)
%                          then x := (car j . y) . x;
%     l := reversip x;
%     if null l then return expn;
%     y := nil;
      for each j in cddr expn do
         if (x := assoc(j,l)) then <<y := x . y; l := delete(x,l)>>;
      expn := sublis(l,car expn)
                 . for each j in cdr expn collect subsublis(l,j);
        %to ensure only opr and individual args are transformed;
      if null y then return expn;
      expn := aconc!*(for each j in reversip!* y
                     collect list('equal,car j,aeval cdr j),expn);
      return if l then subeval expn
              else mk!*sq !*p2q mksp('sub . expn,1)
   end;
+++ subsubf redefined
+++ subsubf compiled, 162 + 48 bytes
subsubf


% Explicit substitution code for lists.

symbolic procedure listsub(u,v);
   makelist for each x in cdr v collect subeval1(u,x);
+++ listsub redefined
+++ listsub compiled, 43 + 16 bytes
listsub

put('list,'subfn,'listsub);listsub

put('int,'subfunc,'subsubf);subsubf

put('df,'subfunc,'subsubf);subsubf

endmodule;nil

end;nilmodule order;nil % Functions for internal ordering of expressions.

% Author: Anthony C. Hearn.

% Copyright (c) 1999 Anthony C. Hearn.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(kord!*);nil
global '(!*physop!-loaded);nil

% symbolic procedure ordad(a,u);
%   if null u then list a
%    else if ordp(a,car u) then a . u
%    else car u . ordad(a,cdr u);

% This definition, due to A.C. Norman, avoids recursion.

symbolic procedure ordad(a,u);
   begin scalar r;
      while u and not ordp(a,car u) do <<r := car u . r; u := cdr u>>;
      u := a . u;
      while r do <<a := cdr r; rplacd(r,u); u := r; r := a>>;
      return u
   end;
+++ ordad redefined
+++ ordad compiled, 35 + 12 bytes
ordad

symbolic procedure ordn u;
   if null u then nil
    else if null cdr u then u
    else if null cddr u then ord2(car u,cadr u)
    else ordad(car u,ordn cdr u);
+++ ordn redefined
+++ ordn compiled, 25 + 16 bytes
ordn

symbolic procedure ord2(u,v);
   if ordp(u,v) then list(u,v) else list(v,u);
+++ ord2 redefined
+++ ord2 compiled, 12 + 12 bytes
ord2



#if (not (memq 'csl lispsystem!*))

% A version of ordp is provided built-in to CSL and the version there
% is intended to behave just the way that this does. Now until recently I
% had used a LOSE flag to make that the version that got used. However both
% helphy/noncom2 and spde/spde redefine ordp - and if I use a LOSE flag
% then their redefinitions get discarded as well as this one. Hence I am
% moving to the ugly and somwhat unsatisfactory use of #if. A better
% resolution will be to arrange that neither hephys nor spde redefine
% this function! But doing that might require that the version within
% CSL be updated to include the changes that they want.

% I will put a copy of the version from hephys/noncom2.red first, but
% commented out. This is to encourage a merge operation! I suspect that
% the regular and the hephys versions could be merged with a bit of thought.

%hephys% symbolic procedure ordp(u,v); % modified
%hephys%    %returns true if u ordered ahead or equal to v, nil otherwise.
%hephys%    %an expression with more structure at a given level is ordered
%hephys%    % behind (and not ahead) of one with less;
%hephys%    % ordering of numbers is left as default
%hephys%    if null u then t
%hephys%    else if null v then nil
%hephys%    else if vectorp u then if vectorp v then ordpv(u,v) else atom v
%hephys%    else if atom u then
%hephys%            if atom v then
%hephys%               if numberp u then
%hephys%                   if numberp v then not(u < v)
%hephys%                   else t
%hephys%               else if numberp v then nil
%hephys%                    else orderp(u,v)
%hephys%            else t
%hephys%     else if atom v then nil
%hephys%     else if car u=car v then ordpl(cdr u,cdr v)
%hephys%     else if flagp(car u,'noncom)
%hephys%      then if flagp(car v,'noncom) then ordp(car u, car v) else t
%hephys%     else if flagp(car v,'noncom) then nil
%hephys%     else ordp(car u,car v);

% The variant from spde seems to be amazingly different and specialized,
% and it looks to me as if I would be a lot harder to merge with it.
% Issues of the general "setkorder" mechanism and its interaction with
% spde would need to be considered too! Note that loading spde will
% have an impact on any attempt to use non-commuting quantities.

%spde% remflag('(ordp ordpa),'lose);   % We must use these definitions.
%spde%
%spde% symbolic procedure ordp(u,v)$
%spde% %Modified ordering function which orders kernels with CAR parts;
%spde% %DF, ETA, XI and C ahead of anything else;
%spde% if null u then null v else if null v then t else
%spde% if eq(u,'df) or eq(u,'eta) and not eq(v,'df)
%spde% or eq(u,'xi) and not(eq(v,'df) or eq(v,'eta))
%spde% or eq(u,'c) and not(eq(v,'df) or eq(v,'eta) or eq(v,'xi)) then t else
%spde% if eq(u,'eta) and eq(v,'df)
%spde% or eq(u,'xi) and (eq(v,'df) or eq(v,'eta))
%spde% or eq(u,'c) and (eq(v,'df) or eq(v,'eta) or eq(v,'xi))
%spde% or eq(v,'df) or eq(v,'eta) or eq(v,'xi) or eq(v,'c) then nil else
%spde% if atom u then if atom v then
%spde% if numberp u then numberp v and not(u<v) else
%spde% if numberp v then t else orderp(u,v) else nil else
%spde% if atom v then t else
%spde% if car u=car v then ordp(cdr u,cdr v) else ordp(car u,car v)$
%spde%
%spde% symbolic procedure ordpa(u,v); ordp(u,v);



symbolic procedure ordp(u,v);
   % Returns TRUE if U ordered ahead or equal to V, NIL otherwise.
   % An expression with more structure at a given level is ordered
   % ahead of one with less.
   if null u then null v
    else if null v then t
    else if vectorp u then if vectorp v then ordpv(u,v) else atom v
    else if atom u
       then if atom v
                then if numberp u then numberp v and not(u<v)
                      else if idp v then orderp(u,v)
                      else numberp v
             else nil
    else if atom v then t
    else if car u=car v then ordpl(cdr u,cdr v)
    else if flagp(car u,'noncom)
     then if flagp(car v,'noncom) then ordp(car u, car v) else t
    else if flagp(car v,'noncom) then nil
    else ordp(car u,car v);

#endif

symbolic procedure ordpl(u,v);
   % Returns TRUE if list U ordered ahead or equal to V, NIL otherwise.
   % We also allow for a dotted pair.
   if atom u then ordp(u,v)
    else if atom v then t
    else if car u=car v then ordpl(cdr u,cdr v)
    else ordp(car u,car v);
+++ ordpl redefined
+++ ordpl compiled, 23 + 16 bytes
ordpl

symbolic procedure ordpv(u,v);
   % U and v are vectors. Set up comparison loop.
   ordpv1(u,v,-1,upbv u,upbv v);
+++ ordpv compiled, 20 + 16 bytes
ordpv

symbolic procedure ordpv1(u,v,i,lu,lv);
   if (i:=i#+1)>lu then i>lv
    else (if x=y then ordpv1(u,v,i,lu,lv) else ordp(x,y))
          where x=getv(u,i),y=getv(v,i);
+++ ordpv1 compiled, 40 + 12 bytes
ordpv1

symbolic procedure ordop(u,v);
   if !*physop!-loaded then physop!-ordop(u,v)
   else begin scalar x;
        x := kord!*;
    a:  if null x then return ordp(u,v)
         else if u eq car x then return t
         else if v eq car x then return;
        x := cdr x;
        go to a
   end;
+++ ordop redefined
+++ ordop compiled, 29 + 28 bytes
ordop

symbolic procedure ordpp(u,v);
   % This version is used for addition, where NONCOM properties aren't
   % relevant.
   begin scalar x;
        if car u eq car v then return cdr u>cdr v;
        x := kord!*;
        u := car u;
        v := car v;
    a:  if null x then return ordpa(u,v)
         else if u eq car x then return t
         else if v eq car x then return nil;
        x := cdr x;
        go to a
   end;
+++ ordpp redefined
+++ ordpp compiled, 35 + 20 bytes
ordpp

symbolic procedure ordpa(u,v);
   % Returns TRUE if U ordered ahead or equal to V, NIL otherwise.
   % An expression with more structure at a given level is ordered
   % ahead of one with less.
   if null u then null v
    else if null v then t
    else if vectorp u then if vectorp v then ordpv(u,v) else atom v
    else if atom u
       then if atom v
                then if numberp u then numberp v and not(u<v)
                      else if idp v then orderp(u,v)
                      else numberp v
             else nil
    else if atom v then t
    else if car u=car v then ordpa(cdr u,cdr v)
    else ordpa(car u,car v);
+++ ordpa redefined
+++ ordpa compiled, 74 + 24 bytes
ordpa

endmodule;nil

end;nilmodule forall;nil % FOR ALL and LET-related commands.

% Author: Anthony C. Hearn.
% Modifications by:  Herbert Melenk.

% Copyright (c) 1993 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*resimp !*sub2 alglist!* arbl!* asymplis!* frasc!* wtl!*);nil

fluid '(!*!*noremove!*!* frlis!* newrule!* oldrules!* props!* subfg!*);nil

fluid '(!*reduce4 !*sqrtrulep powlis!* powlis1!* varstack!*);nil

global '(!*match cursym!* erfg!* letl!* mcond!*);nil

letl!* := '(let match clear saveas such);(let match clear saveas such)   % Special delimiters.

% Contains two RPLAC references commented out.

remprop('forall,'stat);nil

remprop('forall,'formfn);nil

symbolic procedure forallstat;
   begin scalar arbl,conds;
        if cursym!* memq letl!* then symerr('forall,t);
        flag(letl!*,'delim);
        arbl := remcomma xread nil;
        if cursym!* eq 'such then
          <<if not(scan() eq 'that) then symerr('let,t);
            conds := xread nil>>;
        remflag(letl!*,'delim);
        if not(cursym!* memq letl!*) then symerr('let,t)
         else return list('forall,arbl,conds,xread1 t)
   end;
+++ forallstat compiled, 60 + 68 bytes
forallstat

symbolic procedure forall u;
   begin scalar v,x,y;
      v := for each j in car u collect 
             if null j then rsverr j else j;
      x := for each j in v collect newvar j;
      y := pair(v,x);
      mcond!* := if cadr u eq 't then t else subla(y,cadr u);
%     mcond!* := formbool(subla(y,eval cadr u),nil,'algebraic);
      frasc!* := y;
      frlis!* := union(x,frlis!*);
      return lispeval caddr u
   end;
+++ forall compiled, 119 + 44 bytes
forall

symbolic procedure arbstat;
   <<lpriw("*****","ARB no longer supported");
     symerr('if,t)>>;
+++ arbstat compiled, 10 + 32 bytes
arbstat

put('arb,'stat,'arbstat);arbstat

symbolic procedure newvar u;
   if not idp u then typerr(u,"free variable")
%   else if flagp(u,'reserved)
%    then typerr(list("Reserved variable",u),"free variable")
    else bytelist2id append(id2bytelist '!=, id2bytelist u);
+++ newvar redefined
+++ newvar compiled, 22 + 32 bytes
newvar

symbolic procedure formforall(u,vars,mode);
   begin scalar arbl!*,x,y;
      u := cdr u;
%     vars := append(car u,vars);   % Semantics are different.
      if null cadr u then x := t else x := formbool(cadr u,vars,mode);
%     if null cadr u then x := t else x := form1(cadr u,vars,mode);
      y := form1(caddr u,vars,mode);
      % Allow for a LET or MATCH call during a similar evaluation.
      % This might occur in autoloading.
      if eqcar(y,'let) then y := 'let00 . cdr y
       else if eqcar(y,'match) then y := 'match00 . cdr y;
      return list('forall,list('list,mkquote union(arbl!*,car u),
                  mkquote x,mkquote y))
   end;
+++ formforall compiled, 79 + 68 bytes
formforall

symbolic procedure def u;
   % Defines a list of operators.
   <<lprim "Please do not use the DEF operator; it is no longer supported";
     for each x in u do
        if not eqexpr x or not idlistp cadr x then errpri2(x,t)
         else <<mkop caadr x;
                forall list(cdadr x,t,list('let,mkarg(list x,nil)))>>>>;
+++ def compiled, 55 + 48 bytes
def

put('def,'stat,'rlis);rlis

deflist('((forall formforall)),'formfn);(forall)

deflist('((forall forallstat)),'stat);(forall)

flag ('(clear let match),'quote);nil

symbolic procedure formlet1(u,vars,mode);
   requote ('list . for each x in u collect
      if eqexpr x
        then list('list,mkquote car x,form1(cadr x,vars,mode),
                                !*s2arg(form1(caddr x,vars,mode),vars))
       else form1(x,vars,mode));
+++ formlet1 compiled, 126 + 40 bytes
formlet1

symbolic procedure requote u;
   if atom u or not(car u eq 'list) then u
    else (if x then mkquote x else u) where x=requote1 cdr u;
+++ requote compiled, 15 + 20 bytes
requote

symbolic procedure requote1 u;
   begin scalar x,y;
   a: if null u then return reversip x
       else if numberp car u or car u memq '(nil t)
        then x := car u . x
       else if atom car u then return nil
       else if caar u eq 'quote then x := cadar u . x
       else if caar u eq 'list and (y := requote1 cdar u)
        then x := y . x
       else return nil;
      u := cdr u;
      go to a
   end;
+++ requote1 redefined
+++ Garbage collection 2 (internal list3) after 21.28+0.09 seconds
At gc end about 16.0 Mbytes of 80.0 (20.0%) of heap is in use
+++ requote1 compiled, 52 + 20 bytes
requote1

symbolic procedure !*s2arg(u,vars);
   %makes all NOCHANGE operators into their listed form;
   if atom u or eq(car u,'quote) then u
    else if not idp car u or not flagp(car u,'nochange)
     then for each j in u collect !*s2arg(j,vars)
    else mkarg(u,vars);
+++ !*s2arg redefined
+++ !*s2arg compiled, 56 + 24 bytes
*s2arg

put('let,'formfn,'formlet);formlet

put('clear,'formfn,'formclear);formclear

put('match,'formfn,'formmatch);formmatch

symbolic procedure formclear(u,vars,mode);
   list('clear,formclear1(cdr u,vars,mode));
+++ formclear redefined
+++ formclear compiled, 11 + 16 bytes
formclear

symbolic procedure formclear1(u,vars,mode);
   'list . for each x in u collect
      if flagp(x,'share) then mkquote x else form1(x,vars,mode);
+++ formclear1 compiled, 70 + 20 bytes
formclear1

symbolic procedure formlet(u,vars,mode);
   list('let,formlet1(cdr u,vars,mode));
+++ formlet compiled, 11 + 16 bytes
formlet

symbolic procedure formmatch(u,vars,mode);
   list('match,formlet1(cdr u,vars,mode));
+++ formmatch compiled, 11 + 16 bytes
formmatch

symbolic procedure let u; let0 u;
+++ let compiled as link to let0
let    % to distinguish between operator
                                     % and function.

symbolic procedure let0 u;
   let00 u where frasc!* = nil;
+++ let0 redefined
+++ let0 compiled, 9 + 20 bytes
let0

symbolic procedure let00 u;
   begin
      unwind!-protect(
        u := errorset!*(list('let1,mkquote u),t),
        frasc!* := mcond!* := nil);
      if errorp u then error1() else return car u
   end;
+++ let00 compiled, 31 + 36 bytes
let00

symbolic procedure let1 u;
   begin scalar x,y;
      u := reverse u;  % So that rules are added in order given.
      while u do
         <<if idp u then typerr(u,"rule list")
            else if eqcar(y := listeval0(x := car u),'list)
             then rule!-list(reverse cdr y,t)
            else if idp x then revalruletst x
            else if car x eq 'replaceby
             then if frasc!*
                    then rerror(alg,100,
                                "=> invalid in FOR ALL statement")
                   else rule!-list(list x,t)
            else if car x eq 'equal
                    then if smemq('!~,x)
                           then if frasc!* then typerr(x,"rule")
                                 else rule!-list(list x,t)
                          else let2(cadr x,caddr x,nil,t)
            else revalruletst x;
           u := cdr u>>
   end;
+++ let1 compiled, 113 + 80 bytes
let1

symbolic procedure revalruletst u;
   (if u neq v then let1 list v else typerr(u,"rule list"))
   where v = reval u;
+++ revalruletst compiled, 14 + 24 bytes
revalruletst

symbolic procedure let2(u,v,w,b);
   begin scalar flgg,x,y,z;
        % FLGG is set true if free variables are found.
        if (y := getrtype u) and (z := get(y,'typeletfn))
           and flagp(z,'direct)
          then return lispapply(z,list(u,v,y,b,getrtype v))
         else if (y := getrtype v) and (z := get(y,'typeletfn))
                 and flagp(z,'direct)
          then return lispapply(z,list(u,v,nil,b,y));
        x := subla(frasc!*,u);
        if x neq u
          then if atom x then return errpri1 u
                 else <<flgg := t; u := x>>;
        x := subla(frasc!*,v);
        if x neq v
          then <<v := x;
                 if eqcar(v,'!*sq!*) then v := prepsq!* cadr v>>;
                 % to ensure no kernels are replaced by uneq copies
                 % during pattern matching process.
        % Check for unmatched free variables.
        x := smemql(frlis!*,mcond!*);
        y := smemql(frlis!*,u);
        if (z := setdiff(x,y))
           or (z := setdiff(setdiff(smemql(frlis!*,v),x),
                    setdiff(y,x)))
          then <<lprie ("Unmatched free variable(s)" . z);
                 erfg!* := 'hold;
                 return nil>>
         else if atom u then nil
         else if car u eq 'getel then u := lispeval cadr u
         else if flagp(car u,'immediate) then u := reval u;
      return let3(u,v,w,b,flgg)
   end;
+++ let2 redefined
+++ let2 compiled, 183 + 104 bytes
let2

symbolic procedure let3(u,v,w,b,flgg);
   % U is left-hand-side of a rule, v the right-hand-side.
   % W is true if a match, NIL otherwise.
   % B is true if the rule is being added, NIL if being removed.
   % Flgg is true if there are free variables in the rule.
   begin scalar x,y1,y2,z;
        x := u;
        if null x then <<u := 0; return errpri1 u>>
         else if numberp x then return errpri1 u;
        % Allow redefinition of id's, regardless of type.
       % The next line allows type of LHS to be redefined.
       y2 := getrtype v;
       if b and idp x then <<remprop(x,'rtype); remprop(x,'avalue)>>;
%        else if idp x and flagp(x,'reserved)
%         then rederr list(x,"is a reserved identifier");
        if (y1 := getrtype x)
          then return if z := get(y1,'typeletfn)
                        then lispapply(z,list(x,v,y1,b,getrtype v))
                       else typelet(x,v,y1,b,getrtype v)
         else if y2 and not(y2 eq 'yetunknowntype)
          then return if z := get(y2,'typeletfn)
                        then lispapply(z,list(x,v,nil,b,y2))
                       else typelet(x,v,nil,b,y2)
         else letscalar(u,v,w,x,b,flgg)
   end;
+++ let3 redefined
+++ let3 compiled, 145 + 60 bytes
let3

symbolic procedure letscalar(u,v,w,x,b,flgg);
   begin
      if not atom x
               then if not idp car x then return errpri2(u,'hold)
                     else if car x eq 'df
                      then if null letdf(u,v,w,x,b) then nil
                            else return nil
                     else if getrtype car x
                      then return let2(reval x,v,w,b)
                     else if not get(car x,'simpfn)
                      then <<redmsg(car x,"operator");
                             mkop car x;
                             return let3(u,v,w,b,flgg)>>
                     else nil
         else if null b and null w
          then <<remprop(x,'avalue);
                 remprop(x,'rtype);    % just in case
                 remflag(list x,'antisymmetric);
                 remprop(x,'infix);
               % remprop(x,'klist);
               % commented out: the relevant objects may still exist.
                 remprop(x,'kvalue);
                 remflag(list x,'linear);
                 remflag(list x,'noncom);
                 remprop(x,'op);
                 remprop(x,'opmtch);
                 remprop(x,'simpfn);
                 remflag(list x,'symmetric);
                 wtl!* := delasc(x,wtl!*);
                 if flagp(x,'opfn)
                   then <<remflag(list x,'opfn); remd x>>;
                 rmsubs(); % since all kernel lists are gone.
                 return nil>>;
        if eqcar(x,'expt) and caddr x memq frlis!*
          then letexprn(u,v,w,!*k2q x,b,flgg)
           % Special case of a non-integer exponent match.
         else if eqcar(x,'sqrt)
          then <<!*sqrtrulep := t;
                 let2({'expt,cadr x,'(quotient 1 2)},v,w,b)>>;
           % Since SQRTs can be converted into EXPTs.
	varstack!* := delete(x,varstack!*);
	x := simp0 x where !*precise = t;  % We don't want to break
                                           % up exponents.
        return if not domainp numr x then letexprn(u,v,w,x,b,flgg)
                else errpri1 u
   end;
+++ letscalar redefined
+++ letscalar compiled, 274 + 172 bytes
letscalar

symbolic procedure letexprn(u,v,w,x,b,flgg);
   % Replacement of scalar expressions.
   begin scalar y,z;
        if denr x neq 1
          then return let2(let!-prepf numr x,
                           list('times,let!-prepf denr x,v),w,b)
         else if red(x := numr x)
          then return let2(let!-prepf !*t2f lt x,
                           list('difference,v,let!-prepf red x),w,b)
         else if null (y := kernlp x)
          then <<y := term!-split x;
                 return let2(let!-prepf car y,
                            list('difference,v,let!-prepf cdr y),w,b)>>
         else if y neq 1
          then return let2(let!-prepf quotf!*(x,y),
                           list('quotient,v,let!-prepf y),w,b);
        x := klistt x;
        y := list(w . (if mcond!* then mcond!* else t),v,nil);
        if cdr x
          then return <<rmsubs(); !*match:= xadd!*(x . y,!*match,b)>>
         else if null w and cdar x=1    % ONEP
          then <<x := caar x;
                 if null flgg and (null mcond!* or mcond!* eq 't
                        or not smember(x,mcond!*))
                   then <<if atom x
                            then if flagp(x,'used!*) then rmsubs()
                                  else nil
                           else if 'used!* memq cddr fkern x
                              or car x eq 'df
                            then rmsubs();
                          setk1(x,v,b)>>
                  else if atom x then return errpri1 u
                  else <<rmsubs(); % if get(car x,'klist) then rmsubs();
                                   % the "get" is always true currently.
                         put(car x,
                             'opmtch,
                           xadd!*(cdr x . y,get(car x,'opmtch),b))>>>>
         else <<rmsubs();
                if v=0 and null w and not flgg
                  then <<asymplis!* := xadd(car x,asymplis!*,b);
                         powlis!*
                      := xadd(caar x . cdar x . y,powlis!*,'replace)>>
                 else if w or not(cdar y eq t) or frasc!*
                  then powlis1!* := xadd(car x . y,powlis1!*,b)
                 else if null b and (z := assoc(caar x,asymplis!*))
                    and z=car x
                  then asymplis!* := delasc(caar x,asymplis!*)
              else <<powlis!* := xadd(caar x . cdar x . y,powlis!*,b);
                   if b then asymplis!* := delasc(caar x,asymplis!*)>>>>
   end;
+++ letexprn redefined
+++ letexprn compiled, 352 + 132 bytes
letexprn

rlistat '(clear let match);nil


% Further support for rule lists and local rule applications.

symbolic procedure clearrules u;
   rule!-list(u,nil) where !*sqrtrulep=nil;
+++ clearrules redefined
+++ clearrules compiled, 10 + 20 bytes
clearrules

% symbolic procedure letrules u; rule!-list(u,t);

rlistat '(clearrules);nil   % letrules.

symbolic procedure rule!-list(u,type);
   % Type is true if the rule is being added, NIL if being removed.
   begin scalar v,x,y,z;
   a: frasc!* := nil;   % Since free variables must be declared in each
                        % rule.
      if null u or u = {{}} then return (mcond!* := nil);
      mcond!* := t;
      v := car u;
      if idp v
        then if (x := get(v,'avalue)) and car x eq 'list
               then <<u := append(reverse cdadr x,cdr u); go to a>>
              else typerr(v,"rule list")
       else if car v eq 'list
          then <<u := append(cdr v,cdr u); go to a>>
       else if car v eq 'equal
        then lprim "Please use => instead of = in rules"
       else if not(car v eq 'replaceby) then typerr(v,"rule");
      y := remove!-free!-vars cadr v;
      if eqcar(caddr v,'when)
        then <<mcond!* := formbool(remove!-free!-vars!* caddr caddr v,
                                   nil,'algebraic);
               z := remove!-free!-vars!* cadr caddr v>>
       else z := remove!-free!-vars!* caddr v;
      rule!*(y,z,frasc!*,mcond!*,type);
      u := cdr u;
      go to a
   end;
+++ rule!-list redefined
+++ rule!-list compiled, 131 + 80 bytes
rule-list

symbolic procedure rule!*(u,v,frasc,mcond,type);
   % Type is T if a rule is being added, OLD if an old rule is being
   % reinstalled, or NIL if a rule is being removed.
   begin scalar x;
      frasc!* := frasc;
      mcond!* := mcond eq t or subla(frasc,mcond);
      if type and type neq 'old
        then <<newrule!* := list(u,v,frasc,mcond);
%              prin2t list("newrule:",newrule!*);
               if idp u
                 then <<if x := get(u,'rtype)
                          then <<props!*:= (u . ('rtype . x)) . props!*;
                                 remprop(u,'rtype)>>;
                        if x := get(u,'avalue)
                          then <<updoldrules(x,nil);
                                 remprop(u,'avalue)>>>>;
               % Asymptotic case.
               if v=0 and eqcar(u,'expt) and idp cadr u
                  and numberp caddr u
                  and (x := assoc(cadr u,asymplis!*))
                then updoldrules(x,nil)>>;
      return rule(u,v,frasc,if type eq 'old then t else type)
   end;
+++ rule!* redefined
+++ rule!* compiled, 117 + 72 bytes
rule*

symbolic procedure rule(u,v,frasc,type);
   begin scalar flg,frlis,x,y,z;
        % FLGG is set true if free variables are found.
        %
        x := subla(frasc,u);
        if x neq u
          then if atom x then return errpri1 u
                 else <<flg := t; u := x>>;
        x := subla(frasc,v);
        if x neq v
          then <<v := x;
                 if eqcar(v,'!*sq!*) then v := prepsq!* cadr v>>;
                 % to ensure no kernels are replaced by uneq copies
                 % during pattern matching process.
        % Check for unmatched free variables.
        frlis := for each j in frasc collect cdr j;
        x := smemql(frlis,mcond!*);
        y := smemql(frlis,u);
        if (z := setdiff(x,y))
           or (z := setdiff(setdiff(smemql(frlis,v),x),
                    setdiff(y,x)))
          then <<lprie ("Unmatched free variable(s)" . z);
                 erfg!* := 'hold;
                 return nil>>
         else if eqcar(u,'getel) then u := lispeval cadr u;
      return let3(u,v,nil,type,flg)
   end;
+++ rule redefined
+++ rule compiled, 137 + 64 bytes
rule

mkop '!~;nil               % Declare as algebraic operator.

put('!~,'prifn,'tildepri);tildepri

symbolic procedure tildepri u;
  <<prin2!* "~"; if eqcar (cadr u,'!~) then tildepri cadr u else prin2!*  cadr u>>;
+++ tildepri compiled, 16 + 20 bytes
tildepri

newtok '((!= !>) replaceby);nil

infix =>;nil

precedence =>,to;nil

symbolic procedure equalreplaceby u;
   'replaceby . u;
+++ equalreplaceby redefined
+++ equalreplaceby compiled, 4 + 12 bytes
equalreplaceby

put('replaceby,'psopfn,'equalreplaceby);equalreplaceby

flag('(replaceby),'equalopr);nil           % Make LHS, RHS etc work.

flag('(replaceby),'spaced);nil             % Make it print with spaces.

symbolic procedure formreplaceby(u,vars,mode);
   list('list,mkquote car u,form1(cadr u,vars,mode),
                                !*s2arg(form1(caddr u,vars,mode),vars));
+++ formreplaceby compiled, 28 + 32 bytes
formreplaceby

put('replaceby,'formfn,'formreplaceby);formreplaceby

infix when;nil

precedence when,=>;nil

symbolic procedure formwhen(u,vars,mode);
   list('list,algid('when,vars),form1(cadr u,vars,mode),
%  We exclude formbool in following so that rules print prettily.
%                   mkarg(formbool(caddr u,vars,mode),vars));
                    mkarg(caddr u,vars));
+++ formwhen compiled, 26 + 36 bytes
formwhen

put('when,'formfn,'formwhen);formwhen

flag('(whereexp),'listargp);nil   % letsub.

% put('letsub,'simpfn,'simpletsub);

put('whereexp,'psopfn,'evalwhereexp);evalwhereexp

% symbolic procedure simpletsub u; simp evalletsub1(u,t);

symbolic procedure evalwhereexp u;
   % We assume that the arguments of this function are well-formed, as
   % they would be if produced from a "where" parse.
   % It looks like there is a spurious simplification, but it's needed
   % in x:= (e^(12i*pi/5) - e^(8i*pi/5) + 4e^(6i*pi/5) - e^(4i*pi/5)
   %     - 2e^(2i*pi/5) - 1)/(16e^(6i*pi/5)); y:= {e^(~a*i*pi/~(~ b))
   %     => e^((a - b)/b*i*pi) when numberp a and numberp b and a>b};
   %     x where y;
   evalletsub({cdar u,{'aeval,mkquote{'aeval,carx(cdr u,'where)}}},nil);
+++ evalwhereexp redefined
+++ evalwhereexp compiled, 24 + 28 bytes
evalwhereexp

flag('(aeval),'opfn);nil   % To make the previous procedure work.

% symbolic procedure evalletsub1(u,v);
%  begin scalar x;
%     x := car u;
%     u := carx(cdr u,'simpletsub);
%     if eqcar(x,'list) then x := cdr x else errach 'simpletsub;
%     return evalletsub2({x,{'aeval,mkquote u}},v)
%  end;

symbolic procedure evalletsub(u,v);
   if errorp(u := evalletsub2(u,v))
     then rerror(alg,24,"Invalid simplification")
    else car u;
+++ evalletsub redefined
+++ evalletsub compiled, 18 + 32 bytes
evalletsub

symbolic procedure evalletsub2(u,v);
  % car u   is an untagged list of rules or ruleset names,
  % cadr u  is an expression to be evaluated by errorset* with the
  %          rules activated locally,
  % v should be nil unless the rules contain equations.
  % Returns the expression value corresponding to the
  % errorset protocol.
   begin scalar newrule!*,oldrules!*,props!*,w;
      w := set_rules(car u,v);
      % We need resimp on since u may contain (*SQ ... T).
      unwind!-protect(u := errorset!*(cadr u,nil), % where !*resimp = t;
        % Restore previous environment, if changed.
        without!-timeout restore_rules w);
      return u
   end;
+++ evalletsub2 compiled, 46 + 44 bytes
evalletsub2

symbolic procedure set_rules(u,v);
   begin scalar !*resimp,x,y,z;
      for each j in u do
      % The "v" check in next line causes "a where a=>4" to fail.
         if eqcar(j,'replaceby) then y := j . y
          else if null v and eqcar(j,'equal)
           then <<lprim "Please use => instead of = in rules";
                  y := ('replaceby . cdr j) . y>>
          else if (x := validrule j)
             or idp j and (x := validrule reval j)
           then (x := reverse car x) and <<rule!-list(x,t); z := x . z>>
          else typerr(j,"rule list");
      rule!-list(y,t);
      return y . z
   end;
+++ set_rules compiled, 94 + 60 bytes
set_rules

symbolic procedure restore_rules u;
   <<for each j in u do rule!-list(j,nil);
     for each j in oldrules!*
         do if atom cdar j
              then if idp cdar j
                     then if cdar j eq 'scalar
                            then let3(caar j,cadr j,nil,t,nil)
                           else typelet(caar j,cadr j,nil,t,cdar j)
                    else nil
             else rule!*(car j,cadr j,caddr j,cadddr j,'old);
     restore_props()>>
   where !*resimp := nil;
+++ restore_rules compiled, 109 + 56 bytes
restore_rules

symbolic procedure restore_props;
   % At present, the only thing props!* can contain is an RTYPE
   % property.  However, it is in this form to handle any other cases
   % that arise.
   for each j in props!* do
      if pairp cdr j then put(car j,cadr j,cddr j)
       else flag({car j},cdr j);
+++ restore_props redefined
+++ restore_props compiled, 32 + 16 bytes
restore_props

symbolic procedure resimpcar u; resimp car u;
+++ resimpcar compiled, 3 + 12 bytes
resimpcar

symbolic procedure validrule u;
   (if null x then nil else list x) where x=validrule1 u;
+++ validrule redefined
+++ validrule compiled, 9 + 12 bytes
validrule

symbolic procedure validrule1 u;
   if atom u then nil
    else if car u eq 'list
     then if null cdr u then {{}}
           else for each j in cdr u collect validrule1 j
    else if car u eq 'replaceby then u
    else if car u eq 'equal then 'replaceby . cdr u
    else nil;
+++ validrule1 compiled, 58 + 20 bytes
validrule1

symbolic procedure remove!-free!-vars!* u;
   remove!-free!-vars u where !*!*noremove!*!* := t;
+++ remove!-free!-vars!* redefined
+++ remove!-free!-vars!* compiled, 11 + 24 bytes
remove-free-vars*

symbolic procedure remove!-free!-vars u;
   begin scalar x,w;
      return if atom u then u
          else if car u eq '!~
           then if !*!*noremove!*!*
                  then if (x := atsoc(cadr u,frasc!*))
                         or eqcar(cadr u,'!~)
                            and (x := atsoc(cadadr u,frasc!*))
                        then cdr x else u
                 else if atom cdr u then typerr(u,"free variable")
                 % Allow for the substitution of a free variable.
                 else if numberp(w := cadr u) then u
                 else if idp w or eqcar(w,'!~) and (w:=cadr w)
                  then <<frlis!* := union(list get!-free!-form cadr u,
                                          frlis!*);
                         w>>
                 else if idp caadr u   % Free operator.
                  then <<frlis!* := union(list get!-free!-form caadr u,
                                          frlis!*);
                         caadr u . remove!-free!-vars!-l cdadr u>>
                 else typerr(u,"free variable")
          else remove!-free!-vars!-l u
   end;
+++ remove!-free!-vars redefined
+++ remove!-free!-vars compiled, 99 + 48 bytes
remove-free-vars

%symbolic procedure remove!-free!-vars!-l u;
%   if atom u then u
%    else if car u eq '!*sq then remove!-free!-vars!-l prepsq!* cadr u
%    else (if x=u then u else x)
%         where x=remove!-free!-vars car u . remove!-free!-vars!-l cdr u;

% The version that follows is supposed to have exactly the same external
% behaviour as the above simpler one apart from it using a LOT less stack.
% ACN December 2011.

symbolic procedure remove!-free!-vars!-l u;
  begin
    scalar r, w, changed;
  top:
    if atom u then <<
       while r do <<
          if not changed then <<
             if caar w = car r then u := car w
             else <<
               u := car r . u;
               changed := t >> >>
          else u := car r . u;
          w := cdr w;
          r := cdr r >>;
       return u >>
    else if car u eq '!*sq then <<
       u := prepsq!* cadr u;
       changed := t;
       go to top >>;
    w := u . w;
    r := remove!-free!-vars car u . r;
    u := cdr u;
    go to top
  end;
+++ remove!-free!-vars!-l redefined
+++ remove!-free!-vars!-l compiled, 60 + 24 bytes
remove-free-vars-l


symbolic procedure get!-free!-form u;
   begin scalar x,opt;
      if x := atsoc(u,frasc!*) then return cdr x;
      if eqcar(u,'!~) then <<u:= cadr u; x := '(!! !~ !! !~); opt := t>>
       else x := '(!! !~);
      x := intern compress append(x,explode u);
      frasc!* := (u . x) . frasc!*;
      if opt then flag({x},'optional);
      return x
   end;
+++ get!-free!-form redefined
+++ get!-free!-form compiled, 51 + 32 bytes
get-free-form


symbolic procedure term!-split u;
   % U is a standard form which is not a kernel list (i.e., kernlp
   % is false). Result is the dotted pair of the leading part of the
    % expression for which kernlp is true, and the remainder;
   begin scalar x;
      while null red u do <<x := lpow u . x; u := lc u>>;
      return tpowadd(x,!*t2f lt u) . tpowadd(x,red u)
   end;
+++ term!-split compiled, 29 + 12 bytes
term-split

symbolic procedure tpowadd(u,v);
   <<for each j in u do v := !*t2f(j .* v); v>>;
+++ tpowadd compiled, 20 + 8 bytes
tpowadd

symbolic procedure frvarsof(u,l);
  % Extract the free variables in u in their left-to-right order.
   if memq(u,frlis!*) then if memq(u,l) then l else append(l,{u})
    else if atom u then l
    else frvarsof(cdr u,frvarsof(car u,l));
+++ frvarsof redefined
+++ frvarsof compiled, 32 + 12 bytes
frvarsof

symbolic procedure simp0 u;
   begin scalar !*factor,!*combinelogs,x,y,z;
        if eqcar(u,'!*sq) then return simp0 prepsq!* cadr u;
        y := setkorder frvarsof(u,nil);
        x := subfg!* . !*sub2;
        alglist!* := nil . nil;   % Since assignments will change.
        subfg!* := nil;
        if atom u
           or idp car u
              and (flagp(car u,'simp0fn) or get(car u,'rtype))
          then z := simp u
         else z := simpiden u;
        rplaca(alglist!*, delete_from_alglist(u, car alglist!*));
        % Since we don't want to keep this value.
        subfg!* := car x;
        !*sub2 := cdr x;
        setkorder y;
        return z
   end;
+++ simp0 compiled, 85 + 68 bytes
simp0

flag('(cons difference eps expt minus plus quotient times),'simp0fn);nil

symbolic procedure let!-prepf u;
   subla(for each x in frasc!* collect (cdr x . car x),prepf u);
+++ let!-prepf compiled, 47 + 16 bytes
let-prepf

symbolic procedure match u;
   match00 u where frasc!* = nil;
+++ match compiled, 9 + 20 bytes
match

symbolic procedure match00 u;
   <<for each x in u do let2(cadr x,caddr x,t,t);
     frasc!* := mcond!* := nil>>;
+++ match00 compiled, 33 + 24 bytes
match00

symbolic procedure clear u;
   begin
      rmsubs();
      unwind!-protect(u := errorset!*(list('clear1,mkquote u),t),
        mcond!* := frasc!* := nil);
      if errorp u then error1() else return car u
   end;
+++ clear compiled, 32 + 40 bytes
clear

symbolic procedure clear1 u;
   begin scalar x,y;
      while u do
         <<if flagp(x := car u,'share)
             then if not flagp(x,'reserved) then set(x,x) else rsverr x
            % if argument is an explicit list, clear each element.
            else if eqcar(x,'list)
                   then u := nil . append(cdr x,cdr u)
            % The following two cases allow for rules or the lhs of
            % rules as arguments to CLEAR.
            else if eqcar(x,'replaceby) then rule!-list(list x,nil)
            else if smemq('!~,x)
             then if eqcar(x,'equal) then rule!-list(list x,nil)
                   else rule!-list(list list('replaceby,x,nil),nil)
            % Hook for a generalized "clear" facility.
            else if (y := get(if atom x then x else car x,'clearfn))
                 then apply1(y,x)
            else <<let2(x,nil,nil,nil); let2(x,nil,t,nil)>>;
           u := cdr u>>
   end;
+++ clear1 compiled, 116 + 48 bytes
clear1

symbolic procedure typelet(u,v,ltype,b,rtype);
   % General function for setting up rules for typed expressions.
   % LTYPE is the type of the left hand side U, RTYPE, that of RHS V.
   % B is a flag that is true if this is an update, nil for a removal.
   begin scalar ls;
        if null rtype then rtype := 'scalar;
        if ltype eq rtype then go to a
         else if null b then go to c
         else if ltype
          then if ltype eq 'list and rtype eq 'scalar
                 then <<ls := t; go to l>>
                else typerr(list(ltype,u),rtype)
         else if not atom u
          then if arrayp car u then go to a else typerr(u,rtype);
        redmsg(u,rtype);
    l:  put(u,'rtype,rtype);
        ltype := rtype;
    a:  if b and (not atom u or flagp(u,'used!*)) then rmsubs();
    c:  if not atom u
          then if arrayp car u
                 then setelv(u,if b then v else nil)
                else put(car u,'opmtch,xadd!*(cdr u .
                    list(nil . (if mcond!* then mcond!* else t),v,nil),
                        get(car u,'opmtch),b))
         else if null b
          then <<remprop(u,'avalue);
                 remprop(u,'rtype);
                 if ltype eq 'array then remprop(u,'dimension)>>
         else if ls
          then <<remprop(u,'rtype); put!-avalue(u,rtype,v)>>
         else <<if (b := get(u,'avalue))
                  then if not(rtype eq car b)
                          and (not(car b memq(ls := '(scalar list)))
                               or not(rtype memq ls))
                         then typerr(list(car b,u),rtype);
                put!-avalue(u,rtype,v)>>
   end;
+++ typelet compiled, 203 + 84 bytes
typelet

symbolic procedure setk(u,v);
   if not atom u
     then (if x then setk0(car u . apply1(x,cdr u),v)
            else if get(car u,'rtype) eq 'matrix then setk0(u,v)
            else setk0(car u . revlis cdr u,v))
           where x=get(car u,'evalargfn)
    else setk0(u,v);
+++ setk redefined
+++ setk compiled, 42 + 24 bytes
setk

symbolic procedure setk0(u,v);
   % Clear frasc!* to allow for autoloading within LET constructs.
   begin scalar x,frasc!*;
      % We need to reset alglist!* for structures on the left or right
      % hand side.
      if (x := getrtype v) and get(x,'setelemfn)
        then <<alglist!* := nil . nil; let2(u,v,nil,t)>>
       else if not atom u
         and idp car u
      % Excalc currently needs getrtype to check for free indices.
      % Getrtype *must* be called as first argument in OR below.
         and ((x := getrtype u or get(car u,'rtype))
                and (x := get(x,'setelemfn))
               or (x := get(car u,'setkfn)))
        % We must update alglist!* when an element is defined.
        then <<alglist!* := nil . nil; apply2(x,u,v)>>
        % alglist!* is updated here in simp0.
       else if null atom u and null atom car u 
               and (x := get(caar u,'setstructfn))
        then <<alglist!* := nil . nil; apply2(x,u,v)>>
       else let2(u,v,nil,t);
      return v
   end;
+++ setk0 redefined
+++ setk0 compiled, 109 + 48 bytes
setk0

symbolic procedure setk1(u,v,b);
   begin scalar x,y,z,!*uncached;
      !*uncached := t;
      if atom u
        then <<if null b
                 then <<if not get(u,'avalue)
                          then msgpri(nil,u,"not found",nil,nil)
                         else remprop(u,'avalue);
                        return nil>>
                else if (x:= get(u,'avalue)) then put!-avalue(u,car x,v)
                else put!-avalue(u,'scalar,v);
               return v>>
       else if not atom car u
        then rerror(alg,25,"Invalid syntax: improper assignment");
      u := car u . revlis cdr u;
      if null b
        then <<z:=assoc(u,wtl!*);
               if not(y := get(car u,'kvalue))
                  or not (x := assoc(u,y))
                 then <<if null z and null !*sqrtrulep then
                            msgpri(nil,u,"not found",nil,nil)>>
                else put(car u,'kvalue,delete(x,y));
                if z then wtl!*:=delasc(u,wtl!*);
               return nil>>
       else if not (y := get(car u,'kvalue))
        then put!-kvalue(car u,nil,u,v)
       else <<if x := assoc(u,y)
                then <<updoldrules(u,v); y := delasc(car x,y)>>;
              put!-kvalue(car u,y,u,v)>>;
      return v
     end;
+++ setk1 redefined
+++ setk1 compiled, 203 + 88 bytes
setk1

% symbolic procedure put!-avalue(u,v,w);
%    if smember(u,w) then recursiveerror u
%    else put(u,'avalue,{v,w});

symbolic procedure put!-avalue(u,v,w);
   % This definition allows for an assignment such as a := a 4.
   if v eq 'scalar
     then if eqcar(w,'!*sq) and sq_member(u,cadr w)
            then recursiveerror u
           else if !*reduce4 then putobject(u,w,'generic)
           else put(u,'avalue,{v,w})
    else if smember(u,w) then recursiveerror u
    else put(u,'avalue,{v,w});
+++ put!-avalue redefined
+++ put!-avalue compiled, 65 + 48 bytes
put-avalue

symbolic procedure sq_member(u,v);
   sf_member(u,numr v) or sf_member(u,denr v);
+++ sq_member redefined
+++ sq_member compiled, 10 + 12 bytes
sq_member

symbolic procedure sf_member(u,v);
   null domainp v and
     (mvar_member(u,mvar v) or sf_member(u,lc v) or sf_member(u,red v));
+++ sf_member redefined
+++ sf_member compiled, 24 + 12 bytes
sf_member

symbolic procedure mvar_member(u,v);
   % This and arglist member have to cater for the funny forms we
   % find in packages like TAYLOR.
   u = v or (null atom v and arglist_member(u,cdr v));
+++ mvar_member redefined
+++ mvar_member compiled, 13 + 16 bytes
mvar_member

symbolic procedure arglist_member(u,v);
   null atom v and (mvar_member(u,car v) or arglist_member(u,cdr v));
+++ arglist_member redefined
+++ arglist_member compiled, 14 + 12 bytes
arglist_member

% symbolic procedure put!-kvalue(u,v,w,x);
%    if smember(w,x) then recursiveerror w
%     else put(u,'kvalue,aconc(v,{w,x}));

symbolic procedure put!-kvalue(u,v,w,x);
   % This definition is needed to allow p(2) := sqrt(1-p^2).
   if (if eqcar(x,'!*sq) then sq_member(w,cadr x) else smember(w,x))
     then recursiveerror w
    else put(u,'kvalue,aconc(v,{w,x}));
+++ put!-kvalue redefined
+++ put!-kvalue compiled, 40 + 36 bytes
put-kvalue

symbolic procedure klistt u;
   if atom u then nil else caar u . klistt cdr carx(u,'list);
+++ klistt redefined
+++ klistt compiled, 17 + 20 bytes
klistt

symbolic procedure kernlp u;
   % Returns leading domain coefficient if U is a monomial product
   % of kernels, NIL otherwise.
   if domainp u then u else if null red u then kernlp lc u else nil;
+++ kernlp redefined
+++ kernlp compiled, 15 + 8 bytes
kernlp

symbolic procedure xadd(u,v,b);
   % Adds replacement U to table V, with new rule at head.
   % Note that format of u and v depends on whether a free variable
   % occurs in the expression or asymplis* is being updated!!.
   begin scalar x;
        x := assoc(car u,v);
        if null x
          then if b and not(b eq 'replace) then v := u . v else nil
         else if b
          then <<v := delete(x,v);
                 if not atom cdr x and length x=5
                   then x := cdr x;  % No free variable.
                 if not atom cdr x   % atom is asymplis update.
                   then updoldrules(caddr x,cdadr x);
                 if not(b eq 'replace) then v := u . v>>
%        else if cadr x=cadr u then v := delete(x,v);
         else if atom cdr x and cdr x=cdr u
              or not atom cdr x and cadr x=cadr u
          then v := delete(x,v);
        return v
   end;
+++ xadd compiled, 75 + 20 bytes
xadd

symbolic procedure updoldrules(v,w);
   (if null u then nil
     else oldrules!* := append(
                 (if not atom v and numberp cdr v   % asymptotic case.
                    then list list(list('expt,car v,cdr v),0,nil,t)
                   else if atom car u
                    then list list(car u . car v,cadr v,nil,t)
                   else (if car u neq y
                           then list list(car u,y,x,rsubla(x,w))
                          else nil) where y=rsubla(x,v)),
                 oldrules!*)
           where x=caddr u)
    where u=newrule!*;
+++ updoldrules compiled, 83 + 40 bytes
updoldrules

symbolic procedure xadd!*(u,v,b);
   % Adds replacement U to table V, with new rule at head.
   % Also checks boolean part for equality.
   % Note, in an earlier version, we removed all rules in the CLEAR mode
   % regardless of whether they came from a LET or a MATCH, or had
   % boolean constraints.  However, this made the fps tests not work.
   begin scalar x,y;
      x := v;
%     while x and not(car u=caar x and (cadr u=cadar x or null b))
      while x and not(car u=caar x and cadr u=cadar x)
         do x := cdr x;
      if x then <<v := delete(car x,v); x := car x;
                  % If this section is entered, then car x and car
                  % newrule!* should be the same. If not, a rule of the
                  % form a+b => c might have occurred, in which case we
                  % need to adjust the form of the replaced value.
                 if b and newrule!*
                   then if car x neq (y := car newrule!*)
                           and powlisp car x
                      then updoldrules(prepsq simp {'plus,y,
                              {'difference,caddr x,'times .
                       for each j in car x collect {'expt,car j,cdr j}}},
                                       cdadr x)
                  else updoldrules(caddr x,cdadr x)>>;
      if b then v := u . v;
      return v
   end;
+++ xadd!* redefined
+++ xadd!* compiled, 132 + 44 bytes
xadd*

symbolic procedure powlisp u;
   null u or not atom car u and numberp cdar u and powlisp cdr u;
+++ powlisp compiled, 17 + 12 bytes
powlisp

symbolic procedure rsubla(u,v);
   begin scalar x;
        if null u or null v then return v
         else if atom v
                 then return if x:= rassoc(v,u) then car x else v
         else return(rsubla(u,car v) . rsubla(u,cdr v))
   end;
+++ rsubla redefined
+++ rsubla compiled, 26 + 12 bytes
rsubla

endmodule;nil

end;nilmodule eqn;nil   % Support for equations as top level structures.

% Author: Anthony C. Hearn.

% Copyright (c) 1990 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% At the moment "EQUAL" is the tag for such structures.

% Evalequal is defined in alg/algbool.

fluid '(!*evallhseqp);nil

switch evallhseqp;nil

!*evallhseqp := t;t   % Default is currently on.

symbolic procedure equalreval u;
   % This definition really needs to know whether we are trying
   % to produce a tagged standard quotient or a prefix form.
   % It would also be more efficient to leave a *SQ form unchanged
   % on the right hand side as shown.  However, it messes up printing.
  (if !*evallhseqp or not atom car u and flagp(caar u,'immediate)
     then list('equal,reval car u,x)
    else list('equal,car u,x))
   where x= reval y % (if eqcar(y,'!*sq) then aeval y else reval y)
             where y=cadr u;
+++ equalreval redefined
+++ equalreval compiled, 28 + 24 bytes
equalreval

put('equal,'psopfn,'equalreval);equalreval

put('equal,'rtypefn,'quoteequation);quoteequation

put('equal,'i2d,'eqnerr);eqnerr

symbolic procedure eqnerr u; typerr(u,"equation");
+++ eqnerr compiled, 4 + 16 bytes
eqnerr

put('equation,'evfn,'evaleqn);evaleqn

% symbolic procedure evaleqn(u,v);
%    begin scalar op,x;
%       if null cdr u or not eqcar(cadr u,'equal)
%         then rerror(alg,26,"Invalid equation structure");
%      op := car u;
%       if null cddr u
%         then return 'equal . for each j in cdadr u
%          collect if op eq 'eqneval then reval1(j,v) else list(op,j)
%        else if eqcar(caddr u,'equal) or cdddr u
%         then rerror(alg,27,"Invalid equation structure");
%       x := caddr u;
%       return 'equal . for each j in cdadr u collect list(op,j,x)
%   end;

% put('eqneval,'rtypefn,'getrtypecar);

symbolic procedure evaleqn(u,v);
 % This function allows us to perform elementary equation arithmetic
 % combining one equation and scalars by  + - * / ^, and to compute
 % sums and differences of equations. Restriction: the equation must
 % be the leftmost term in the arithmetic expression.
  begin scalar e,l,r,w,op,x,found;
   if (x:=get(u,'avalue)) then u:=cadr x;
   if not !*evallhseqp then
   <<if eqcar(u,'equal) then return equalreval cdr u else
     typerr(u,"algebraic expression when evallhseqp is off")>>;
   op:=car u; w:=cdr u;
   if op='plus or op='difference or op='minus then
   <<for each q in w do
     <<q:=reval q;
       if eqcar(q,'equal)
          then <<l:=cadr q.l; r:=caddr q.r;found:=t>>
          else   <<l:=q.l; r:=q.r>>;
     >>;
     r:=op.reverse r; l:=op.reverse l;
   >>
   else
   << u:=op . for each q in w collect reval q;
      e:=evaleqn1(u,u,nil);
      if e then
      <<l:=subst(cadr e,e,u); r:=subst(caddr e,e,u); found:=t>>;
   >>;
   if not found then rederr
      "failed to locate equal sign in equation processing";
   return {'equal, reval1(l,v), reval1(r,v)}
  end;
+++ evaleqn compiled, 199 + 64 bytes
evaleqn

symbolic procedure evaleqn1(u,u0,e);
   if atom u then e
    else
   if car u='equal then
     (if e then typerr(u0,"equation expression") else u)
   else evaleqn1(cdr u,u0,evaleqn1(car u,u0,e));
+++ evaleqn1 compiled, 27 + 20 bytes
evaleqn1

% put(equal,'prifn,'equalpri);

% put('equal,'lengthfn,'eqnlength);

symbolic procedure lhs u;
   % Returns the left-hand-side of an equation.
   lhs!-rhs(u,'cadr);
+++ lhs compiled, 4 + 16 bytes
lhs

symbolic procedure rhs u;
   % Returns the right-hand-side of an equation.
   lhs!-rhs(u,'caddr);
+++ rhs compiled, 4 + 16 bytes
rhs

symbolic procedure lhs!-rhs(u,op);
 <<if not(pairp u and get(car u,'infix) and cdr u and cddr u
          and null cdddr u)
                then typerr(u,"argument for LHS or RHS");
   apply1(op,u)>>;
+++ lhs!-rhs compiled, 29 + 16 bytes
lhs-rhs

flag('(lhs rhs),'opfn);nil  % Make symbolic operators.


% Explicit substitution code for equations.

symbolic procedure eqnsub(u,v);
   if !*evallhseqp or not atom car u and flagp(caar u,'immediate)
     then 'equal . for each x in cdr v collect subeval1(u,x)
    else list('equal,cadr v,subeval1(u,caddr v));
+++ eqnsub compiled, 69 + 24 bytes
eqnsub

put('equation,'subfn,'eqnsub);eqnsub

put('equation,'lengthfn,'eqnlength);eqnlength

symbolic procedure eqnlength u; length cdr u;
+++ eqnlength compiled, 3 + 8 bytes
eqnlength

endmodule;nil

end;nilmodule rmsubs;nil   % Remove system wide standard quotient substitutions.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(alglist!*);nil

global '(!*sqvar!*);nil

% Contains RPLACA update of *SQVAR*.

!*sqvar!*:= list 't;(t)    %variable used by *SQ expressions to control
                        %resimplification;

symbolic procedure rmsubs;
   begin
        rplaca(!*sqvar!*,nil); !*sqvar!* := list t;
%       while kprops!* do
%          <<remprop(car kprops!*,'klist); %kprops!* := cdr kprops!*>>;
%       exlist!* := list '(!*);
        %This is too dangerous: someone else may have constructed a
        %standard form;
        alglist!* := nil . nil
   end;
+++ rmsubs redefined
+++ rmsubs compiled, 11 + 20 bytes
rmsubs

endmodule;nil

end;nilmodule algdcl;nil  % Various declarations.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


global '(preclis!* ws);nil

symbolic procedure formopr(u,vars,mode);
   if mode eq 'symbolic
     then list('flag,mkquote cdr u,mkquote 'opfn)
    else list('operator,mkarg(cdr u,vars));
+++ formopr redefined
+++ formopr compiled, 25 + 32 bytes
formopr

put('operator,'formfn,'formopr);formopr

symbolic procedure operator u; for each j in u do mkop j;
+++ operator redefined
+++ operator compiled, 15 + 12 bytes
operator

rlistat '(operator);nil

symbolic procedure remopr u;
   % Remove all operator related properties from id u.
   begin
      remprop(u,'alt);
      remprop(u,'infix);
      remprop(u,'op);
      remprop(u,'prtch);
      remprop(u,'simpfn);
      remprop(u,'unary);
      remflag(list u,'linear);
      remflag(list u,'nary);
      remflag(list u,'opfn);
      remflag(list u,'antisymmetric);
      remflag(list u,'symmetric);
      remflag(list u,'right);
      preclis!* := delete(u,preclis!*)
   end;
+++ remopr compiled, 66 + 60 bytes
remopr

flag('(remopr),'eval);nil

symbolic procedure den u;
   mk!*sq (denr simp!* u ./ 1);
+++ den redefined
+++ den compiled, 8 + 20 bytes
den

symbolic procedure num u;
   mk!*sq (numr simp!* u ./ 1);
+++ num compiled, 8 + 20 bytes
num

flag('(den num),'opfn);nil

flag('(den num),'noval);nil

put('saveas,'formfn,'formsaveas);formsaveas

symbolic procedure formsaveas(u,vars,mode);
   list('saveas,formclear1(cdr u,vars,mode));
+++ formsaveas compiled, 11 + 16 bytes
formsaveas

symbolic procedure saveas u;
   let00 list list(if smemq('!~,car u) then 'replaceby else 'equal,
                   car u,
                   if eqcar(ws,'!*sq)
                      and smemql(for each x in frasc!* collect car x,
                                 cadr ws)
                     then list('!*sq,cadr ws,nil)
                    else ws);
+++ saveas compiled, 74 + 40 bytes
saveas

rlistat '(saveas);nil

endmodule;nil

end;nilmodule opmtch;nil % Functions that apply basic pattern matching rules.

% Author: Anthony C. Hearn.
% Modifications by: Winfried Neun.

% Copyright (c) 2000 Anthony C. Hearn. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*uncached frlis!* matchlength!* subfg!*);nil

matchlength!* := 5;5 % Maximum number of arguments checked in matching.

share matchlength!*;nil

% Operator // for extended quotient match to be used only in the
% lhs of a rule.

newtok '((!/ !/) slash);nil

mkop 'slash;nil

infix slash;nil

precedence slash, quotient;nil

% put('slash,'simpfn, function(lambda(u); typerr("//",'operator)));

symbolic procedure emtch u;
   if atom u then u else (lambda x; if x then x else u) opmtch u;
+++ emtch redefined
+++ emtch compiled, 10 + 12 bytes
emtch

% Support for associative access:
% An empty table is represented as NIL
% Otherwise it will be a hash table. These days both CSL and PSL support
% hash tables. As done here when there is not information to be stored
% the NIL does not consume space...

symbolic inline procedure assoc_lookup(u, table);
  if null table then nil
  else gethash(u, table);
+++ Record new inline definition:
(de assoc_lookup (u table) (cond ((null table) nil) (t (gethash u table))))
(progn (de assoc_lookup (u table) (cond ((null table) nil) (t (gethash u table))
)) (put (quote assoc_lookup) (quote number!-of!-args) 2) (put (quote
assoc_lookup) (quote procedure_type) (quote (arrow (times general general)
general))) (putc (quote assoc_lookup) (quote inline) (quote (lambda (u table) (
cond ((null table) nil) (t (gethash u table)))))))
+++ assoc_lookup compiled, 6 + 12 bytes
(lambda (u table) (cond ((null table) nil) (t (gethash u table))))

symbolic inline procedure assoc_add(u, q, table);
 << if null table then table := mkhash(20, 3, 2.0);
    puthash(u, table, u . q);
    table >>;
+++ Record new inline definition:
(de assoc_add (u q table) (progn (cond ((null table) (setq table (mkhash 20 3
2.0)))) (puthash u table (cons u q)) table))
(progn (de assoc_add (u q table) (progn (cond ((null table) (setq table (mkhash
20 3 2.0)))) (puthash u table (cons u q)) table)) (put (quote assoc_add) (quote
number!-of!-args) 3) (put (quote assoc_add) (quote procedure_type) (quote (arrow
(times general general general) general))) (putc (quote assoc_add) (quote inline
) (quote (lambda (u q table) (progn (cond ((null table) (setq table (mkhash 20 3
2.0)))) (puthash u table (cons u q)) table)))))
+++ assoc_add compiled, 22 + 28 bytes
(lambda (u q table) (progn (cond ((null table) (setq table (mkhash 20 3 2.0))))
(puthash u table (cons u q)) table))

symbolic procedure opmtch u;
   begin scalar q,x,y,z;
        if null(x := get(car u,'opmtch)) then return nil
         else if null subfg!* then return nil  % null(!*sub2 := t).
         else if (null !*uncached) and (q := assoc_lookup(u,cdr alglist!*))
                 then return cdr q;
        z := for each j in cdr u collect emtch j;
    a:  if null x then go to c;
        y := mcharg(z,caar x,car u);
    b:  if null y then <<x := cdr x; go to a>>
         else if lispeval subla(car y,cdadar x)
          then <<q := subla(car y,caddar x); go to c>>;
        y := cdr y;
        go to b;
    c:  if not !*uncached then rplacd(alglist!*,
                                      assoc_add(u, q, cdr alglist!*));
        return q
   end;
+++ Assignment to parameter of inline: (setq table (mkhash 20 3 2.0))
+++ Macro was: (assoc_add (u q table) (progn (cond ((null table) (setq table (
mkhash 20 3 2.0)))) (puthash u table (cons u q)) table))

+++ opmtch redefined
+++ opmtch compiled, 142 + 56 bytes
opmtch

symbolic procedure mcharg(u,v,w);
  <<if atsoc('minus,v) then mcharg1(reform!-minus(u,v),v,w) else
    if v and eqcar(car v,'slash) then
      for each f in reform!-minus2(u,v) join mcharg1(car f,cdr f,w)
    else mcharg1(u,v,w)>>;
+++ mcharg redefined
+++ mcharg compiled, 76 + 32 bytes
mcharg

symbolic procedure mcharg1(u,v,w);
   % Procedure to determine if an argument list matches given template.
   % U is argument list of operator W, V is argument list template being
   % matched against.  If there is no match, value is NIL,
   % otherwise a list of lists of free variable pairings.
   if null u and null v then list nil
    else begin integer m,n;
        m := length u;
        n := length v;
        if flagp(w,'nary) and m>2
          then if m<=matchlength!* and flagp(w,'symmetric)
                             then return mchcomb(u,v,w)
                else if n=2 then <<u := cdr mkbin(w,u); m := 2>>
                else return nil;   % We cannot handle this case.
        return if m neq n then nil
                else if flagp(w,'symmetric) then mchsarg(u,v,w)
                else if mtp v then list pair(v,u)
                else mcharg2(u,v,list nil,w)
   end;
+++ mcharg1 redefined
+++ mcharg1 compiled, 93 + 44 bytes
mcharg1

symbolic procedure reform!-minus(u,v);
  % Convert forms (quotient (minus a) b) to (minus (quotient a b))
  % if the corresponding pattern in v has a top level minus.
    if null v or null u then u else
      ((if eqcar(car v,'minus) and eqcar(c,'quotient)
           and eqcar(cadr c,'minus)
          then {'minus,{'quotient,cadr cadr c,caddr c}} else c)
                      . reform!-minus(cdr u,cdr v))
                               where c=car u;
+++ reform!-minus redefined
+++ reform!-minus compiled, 44 + 16 bytes
reform-minus

symbolic procedure reform!-minus2(u,v);
 % Prepare an extended quotient match; v is a pattern with leading "//".
 % Create for a form (quotient a b) a second form
 %  (quotient (minus a) (minus b)) if b contains a minus sign.
   if null u or not eqcar(car u,'quotient) then nil else
  <<v := ('quotient . cdar v) . cdr v;
   if not smemq('minus,caddar u) then {u.v}
     else
   {u . v,
    ({'quotient,reval {'minus,cadar u},reval {'minus,caddar u}} . cdr u)
                . v}>>;
+++ reform!-minus2 compiled, 53 + 20 bytes
reform-minus2

symbolic procedure mchcomb(u,v,op);
   begin integer n;
      n := length u - length v +1;
      if n<1 then return nil
      else if n=1 then return mchsarg(u,v,op)
      else if not smemqlp(frlis!*,v) then return nil;
% The expansion of "for each ... join" is careful not to scan the
% list that is being generated from the start at each step and so is
% not a terrible cost issue.
      return for each x in comb(u,n) join
           if null ncmp!* then mchsarg((op . x) . setdiff(u,x),v,op)
           else (if null y then nil
                 else mchsarg((op . x) . car y,
                              if cdr y then reverse v else v,op))
             where y = mchcomb2(x,u,nil,nil,nil)
   end;
+++ mchcomb compiled, 189 + 48 bytes
mchcomb

symbolic procedure mchcomb2(u,v,w,bool1,bool2);
   % Determines if v can be removed from u according to noncom rules,
   % and whether remaining terms must be on the left (t) or right (nil).
   if null u
     then reversip2(w,v) . bool2
   % (bool2 or null noncomlistp v and noncomlistp w and 'ok)
    else if car u = car v
           then if noncomp car u then mchcomb2(cdr u,cdr v,w,t,bool2)
                 else mchcomb2(cdr u,cdr v,w,bool1,bool2)
    else if noncomp car u
     then if bool1 then nil
           else mchcomb2(u,cdr v,car v . w,t,if bool2 then bool2 else t)
    else mchcomb2(u,cdr v,car v . w,bool1,bool2);
+++ mchcomb2 compiled, 79 + 20 bytes
mchcomb2

%- symbolic procedure comb(u,n);
%-    % Value is list of all combinations of N elements from the list U.
%-    begin scalar v; integer m;
%-         if n=0 then return list nil
%-          else if (m:=length u-n)<0 then return nil
%-          else for i := 1:m do
%-           <<v := nconc!*(v,mapcons(comb(cdr u,n-1),car u));
%-             u := cdr u>>;
%-         return u . v
%-    end;

symbolic procedure comb(u,n);
% Value is list of all combinations of N elements from the list U.
% This new version does not return the combinations in the same order,
% but I really hope that does not matter. It avoids the use of
% nconc that repeatedly tagged items on the end of what could end up
% a very long list, and so for long lists u its costs should be
% smaller.
  begin
    scalar v, w;
    integer m;
    if n=0 then return list nil
    else if (m:=length u-n)<0 then return nil;
    for i := 1:m do <<
      w := comb(cdr u, n-1);
      for each q in w do v := ((car u) . q) . v;
      u := cdr u>>;
    return u . v
  end;
+++ comb redefined
+++ comb compiled, 66 + 16 bytes
comb


symbolic procedure mcharg2(u,v,w,x);
   % Matches compatible list U of operator X against template V.
   begin scalar y;
        if null u then return w;
        y := mchk(car u,car v);
        u := cdr u;
        v := cdr v;
        return for each j in y
           join mcharg2(u,updtemplate(j,v,x),msappend(w,j),x)
   end;
+++ mcharg2 redefined
+++ mcharg2 compiled, 86 + 24 bytes
mcharg2

symbolic procedure msappend(u,v);
   % Mappend u and v with substitution.
   for each j in u collect append(v,sublis(v,j));
+++ msappend redefined
+++ msappend compiled, 48 + 8 bytes
msappend

symbolic procedure updtemplate(u,v,w);
   begin scalar x,y;
      return for each j in v collect
        if (x := subla(u,j)) = j then j
         else if (y := reval!-without(x,w)) neq x then y
         else x
   end;
+++ updtemplate redefined
+++ updtemplate compiled, 73 + 12 bytes
updtemplate

symbolic procedure reval!-without(u,v);
   % Evaluate U without rules for operator V.  This avoids infinite
   % recursion with statements like
   % for all a,b let kp(dx a,kp(dx a,dx b)) = 0; kp(dx 1,dx 2).
   begin scalar x;
      x := get(v,'opmtch);
      remprop(v,'opmtch);
      unwind!-protect(u := errorset!*(list('reval,mkquote u),t),
        put(v,'opmtch,x));
      if errorp u then error1() else return car u
   end;
+++ reval!-without compiled, 41 + 36 bytes
reval-without

symbolic procedure mchk(u,v);
  % Extension to optional arguments for binary forms suggested by
  % Herbert Melenk.
   if u=v then list nil
    else if eqcar(u,'!*sq) then mchk(prepsqxx cadr u,v)
    else if eqcar(v,'!*sq) then mchk(u,prepsqxx cadr v)
    else if atom v
           then if v memq frlis!* then list list (v . u) else nil
    else if atom u      % Special check for negative number match.
     then if numberp u and u<0 and eqcar(v,'minus)
          then mchk(list('minus,-u),v) else mchkopt(u,v)
       % "difference" may occur in a pattern like (a - b)^~n.
    else if car v = 'difference then
       mchk(u,{'plus,cadr v,{'minus,caddr v}})
    else if get(car u,'dname) or get(car v,'dname) then nil
    else if car u eq car v then mcharg(cdr u,cdr v,car u)
    else if car v memq frlis!*    % Free operator.
      then for each j in mcharg(subst(car u,car v,cdr u),
                                subst(car u,car v,cdr v),
                                car u)
               collect (car v . car u) . j
    else if car u eq 'minus then mchkminus(cadr u,v)
    else mchkopt(u,v);
+++ mchk redefined
+++ mchk compiled, 179 + 44 bytes
mchk

symbolic procedure mchkopt(u,v);
 % Check whether the pattern v is a binary form with an optional
 % argument.
   (if o then mchkopt1(u,v,o)) where o=get(car v,'optional);
+++ mchkopt redefined
+++ mchkopt compiled, 12 + 12 bytes
mchkopt

symbolic procedure mchkopt1(u,v,o);
  begin scalar v1,v2,w;
    if null (w:=cdr v) then return nil; v1:=car w;
    if null (w:=cdr w) then return nil; v2:=car w;
    if cdr w then return nil;
    return
     if flagp(v1,'optional) then
      for each r in mchk(u,v2) collect (v1.car o) . r
     else if flagp(v2,'optional) then
      for each r in mchk(u,v1) collect (v2.cadr o) . r
     else nil;
   end;
+++ mchkopt1 redefined
+++ mchkopt1 compiled, 114 + 12 bytes
mchkopt1

put('plus,'optional,'(0 0));(0 0)
put('times,'optional,'(1 1));(1 1)
put('quotient,'optional,
     '((rule_error "fraction with optional numerator") 1));((rule_error
fraction with optional numerator) 1)
put('expt,'optional,
     '((rule_error "exponential with optional base")  1));((rule_error
exponential with optional base) 1)

symbolic procedure rule_error u;
  rederr{"error in rule:",u,"illegal"};
+++ rule_error compiled, 7 + 20 bytes
rule_error

symbolic operator rule_error;nil

% The following function pushes a minus sign into a term.
% E.g. a + ~~y*~z matches
%                         y   z
%     (a + b)             1   b
%     (a - b)            -1   b
%     (a -3b)            -3   b
%                         b  -3
%     (a - b*c)          -b   c
%                         c  -b
%
% For products, the minus is assigned to a numeric coefficient or
% an artificial factor (-1) is created. For quotients the minus is
% always put in the numerator.

symbolic procedure mchkminus(u,v);
  if not(car v memq '(times quotient)) then nil else
  if atom u or not(car u eq car v) then
    if car v eq 'times then mchkopt1(u,v,'((minus 1)(minus 1)))
        else mchkopt({'minus,u},v)
  else if numberp cadr u or pairp cadr u and get(caadr u,'dname)
        or car v eq 'quotient
     then mcharg({'minus,cadr u}.cddr u,cdr v,car v)
  else mcharg('(minus 1).cdr u,cdr v,'times);
+++ mchkminus compiled, 73 + 44 bytes
mchkminus

symbolic procedure mkbin(u,v);
   if null cddr v then u . v else list(u,car v,mkbin(u,cdr v));
+++ mkbin compiled, 18 + 8 bytes
mkbin

symbolic procedure mtp v;
   null v or (car v memq frlis!* and not(car v member cdr v)
       and mtp cdr v);
+++ mtp redefined
+++ mtp compiled, 20 + 16 bytes
mtp

symbolic procedure mchsarg(u,v,w);
   %  From ACH: I don't understand why I put in the following reversip,
   %  since it causes the least direct match to come back first.
   reversip!* if mtp v and (w neq 'times or noncomfree u)
     then for each j in noncomperm v collect pair(j,u)
    else for each j in noncomperm u join mcharg2(j,v,list nil,w);
+++ mchsarg redefined
+++ mchsarg compiled, 125 + 40 bytes
mchsarg

symbolic procedure noncomfree u;
   if idp u then not flagp(u,'noncom)
    else atom u or noncomfree car u and noncomfree cdr u;
+++ noncomfree redefined
+++ noncomfree compiled, 24 + 20 bytes
noncomfree

symbolic procedure noncomperm u;
   % Find possible permutations when non-commutativity is taken into
   % account.
   if null u then list u
    else for each j in u join
       (if x eq 'failed then nil else mapcons(noncomperm x,j))
        where x=noncomdel(j,u);
+++ noncomperm redefined
+++ noncomperm compiled, 68 + 24 bytes
noncomperm

symbolic procedure noncomdel(u,v);
   if null noncomp!* u then delete(u,v) else noncomdel1(u,v);
+++ noncomdel redefined
+++ noncomdel compiled, 14 + 16 bytes
noncomdel

symbolic procedure noncomdel1(u,v);
   begin scalar z;
   a: if null v then return reversip!* z
       else if u eq car v then return reversip2(z,cdr v)
       else if noncomp!* car v then return 'failed;
      z := car v . z;
      v := cdr v;
      go to a
   end;
+++ noncomdel1 compiled, 28 + 24 bytes
noncomdel1

symbolic procedure noncomp!* u;
   noncomp u or eqcar(u,'expt) and noncomp cadr u;
+++ noncomp!* redefined
+++ noncomp!* compiled, 14 + 16 bytes
noncomp*

flagop antisymmetric,symmetric;nil

flag ('(plus times),'symmetric);nil

endmodule;nil

end;nilmodule prep;nil % Functions for converting canon. forms into prefix forms.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*bool !*intstr);nil

symbolic procedure prepsqxx u;
   % This is a top level conversion function.  It is not clear if we
   % need prepsqxx, prepsqx, prepsq!* and prepsq, but we keep them all
   % for the time being.
   negnumberchk prepsqx u;
+++ prepsqxx redefined
+++ prepsqxx compiled, 5 + 16 bytes
prepsqxx

symbolic procedure negnumberchk u;
   if eqcar(u,'minus) and numberp cadr u then - cadr u else u;
+++ negnumberchk redefined
+++ negnumberchk compiled, 15 + 12 bytes
negnumberchk

symbolic procedure prepsqx u;
   if !*intstr then prepsq!* u else prepsq u;
+++ prepsqx redefined
+++ prepsqx compiled, 10 + 20 bytes
prepsqx

symbolic procedure prepsq u;
   if null numr u then 0 else sqform(u,function prepf);
+++ prepsq redefined
+++ prepsq compiled, 9 + 20 bytes
prepsq

symbolic procedure sqform(u,v);
   (lambda (x,y); if y=1 then x else list('quotient,x,y))
      (apply1(v,numr u),apply1(v,denr u));
+++ sqform redefined
+++ sqform compiled, 17 + 16 bytes
sqform

% For at least a while I am leaving the OLD version around, albeit
% unused.

symbolic procedure oldprepf u;
   (if null x then 0 else replus x) where x=oldprepf1(u,nil);
+++ oldprepf compiled, 11 + 20 bytes
oldprepf

symbolic procedure prepf u;
  replus1 prepf1a(u, nil);
+++ prepf redefined
+++ prepf compiled, 6 + 16 bytes
prepf

% This old version of prepf1 seems bad to me in that it keeps using
% nconc to append segments of the result. Each such call involves
% traversing the length of the result generated by an inner call to prepf1.
% In bad cases this leads to costs that grow badly as the number of variable
% increases.  

symbolic procedure oldprepf1(u,v);
   if null u then nil
   else if domainp u then list retimes(prepd u . exchk v)
   else nconc!*(oldprepf1(lc u,if mvar u eq 'k!* then v else lpow u . v),
                oldprepf1(red u,v));
+++ oldprepf1 compiled, 44 + 28 bytes
oldprepf1

% prepf1 seems only to be used in this file, and so as soon as it has been
% performed the result will be passed to replus (and through that to
% unplus). So it should make good sense to perform the replus/unplus steps
% as one goes... But I will leave a function prepf1 that behaves exactly as
% per the original just in case anybody wants it and make my composite
% of pref1 and replus a new function...

symbolic procedure prepf1(u, v);
   reversip prepf1_reversed(u, v, nil);
+++ prepf1 compiled, 9 + 12 bytes
prepf1

% This code builds up the result in reversed order. It is more explicitly
% tail-recursive in the CDR direction and avoids not just any twitching about
% side effects with nconc but potential repeated scannning of data.

symbolic procedure prepf1_reversed(u, v, r);
  begin
top:
    if null u then return r
    else if domainp u then return (retimes(prepd u . exchk v) . r);
    r := prepf1_reversed(lc u,
                         if mvar u eq 'k!* then v else lpow u . v,
                         r);
    u := red u;
    go to top
  end;
+++ prepf1_reversed compiled, 41 + 24 bytes
prepf1_reversed

% prepf1a will be like prepf1 except that it performs any "unplus"
% operations that might be useful. It is the version that will actually go
% into service. If it proves sensible over a while then the earlier code
% will be removed totally. Note that this version will do what I believe to
% be correct rather than what the previous version of the code did!

symbolic procedure prepf1a(u, v);
  reversip prepf1a_reversed(u, v, nil);
+++ prepf1a redefined
+++ prepf1a compiled, 9 + 12 bytes
prepf1a

symbolic procedure prepf1a_reversed(u, v, r);
  begin
top:
    if null u then return r
    else if domainp u then return
       begin
          scalar z;
          z := retimes(prepd u . exchk v);
% I will note that an embedded (plus P Q) or (difference P Q) can arise from
% the conversion of a domain element in the case of complex values, so without
% the top line (x + (i+1)) might end up as
%    (plus x (plus i 1)),
% while I adjust it here to be (plus x i 1). That seems reasonable.
% Similarly (x + (-1-i)) might end up as
%    (plus x (difference (minus 1) i))
% and is adjusted to (plus (minus 1) (minus i).
          if eqcar(z, 'plus) then <<
             for each y in cdr z do r := y . r >>
	  else if eqcar(z, 'difference) then <<
	     r := cadr z . r; r := {'minus,caddr z} . r >>
          else r := z . r;
          return r
       end;
    r := prepf1a_reversed(lc u,
                          if mvar u eq 'k!* then v else lpow u . v,
                          r);
    u := red u;
    go to top
  end;
+++ prepf1a_reversed redefined
+++ prepf1a_reversed compiled, 85 + 36 bytes
prepf1a_reversed

symbolic procedure prepd u;
   if atom u then if u<0 then list('minus,-u) else u
    else if apply1(get(car u,'minusp),u)
%    then list('minus,prepd1 !:minus u)
     then (if null x then 0 else list('minus,x))
          where x=prepd1 !:minus u
%   else if !:onep u then 1
    else apply1(get(car u,'prepfn),u);
+++ prepd redefined
+++ prepd compiled, 42 + 28 bytes
prepd

symbolic procedure prepd1 u;
   if atom u then u else apply1(get(car u,'prepfn),u);
+++ prepd1 redefined
+++ prepd1 compiled, 9 + 12 bytes
prepd1

% symbolic procedure exchk u;
%    begin scalar z;
%       for each j in u do
%          if cdr j=1
%            then if eqcar(car j,'expt) and caddar j = '(quotient 1 2)
%                    then z := list('sqrt,cadar j) .z
%                   else z := sqchk car j . z
%            else z := list('expt,sqchk car j,cdr j) . z;
%       return z
%   end;

symbolic procedure exchk u; exchk1(u,nil,nil,nil);
+++ exchk redefined
+++ exchk compiled, 11 + 12 bytes
exchk

symbolic procedure exchk1(u,v,w,x);
   % checks forms for kernels in EXPT. U is list of powers.  V is used
   % to build up the final answer. W is an association list of
   % previous non-constant (non foldable) EXPT's, X is an association
   % list of constant (foldable) EXPT arguments.
   if null u then exchk2(append(x,w),v)
    else if eqcar(caar u,'expt)
     then begin scalar y,z;
            y := simpexpon list('times,cdar u,caddar car u);
            if numberp cadaar u   % constant argument
              then <<z := assoc2(y,x);
                     if z then rplaca(z,car z*cadaar u)
                      else x := (cadaar u . y) . x>>
             else <<z := assoc(cadaar u,w);
                    if z then rplacd(z,addsq(y,cdr z))
                     else w := (cadaar u . y) . w>>;
            return exchk1(cdr u,v,w,x)
        end
    else if cdar u=1 then exchk1(cdr u,sqchk caar u . v,w,x)
    else exchk1(cdr u,list('expt,sqchk caar u,cdar u) . v,w,x);
+++ exchk1 redefined
+++ exchk1 compiled, 135 + 40 bytes
exchk1

symbolic procedure exchk2(u,v);
   if null u then v
    else exchk2(cdr u,
%               ((if eqcar(x,'quotient) and caddr x = 2
%                  then if cadr x = 1 then list('sqrt,caar u)
%                        else list('expt,list('sqrt,caar u),cadr x)
                ((if x=1 then caar u
                   else if !*nosqrts then list('expt,caar u,x)
                   else if x = '(quotient 1 2) then list('sqrt,caar u)
                   else if x=0.5 then list('sqrt,caar u)
                   else list('expt,caar u,x)) where x = prepsqx cdar u)
                . v);
+++ exchk2 redefined
+++ exchk2 compiled, 59 + 36 bytes
exchk2

symbolic procedure assoc2(u,v);
   % Finds key U in second position of terms of V, or returns NIL.
   if null v then nil
    else if u = cdar v then car v
    else assoc2(u,cdr v);
+++ assoc2 redefined
+++ assoc2 compiled, 14 + 8 bytes
assoc2

symbolic procedure replus u;
   if null u then 0
    else if atom u then u
    else if null cdr u then car u
    else 'plus . unplus u;
+++ replus redefined
+++ replus compiled, 20 + 20 bytes
replus

% replus1 is like replus except that it expects that the list of items
% it is given do not contain "plus" objects... except possibly one that
% is used as a sort of marker.

symbolic procedure replus1 u;
   if null u then 0
    else if atom u or (eqcar(u, 'plus) and cdr u) then u
    else if null cdr u then car u
    else 'plus . u;
+++ replus1 redefined
+++ replus1 compiled, 23 + 16 bytes
replus1

symbolic procedure unplus u;
   if atom u then u
   else if car u = 'plus then unplus cdr u
   else if atom car u or not eqcar(car u,'plus)
      then (car u) . unplus cdr u
   else append(cdar u,unplus cdr u);
+++ unplus redefined
+++ unplus compiled, 43 + 12 bytes
unplus

% symbolic procedure retimes u;
%    % U is a list of prefix expressions. Value is prefix form for the
%    % product of these;
%    begin scalar bool,x;
%       for each j in u do
%         <<if j=1 then nil     % ONEP
%             else if eqcar(j,'minus)
%              then <<bool := not bool;
%                     if cadr j neq 1 then x := cadr j . x>>     % ONEP
%             else if numberp j and minusp j
%              then <<bool := not bool;
%                    if j neq -1 then x := (-j) . x>>
%             else x := j . x>>;
%        x := if null x then 1
%                else if cdr x then 'times . reverse x else car x;
%        return if bool then list('minus,x) else x
%   end;

symbolic procedure retimes u;
   begin scalar !*bool;
      u := retimes1 u;
      u := if null u then 1
            else if cdr u then 'times . u
            else car u;
      return if !*bool then list('minus,u) else u
   end;
+++ retimes redefined
+++ retimes compiled, 33 + 32 bytes
retimes

symbolic procedure retimes1 u;
   if null u then nil
    else if car u = 1 then retimes1 cdr u
    else if minusp car u
     then <<!*bool := not !*bool; retimes1((-car u) . cdr u)>>
    else if atom car u then car u . retimes1 cdr u
    else if caar u eq 'minus
     then <<!*bool := not !*bool; retimes1(cadar u . cdr u)>>
    else if caar u eq 'times then retimes1 append(cdar u,cdr u)
    else car u . retimes1 cdr u;
+++ retimes1 redefined
+++ retimes1 compiled, 73 + 32 bytes
retimes1

symbolic procedure sqchk u;
   if atom u then u
    else (if x then apply1(x,u) else if atom car u then u else prepf u)
          where x=get(car u,'prepfn2);
+++ sqchk redefined
+++ sqchk compiled, 19 + 12 bytes
sqchk

put('!*sq,'prepfn2,'prepcadr);prepcadr

put('expt,'prepfn2,'prepexpt);prepexpt

symbolic procedure prepcadr u; prepsq cadr u;
+++ prepcadr redefined
+++ prepcadr compiled, 4 + 12 bytes
prepcadr

symbolic procedure prepexpt u; if caddr u=1 then cadr u else u;
+++ prepexpt compiled, 8 + 12 bytes
prepexpt

% When I enable this then "!*hold" is removed on the way towawards printing.
% This may generally be a good thing since it causes any necessary extra
% sets of parens to get inserted. When !*hold is removed that way there
% is then no cause to need a 'prifn on !*hold - but I leave that present
% for when anybody has gone "off prephold"... the flexibility here is
% provided because the "hold" capability is at present an experiment.

put('!*hold, 'prepfn2, 'prephold);prephold

switch prephold;nil
!*prephold := t;t

symbolic procedure prephold u;
   if (not !*prephold) or atom u then u
   else if eqcar(u, '!*hold) then prephold cadr u
   else if eqcar(u, '!*sq) then prepsq cadr u
   else prephold car u . prephold cdr u;
+++ prephold compiled, 40 + 24 bytes
prephold

endmodule;nil

end;nilmodule extout;nil % Extended output package for expressions.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*allfac !*div !*mcd !*noequiv !*pri !*rat factors!* kord!*
  !*combinelogs wtl!*);nil

global '(dnl!* ordl!* upl!*);nil

switch allfac,div,pri,rat;nil

!*allfac := t;t          % factoring option for this package
!*pri := t;t             % to activate this package

% dnl!* := nil;         % output control flag: puts powers in denom
% factors!* := nil;     % list of output factors
% ordl!* := nil;        % list of kernels introduced by ORDER statement
% upl!* := nil;         % output control flag: puts denom powers in
                        % numerator
% !*div := nil;         % division option in this package
% !*rat := nil;         % flag indicating rational mode for output.

symbolic procedure factor u;
   factor1(u,t,'factors!*);
+++ factor compiled, 6 + 20 bytes
factor

symbolic procedure factor1(u,v,w);
   begin scalar x,y,z,r;
        y := lispeval w;
        for each j in u do
          if (x := getrtype j) and (z := get(x,'factor1fn))
              then apply2(z,u,v)
            else <<while eqcar(j:=reval j,'list) and cdr j do
                     <<r:=append(r,cddr j); j:=cadr j>>;
                   x := !*a2kwoweight j;
                   if v then y := aconc!*(delete(x,y),x)
                    else if not(x member y)
                     then msgpri(nil,j,"not found",nil,nil)
                    else y := delete(x,y)>>;
        set(w,y);
        if r then return factor1(r,v,w)
   end;
+++ factor1 compiled, 106 + 44 bytes
factor1

symbolic procedure remfac u;
   factor1(u,nil,'factors!*);
+++ remfac compiled, 6 + 16 bytes
remfac

rlistat '(factor remfac);nil

symbolic procedure order u;
   <<rmsubs();   % Since order of terms in an operator argument can
                 % affect simplification.
     if u and null car u and null cdr u then (ordl!* := nil)
      else for each x in kernel!-list u do
        <<if x member ordl!* then ordl!* := delete(x,ordl!*);
          ordl!* := aconc!*(ordl!*,x)>>>>;
+++ order compiled, 41 + 24 bytes
order

rlistat '(order);nil

symbolic procedure up u;
   factor1(u,t,'upl!*);
+++ up compiled, 6 + 20 bytes
up

symbolic procedure down u;
   factor1(u,t,'dnl!*);
+++ down compiled, 6 + 20 bytes
down

% rlistat '(up down);  % Omitted since not documented.

symbolic procedure formop u;
   if domainp u then u
    else raddf(multop(lpow u,formop lc u),formop red u);
+++ formop redefined
+++ formop compiled, 34 + 16 bytes
formop

symbolic procedure multop(u,v);
   if null kord!* then multpf(u,v)
    else if car u eq 'k!* then v
    else rmultpf(u,v);
+++ multop redefined
+++ multop compiled, 19 + 28 bytes
multop

symbolic inline procedure lcx u;
   % Returns leading coefficient of a form with zero reductum, or an
   % error otherwise.
   cdr carx(u,'lcx);
+++ Record new inline definition:
(de lcx (u) (cdr (carx u (quote lcx))))
(progn (de lcx (u) (cdr (carx u (quote lcx)))) (put (quote lcx) (quote
number!-of!-args) 1) (put (quote lcx) (quote procedure_type) (quote (arrow
general general))) (putc (quote lcx) (quote inline) (quote (lambda (u) (cdr (
carx u (quote lcx)))))))
+++ lcx compiled, 6 + 12 bytes
(lambda (u) (cdr (carx u (quote lcx))))

symbolic procedure quotof(p,q);
   % P is a standard form, Q a standard form which is either a domain
   % element or has zero reductum.
   % Returns the quotient of P and Q for output purposes.
   if null p then nil
    else if p=q then 1
    else if q=1 then p
    else if domainp q then quotofd(p,q)
    else if domainp p
      % Make sure free variable degrees are accommodated.
     then (mksp(mvar q,
                if numberp x then -x else {'minus,x})
                    .* quotof(p,lcx q) .+ nil) where x = ldeg q
    else (lambda (x,y);
          if car x eq car y
              then (lambda (n,w,z);
                 if n=0 then raddf(w,z)
                  else ((car y .** n) .* w) .+ z)
              (cdr x-cdr y,quotof(lc p,lcx q),quotof(red p,q))
           else if ordop(car x,car y)
              then (x .* quotof(lc p,q)) .+ quotof(red p,q)
           else mksp(car y,- cdr y) .* quotof(p,lcx q) .+ nil)
       (lpow p,lpow q);
+++ quotof redefined
+++ quotof compiled, 148 + 48 bytes
quotof

symbolic procedure quotofd(p,q);
   % P is a form, Q a domain element. Value is quotient of P and Q
   % for output purposes.
   if null p then nil
    else if domainp p then quotodd(p,q)
    else (lpow p .* quotofd(lc p,q)) .+ quotofd(red p,q);
+++ quotofd redefined
+++ quotofd compiled, 32 + 16 bytes
quotofd

symbolic procedure quotodd(p,q);
   % P and Q are domain elements. Value is domain element for P/Q.
   if atom p and atom q then int!-equiv!-chk mkrn(p,q)
    else lowest!-terms(p,q);
+++ quotodd redefined
+++ quotodd compiled, 14 + 20 bytes
quotodd

symbolic procedure lowest!-terms(u,v);
   % Reduces compatible domain elements U and V to a ratio in lowest
   % terms.  Value as a rational may contain domain arguments rather
   % just integers.  Modified to use dcombine for field division.
   if u=v then 1
    else if flagp(dmode!*,'field) or not atom u and flagp(car u,'field)
       or not atom v and flagp(car v,'field)
%    then multdm(u,!:recip v)
     then dcombine!*(u,v,'quotient)
     else begin scalar x;
      if atom(x := dcombine!*(u,v,'gcd)) and x neq 1 then
         <<u := dcombine!*(u,x,'quotient);
           v := dcombine!*(v,x,'quotient)>>;
      return if v=1 then u else '!:rn!: . (u . v)
   end;
+++ lowest!-terms compiled, 66 + 32 bytes
lowest-terms

symbolic procedure dcombine!*(u,v,w);
   if atom u and atom v then apply2(w,u,v) else dcombine(u,v,w);
+++ dcombine!* compiled, 14 + 12 bytes
dcombine*

symbolic procedure ckrn u;
   % Factors out the leading numerical coefficient from field domains.
   if flagp(dmode!*,'field) and not(dmode!* memq '(!:rd!: !:cr!:))
     then begin scalar x;
       x := lnc u;
       x := multf(x,ckrn1 quotfd(u,x));
       if null x then x := 1;
          % NULL could be caused by floating point underflow.
       return x
      end
     else ckrn1 u;
+++ ckrn redefined
+++ ckrn compiled, 33 + 36 bytes
ckrn

symbolic procedure ckrn1 u;
   begin scalar x;
        if domainp u then return u;
    a:  x := gck2(ckrn1 cdar u,x);
        if null cdr u
          then return if noncomp mvar u then x else list(caar u . x)
         else if domainp cdr u or not(caaar u eq caaadr u)
          then return gck2(ckrn1 cdr u,x);
        u := cdr u;
        go to a
   end;
+++ ckrn1 redefined
+++ ckrn1 compiled, 50 + 16 bytes
ckrn1

symbolic procedure gck2(u,v);
   % U and V are domain elements or forms with a zero reductum.
   % Value is the gcd of U and V.
   if null v then u
    else if u=v then u
    else if domainp u
     then if domainp v then
        if flagp(dmode!*,'field)
          or pairp u and flagp(car u,'field)
          or pairp v and flagp(car v,'field) then 1
           else if dmode!* eq '!:gi!: then intgcdd(u,v) else gcddd(u,v)
        else gck2(u,cdarx v)
    else if domainp v then gck2(cdarx u,v)
    else (lambda (x,y);
        if car x eq car y
          then list((if cdr x>cdr y then y else x) .
                    gck2(cdarx u,cdarx v))
         else if ordop(car x,car y) then gck2(cdarx u,v)
         else gck2(u,cdarx v))
    (caar u,caar v);
+++ gck2 compiled, 116 + 36 bytes
gck2

symbolic procedure cdarx u;
   cdr carx(u,'cdar);
+++ cdarx redefined
+++ cdarx compiled, 5 + 16 bytes
cdarx

symbolic procedure negf!* u; negf u where !*noequiv = t;
+++ negf!* compiled, 11 + 24 bytes
negf*

symbolic procedure prepsq!* u;
   begin scalar x,y,!*combinelogs;
        if null numr u then return 0;
        % The following leads to some ugly output.
%        else if minusf numr u
%         then return list('minus,prepsq!*(negf!* numr u ./ denr u));
        x := setkorder ordl!*;
        setkorder
                  append(sort(for each j in factors!*
                     join if not idp j then nil
                           else if y := get(j,'prepsq!*fn)
                            then apply2(y,u,j)
                           else for each k in get(j,'klist)
                                     collect car k,'ordop),
                   append(sort(factors!*,'ordop),ordl!*));
        if kord!* neq x or wtl!*
          then u := formop numr u . formop denr u;
%       u := if !*rat or (not flagp(dmode!*,'field) and !*div)
        u := if !*rat or !*div
                      or upl!* or dnl!*
               then replus prepsq!*1(numr u,denr u,nil)
              else sqform(u,function prepsq!*2);
        setkorder x;
        return u
end;
+++ prepsq!* redefined
+++ prepsq!* compiled, 245 + 96 bytes
prepsq*

symbolic procedure prepsq!*0(u,v);
   % U is a standard quotient, but not necessarily in lowest terms.
   % V a list of factored powers.
   % Value is equivalent list of prefix expressions (an implicit sum).
   begin scalar x;
      return if null numr u then nil
              else if (x := gcdf(numr u,denr u)) neq 1
        then prepsq!*1(quotf!-fail(numr u,x),quotf!-fail(denr u,x),v)
       else prepsq!*1(numr u,denr u,v)
   end;
+++ prepsq!*0 redefined
+++ prepsq!*0 compiled, 27 + 24 bytes
prepsq*0

symbolic procedure prepsq!*1(u,v,w);
   % U and V are the numerator and denominator expression resp,
   % in lowest terms.
   % W is a list of powers to be factored from U.
   begin scalar x,y,z;
        % Look for "factors" in the numerator.
        if not domainp u and (mvar u member factors!* or (not
                atom mvar u and car mvar u member factors!*))
          then return nconc!*(
               if v=1 then prepsq!*0(lc u ./ v,lpow u . w)
                else (begin scalar n,v1,z1;
                % See if the same "factor" appears in denominator.
                n := ldeg u;
                v1 := v;
                z1 := !*k2f mvar u;
                while (z := quotfm(v1,z1)) do <<v1 := z; n := n-1>>;
                return
                  prepsq!*0(lc u ./ v1,
                            if n>0 then (mvar u .** n) . w
                             else if n<0
                              then mksp(list('expt,mvar u,n),1) . w
                             else w)
                   end),
                        prepsq!*0(red u ./ v,w));
        % Now see if there are any remaining "factors" in denominator.
        % (KORD!* contains all potential kernel factors.)
        if not domainp v
         then for each j in kord!* do
           begin integer n; scalar z1;
                n := 0;
                z1 := !*k2f j;
                while z := quotfm(v,z1) do <<n := n-1; v := z>>;
                if n<0 then w := mksp(list('expt,j,n),1) . w
           end;
        % Now all "factors" have been removed.
        if kernlp u then <<u := mkkl(w,u); w := nil>>;
        if dnl!*
          then <<x := if null !*allfac then 1 else ckrn u;
                 z := ckrn!*(x,dnl!*);
                 x := quotof(x,z);
                 u := quotof(u,z);
                 v := quotof(v,z)>>;
        if upl!*
          then <<y := ckrn v;
                 z := ckrn!*(y,upl!*);
                 y := quotof(y,z);
                 u := quotof(u,z);
                 v := quotof(v,z)>>
         else if !*div then y := ckrn v
         else y := 1;
        u := canonsq (u . quotof(v,y));
%       if !*gcd then u := cancel u;
        u := quotof(numr u,y) ./ denr u;
        if !*allfac
          then <<x := ckrn numr u; y := ckrn denr u;
                 if (x neq 1 or y neq 1)
                    and (x neq numr u or y neq denr u)
                  then <<v := quotof(denr u,y);
                         u := quotof(numr u,x);
                         w := prepf mkkl(w,x);
                         x := prepf y;
                         u := addfactors(w,u);
                         v := addfactors(x,v);
                         return if v=1 then rmplus u
                                 else list if eqcar(u,'minus)
                                             then list('minus,
                                               list('quotient,cadr u,v))
                                           else list('quotient,u,v)>>>>;
        return if w then list retimes aconc!*(exchk w,prepsq u)
         else rmplus prepsq u
   end;
+++ prepsq!*1 redefined
+++ prepsq!*1 compiled, 391 + 124 bytes
prepsq*1

symbolic procedure addfactors(u,v);
   % U is a (possible) product of factors, v a standard form.
   % Result is a folded prefix expression.
   if u = 1 then prepf v
    else if v = 1 then u
    else if eqcar(u,'times) then 'times . aconc!*(cdr u,prepf v)
    else retimes list(u,prepf v);
+++ addfactors redefined
+++ addfactors compiled, 40 + 28 bytes
addfactors

symbolic procedure rmplus u; if eqcar(u,'plus) then cdr u else list u;
+++ rmplus redefined
+++ rmplus compiled, 9 + 12 bytes
rmplus

symbolic procedure prepsq!*2 u; replus prepsq!*1(u,1,nil);
+++ prepsq!*2 redefined
+++ prepsq!*2 compiled, 9 + 20 bytes
prepsq*2

symbolic procedure ckrn!*(u,v);
   if null u then errach 'ckrn!*
    else if domainp u then 1
    else if caaar u member v
       then list (caar u . ckrn!*(cdr carx(u,'ckrn),v))
    else ckrn!*(cdr carx(u,'ckrn),v);
+++ ckrn!* compiled, 39 + 24 bytes
ckrn*

symbolic procedure mkkl(u,v);
   if null u then v else mkkl(cdr u,list (car u . v));
+++ mkkl redefined
+++ mkkl compiled, 15 + 8 bytes
mkkl

symbolic procedure quotfm(u,v);
   begin scalar !*mcd; !*mcd := t; return quotf(u,v) end;
+++ quotfm redefined
+++ quotfm compiled, 12 + 24 bytes
quotfm

endmodule;nil

end;nilmodule depend;nil % Defining and checking expression dependency.

% Author: Anthony C. Hearn.
% Modifications by: Francis J. Wright <F.J.Wright@qmw.ac.uk>.

% Copyright (c) 1996 The RAND Corporation. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(alglist!* depl!* frlis!*);nil

% DEPL* is a list of dependencies among kernels.

symbolic procedure depend u;
   depend0(u,t);
+++ depend compiled, 4 + 16 bytes
depend

symbolic procedure nodepend u;
   <<rmsubs(); depend0(u,nil)>>;
+++ nodepend compiled, 7 + 16 bytes
nodepend

rlistat '(depend nodepend);nil

%symbolic procedure depend0(u,bool);
%   % We need to include both <id> and <id>_ in the list to provide for
%   % ROOT_OF expressions.
%   <<for each x in cdr u do depend1(car u,x,bool);
%     if idp car u
%       then (for each x in cdr u do depend1(y,x,bool))
%             where y=intern compress append(explode car u,'(!! !_))>>;

symbolic procedure depend1(u,v,bool);
   begin scalar y,z;
      u := !*a2k u;
      v := !*a2k v;
      if u eq v then return nil;
      y := assoc(u,depl!*);
%     if y then if bool then rplacd(y,union(list v,cdr y))
%                else if (z := delete(v,cdr y)) then rplacd(y,z)
      if y then if bool
                 then depl!*:= repasc(car y,union(list v,cdr y),depl!*)
                 else if (z := delete(v,cdr y))
                  then depl!* := repasc(car y,z,depl!*)
                 else depl!* := delete(y,depl!*)
       else if null bool
         then lprim list(u,"has no prior dependence on",v)
       else depl!* := list(u,v) . depl!*
   end;
+++ depend1 redefined
+++ depend1 compiled, 73 + 32 bytes
depend1

symbolic procedure depends(u,v);
   if null u or numberp u or numberp v then nil
    else if u=v then u
    else if atom u and u memq frlis!* then t
      %to allow the most general pattern matching to occur;
    else if (lambda x; x and ldepends(cdr x,v)) assoc(u,depl!*)
     then t
    else if not atom u and idp car u and get(car u,'dname) then
        (if depends!-fn then apply2(depends!-fn,u,v) else nil)
           where (depends!-fn = get(car u,'domain!-depends!-fn))
    else if not atom u
      and (ldepends(cdr u,v) or depends(car u,v)) then t
    else if atom v or idp car v and get(car v,'dname) then nil
    % else dependsl(u,cdr v);
    else nil;
+++ depends redefined
+++ depends compiled, 96 + 32 bytes
depends

symbolic procedure ldepends(u,v);
   % Allow for the possibility that U is an atom.
   if null u then nil
    else if atom u then depends(u,v)
    else depends(car u,v) or ldepends(cdr u,v);
+++ ldepends redefined
+++ ldepends compiled, 18 + 12 bytes
ldepends

symbolic procedure dependsl(u,v);
   v and (depends(u,car v) or dependsl(u,cdr v));
+++ dependsl compiled, 13 + 12 bytes
dependsl

symbolic procedure freeof(u,v);
   not(smember(v,u) or v member assoc(u,depl!*));
+++ freeof redefined
+++ freeof compiled, 16 + 20 bytes
freeof

symbolic operator freeof;nil

flag('(freeof),'boolean);nil

% infix freeof;

% precedence freeof,lessp;   %put it above all boolean operators;

% This following code, by Francis J. Wright, enhances the depend and
% nodepend commands.  If the first argument is an (algebraic) LIST
% then change the dependency for each element of it, i.e.

%   (no)depend {y1, y2, ...}, x1, x2, ...  maps to
%   (no)depend y1, x1, x2, ...;  (no)depend y2, x1, x2, ...; ...

% Also allow a sequence of such dependence sequences, where the
% beginning of each new sequence is indicated by a LIST of one or more
% dependent variables.

symbolic procedure depend0(u, bool);
   % u = y,x1,x2,..., {yy1,yy2,...},xx1,xx2,...,  OR
   % u = {y1,y2,...},x1,x2,..., {yy1,yy2,...},xx1,xx2,...,
 <<alglist!* := nil . nil;  % We need to clear cache.
   while u do
      begin scalar v;
         % Make v point to the next dependent variable list or nil.
         v := cdr u;
         while v and not rlistp car v do v := cdr v;
         for each y in (if rlistp car u then cdar u else {car u}) do
            begin scalar x;
               x := u;
               while not((x := cdr x) eq v) do depend1(y,car x,bool);
               if idp y
                 then <<y := bytelist2id append(id2bytelist y, id2bytelist '!_);
                        x := u;
                        while not((x := cdr x) eq v) do
                           depend1(y,car x,bool)>>
            end;
         u := v
      end>>;
+++ depend0 compiled, 99 + 36 bytes
depend0

endmodule;nil

end;nilmodule str;nil  % Routines for structuring expressions.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 The RAND Corporation. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*fort !*nat !*savestructr scountr svar svarlis);nil

global '(varnam!*);nil

varnam!* := 'ans;ans

switch savestructr;nil

flag('(structr),'intfn);nil        % To fool the supervisor into printing
                                % results of STRUCTR.

% ***** two essential uses of RPLACD occur in this module.

symbolic procedure structr u;
   begin scalar scountr,fvar,svar,svarlis;
      % SVARLIS is a list of elements of form:
      % (<unreplaced expression> . <newvar> . <replaced exp>);
      scountr :=0;
      fvar := svar := varnam!*;
      if cdr u
        then <<fvar := svar := cadr u; if cddr u then fvar := caddr u>>;
      u := structr1 aeval car u;
      if !*fort then svarlis := reversip!* svarlis
       else if not !*savestructr
        then <<assgnpri(u,nil,'only);
               if not eqcar(u,'mat) then terpri(); % MAT already has eol
               if scountr=0 then return nil
                else <<if null !*nat then terpri();
                       prin2t "   where">>>>;
      if !*fort or not !*savestructr
        then for each x in svarlis do
             <<terpri!* t;
               if null !*fort then prin2!* "      ";
               assgnpri(cddr x,list cadr x,t)>>;
      if !*fort then assgnpri(u,list fvar,t)
       else if !*savestructr
        then return 'list . u .
                        foreach x in svarlis
                           collect list('equal,cadr x,
                                               mkquote cddr x)
   end;
+++ structr compiled, 209 + 104 bytes
structr

rlistat '(structr);nil

symbolic procedure structr1 u;
   % This routine considers special case STRUCTR arguments. It could be
   % easily generalized.
   if atom u then u
    else if car u eq 'mat
     then car u .
        (for each j in cdr u collect for each k in j collect structr1 k)
    else if car u eq 'list
     then 'list . for each j in cdr u collect structr1 j
    else if car u eq 'equal then list('equal,cadr u,structr1 caddr u)
    else if car u eq '!*sq
     then mk!*sq(structf numr cadr u ./ structf denr cadr u)
    else if getrtype u then typerr(u,"STRUCTR argument")
    else u;
+++ structr1 compiled, 216 + 44 bytes
structr1

symbolic procedure structf u;
   if null u then nil
    else if domainp u then u
    else begin scalar x,y;
        x := mvar u;
        if sfp x then if y := assoc(x,svarlis) then x := cadr y
                else x := structk(prepsq!*(structf x ./ 1),
                                  structvar(),x)
%        else if not atom x and not atomlis cdr x
          else if not atom x
             and not(atom car x and flagp(car x,'noreplace))
          then if y := assoc(x,svarlis) then x := cadr y
                else x := structk(x,structvar(),x);
% Suggested patch by Rainer Schoepf to cache powers.
%       if ldeg u = 1
%         then return x .** ldeg u .* structf lc u .+ structf red u;
%       z := retimes exchk list (x .** ldeg u);
%       if y := assoc(z,svarlis) then x := cadr y
%        else x := structk(z, structvar(), z);
%       return x .** 1 .* mystructf lc u .+ mystructf red u
        return x .** ldeg u .* structf lc u .+ structf red u
     end;
+++ structf compiled, 86 + 40 bytes
structf

symbolic procedure structk(u,id,v);
   begin scalar x;
      if x := subchk1(u,svarlis,id)
        then rplacd(x,(v . id . u) . cdr x)
       else if x := subchk2(u,svarlis)
        then svarlis := (v . id . x) . svarlis
       else svarlis := (v . id . u) . svarlis;
      return id
   end;
+++ structk compiled, 47 + 20 bytes
structk

symbolic procedure subchk1(u,v,id);
   begin scalar w;
      while v do
       <<smember(u,cddar v)
            and <<w := v; rplacd(cdar v,subst(id,u,cddar v))>>;
         v := cdr v>>;
      return w
   end;
+++ subchk1 compiled, 29 + 12 bytes
subchk1

symbolic procedure subchk2(u,v);
   begin scalar bool;
      for each x in v do
       smember(cddr x,u)
          and <<bool := t; u := subst(cadr x,cddr x,u)>>;
      if bool then return u else return nil
   end;
+++ subchk2 compiled, 35 + 16 bytes
subchk2

symbolic procedure structvar;
   begin
      scountr := scountr + 1;
      return if arrayp svar then list(svar,scountr)
       else intern compress append(explode svar,explode scountr)
   end;
+++ structvar compiled, 26 + 20 bytes
structvar

endmodule;nil

end;nilmodule coeff;nil  % Routines for finding coefficients of forms.

% Author: Anthony C. Hearn.

% Modifications by: F. Kako (including introduction of COEFFN).

% Copyright (c) 1991 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*ratarg);nil

global '(hipow!* lowpow!*);nil

switch ratarg;nil

flag ('(hipow!* lowpow!*),'share);nil

symbolic procedure coeffeval u;
   begin integer n;
      n := length u;
      if n<2 or n>3
        then rerror(alg,28,
                    "COEFF called with wrong number of arguments")
       else return coeff1(car u,cadr u,
                         if null cddr u then nil else caddr u)
      end;
+++ coeffeval compiled, 40 + 40 bytes
coeffeval

put('coeff,'psopfn,'coeffeval);coeffeval

symbolic procedure coeff1(u,v,w);
   % Finds the coefficients of V in U and returns results in W.
   % We turn EXP on and FACTOR off to make sure powers of V separate.
   (begin scalar !*factor,bool,x,y,z;
        if eqcar(u,'!*sq) and null !*exp
          then <<!*exp := t; u := resimp cadr u>>
         else <<!*exp := t; u := simp!* u>>;
        v := !*a2kwoweight v;
        bool := !*ratarg or freeof(prepf denr u,v);
        if null bool then u := !*q2f u;
        x := updkorder v;
        if null bool then <<y := reorder u; u := 1>>
         else <<y := reorder numr u; u := denr u>>;
        setkorder x;
        if null y then go to a;
        while not domainp y and mvar y=v
           do <<z := (ldeg y . !*ff2a(lc y,u)) . z; y := red y>>;
        if null y then go to b;
    a:  z := (0 . !*ff2a(y,u)) . z;
    b:  lowpow!* := caar z;
        z := reverse z;
        hipow!* := caar z;
        z := multiple!-result(z,w);
        return if null w then z else hipow!*
   end) where !*exp = !*exp;
+++ coeff1 compiled, 184 + 100 bytes
coeff1

symbolic procedure coeffn(u,v,n);
   % Returns n-th coefficient of U.
   % We turn EXP on and FACTOR off to make sure powers of V separate.
   begin scalar !*exp,!*factor,bool,x,y;
      !*exp := t;
      n := reval n;
      if not fixp n or minusp n then typerr(n,"COEFFN index");
      v := !*a2kwoweight v;
      u := simp!* u;
      bool := !*ratarg or freeof(prepf denr u,v);
      if null bool then u := !*q2f u;
      x := updkorder v;
      if null bool then <<y := reorder u; u := 1>>
       else <<y := reorder numr u; u := denr u>>;
      setkorder x;
      if null y then return 0; % changed by JHD for consistency
   b: if domainp y or mvar y neq v
        then return if n=0 then !*ff2a(y,u) else 0
       else if n=ldeg y then return !*ff2a(lc y,u)
       else if n>ldeg y then return 0
       else <<y := red y; go to b>>
   end;
+++ coeffn compiled, 141 + 84 bytes
coeffn

flag('(coeffn),'opfn);nil

flag('(coeffn),'noval);nil

endmodule;nil

end;nilmodule weight;nil % Asymptotic command package.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 RAND.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% Modified by F.J. Wright@Maths.QMW.ac.uk, 18 May 1994,
% mainly to return the previous settings rather than nothing.

fluid '(asymplis!* wtl!*);nil

flag('(k!*),'reserved);nil

% Asymptotic list and weighted variable association lists.

symbolic procedure weight u;
   % Returns previous weight list for the argument variables, omitting
   % any unweighted variables.  Returns the current weight without
   % resetting it for any argument that is a variable rather than a
   % weight equation, and with no arguments returns all current
   % variable weights.
   makelist if null car u then
      for each x in wtl!* collect {'equal, car x, cdr x}
   else <<
      % Make sure asymplis!* is initialized.
      if null atsoc('k!*,asymplis!*)
         then asymplis!* := '(k!* . 2) . asymplis!*;
      rmsubs();
      % Build the output list while processing the input:
      for each x in u join
      begin scalar y,z;
         if eqexpr x then <<
            z := reval caddr x;
            if not fixp z or z<=0 then typerr(z,"weight");
            x := cadr x >>;
         y := !*a2kwoweight x;
         x := if (x := atsoc(y,wtl!*)) then {{'equal, car x, cdr x}};
         if z then wtl!* :=  (y . z) . delasc(y,wtl!*);
         return x
      end
   >>;
+++ weight compiled, 232 + 68 bytes
weight


symbolic procedure wtlevel n;
   begin scalar oldn;
      % Returns previous wtlevel; with no arg returns current wtlevel
      % without resetting it.
      oldn := (if x then cdr x - 1 else 1)
              where x = atsoc('k!*,asymplis!*);
      if car n then <<
         n := reval car n;
         if not fixp n or n<0 then typerr(n,"weight level");
         if n<oldn then rmsubs();
         if n neq oldn
           then asymplis!*:= ('k!* . (n+1)) . delasc('k!*,asymplis!*)>>;
      return oldn
   end;
+++ wtlevel compiled, 57 + 40 bytes
wtlevel

rlistat '(weight wtlevel);nil
% but preserve current mode as mode of result:
flag('(weight wtlevel), 'nochange);nil

% algebraic let k!***2=0;

endmodule;nil

end;nilmodule linop;nil % Linear operator package.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*intstr);nil

symbolic procedure linear u;
   <<
	  for each x in u do
      	 if not idp x then typerr(x,'operator) else flag(list x,'linear);
   	  rmsubs()
   >>;
+++ linear compiled, 32 + 24 bytes
linear

rlistat '(linear);nil

symbolic procedure formlnr u;
   begin scalar x,y,z;
      x := car u;
      if null cdr u or null cddr u
        then rerror(alg,29,list("Linear operator",
                                x,"called with too few arguments"));
      y := cadr u;
      z := !*a2k caddr u . cdddr u;
      return if y = 1 then u
       else if not depends(y,car z)
        then list('times,y,x . 1 . z)
       else if atom y then u
       else if car y eq 'plus
        then 'plus . for each j in cdr y collect formlnr(x . j. z)
       else if car y eq 'minus
        then list('minus,formlnr(x . cadr y . z))
       else if car y eq 'difference
        then list('difference,formlnr(x . cadr y . z),
                              formlnr(x . caddr y . z))
       else if car y eq 'times then formlntms(x,cdr y,z,u)
       else if car y eq 'quotient then formlnquot(x,cdr y,z,u)
       else if car y eq 'recip
        then formlnrecip(x,carx(cdr y,'recip),z,u)
       else if y := expt!-separate(y,car z)
        then list('times,car y,x . cdr y . z)
       else u
   end;
+++ formlnr compiled, 235 + 84 bytes
formlnr

symbolic procedure formseparate(u,v);
   %separates U into two parts, and returns a dotted pair of them: those
   %which are not commutative and do not depend on V, and the remainder;
   begin scalar w,x,y;
      for each z in u do
        if not noncomp z and not depends(z,v) then x := z . x
         else if (w := expt!-separate(z,v))
        then <<x := car w . x; y := cdr w . y>>
         else y := z . y;
      return reversip!* x . reversip!* y
   end;
+++ formseparate compiled, 58 + 24 bytes
formseparate

symbolic procedure expt!-separate(u,v);
   %determines if U is an expression in EXPT that can be separated into
   %two parts, one that does not depend on V and one that does,
   %except if there is no non-dependent part, NIL is returned;
   if not eqcar(u,'expt) or depends(cadr u,v)
           or not eqcar(caddr u,'plus)
     then nil
    else expt!-separate1(cdaddr u,cadr u,v);
+++ expt!-separate compiled, 28 + 24 bytes
expt-separate

symbolic procedure expt!-separate1(u,v,w);
   begin scalar x;
      x := formseparate(u,w);
      return if null car x then nil
              else list('expt,v,replus car x) .
                   if null cdr x then 1 else list('expt,v,replus cdr x)
   end;
+++ expt!-separate1 compiled, 38 + 24 bytes
expt-separate1

symbolic procedure formlntms(u,v,w,x);
   %U is a linear operator, V its first argument with TIMES removed,
   %W the rest of the arguments and X the whole expression.
   %Value is the transformed expression;
   begin scalar y;
      y := formseparate(v,car w);
      return if null car y then x
              else 'times . aconc!*(car y,
                if null cddr y then formlnr(u . cadr y . w)
                      else u . ('times . cdr y) . w)
   end;
+++ formlntms compiled, 41 + 24 bytes
formlntms

symbolic procedure formlnquot(fn,quotargs,rest,whole);
   %FN is a linear operator, QUOTARGS its first argument with QUOTIENT
   %removed, REST the remaining arguments, WHOLE the whole expression.
   %Value is the transformed expression;
   begin scalar x;
      return if not depends(cadr quotargs,car rest)
         then list('quotient,formlnr(fn . car quotargs . rest),
                   cadr quotargs)
        else if not depends(car quotargs,car rest)
               and car quotargs neq 1
         then list('times,car quotargs,
                   formlnr(fn . list('recip,cadr quotargs) . rest))
        else if eqcar(car quotargs,'plus)
         then 'plus . for each j in cdar quotargs
                collect formlnr(fn . ('quotient . j . cdr quotargs)
                                 . rest)
        else if eqcar(car quotargs,'minus)
         then list('minus,formlnr(fn .
                        ('quotient . cadar quotargs . cdr quotargs)
                            . rest))
        else if eqcar(car quotargs,'times)
                and car(x := formseparate(cdar quotargs,car rest))
         then 'times . aconc!*(car x,
                formlnr(fn . list('quotient,mktimes cdr x,
                             cadr quotargs) . rest))
        else if eqcar(cadr quotargs,'times)
                and car(x := formseparate(cdadr quotargs,car rest))
         then list('times,list('recip,mktimes car x),
                formlnr(fn . list('quotient,car quotargs,mktimes cdr x)
                         . rest))
        else if x := expt!-separate(car quotargs,car rest)
         then list('times,car x,formlnr(fn . list('quotient,cdr x,cadr
                                                     quotargs) . rest))
        else if x := expt!-separate(cadr quotargs,car rest)
         then list('times,list('recip,car x),
                   formlnr(fn . list('quotient,car quotargs,cdr x)
                              . rest))
        else if (x := reval!* cadr quotargs) neq cadr quotargs
         then formlnquot(fn,list(car quotargs,x),rest,whole)
        else whole
   end;
+++ formlnquot compiled, 291 + 60 bytes
formlnquot

symbolic procedure formlnrecip(fn,reciparg,rest,whole);
   % FN is a linear operator, RECIPARG the RECIP argument, REST the
   % remaining arguments, WHOLE the whole expression.  Value is the
   % transformed expression.
   begin scalar x;
      return if not depends(reciparg,car rest)
         then list('quotient,fn . 1 . rest,reciparg)
        else if eqcar(reciparg,'minus)
         then list('minus,formlnr(fn . ('recip . cdr reciparg) . rest))
        else if eqcar(reciparg,'times)
                and car(x := formseparate(cdr reciparg,car rest))
         then list('times,list('recip,mktimes car x),
                formlnr(fn . list('recip,mktimes cdr x)
                         . rest))
        else if x := expt!-separate(reciparg,car rest)
         then list('times,list('recip,car x),
                   formlnr(fn . list('recip,cdr x)
                              . rest))
        else if (x := reval!* reciparg) neq reciparg
         then formlnrecip(fn,x,rest,whole)
        else whole
   end;
+++ formlnrecip compiled, 119 + 52 bytes
formlnrecip

symbolic procedure mktimes u;
   if null cdr u then car u else 'times . u;
+++ mktimes compiled, 9 + 12 bytes
mktimes

symbolic procedure reval!* u;
   %like REVAL, except INTSTR is always ON;
   begin scalar !*intstr;
      !*intstr := t;
      return reval u
   end;
+++ reval!* compiled, 11 + 24 bytes
reval*

endmodule;nil

end;nilmodule elem;nil % Simplification rules for elementary functions.

% Author: Anthony C. Hearn.
% Modifications by:  Herbert Melenk, Rainer Schoepf and others.

% Copyright (c) 1993 The RAND Corporation. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*!*sqrt !*complex !*keepsqrts !*precise !*precise_complex
        !*rounded dmode!* !*elem!-inherit);nil

% No references to RPLAC-based functions in this module.

% For a proper bootstrapping the following order of operator
% declarations is essential:

%    sqrt
%    sign with reference to sqrt
%    trigonometrical functions using abs which uses sign

algebraic;nil

% Square roots.

deflist('((sqrt outer!-simpsqrt)),'simpfn);(sqrt)

% for all x let sqrt x**2=x;

% !*!*sqrt:  used to indicate that SQRTs have been used.

% !*keepsqrts:  causes SQRT rather than EXPT to be used.

symbolic procedure mksqrt u;
   if not !*keepsqrts then list('expt,u,list('quotient,1,2))
    else <<if null !*!*sqrt then <<!*!*sqrt := t;
                              algebraic for all x let sqrt x**2=x>>;
      list('sqrt,u)>>;
+++ mksqrt redefined
+++ mksqrt compiled, 36 + 56 bytes
mksqrt

for all x let df(sqrt x,x)=sqrt x/(2*x);nil


% SIGN operator.

symbolic procedure sign!-of u;
  % Returns -1,0 or 1 if the sign of u is known. Otherwise nil.
   (numberp s and s) where s = numr simp!-sign{u};
+++ sign!-of redefined
+++ sign!-of compiled, 11 + 12 bytes
sign-of

symbolic procedure simp!-sign1 u;
 begin scalar s,n;
   s:=if atom u then
      << if !*modular then simpiden {'sign,u}
          else if numberp u then
                  (if u > 0 then 1 else if u < 0 then -1 else nil) ./ 1
          else simp!-sign2 u >>
       else if car u eq '!:rd!: then
 	  (if rd!:zerop u then nil else if rd!:minusp u then -1 else 1) ./ 1
%       This may be wrong in general, eg. sign(abs(y)) would always return 1, even if y is later set to 0.
%       else if car u eq 'abs then 1 ./ 1 
       else if car u eq 'minus then negsq simp!-sign1 cadr u
       else if car u eq 'times then simp!-sign!-times u
       else if car u eq 'quotient then simp!-sign!-quot u
       else if car u eq 'plus then simp!-sign!-plus u
       else if car u eq 'expt then simp!-sign!-expt u
       else if car u eq 'sqrt then simp!-sign!-sqrt u
       else simp!-sign2 u;
   n:=numr s;
   if not numberp n or n=1 or n=-1 or n=0 then return s;
   typerr(n,"sign value");
 end;
+++ simp!-sign1 compiled, 150 + 104 bytes
simp-sign1

symbolic procedure simp!-sign2 u;
   % fallback to standard rules: 1. try numeric evaluation, 2. call simpiden
   (if x then x ./ 1 else simpiden{'sign,u}) where x := rd!-sign u;
+++ simp!-sign2 redefined
+++ simp!-sign2 compiled, 14 + 24 bytes
simp-sign2

symbolic procedure simp!-sign u;
   simp!-sign1 reval car u;
+++ simp!-sign redefined
+++ simp!-sign compiled, 5 + 16 bytes
simp-sign

symbolic inline procedure sq!-is!-sign u;
   % Returns t is s.q. u is either 1, -1, or 0
   denr u = 1 and (nu=1 or nu=-1 or nu=0) where nu=numr u;
+++ Record new inline definition:
(de sq!-is!-sign (u) ((lambda (nu) (and (equal (cdr u) 1) (or (equal nu 1) (
equal nu (minus 1)) (equal nu 0)))) (car u)))
(progn (de sq!-is!-sign (u) ((lambda (nu) (and (equal (cdr u) 1) (or (equal nu 1
) (equal nu (minus 1)) (equal nu 0)))) (car u))) (put (quote sq!-is!-sign) (
quote number!-of!-args) 1) (put (quote sq!-is!-sign) (quote procedure_type) (
quote (arrow general general))) (putc (quote sq!-is!-sign) (quote inline) (quote
(lambda (u) ((lambda (nu) (and (equal (cdr u) 1) (or (equal nu 1) (equal nu (
minus 1)) (equal nu 0)))) (car u))))))
+++ sq!-is!-sign compiled, 23 + 24 bytes
(lambda (u) ((lambda (nu) (and (equal (cdr u) 1) (or (equal nu 1) (equal nu (
minus 1)) (equal nu 0)))) (car u)))
   
symbolic procedure simp!-sign!-times w;
 % Factor all known signs out of the product.
  begin scalar n,s,x;
   n:=1;
   for each f in cdr w do
   << x:=simp!-sign1 f;
      % Make sure that only values 1,-1, and 0 are used here, everything else is left in place
      if sq!-is!-sign x then n:=n * numr x else s:=f.s>>;
   s:=if null s then '(1 . 1)
       else simp!-sign2(if cdr s then 'times.reversip s else car s);
   return multsq (n ./ 1,s)
  end;
+++ simp!-sign!-times compiled, 87 + 44 bytes
simp-sign-times

symbolic procedure simp!-sign!-quot w;
 % Factor known signs out of the quotient.
  begin scalar x,y,flg,z;
     if eqcar(cadr w,'minus) then << flg:=t;  w := {car w,cadr cadr w, caddr w} >>;
     x := simp!-sign1 cadr w;		% numerator
     y := simp!-sign1 caddr w;		% denominator
     if sq!-is!-sign x or sq!-is!-sign y then z := quotsq (x,y)
      else z := simp!-sign2 w;
     return if flg then negsq z else z
  end;
+++ simp!-sign!-quot compiled, 101 + 44 bytes
simp-sign-quot

symbolic procedure simp!-sign!-plus w;
 % Stop sign evaluation as soon as two different signs
 % or one unknown sign were found.
  begin scalar n,m,x,q;
   for each f in cdr w do if null q then
   <<x:=simp!-sign1 f;
     m:=if sq!-is!-sign x then numr x;
     if null m or n and m neq n then q:=t;
     n:=m>>;
   return if null q then n ./ 1 else simp!-sign2 w;
  end;
+++ simp!-sign!-plus compiled, 78 + 32 bytes
simp-sign-plus

symbolic procedure simp!-sign!-expt w;
  (if fixp ex and evenp ex and not(!*complex or !*precise_complex) then (1 ./ 1)
    else (
     if fixp ex and sq!-is!-sign sb
       then (if not evenp ex and numr sb < 0 then -1 else 1) ./ 1
      else if fixp ex and not(!*complex or !*precise_complex) then sb
      else if ex = '(quotient 1 2) and sb = (1 ./ 1) then 1 ./ 1
      else if sb = (1 ./ 1) and realvaluedp ex then (1 ./ 1)
      else simp!-sign2 w
         ) where sb := simp!-sign1 cadr w
  ) where ex := caddr w;
+++ simp!-sign!-expt compiled, 119 + 48 bytes
simp-sign-expt

symbolic procedure simp!-sign!-sqrt w;
   (if u = (1 ./ 1) then u else simp!-sign2 w)
      where u := simp!-sign!-expt {'expt,cadr w,'(quotient 1 2)};
+++ simp!-sign!-sqrt compiled, 20 + 28 bytes
simp-sign-sqrt

fluid '(rd!-sign!*);nil

symbolic procedure rd!-sign u;
  % if U is constant evaluable return sign of u.
  % the value is set aside.
  if pairp rd!-sign!* and u=car rd!-sign!* then cdr rd!-sign!*
    else
  if !*complex or !*rounded or not constant_exprp u then nil
    else
  (begin scalar x,y,dmode!*;
    setdmode('rounded,t);
    x := aeval u;
    if evalnumberp x and 0=reval {'impart,x}
    then y := if evalgreaterp(x,0) then 1 else
         if evalequal(x,0) then 0 else -1;
    setdmode('rounded,nil);
    rd!-sign!*:=(u.y);
    return y
  end) where alglist!*=alglist!*;
+++ rd!-sign compiled, 94 + 88 bytes
rd-sign

symbolic operator rd!-sign;nil

operator sign;nil

put('sign,'simpfn,'simp!-sign);simp-sign

% The rules for products and sums are covered by the routines
% below in order to avoid a combinatoric explosion. Abs (sign ~x)
% cannot be defined by a rule because the evaluation of abs needs
% sign.

sign_rules :=
   {
%%   sign ~x => (if x>0 then 1 else if x<0 then -1 else 0)
%%      when numberp x and impart x=0,
%%   sign(e) => 1,
%%   sign(pi) => 1,
%%   sign(-~x) => -sign(x),
%%   sign( ~x * ~y) =>  sign x * sign y
%%         when numberp sign x or numberp sign y,
%%   sign( ~x / ~y) =>  sign x * sign y
%%         when y neq 1 and (numberp sign x or numberp sign y),
%%   sign( ~x + ~y) =>  sign x when sign x = sign y,
%%   sign( ~x ^ ~n) => 1 when fixp (n/2) and 
%%                            lisp(not (!*complex or !*precise_complex)),
%%   sign( ~x ^ ~n) => sign x^n when fixp n and numberp sign x,
%%   sign( ~x ^ ~n) => sign x when fixp n and 
%%                                 lisp(not (!*complex or !*precise_complex)),
%%   sign(sqrt ~a)  => 1 when sign a=1,
     sign(sinh ~x)  => sign(x) when numberp sign(x) or realvaluedp x,
     sign(cosh ~x)  => 1 when realvaluedp x,
     sign(tanh ~x)  => sign(x) when numberp sign(x) or realvaluedp x,
%%   sign( ~a ^ ~x) => 1 when sign a=1 and realvaluedp x,
%%   sign(abs ~a)   => 1,
%%   sign ~a => rd!-sign a when rd!-sign a,
     % Next rule here for convenience.
     abs(~x)^2 => x^2 when symbolic not !*precise or realvaluedp x
   }$(list (replaceby (sign (sinh (~ x))) (when (sign x) (or (numberp (sign x))
(realvaluedp x)))) (replaceby (sign (cosh (~ x))) (when 1 (realvaluedp x))) (
replaceby (sign (tanh (~ x))) (when (sign x) (or (numberp (sign x)) (realvaluedp
x)))) (replaceby (expt (abs (~ x)) 2) (when (expt x 2) (or (symbolic (not
*precise)) (realvaluedp x)))))
     % $ above needed for bootstrap.

let sign_rules;
*** tanh declared operator 

*** cosh declared operator 

*** sinh declared operator 
nil

% Rule for I**2.

remflag('(i),'reserved);nil

let i**2= -1;nil

flag('(e i nil pi),'reserved);nil   % Leave out T for now.

% Some more reserved ids (for realroot)

flag('(positive negative infinity),'reserved);nil

% Logarithms.

%%let log(e)= 1,
%%    log(1)= 0,
%%    log10(10) = 1,
%%    log10(1) = 0;
%%
%%for all x let logb(1,x) = 0,
%%              logb(x,x) = 1,
%%              logb(x,e) = log(x),
%%              logb(x,10) = log10(x);
%%
%%for all x let log(e**x)=x; % e**log x=x now done by simpexpt.
%%
%%for all x let logb(a**x,a)=x;
%%
%%for all x let log10(10**x)=x;

for all x let 10^log10(x)=x;nil

%% Remove these rules as they return wrong results in complex mode
%% and are superceded by the code in poly/compopr.red
%let impart(log(~a)) => 0 when numberp a and a>0;
%let repart(log(~a)) => log(a) when numberp a and a>0;

%% The following rule interferes with HE vector simplification,
%% until the problem is resolved use a more complicated rule
%for all a,x let a^logb(x,a)=x;
for all a,b,x such that a=b let a^logb(x,b)=x;nil


% The next rule is implemented via combine/expand logs.

% for all x,y let log(x*y) = log x + log y, log(x/y) = log x - log y;

let df(log(~x),~x) => 1/x;nil

let df(log(~x/~y),~z) => df(log x,z) - df(log y,z);nil

let df(log10(~x),~x) => 1/(x*log(10));nil

let df(logb(~x,~a),~x) => 1/(x*log(a)) - logb(x,a)/(a*log(a))*df(a,x);nil

% Trigonometrical functions.

deflist('((acos simpiden) (asin simpiden) (atan simpiden)
          (acosh simpiden) (asinh simpiden) (atanh simpiden)
          (acot simpiden) (cos simpiden) (sin simpiden) (tan simpiden)
          (sec simpiden) (sech simpiden) (csc simpiden) (csch simpiden)
          (cot simpiden)(acot simpiden)(coth simpiden)(acoth simpiden)
          (cosh simpiden) (sinh simpiden) (tanh simpiden)
          (asec simpiden) (acsc simpiden)
          (asech simpiden) (acsch simpiden)
   ),'simpfn);(acos asin atan acosh asinh atanh acot cos sin tan sec sech csc
csch cot acot coth acoth cosh sinh tanh asec acsc asech acsch)

% The following declaration causes the simplifier to pass the full
% expression (including the function) to simpiden.

flag ('(acos asin atan acosh acot asinh atanh cos sin tan cosh sinh tanh
        csc csch sec sech cot acot coth acoth asec acsc asech acsch),
      'full);nil

% flag ('(atan),'oddreal);

flag('(acoth acsc acsch asin asinh atan atanh sin tan csc csch sinh
       tanh cot coth),
     'odd);nil

flag('(cos sec sech cosh),'even);nil

flag('(cot coth csc csch acoth),'nonzero);nil

% In the following rules, it is not necessary to let f(0)=0, when f
% is odd, since simpiden already does this.

% Some value have been commented out since these can be computed from
% other functions.

let cos(0)= 1,
  % sec(0)= 1,
  % cos(pi/12)=sqrt(2)/4*(sqrt 3+1),
    sin(pi/12)=sqrt(2)/4*(sqrt 3-1),
    sin(5pi/12)=sqrt(2)/4*(sqrt 3+1),
  % cos(pi/6)=sqrt 3/2,
    sin(pi/6)= 1/2,
  % cos(pi/4)=sqrt 2/2,
    sin(pi/4)=sqrt 2/2,
  % cos(pi/3) = 1/2,
    sin(pi/3) = sqrt(3)/2,
    cos(pi/2)= 0,
    sin(pi/2)= 1,
    sin(pi)= 0,
    cos(pi)=-1,
    cosh 0=1,
    sech(0) =1,
    sinh(i) => i*sin(1),
    cosh(i) => cos(1),
    acosh(0) => i*pi/2,
    acosh(1) => 0,
    acosh(-1) => i*pi,
    acoth(0) => i*pi/2
  % acos(0)= pi/2,
  % acos(1)=0,
  % acos(1/2)=pi/3,
  % acos(sqrt 3/2) = pi/6,
  % acos(sqrt 2/2) = pi/4,
  % acos(1/sqrt 2) = pi/4
  % asin(1/2)=pi/6,
  % asin(-1/2)=-pi/6,
  % asin(1)=pi/2,
  % asin(-1)=-pi/2
  ;nil

for all x let cos acos x=x, sin asin x=x, tan atan x=x,
           cosh acosh x=x, sinh asinh x=x, tanh atanh x=x,
           cot acot x=x, coth acoth x=x, sec asec x=x,
           csc acsc x=x, sech asech x=x, csch acsch x=x;nil

for all x let acos(-x)=pi-acos(x),
              asec(-x)=pi-asec(x),
              acot(-x)=pi-acot(x);nil

% Fold the elementary trigonometric functions down to the origin.

let

 sin( (~~w + ~~k*pi)/~~d)
     => (if evenp fix repart(k/d) then 1 else -1)
          * sin(w/d + ((k/d)-fix repart(k/d))*pi)
      when ((ratnump(rp) and abs(rp) >= 1) where rp => repart(k/d)),

 sin( ~~k*pi/~~d) => sin((1-k/d)*pi)
      when ratnump(k/d) and k/d > 1/2,

 cos( (~~w + ~~k*pi)/~~d)
     => (if evenp fix repart(k/d) then 1 else -1)
          * cos(w/d + ((k/d)-fix repart(k/d))*pi)
      when ((ratnump(rp) and abs(rp) >= 1) where rp => repart(k/d)),

 cos( ~~k*pi/~~d) => -cos((1-k/d)*pi)
      when ratnump(k/d) and k/d > 1/2,

% next two rules needed with current definition of knowledge_about
 csc( (~~w + ~~k*pi)/~~d)
     => (if evenp fix repart(k/d) then 1 else -1)
          * csc(w/d + ((k/d)-fix repart(k/d))*pi)
      when ((ratnump(rp) and abs(rp) >= 1) where rp => repart(k/d)),

 csc( ~~k*pi/~~d) => csc((1-k/d)*pi)
      when ratnump(k/d) and k/d > 1/2,

 sec( (~~w + ~~k*pi)/~~d)
     => (if evenp fix repart(k/d) then 1 else -1)
          * sec(w/d + ((k/d)-fix repart(k/d))*pi)
      when ((ratnump(rp) and abs(rp) >= 1) where rp => repart(k/d)),

 sec( ~~k*pi/~~d) => -sec((1-k/d)*pi)
      when ratnump(k/d) and k/d > 1/2,

 tan( (~~w + ~~k*pi)/~~d)
     => tan(w/d + ((k/d)-fix repart(k/d))*pi)
      when ((ratnump(rp) and abs(rp) >= 1) where rp => repart(k/d)),

 cot( (~~w + ~~k*pi)/~~d)
     => cot(w/d + ((k/d)-fix repart(k/d))*pi)
      when ((ratnump(rp) and abs(rp) >= 1) where rp => repart(k/d));nil

% The following rules follow the pattern
%   sin(~x + pi/2)=> cos(x) when x freeof pi
% however allowing x to be a quotient and a negative pi/2 shift.
% We need to handleonly pi/2 shifts here because
% the bigger shifts are already covered by the rules above.
%
% Note the use of ~~d instead of ~d in the denominator for rational k.

let sin((~x + ~~k*pi)/~~d) => sign repart(k/d)*cos(x/d + i*pi*impart(k/d))
         when abs repart(k/d) = 1/2,

    cos((~x + ~~k*pi)/~~d) => -sign repart(k/d)*sin(x/d + i*pi*impart(k/d))
         when abs repart(k/d) = 1/2,

    csc((~x + ~~k*pi)/~~d) => sign repart(k/d)*sec(x/d + i*pi*impart(k/d))
         when abs repart(k/d) = 1/2,

    sec((~x + ~~k*pi)/~~d) => -sign repart(k/d)*csc(x/d + i*pi*impart(k/d))
         when abs repart(k/d) = 1/2,

    tan((~x + ~~k*pi)/~~d) => -cot(x/d + i*pi*impart(k/d))
         when abs repart(k/d) = 1/2,

    cot((~x + ~~k*pi)/~~d) => -tan(x/d + i*pi*impart(k/d))
         when x freeof pi and abs repart(k/d) = 1/2;nil

% Inherit function values.

symbolic (!*elem!-inherit := t);t

symbolic procedure knowledge_about(op,arg,top);
  % True if the form '(op arg) can be formally simplified.
  % Avoiding recursion from rules for the target operator top by
  % a local remove of the property opmtch.
  % The internal switch !*elem!-inherit!* allows us to turn the
  % inheritage temporarily off.
    if dmode!* eq '!:rd!: or dmode!* eq '!:cr!:
     or null !*elem!-inherit then nil else
    (begin scalar r,old;
       old:=get(top,'opmtch); put(top,'opmtch,nil);
       unwind!-protect(r:= errorset!*({'aeval,mkquote{op,arg}},nil),
                       put(top,'opmtch,old));
       return not errorp r and not smemq(op,car r)
             and not smemq(top,car r);
    end) where varstack!*=nil;
+++ knowledge_about compiled, 81 + 60 bytes
knowledge_about

symbolic operator knowledge_about;nil

symbolic procedure trigquot(n,d);
  % Form a quotient n/d, replacing sin and cos by tan/cot
  % whenver possible.
  begin scalar m,u,v,w;
    u:=if eqcar(n,'minus) then <<m:=t; cadr n>> else n;
    v:=if eqcar(d,'minus) then <<m:=not m; cadr d>> else d;
    if pairp u and pairp v then
      if car u eq 'sin and car v eq 'cos and cadr u=cadr v
            then w:='tan else
      if car u eq 'cos and car v eq 'sin and cadr u=cadr v
            then w:='cot;
    if null w then return{'quotient,n,d};
    w:={w,cadr u};
    return if m then {'minus,w} else w;
  end;
+++ trigquot compiled, 89 + 40 bytes
trigquot

symbolic operator trigquot;nil

% cos, tan, cot, sec, csc inherit from sin.


let cos(~x)=>sin(x+pi/2)
        when (x+pi/2)/pi freeof pi and knowledge_about(sin,x+pi/2,cos),
    cos(~x)=>-sin(x-pi/2)
        when (x-pi/2)/pi freeof pi and knowledge_about(sin,x-pi/2,cos),
    tan(~x)=>trigquot(sin(x),cos(x)) when knowledge_about(sin,x,tan),
    cot(~x)=>trigquot(cos(x),sin(x)) when knowledge_about(sin,x,cot),
    sec(~x)=>1/cos(x) when knowledge_about(cos,x,sec),
    csc(~x)=>1/sin(x) when knowledge_about(sin,x,csc);nil

% area functions

let asin(~x)=>pi/2 - acos(x) when knowledge_about(acos,x,asin),
    acot(~x)=>pi/2 - atan(x) when knowledge_about(atan,x,acot),
    acsc(~x) => asin(1/x) when knowledge_about(asin,1/x,acsc),
    asec(~x) => acos(1/x) when knowledge_about(acos,1/x,asec),
    acsch(~x) => acsc(-i*x)/i when knowledge_about(acsc,-i*x,acsch),
    asech(~x) => asec(x)/i when knowledge_about(asec,x,asech);nil

% hyperbolic functions

let sinh(i*~x)=>i*sin(x) when knowledge_about(sin,x,sinh),
    sinh(i*~x/~n)=>i*sin(x/n) when knowledge_about(sin,x/n,sinh),
    cosh(i*~x)=>cos(x) when knowledge_about(cos,x,cosh),
    cosh(i*~x/~n)=>cos(x/n) when knowledge_about(cos,x/n,cosh),
    cosh(~x)=>-i*sinh(x+i*pi/2)
       when (x+i*pi/2)/pi freeof pi
          and knowledge_about(sinh,x+i*pi/2,cosh),
    cosh(~x)=>i*sinh(x-i*pi/2)
       when (x-i*pi/2)/pi freeof pi
          and knowledge_about(sinh,x-i*pi/2,cosh),
    tanh(~x)=>sinh(x)/cosh(x) when knowledge_about(sinh,x,tanh),
    coth(~x)=>cosh(x)/sinh(x) when knowledge_about(sinh,x,coth),
    sech(~x)=>1/cosh(x) when knowledge_about(cosh,x,sech),
    csch(~x)=>1/sinh(x) when knowledge_about(sinh,x,csch);nil

let acsch(~x) => asinh(1/x) when knowledge_about(asinh,1/x,acsch),
    asech(~x) => acosh(1/x) when knowledge_about(acosh,1/x,asech),
    asinh(~x) => -i*asin(i*x) when i*x freeof i
                   and knowledge_about(asin,i*x,asinh);nil


% hyperbolic functions

let

 sinh( (~~w + ~~k*pi)/~~d)
      => (if evenp fix impart(k/d) then 1 else -1)
           * sinh(w/d + (k/d-i*fix impart(k/d))*pi)
       when ((ratnump(ip) and abs(ip) >= 1) where ip => impart(k/d)),

 sinh( ~~k*pi/~~d) => sinh((i-k/d)*pi)
       when ratnump(i*k/d) and abs(i*k/d) > 1/2,

 cosh( (~~w + ~~k*pi)/~~d)
      => (if evenp fix impart(k/d) then 1 else -1)
           * cosh(w/d + (k/d-i*fix impart(k/d))*pi)
       when ((ratnump(ip) and abs(ip) >= 1) where ip => impart(k/d)),

 cosh( ~~k*pi/~~d) => -cosh((i-k/d)*pi)
       when ratnump(i*k/d) and abs(i*k/d) > 1/2,

% next two rules needed with current definition of knowledge_about
 csch( (~~w + ~~k*pi)/~~d)
      => (if evenp fix impart(k/d) then 1 else -1)
           * csch(w/d + (k/d-i*fix impart(k/d))*pi)
       when ((ratnump(ip) and abs(ip) >= 1) where ip => impart(k/d)),

 csch( ~~k*pi/~~d) => csch((i-k/d)*pi)
       when ratnump(i*k/d) and abs(i*k/d) > 1/2,

 sech( (~~w + ~~k*pi)/~~d)
      => (if evenp fix impart(k/d) then 1 else -1)
           * sech(w/d + (k/d-i*fix impart(k/d))*pi)
       when ((ratnump(ip) and abs(ip) >= 1) where ip => impart(k/d)),

 sech( ~~k*pi/~~d) => -sech((i-k/d)*pi)
       when ratnump(i*k/d) and abs(i*k/d) > 1/2,

 tanh( (~~w + ~~k*pi)/~~d)
      => tanh(w/d + (k/d-i*fix impart(k/d))*pi)
       when ((ratnump(ip) and abs(ip) >= 1) where ip => impart(k/d)),

 coth( (~~w + ~~k*pi)/~~d)
      => coth(w/d + (k/d-i*fix impart(k/d))*pi)
       when ((ratnump(ip) and abs(ip) >= 1) where ip => impart(k/d));nil

% The following rules follow the pattern
%   sinh(~x + i*pi/2)=> cosh(x) when x freeof pi
% however allowing x to be a quotient and a negative i*pi/2 shift.
% We need to handle only pi/2 shifts here because
% the bigger shifts are already covered by the rules above.

let 
    sinh((~~x + ~~k*pi)/~~d) => i*sign impart(k/d)*cosh(x/d + pi*repart(k/d))
         when abs impart(k/d) = 1/2,

    cosh((~~x + ~~k*pi)/~~d) => i*sign impart(k/d)*sinh(x/d+pi*repart(k/d))
         when abs impart(k/d) = 1/2,

% next 2 rules could be omitted and use inheritance
    csch((~~x + ~~k*pi)/~~d) => -i*sign impart(k/d)*sech(x/d + pi*repart(k/d))
         when abs impart(k/d) = 1/2,

    sech((~~x + ~~k*pi)/~~d) => -i*sign impart(k/d)*csch(x/d+pi*repart(k/d))
         when abs impart(k/d) = 1/2,

    tanh((~~x + ~~k*pi)/~~d) => coth(x/d+pi*repart(k/d))
         when abs impart(k/d) = 1/2,

    coth((~~x + ~~k*pi)/~~d) => tanh(x/d+pi*repart(k/d))
         when abs impart(k/d) = 1/2;nil


% Transfer inverse function values from cos to acos and tan to atan.
% Negative values not needed.

acos_rules :=
  symbolic(
  'list . for j:=0:12 join
    (if eqcar(q,'acos) and cadr q=w then {{'replaceby,q,u}})
     where q=reval{'acos,w}
      where w=reval{'cos,u}
       where u=reval{'quotient,{'times,'pi,j},12})$(list (replaceby (acos 1) 0)
(replaceby (acos (quotient (plus (sqrt 6) (sqrt 2)) 4)) (quotient pi 12)) (
replaceby (acos (quotient (sqrt 3) 2)) (quotient pi 6)) (replaceby (acos (
quotient (sqrt 2) 2)) (quotient pi 4)) (replaceby (acos (quotient 1 2)) (
quotient pi 3)) (replaceby (acos (quotient (plus (sqrt 6) (minus (sqrt 2))) 4))
(quotient (times 5 pi) 12)) (replaceby (acos 0) (quotient pi 2)) (replaceby (
acos (quotient (plus (minus (sqrt 6)) (sqrt 2)) 4)) (quotient (times 7 pi) 12))
(replaceby (acos (quotient (plus (minus (sqrt 6)) (minus (sqrt 2))) 4)) (
quotient (times 11 pi) 12)))

let acos_rules;nil

clear acos_rules;nil

atan_rules :=
  symbolic(
  'list . for j:=0:5 join
    (if eqcar(q,'atan) and cadr q=w then {{'replaceby,q,u}})
     where q= reval{'atan,w}
      where w= reval{'tan,u}
       where u= reval{'quotient,{'times,'pi,j},12})$(list (replaceby (atan (
quotient (plus (sqrt 3) (minus 1)) (plus (sqrt 3) 1))) (quotient pi 12)) (
replaceby (atan (quotient 1 (sqrt 3))) (quotient pi 6)) (replaceby (atan 1) (
quotient pi 4)) (replaceby (atan (sqrt 3)) (quotient pi 3)) (replaceby (atan (
quotient (plus (sqrt 3) 1) (plus (sqrt 3) (minus 1)))) (quotient (times 5 pi) 12
)))

let atan_rules;nil

clear atan_rules;nil


repart(pi) := pi$(*sq ((((pi . 1) . 1)) . 1) t)       % $ used for bootstrapping purposes.
impart(pi) := 0$0

% ***** Differentiation rules *****.

for all x let df(acos(x),x)= -sqrt(1-x**2)/(1-x**2),
              df(asin(x),x)= sqrt(1-x**2)/(1-x**2),
              df(atan(x),x)= 1/(1+x**2),
              df(acosh(x),x)= sqrt(x-1)*sqrt(x+1)/(x**2-1),
              df(acot(x),x)= -1/(1+x**2),
              df(acoth(x),x)= -1/(1-x**2),
              df(asinh(x),x)= sqrt(x**2+1)/(x**2+1),
              df(atanh(x),x)= 1/(1-x**2),
              df(acoth(x),x)= 1/(1-x**2),
              df(cos x,x)= -sin(x),
              df(sin x,x)= cos(x),
              df(sec x,x) = sec(x)*tan(x),
              df(csc x,x) = -csc(x)*cot(x),
              df(tan x,x)=1 + tan x**2,
              df(sinh x,x)=cosh x,
              df(cosh x,x)=sinh x,
              df(sech x,x) = -sech(x)*tanh(x),
%              df(tanh x,x)=sech x**2,
              % J.P. Fitch prefers this one for integration purposes
              df(tanh x,x)=1-tanh(x)**2,
              df(csch x,x)= -csch x*coth x,
              df(cot x,x)=-1-cot x**2,
              df(coth x,x)=1-coth x**2;nil

% Beware we cannot take an x factor inside the sqrt in the 4 formulae below
% as this changes the cuts and introduces sign errors in part of the domain.
let df(acsc(~x),x) =>  -1/(x^2*sqrt(1-1/x^2)),
    df(asec(~x),x) => 1/(x^2*sqrt(1-1/x^2)),
    df(acsch(~x),x)=> -1/(x^2*sqrt(1+ 1/x^2)),
    df(asech(~x),x)=> -1/(x^2*sqrt(1/x-1)*sqrt(1/x+1));nil

% rules for atan2  
let df(atan2(~y,~x),~z) => (x*df(y, z)-y*df(x, z))/(x^2+y^2);
*** atan2 declared operator 
nil

% This procedure now works for complex arguments and gives results compatible 
% with the numerical results returned by cratan2!* (and rdatan2!*)
% It may currently be somewhat inefficient as it frequently inter-converts
% between prefix and standard quotient forms 
symbolic procedure simp!-atan2 u;
<< if length u neq 2 then  
      rerror(alg,17,list("Wrong number of arguments to", 'atan2));
   (if val then val    % where val=valuechk('atan2, u)
    else % NB some simplifications seem to fail if !*complex=t
    begin scalar x,y,z,v,w, !*complex; 
       y := reval car u;
       x := reval cadr u;

       % deal with usual case of real arguments separately as more
       % simp!-sign1 succeeds more often with simpler arguments
       if null numr simpimpart list x and null numr simpimpart list y then
          return simpatan2r(y, x);

       % save simplified original arguments for default return value
       u := {y, x};  

       if x=0 then <<
      	  z:= simp!-sign1 prepsq simprepart list y;
      	  if null numr z then z:= simp!-sign1 reval {'quotient, y, 'i};
      	  if denr z=1 and fixp numr z then 
	     return multsq(z, simp {'quotient,'pi, 2})>>
       else if y=0 then <<
      	  z:= simp!-sign1 prepsq simprepart list x;
      	  if null numr z then z:= simp!-sign1 reval {'quotient, x, 'i};
      	  if denr z=1 and fixp numr z then 
	     if numr z=1 then return nil ./ 1
	     else return simp 'pi>>
       else <<
      	  z := simp!* {'plus, {'expt, x, 2}, {'expt, y, 2}};
      	  if null numr z then 
	     rerror(alg, 212, "Essential singularity encountered in atan");
      	  x := {'quotient, x, {'sqrt, z:=prepsq z}};
      	  y := {'quotient, y, {'sqrt, z}};
	  z:= simp!-sign1 prepsq simprepart list x;
      	  if null numr z then z := simp!-sign1  reval {'quotient, x, 'i};
	  v := simp!-sign1 prepsq simprepart list y;
      	  if null numr v then v := simp!-sign1 reval {'quotient, y, 'i};
      	  if denr z=1 and fixp numr z and denr v=1 and fixp numr v then <<
	     w := simp {'atan, prepsq rationalizesq simp {'quotient, y, x}};
	     if numr z=1 then return w
	     else if numr v=1 then return addsq(simp 'pi, w)
	     else return subtrsq(w, simp 'pi) >>
       >>;
       return simpiden {'atan2, car u, cadr u}
    end) where val = valuechk('atan2, u)
>>;
+++ simp!-atan2 compiled, 345 + 140 bytes
simp-atan2

put('atan2,'simpfn,'simp!-atan2);simp-atan2
  
symbolic procedure simpatan2r(y, x);
begin scalar z,v,w;
% Arguments are real and simplified
   if x=0 then << 
      z := simp!-sign1 y;
      if null numr z then rerror(alg, 211, "atan2(0, 0) formed") 
      else return quotsq(simp {'quotient, 'pi, 2}, z)>>
   else if y=0 then <<
      z := simp!-sign1 x;
      return multsq(addsq(1 ./ 1, quotsq((-1) ./ 1, z)),
	            simp {'quotient, 'pi, 2})>>
   else << 
      z := simp!-sign1 x; v := simp!-sign1 y;
      if denr z=1 and fixp numr z and denr v=1 and fixp numr v then <<
       	 w := simp {'atan, {'quotient, y, x}};
	 if numr z=1 then return w
	 else if numr v=1 then return addsq(simp 'pi, w)
	 else return subtrsq(w, simp 'pi) >>
   >>;
   return simpiden {'atan2, y, x};
end;
+++ simpatan2r compiled, 130 + 84 bytes
simpatan2r


%for all x let e**log x=x;   % Requires every power to be checked.

for all x,y let df(x**y,x)= y*x**(y-1),
                df(x**y,y)= log x*x**y;nil

% Ei, erf, erfc, erfi, exp and dilog.

operator dilog,Ei,erf,erfi,erfc,exp;nil

let {
   dilog(0) => pi**2/6,
   dilog(1) => 0,
   dilog(2) => -pi^2/12,
   dilog(-1) => pi^2/4-i*pi*log(2)
};nil

let df(dilog(~x),(~x)) => -log(x)/(x-1);nil

let df(Ei(~x),~x) => e**x/x;nil



let Ei(~x) => compute!:int!:functions(x,Ei)
              when numberp x and abs(x) <= 20 and lisp !*rounded;nil


let erf 0=0;nil

for all x let erf(-x)=-erf x;nil

for all x let df(erf x,x)=2*sqrt(pi)*e**(-x**2)/pi;nil

let erf (~x) => compute!:int!:functions(x,erf)
                when numberp x and abs(x)<5 and lisp !*rounded;nil

let erfc(~x) => 1 - erf(x);nil
let erfi(~z)  => -i * erf(i*z);nil

for all x let exp(x)=e**x;nil

% Supply missing argument and simplify 1/4 roots of unity.

let   e**(i*pi/2) = i,
      e**(i*pi) = -1;nil
%     e**(3*i*pi/2)=-i;

% Ci and si.

operator ci,si;nil

let {
  si(0) => 0,
  si(-~x) => (- si(x)),
  df(si(~x),x) => sin(x)/x,
  si(~x) => compute!:int!:functions(x,si)
            when numberp x and lisp !*rounded,

  ci(-~x) => - ci(x) -i*pi,
  df(ci(~x),x) => cos(x)/x,
  ci(~x) => compute!:int!:functions(x,ci)
            when numberp x and abs(x) <= 20 and lisp !*rounded
};nil

% Rule for derivative of absolute value.

for all x let df(abs x,x)=abs x/x;nil

% More trigonometrical rules.

invtrigrules := {
  sin(atan ~u)   => u/sqrt(1+u^2),
  cos(atan ~u)   => 1/sqrt(1+u^2),
  sin(2*atan ~u) => 2*u/(1+u^2),
  cos(2*atan ~u) => (1-u^2)/(1+u^2),
  sin(~n*atan ~u) => sin((n-2)*atan u) * (1-u^2)/(1+u^2) +
                     cos((n-2)*atan u) * 2*u/(1+u^2)
                     when fixp n and n>2,
  cos(~n*atan ~u) => cos((n-2)*atan u) * (1-u^2)/(1+u^2) -
                     sin((n-2)*atan u) * 2*u/(1+u^2)
                     when fixp n and n>2,
  sin(acos ~u) => sqrt(1-u^2),
  cos(asin ~u) => sqrt(1-u^2),
  sin(2*acos ~u) => 2 * u * sqrt(1-u^2),
  cos(2*acos ~u) => 2*u^2 - 1,
  sin(2*asin ~u) => 2 * u * sqrt(1-u^2),
  cos(2*asin ~u) => 1 - 2*u^2,
  sin(~n*acos ~u) => sin((n-2)*acos u) * (2*u^2 - 1) +
                     cos((n-2)*acos u) * 2 * u * sqrt(1-u^2)
                     when fixp n and n>2,
  cos(~n*acos ~u) => cos((n-2)*acos u) * (2*u^2 - 1) -
                     sin((n-2)*acos u) * 2 * u * sqrt(1-u^2)
                     when fixp n and n>2,
  sin(~n*asin ~u) => sin((n-2)*asin u) * (1 - 2*u^2) +
                     cos((n-2)*asin u) * 2 * u * sqrt(1-u^2)
                     when fixp n and n>2,
  cos(~n*asin ~u) => cos((n-2)*asin u) * (1 - 2*u^2) -
                     sin((n-2)*asin u) * 2 * u * sqrt(1-u^2)
                     when fixp n and n>2
%  Next rule causes a simplification loop in solve(atan y=y).
% atan(~x) => acos((1-x^2)/(1+x^2)) * sign (x) / 2
%             when symbolic(not !*complex) and x^2 neq -1
%                   and acos((1-x^2)/(1+x^2)) freeof acos
}$(list (replaceby (sin (atan (~ u))) (quotient u (sqrt (plus 1 (expt u 2))))) (
replaceby (cos (atan (~ u))) (quotient 1 (sqrt (plus 1 (expt u 2))))) (replaceby
(sin (times 2 (atan (~ u)))) (times 2 (quotient u (plus 1 (expt u 2))))) (
replaceby (cos (times 2 (atan (~ u)))) (quotient (difference 1 (expt u 2)) (plus
1 (expt u 2)))) (replaceby (sin (times (~ n) (atan (~ u)))) (when (plus (times (
sin (times (difference n 2) (atan u))) (quotient (difference 1 (expt u 2)) (plus
1 (expt u 2)))) (times (cos (times (difference n 2) (atan u))) 2 (quotient u (
plus 1 (expt u 2))))) (and (fixp n) (greaterp n 2)))) (replaceby (cos (times (~
n) (atan (~ u)))) (when (difference (times (cos (times (difference n 2) (atan u)
)) (quotient (difference 1 (expt u 2)) (plus 1 (expt u 2)))) (times (sin (times
(difference n 2) (atan u))) 2 (quotient u (plus 1 (expt u 2))))) (and (fixp n) (
greaterp n 2)))) (replaceby (sin (acos (~ u))) (sqrt (difference 1 (expt u 2))))
(replaceby (cos (asin (~ u))) (sqrt (difference 1 (expt u 2)))) (replaceby (sin
(times 2 (acos (~ u)))) (times 2 u (sqrt (difference 1 (expt u 2))))) (replaceby
(cos (times 2 (acos (~ u)))) (difference (times 2 (expt u 2)) 1)) (replaceby (
sin (times 2 (asin (~ u)))) (times 2 u (sqrt (difference 1 (expt u 2))))) (
replaceby (cos (times 2 (asin (~ u)))) (difference 1 (times 2 (expt u 2)))) (
replaceby (sin (times (~ n) (acos (~ u)))) (when (plus (times (sin (times (
difference n 2) (acos u))) (difference (times 2 (expt u 2)) 1)) (times (cos (
times (difference n 2) (acos u))) 2 u (sqrt (difference 1 (expt u 2))))) (and (
fixp n) (greaterp n 2)))) (replaceby (cos (times (~ n) (acos (~ u)))) (when (
difference (times (cos (times (difference n 2) (acos u))) (difference (times 2 (
expt u 2)) 1)) (times (sin (times (difference n 2) (acos u))) 2 u (sqrt (
difference 1 (expt u 2))))) (and (fixp n) (greaterp n 2)))) (replaceby (sin (
times (~ n) (asin (~ u)))) (when (plus (times (sin (times (difference n 2) (asin
u))) (difference 1 (times 2 (expt u 2)))) (times (cos (times (difference n 2) (
asin u))) 2 u (sqrt (difference 1 (expt u 2))))) (and (fixp n) (greaterp n 2))))
(replaceby (cos (times (~ n) (asin (~ u)))) (when (difference (times (cos (times
(difference n 2) (asin u))) (difference 1 (times 2 (expt u 2)))) (times (sin (
times (difference n 2) (asin u))) 2 u (sqrt (difference 1 (expt u 2))))) (and (
fixp n) (greaterp n 2)))))

% The following are useful for simplifying sqrts of complex values
% Added by A Barnes, Aug 2015
invtrigrules2 := {
    sin(atan(~x)/2) => sin(atan((sqrt(1+x^2)-1)/x)),
    cos(atan(~x)/2) => cos(atan((sqrt(1+x^2)-1)/x))
%    tan(atan(~x)/2) => (sqrt(1+x^2)-1)/x
}$(list (replaceby (sin (quotient (atan (~ x)) 2)) (sin (atan (quotient (
difference (sqrt (plus 1 (expt x 2))) 1) x)))) (replaceby (cos (quotient (atan (
~ x)) 2)) (cos (atan (quotient (difference (sqrt (plus 1 (expt x 2))) 1) x)))))

let invtrigrules2;nil

invhyprules := {
  sinh(atanh ~u)   => u/sqrt(1-u^2),
  cosh(atanh ~u)   => 1/sqrt(1-u^2),
  sinh(2*atanh ~u) => 2*u/(1-u^2),
  cosh(2*atanh ~u) => (1+u^2)/(1-u^2),
  sinh(~n*atanh ~u) => sinh((n-2)*atanh u) * (1+u^2)/(1-u^2) +
                       cosh((n-2)*atanh u) * 2*u/(1-u^2)
                       when fixp n and n>2,
  cosh(~n*atanh ~u) => cosh((n-2)*atanh u) * (1+u^2)/(1-u^2) +
                       sinh((n-2)*atanh u) * 2*u/(1-u^2)
                       when fixp n and n>2,
  sinh(acosh ~u) => sqrt(u-1)*sqrt(u+1),
  cosh(asinh ~u) => sqrt(1+u^2),
  sinh(2*acosh ~u) => 2 * u * sqrt(u-1)*sqrt(u+1),
  cosh(2*acosh ~u) => 2*u^2 - 1,
  sinh(2*asinh ~u) => 2 * u * sqrt(1+u^2),
  cosh(2*asinh ~u) => 1 + 2*u^2,
  sinh(~n*acosh ~u) => sinh((n-2)*acosh u) * (2*u^2 - 1) +
                       cosh((n-2)*acosh u) * 2 * u * sqrt(u-1)*sqrt(u+1)
                       when fixp n and n>2,
  cosh(~n*acosh ~u) => cosh((n-2)*acosh u) * (2*u^2 - 1) +
                       sinh((n-2)*acosh u) * 2 * u * sqrt(u-1)*sqrt(u+1)
                       when fixp n and n>2,
  sinh(~n*asinh ~u) => sinh((n-2)*asinh u) * (1 + 2*u^2) +
                       cosh((n-2)*asinh u) * 2 * u * sqrt(1+u^2)
                       when fixp n and n>2,
  cosh(~n*asinh ~u) => cosh((n-2)*asinh u) * (1 + 2*u^2) +
                       sinh((n-2)*asinh u) * 2 * u * sqrt(1+u^2)
                       when fixp n and n>2,
  atanh(~x) => acosh((1+x^2)/(1-x^2)) * sign (x) / 2
               when symbolic(not !*complex)
                     and x^2 neq 1
                     and acosh((1+x^2)/(1-x^2)) freeof acosh
}$(list (replaceby (sinh (atanh (~ u))) (quotient u (sqrt (difference 1 (expt u
2))))) (replaceby (cosh (atanh (~ u))) (quotient 1 (sqrt (difference 1 (expt u 2
))))) (replaceby (sinh (times 2 (atanh (~ u)))) (times 2 (quotient u (difference
1 (expt u 2))))) (replaceby (cosh (times 2 (atanh (~ u)))) (quotient (plus 1 (
expt u 2)) (difference 1 (expt u 2)))) (replaceby (sinh (times (~ n) (atanh (~ u
)))) (when (plus (times (sinh (times (difference n 2) (atanh u))) (quotient (
plus 1 (expt u 2)) (difference 1 (expt u 2)))) (times (cosh (times (difference n
2) (atanh u))) 2 (quotient u (difference 1 (expt u 2))))) (and (fixp n) (
greaterp n 2)))) (replaceby (cosh (times (~ n) (atanh (~ u)))) (when (plus (
times (cosh (times (difference n 2) (atanh u))) (quotient (plus 1 (expt u 2)) (
difference 1 (expt u 2)))) (times (sinh (times (difference n 2) (atanh u))) 2 (
quotient u (difference 1 (expt u 2))))) (and (fixp n) (greaterp n 2)))) (
replaceby (sinh (acosh (~ u))) (times (sqrt (difference u 1)) (sqrt (plus u 1)))
) (replaceby (cosh (asinh (~ u))) (sqrt (plus 1 (expt u 2)))) (replaceby (sinh (
times 2 (acosh (~ u)))) (times 2 u (sqrt (difference u 1)) (sqrt (plus u 1)))) (
replaceby (cosh (times 2 (acosh (~ u)))) (difference (times 2 (expt u 2)) 1)) (
replaceby (sinh (times 2 (asinh (~ u)))) (times 2 u (sqrt (plus 1 (expt u 2)))))
(replaceby (cosh (times 2 (asinh (~ u)))) (plus 1 (times 2 (expt u 2)))) (
replaceby (sinh (times (~ n) (acosh (~ u)))) (when (plus (times (sinh (times (
difference n 2) (acosh u))) (difference (times 2 (expt u 2)) 1)) (times (cosh (
times (difference n 2) (acosh u))) 2 u (sqrt (difference u 1)) (sqrt (plus u 1))
)) (and (fixp n) (greaterp n 2)))) (replaceby (cosh (times (~ n) (acosh (~ u))))
(when (plus (times (cosh (times (difference n 2) (acosh u))) (difference (times
2 (expt u 2)) 1)) (times (sinh (times (difference n 2) (acosh u))) 2 u (sqrt (
difference u 1)) (sqrt (plus u 1)))) (and (fixp n) (greaterp n 2)))) (replaceby
(sinh (times (~ n) (asinh (~ u)))) (when (plus (times (sinh (times (difference n
2) (asinh u))) (plus 1 (times 2 (expt u 2)))) (times (cosh (times (difference n
2) (asinh u))) 2 u (sqrt (plus 1 (expt u 2))))) (and (fixp n) (greaterp n 2))))
(replaceby (cosh (times (~ n) (asinh (~ u)))) (when (plus (times (cosh (times (
difference n 2) (asinh u))) (plus 1 (times 2 (expt u 2)))) (times (sinh (times (
difference n 2) (asinh u))) 2 u (sqrt (plus 1 (expt u 2))))) (and (fixp n) (
greaterp n 2)))) (replaceby (atanh (~ x)) (when (times (acosh (quotient (plus 1
(expt x 2)) (difference 1 (expt x 2)))) (quotient (sign x) 2)) (and (symbolic (
not *complex)) (neq (expt x 2) 1) (freeof (acosh (quotient (plus 1 (expt x 2)) (
difference 1 (expt x 2)))) acosh)))))

let invtrigrules,invhyprules;nil

trig_imag_rules := {
    sin(i * ~~x / ~~y)   => i * sinh(x/y) when impart(y)=0,
    cos(i * ~~x / ~~y)   => cosh(x/y) when impart(y)=0,
    sinh(i * ~~x / ~~y)  => i * sin(x/y) when impart(y)=0,
    cosh(i * ~~x / ~~y)  => cos(x/y) when impart(y)=0,
    asin(i * ~~x / ~~y)  => i * asinh(x/y) when impart(y)=0,
    atan(i * ~~x / ~~y)  => i * atanh(x/y) when impart(y)=0
                                and not((x=1 or x=-1) and y=1),
    asinh(i * ~~x / ~~y) => i * asin(x/y) when impart(y)=0,
    atanh(i * ~~x / ~~y) => i * atan(x/y) when impart(y)=0
}$(list (replaceby (sin (times i (quotient (~ (~ x)) (~ (~ y))))) (when (times i
(sinh (quotient x y))) (equal (impart y) 0))) (replaceby (cos (times i (quotient
(~ (~ x)) (~ (~ y))))) (when (cosh (quotient x y)) (equal (impart y) 0))) (
replaceby (sinh (times i (quotient (~ (~ x)) (~ (~ y))))) (when (times i (sin (
quotient x y))) (equal (impart y) 0))) (replaceby (cosh (times i (quotient (~ (~
x)) (~ (~ y))))) (when (cos (quotient x y)) (equal (impart y) 0))) (replaceby (
asin (times i (quotient (~ (~ x)) (~ (~ y))))) (when (times i (asinh (quotient x
y))) (equal (impart y) 0))) (replaceby (atan (times i (quotient (~ (~ x)) (~ (~
y))))) (when (times i (atanh (quotient x y))) (and (equal (impart y) 0) (not (
and (or (equal x 1) (equal x (minus 1))) (equal y 1)))))) (replaceby (asinh (
times i (quotient (~ (~ x)) (~ (~ y))))) (when (times i (asin (quotient x y))) (
equal (impart y) 0))) (replaceby (atanh (times i (quotient (~ (~ x)) (~ (~ y))))
) (when (times i (atan (quotient x y))) (equal (impart y) 0))))

let trig_imag_rules;nil

% Generalized periodicity rules for trigonometric functions.
% FJW, 16 October 1996.
% exp rule corrected and others generalised to work for negative n
% by AB March 2015 (negative n used to give error)

let {
 cos(~n*pi*arbint(~i) + ~~x) => cos((if evenp n then 0 else 1)*pi*arbint(i) + x)
  when fixp n,
 sin(~n*pi*arbint(~i) + ~~x) => sin((if evenp n then 0 else 1)*pi*arbint(i) + x)
  when fixp n,
 tan(~n*pi*arbint(~i) + ~~x) => tan(x) when fixp n,
 sec(~n*pi*arbint(~i) + ~~x) => sec((if evenp n then 0 else 1)*pi*arbint(i) + x)
  when fixp n,
 csc(~n*pi*arbint(~i) + ~~x) => csc((if evenp n then 0 else 1)*pi*arbint(i) + x)
  when fixp n,
 cot(~n*pi*arbint(~i) + ~~x) => cot(x) when fixp n,
 exp(~n*i*pi*arbint(~k) + ~~x) => 
      exp((if evenp n then 0 else 1)*i*pi*arbint(k) + x) when fixp n
};
*** arbint declared operator 
nil

endmodule;nil

end;nilmodule showrule;nil % Display rules for an operator.

% Author: Herbert Melenk, ZIB, Berlin. E-mail: melenk@zib.de.
% Copyright (c) 1992 ZIB Berlin. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% Modified by: Francis J. Wright <F.J.Wright@Maths.QMW.ac.uk>
% Time-stamp: <10 November 1998>

% $Id: showrule.red 1.2 1998-11-10 08:33:09+00 fjw Exp $

global '(!*match);nil

fluid '(asymplis!* powlis!*);nil

% All let-rules for an operator are collected as rule set.

% Usage in algebraic mode:
%  e.g. SHOWRULES SIN;
% The rules for exponentiation can be listed by
%       SHOWRULES EXPT;

symbolic procedure showrules opr;
   begin scalar r;
     r := showruleskvalue opr;
     r:=append(r,showrulesopmtch opr);
     r:=append(r,showrules!*match opr);
     r:=append(r,showrulesdfn opr);
     if opr eq 'expt then
        <<r:=append(r,showrulespowlis!*());
          r:=append(r,showrulespowlis1!*());
          r:=append(r,showrulesasymplis!*())>>
     else
        %% FJW: Show rules for powers of opr:
        <<r:=append(r,showrulespowlis!*opr opr);
          r:=append(r,showrulespowlis1!*opr opr);
          r:=append(r,showrulesasymplis!*opr opr)>>;
       return 'list.r;
   end;
+++ showrules compiled, 82 + 56 bytes
showrules

symbolic procedure showruleskvalue opr;
  for each rule in get(opr,'kvalue) collect
   begin scalar pattern, vars, target;
      pattern := car rule;
      vars := selectletvars pattern;
      vars := arbvars vars;
      pattern := subla(vars,pattern);
      target := cadr rule;
      target := subla(vars,target);
      return mkrule(nil,pattern,target)
   end;
+++ showruleskvalue compiled, 80 + 20 bytes
showruleskvalue

symbolic procedure showonerule(test,pattern,target);
   % central routine produces one rule.
   begin scalar vars;
      vars := selectletvars pattern;
      vars := arbvars vars;
      pattern := subla(vars,pattern);
      test := subla(vars,test);
      target := subla(vars,target);
      test := simpletsymbolic test;
      if test=t then test:=nil;
      %% target := simpletsymbolic target;
      %% FJW: mangles lists in target, e.g. for hypergeometric, but
      %% not applying simpletsymbolic might not be the right fix!
      return mkrule(test,pattern,target)
   end;
+++ showonerule compiled, 32 + 28 bytes
showonerule

symbolic procedure showrulesopmtch opr;
   for each rule in get(opr,'opmtch) collect
      showonerule(cdadr rule,opr . car rule,caddr rule);
+++ showrulesopmtch compiled, 52 + 12 bytes
showrulesopmtch

symbolic procedure showrulesdfn opr;
   append(showrulesdfn1 opr, showrulesdfn2 opr);
+++ showrulesdfn compiled, 9 + 16 bytes
showrulesdfn

symbolic procedure showrulesdfn1 opr;
   for i:=1:5 join showrulesdfn1!*(opr,i);
+++ showrulesdfn1 compiled, 43 + 24 bytes
showrulesdfn1

symbolic procedure showrulesdfn1!*(opr,n);
   % simple derivatives
   begin scalar dfn,pl,rule,pattern,target;
    dfn:=dfn_prop(for j:=0:n collect j);
    if(pl:=get(opr,dfn)) then return
     for j:=1:n join
      if (rule:=nth(pl,j)) then
      <<  pattern := car rule;
          pattern := {'df,opr . pattern,nth(pattern,j)};
          target := cdr rule;
          {showonerule(nil,pattern,target)}
      >>;
   end;
+++ showrulesdfn1!* compiled, 149 + 36 bytes
showrulesdfn1*

symbolic procedure mkrule(c,a,b);
  <<b:=strip!~ b; c:=strip!~ c;
    {'replaceby,separate!~ a,if c then {'when,b,c} else b}>>;
+++ mkrule compiled, 26 + 24 bytes
mkrule

symbolic procedure strip!~ u;
   if null u then u else
   if idp u then
     (if eqcar(w,'!~) then intern compress cdr w else u)
         where w=explode2 u
   else if atom u then u
   else if car u = '!~ then strip!~ cadr u
   else strip!~ car u . strip!~ cdr u;
+++ strip!~ compiled, 57 + 16 bytes
strip~

symbolic procedure separate!~ u;
   if null u or u='!~ then u else
   if idp u then
     (if eqcar(w,'!~) then {'!~,intern compress cdr w} else u)
         where w=explode2 u
   else if atom u then u
   else separate!~ car u . separate!~ cdr u;
+++ separate!~ compiled, 57 + 16 bytes
separate~


symbolic procedure showrulesdfn2 opr;
   % collect possible rules from df
   for each rule in get('df,'opmtch) join
      if eqcar(caar rule,opr) then
    {showonerule(cdadr rule,'df . car rule,caddr rule)};
+++ showrulesdfn2 compiled, 75 + 20 bytes
showrulesdfn2

symbolic procedure showrules!*match opr;
  for each rule in !*match join if smember(opr,rule) then
   begin scalar pattern,target,test,p1,p2;
       pattern := car rule;
       p1 := car pattern;
       p2 := cadr pattern;
       pattern := list('times,prepsq !*p2q p1,
                                prepsq !*p2q p2);
       test := cdadr rule;
       target := caddr rule;
       return {showonerule(test,pattern,target)}
     end;
+++ showrules!*match compiled, 142 + 36 bytes
showrules*match

symbolic procedure showrulespowlis!*();
 for each rule in powlis!* collect
   begin scalar pattern,target;
      pattern := list ('expt,car rule,cadr rule);
      target := cadddr rule;
      return mkrule(nil,pattern,target);
   end;
+++ showrulespowlis!* compiled, 64 + 20 bytes
showrulespowlis*

symbolic procedure showrulespowlis1!*();
 for each rule in powlis1!* collect
   begin scalar pattern,target,test,p1,p2;
      pattern := car rule;
      p1 := car pattern;
      p2 := cdr pattern;
      pattern := list ('expt, p1, p2);
      test := cdadr rule;
      target := caddr rule;
      return showonerule(test,pattern,target);
    end;
+++ showrulespowlis1!* compiled, 84 + 20 bytes
showrulespowlis1*

symbolic procedure showrulesasymplis!*();
   for each rule in asymplis!* collect
      mkrule(nil,{'expt,car rule,cdr rule},0);
+++ showrulesasymplis!* compiled, 48 + 24 bytes
showrulesasymplis*

symbolic procedure showrulespowlis!*opr opr;
   %% FJW: Pick rules in powlis!* for operator opr:
   for each rule in powlis!* join
      if eqcar(car rule, opr) then
      begin scalar pattern,target;
         pattern := list ('expt,car rule,cadr rule);
         target := cadddr rule;
         return mkrule(nil,pattern,target) . nil
      end;
+++ showrulespowlis!*opr compiled, 87 + 24 bytes
showrulespowlis*opr

symbolic procedure showrulespowlis1!*opr opr;
   %% FJW: Pick rules in powlis1!* for operator opr:
   for each rule in powlis1!* join
      if eqcar(caar rule, opr) then
      begin scalar pattern,target,test,p1,p2;
         pattern := car rule;
         p1 := car pattern;
         p2 := cdr pattern;
         pattern := list ('expt, p1, p2);
         test := cdadr rule;
         target := caddr rule;
         return showonerule(test,pattern,target) . nil
       end;
+++ showrulespowlis1!*opr compiled, 107 + 24 bytes
showrulespowlis1*opr

symbolic procedure showrulesasymplis!*opr opr;
   %% FJW: Pick rules in asymplis!* for operator opr:
   for each rule in asymplis!* join
      if eqcar(car rule, opr) then
         mkrule(nil,{'expt,car rule,cdr rule},0) . nil;
+++ showrulesasymplis!*opr compiled, 72 + 28 bytes
showrulesasymplis*opr

symbolic procedure selectletvars u;
     if null u then nil else
     if memq(u,frlis!*) then {u} else
     if atom u then nil else
     union (selectletvars car u, selectletvars cdr u);
+++ selectletvars compiled, 23 + 16 bytes
selectletvars

symbolic procedure simpletsymbolic u;
    if atom u then u else
    if car u eq 'quote then simpletsymbolic cadr u else
    if car u memq '(aeval reval revalx boolvalue!*) then
       if needs!-lisp!-tag cadr u
         then {'symbolic,simpletsymbolic cadr u}
        else simpletsymbolic cadr u
     else
    if car u eq 'list then simpletsymbolic cdr u else
    if isboolfn car u then simpletsymbolic (isboolfn car u . cdr u)
       else simpletsymbolic car u . simpletsymbolic cdr u;
+++ simpletsymbolic compiled, 71 + 32 bytes
simpletsymbolic

symbolic procedure needs!-lisp!-tag u;
   if numberp u then nil else
   if atom u then t else
   if car u memq '(aeval reval revalx boolvalue!* quote) then nil else
   if car u eq 'list then needs!-lisp!-tag1 cdr u
   else if car u eq 'cons then
        needs!-lisp!-tag cadr u or needs!-lisp!-tag caddr u
   else t;
+++ needs!-lisp!-tag compiled, 37 + 28 bytes
needs-lisp-tag

symbolic procedure needs!-lisp!-tag1 u;
  if null u then nil else
    needs!-lisp!-tag car u or needs!-lisp!-tag1 cdr u;
+++ needs!-lisp!-tag1 compiled, 11 + 12 bytes
needs-lisp-tag1

fluid '(bool!-functions!*);nil

bool!-functions!* :=
  for each x in {'equal,'greaterp,'lessp,'geq,'leq,'neq,'numberp}
      collect get(x,'boolfn).x;((evalequal . equal) (evalgreaterp . greaterp) (
evallessp . lessp) (evalgeq . geq) (evalleq . leq) (evalneq . neq) (evalnumberp
. numberp))

symbolic procedure isboolfn u;
    if idp u and (u:=assoc(u,bool!-functions!*)) then cdr u;
+++ isboolfn compiled, 15 + 16 bytes
isboolfn

symbolic procedure arbvars vars;
  for each var in vars collect
         var . {'!~, intern compress cddr explode var};
+++ arbvars compiled, 66 + 12 bytes
arbvars

symbolic operator showrules;nil

endmodule;nil

end;nilmodule nestrad;nil % Simplify nested square roots.

% Author: H. Melenk.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% Modifications by: A. C. Hearn:

% The case sqrt(x+8-6*sqrt(x-1)) gave the wrong sign for say x=5.
% However, adding an abs call messed up int(1/(x**4+4*x**2+1),x).
% So for the time being, we only use this code when the argument can
% be shown to be a non-negative number.

fluid '(!*intflag!*);nil

symbolic procedure unnest!-sqrt!-sqrt!*(a0,b0,r0);
  % look for a simplified equivalent to sqrt(a + b*sqrt(c));
  % See: Borodin et al, JSC (1985) 1,p 169ff.
  begin scalar d,a,b,r,s,w;
   if numberp r and r<0 then return nil;
   a:=simp a0; b:=simp b0; r:=simp r0;
     % discriminant: d:=sqrt(a^2-b^2*r).
   d:=subtrsq(multsq(a,a),multsq(multsq(b,b),r));
   if denr d neq 1 or (not domainp(d:=numr d) and not evenp ldeg d)
      or cdr(d:=radf(d,2)) then return nil;
   d := car d ./ 1;
    % s := 2(a+d).
   s:=addsq(a,d); s:=addsq(s,s); s:=prepsq s;
    % w:=(s+2 b sqrt r)/2 sqrt s.
   w:={'quotient,{'times,{'sqrt,s},{'plus,s,{'times,2,b0,{'sqrt,r0}}}},
                 {'times,2,s}};
   return w;
 end;
+++ unnest!-sqrt!-sqrt!* compiled, 130 + 68 bytes
unnest-sqrt-sqrt*

symbolic procedure unnest!-sqrt!-sqrt(a,b,r);
  begin scalar w;
     return if (w:=unnest!-sqrt!-sqrt!*(a,b,r)) then chkabs w
             else if (w:=unnest!-sqrt!-sqrt!*({'times,b,r},a,r))
              then chkabs {'quotient,w,{'expt,r,{'quotient,1,4}}}
             else nil
  end;
+++ unnest!-sqrt!-sqrt compiled, 44 + 36 bytes
unnest-sqrt-sqrt

symbolic procedure chkabs u;
   if !*intflag!* then u      % The integrator doesn't care about sign.
%   else (if null x then {'abs,u}
    else (if null x then u
           else if not minusp!: x then u
           else {'minus,u})
         where x = not_imag_num u;
+++ chkabs compiled, 18 + 24 bytes
chkabs

symbolic operator unnest!-sqrt!-sqrt;nil

algebraic;nil

sqrtsqrt_rules := {
(~a + ~b * ~c^(1/2)) ^(1/2) => !*!*w
   when (!*!*w:=unnest!-sqrt!-sqrt(a,b,c)),
(~a + ~c^(1/2)) ^(1/2) => !*!*w
   when (!*!*w:=unnest!-sqrt!-sqrt(a,1,c))}$(list (replaceby (expt (plus (~ a) (
times (~ b) (expt (~ c) (quotient 1 2)))) (quotient 1 2)) (when **w (setq **w (
unnest-sqrt-sqrt a b c)))) (replaceby (expt (plus (~ a) (expt (~ c) (quotient 1
2))) (quotient 1 2)) (when **w (setq **w (unnest-sqrt-sqrt a 1 c)))))

let sqrtsqrt_rules;nil

endmodule;nil

end;nilmodule maxmin;nil  % Support for generalized MAX and MIN.

% Author: F.J. Wright, QMW, London (fjw@maths.qmw.ac.uk) 7/7/90.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% Provide support for the MAX and MIN functions to allow:-
%     any number domain;
%     any symbolic arguments remain so;
%     nested algebraic-level lists of arguments;
% and to discard redundant nested max and min.
% The Lisp functions max and min are not affected.

% Revision : W. Neun, ZIB Berlin, 25/6/94
%  added handling of  max(n,n+1,n-1) => n+1

put('max, 'simpfn, 'simpmax);simpmax

symbolic procedure simpmax u;
   s_simpmaxmin('max, function evalgreaterp, u, nil);
+++ simpmax compiled, 12 + 20 bytes
simpmax

put('min, 'simpfn, 'simpmin);simpmin

symbolic procedure simpmin u;
   s_simpmaxmin('min, function evallessp, u, nil);
+++ simpmin compiled, 12 + 20 bytes
simpmin

flag('(max min),'listargp);nil

symbolic inline procedure maxmin_difflist(u,v);
 for each uu in u collect reval list('difference,uu ,v);
+++ Record new inline definition:
(de maxmin_difflist (u v) (prog (uu forall!-result forall!-endptr) (setq uu u) (
cond ((null uu) (return nil))) (setq forall!-result (setq forall!-endptr (cons (
(lambda (uu) (reval (list (quote difference) uu v))) (car uu)) nil))) looplabel
(setq uu (cdr uu)) (cond ((null uu) (return forall!-result))) (rplacd
forall!-endptr (cons ((lambda (uu) (reval (list (quote difference) uu v))) (car
uu)) nil)) (setq forall!-endptr (cdr forall!-endptr)) (go looplabel)))
(progn (de maxmin_difflist (u v) (prog (uu forall!-result forall!-endptr) (setq
uu u) (cond ((null uu) (return nil))) (setq forall!-result (setq forall!-endptr
(cons ((lambda (uu) (reval (list (quote difference) uu v))) (car uu)) nil)))
looplabel (setq uu (cdr uu)) (cond ((null uu) (return forall!-result))) (rplacd
forall!-endptr (cons ((lambda (uu) (reval (list (quote difference) uu v))) (car
uu)) nil)) (setq forall!-endptr (cdr forall!-endptr)) (go looplabel))) (put (
quote maxmin_difflist) (quote number!-of!-args) 2) (put (quote maxmin_difflist)
(quote procedure_type) (quote (arrow (times general general) general))) (putc (
quote maxmin_difflist) (quote inline) (quote (lambda (u v) (prog (uu
forall!-result forall!-endptr) (setq uu u) (cond ((null uu) (return nil))) (setq
forall!-result (setq forall!-endptr (cons ((lambda (uu) (reval (list (quote
difference) uu v))) (car uu)) nil))) looplabel (setq uu (cdr uu)) (cond ((null
uu) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda (uu) (reval
(list (quote difference) uu v))) (car uu)) nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel))))))
+++ maxmin_difflist compiled, 42 + 16 bytes
(lambda (u v) (prog (uu forall-result forall-endptr) (setq uu u) (cond ((null uu
) (return nil))) (setq forall-result (setq forall-endptr (cons ((lambda (uu) (
reval (list (quote difference) uu v))) (car uu)) nil))) looplabel (setq uu (cdr
uu)) (cond ((null uu) (return forall-result))) (rplacd forall-endptr (cons ((
lambda (uu) (reval (list (quote difference) uu v))) (car uu)) nil)) (setq
forall-endptr (cdr forall-endptr)) (go looplabel)))


symbolic procedure s_simpmaxmin(maxmin, relation, u,rec);
   begin scalar arglist, arglistp, mval, x;
      if null u then return nil ./ 1;   % 0 returned for empty args.
      arglistp := arglist := list nil;  % Dummy car with cdr to rplacd.
      for each val in flattenmaxmin(maxmin, revlis u) do
         if atom denr(x := simp!* val)
            and (atom numr x or car numr x memq '(!:rd!: !:rn!:))
         % extremize numerical args:
           then (if null mval or apply2(relation,val, mval)
                   then mval := val)
         else
         % successively append symbolic args efficiently:
            << rplacd(arglistp, list val); arglistp := cdr arglistp >>;
      arglist := cdr arglist;  % Discard dummy car
      % Put any numerical extreme value at head of arg list:
      if mval then arglist := mval . arglist;
      % If more than one arg then keep as a max or min:
      if cdr arglist and rec then
                return !*kk2f(maxmin . !*trim arglist) ./ 1;
      if cdr arglist then
        if length cdr arglist >= 1 and
           not eqcar(prepsq(mval :=s_simpmaxmin(maxmin,relation,
                        maxmin_difflist(arglist,car arglist),t)),maxmin)
           then return addsq(mval,simp!* car arglist)
           else return !*kk2f(maxmin . !*trim arglist) ./ 1;
      % Otherwise just return the single (extreme) value:
      return simp car arglist
   end;
+++ s_simpmaxmin compiled, 206 + 60 bytes
s_simpmaxmin  % simpmaxmin

symbolic procedure !*trim u;
   % Trim repeated elements from u.
   if null u then nil
    else if car u member cdr u then !*trim cdr u
    else car u . !*trim cdr u;
+++ !*trim compiled, 23 + 12 bytes
*trim

symbolic procedure flattenmaxmin(maxmin, u);
   % Flatten algebraic-mode lists and already recursively simplified
   % calls of max/min as appropriate.
   for each el in u join
      if atom el then list el
      else if car el eq 'list then flattenmaxmin(maxmin, cdr el)
      else if car el eq maxmin then cdr el
      else if car el='mat then for each r in cdr el join r
      else list el;
+++ flattenmaxmin compiled, 173 + 20 bytes
flattenmaxmin

endmodule;nil

end;nilmodule nssimp;nil  % Simplification functions for non-scalar quantities.

% Author: Anthony C. Hearn.

% Copyright (c) 1987 The RAND Corporation. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*div frlis!* subfg!*);nil

% Several inessential uses of ACONC, NCONC, and MAPping "JOIN". Latter
% not yet changed.

symbolic procedure nssimp(u,v);
   %U is a prefix expression involving non-commuting quantities.
   %V is the type of U.  Result is an expression of the form
   % SUM R(I)*PRODUCT M(I,J) where the R(I) are standard
   %quotients and the M(I,J) non-commuting expressions;
   %N. B: the products in M(I,J) are returned in reverse order
   %(to facilitate, e.g., matrix augmentation);
   begin scalar ncx,r,s,w,x,y,z;
        u := dsimp(u,v);
    a:  if null u then return z;
        w := car u;
        ncx := nil;
    c:  if null w then go to d
         else if numberp(r := car w)
                or not(eqcar(r,'!*div) or
                       (if (s := getrtype r) eq 'yetunknowntype
                          then getrtype(r :=
                                        eval!-yetunknowntypeexpr(r,nil))
                         else s) eq v)
% E.S.: When the simplification mode is matrix the following wraps noncom
%       scalar expressions as 1x1 matrices to preserve multiplication order.
          then if (v eq 'matrix) and noncomp r
                  then y := aconc!*(y,mkscalmat mk!*sq simptimes (r . nil))
         else x := aconc!*(x,r)
         else y := aconc!*(y,r);
        w := cdr w;
        go to c;
    d:  if null y then go to er;
    e:  z := addns(((if null x then 1 ./ 1 else simptimes x) . y),z);
        u := cdr u;
        x := y:= nil;
        go to a;
    er: y := v;
        if idp car x
          then if not flagp(car x,get(y,'fn)) then redmsg(car x,y)
            else rerror(alg,30,list(y,x,"not set"))
         else if w := get(get(y,'tag),'i2d)
          then <<y := list apply1(w,1); go to e>>
         %to allow a scalar to be a 1 by 1 matrix;
         else msgpri(list("Missing",y,"in"),car x,nil,nil,t);
        put(car x,'rtype,y);
        y := list car x;
        x := cdr x;
        go to e
   end;
+++ nssimp compiled, 199 + 116 bytes
nssimp

symbolic procedure dsimp(u,v);
   %result is a list of lists representing a sum of products;
   %N. B: symbols are in reverse order in product list;
   if numberp u then list list u
    else if atom u
     then (if x and subfg!* then dsimp(cadr x,v)
            else if flagp(u,'share) then dsimp(lispeval u,v)
            else <<flag(list u,'used!*); list list u>>)
      where x= get(u,'avalue)
    else if car u eq 'plus
     then for each j in cdr u join dsimp(j,v)
    else if car u eq 'difference
     then nconc!*(dsimp(cadr u,v),
                dsimp('minus . cddr u,v))
    else if car u eq 'minus
     then dsimptimes(list(-1,carx(cdr u,'dsimp)),v)
    else if car u eq 'times then dsimptimes(cdr u,v)
    else if car u eq 'quotient
     then dsimptimes(list(cadr u,list('recip,carx(cddr u,'dsimp))),v)
    else if not(getrtype u eq v) then list list u
    else if car u eq 'recip
     then list list list('!*div,carx(cdr u,'dsimp))
    else if car u eq 'expt then (lambda z;
       if not numberp z then errpri2(u,t)
        else if z<0
         then list list list('!*div,'times . nlist(cadr u,-z))
         else if z=0 then list list list('!*div,cadr u,1)
        else dsimptimes(nlist(cadr u,z),v))
      reval_without_mod caddr u
    else if flagp(car u,'noncommuting) then list list u
    else if arrayp car u
       then dsimp(getelv u,v)
    else (if x then dsimp(x,v)
           else ((if z then dsimp(z,v) else {{y}})
                  where z=opmtch y) where y=revop1 u)
          where x=opmtch u;
+++ dsimp compiled, 295 + 120 bytes
dsimp

symbolic procedure dsimptimes(u,v);
   if null u then errach 'dsimptimes
    else if null cdr u then dsimp(car u,v)
    else (lambda j; for each k in dsimptimes(cdr u,v) join mappend(j,k))
          dsimp(car u,v);
+++ dsimptimes compiled, 63 + 24 bytes
dsimptimes

symbolic procedure addns(u,v);
   if null v then list u
    else if cdr u=cdar v
       then (lambda x; % if null car x then cdr v else;
                         (x . cdr u) . cdr v)
       addsq(car u,caar v)
    else if ordp(cdr u,cdar v) then u . v
    else car v . addns(u,cdr v);
+++ addns compiled, 54 + 16 bytes
addns

symbolic procedure getelx u;
   %to take care of free variables in LET statements;
   if smemqlp(frlis!*,cdr u) then nil
    else if null(u := getelv u) then 0
    else reval u;
+++ getelx compiled, 20 + 28 bytes
getelx

endmodule;nil

end;nilmodule part;nil  % Access and updates parts of an algebraic expression.

% Author: Anthony C. Hearn.

% Copyright (c) 1991 RAND. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*intstr);nil

symbolic procedure revalpart u;
   if null u then rerror(alg,201,"part called without arguments")
    else begin scalar !*intstr,bool,expn,v,z;
      !*intstr := t;   % To make following result in output form.
      expn := if (z := getrtype car u) eq 'list then 
                  if null atom car u and get(caar u,'listfn) 
                     then reval car u else listeval0 car u
               else reval car u;
      !*intstr := nil;
      v := cdr u;
      while v do
         begin scalar x,y,ishold;
           ishold := eqcar(expn, '!*hold);
           if atom expn then <<parterr2(expn,car v); bool := t>>
            else if not numberp(x := reval car v)
             then msgpri("Invalid argument",car v,"to part",nil,t)
% As of July 2011 I can only see 'partop properties set in the
% eds package (on !!cfrm!! and !!eds!! and in the taylor package
% on Taylor!*.
            else if (y := get(car expn,'partop))
             then return <<expn := apply2(y,expn,x); v := cdr v>>
            else if x=0
              then return <<expn :=
                              (if (getrtype w eq 'list) and (z := 'list)
                                 then listeval0 w
                                else if z eq 'list
                                 then <<!*intstr := t; w := reval w;
                                        !*intstr := z := nil; w>>
                                else w) where w = car expn;
                           v := nil>>
            else if x<0 then <<x := -x; y := reverse cdr expn>>
            else y := cdr expn;
           if ishold then <<
              y := car y;
              if atom y then <<parterr2(expn,car v); bool:=t>>
              else y := cdr y >>;
           if bool then nil
            else if length y<x then <<parterr2(expn,car v); bool := t>>
            else if ishold then <<
                expn := nth(y, x);
                if not atom expn and
                   not eqcar(expn, '!*hold) then expn := list('!*hold, expn) >>
            else expn := (if (getrtype w eq 'list) and (z := 'list)
                            then listeval0 w
                           else if z eq 'list
                            then <<!*intstr := t; w := reval w;
                                   !*intstr := z := nil; w>>
                           else w) where w = nth(y,x);
           v := if bool then nil else cdr v
        end;
      return if bool then 0 else reval expn
   end;
+++ revalpart redefined
+++ revalpart compiled, 304 + 88 bytes
revalpart

symbolic procedure parterr2(u,v);
   <<msgpri("Expression",u,"does not have part",v,nil); 0>>;
+++ parterr2 compiled, 16 + 24 bytes
parterr2

put('part,'psopfn,'revalpart);revalpart

flag('(part),'immediate);nil

symbolic procedure revalsetpart u;
   % Simplifies a SETPART expression.
   if null cdr u then rerror(alg,201,"part called without arguments")
    else begin scalar !*intstr,x,y;
      x := reverse cdr u;
      !*intstr := t;
      y := reval car u;
      !*intstr := nil;
      return  revalsetp1(y,reverse cdr x,reval car x)
   end;
+++ revalsetpart compiled, 41 + 44 bytes
revalsetpart

symbolic procedure revalsetp1(expn,ptlist,rep);
   if null ptlist then rep
    else if atom expn then parterr(expn,car ptlist)
    else begin scalar x,y;
      if not numberp(x := reval car ptlist)
             then msgpri("Invalid argument",car ptlist,"to part",nil,t)
       else return
        if y := get(car expn,'setpartop) then apply3(y,expn,ptlist,rep)
         else if x=0 then rep . cdr expn
         else if x<0
          then car expn .
                reverse ssl(reverse cdr expn,
                            -x,cdr ptlist,rep,expn . car ptlist)
         else car expn . ssl(cdr expn,x,cdr ptlist,
                             rep,expn . car ptlist)
   end;
+++ revalsetp1 compiled, 111 + 44 bytes
revalsetp1

symbolic procedure ssl(expn,indx,ptlist,rep,rest);
   if null expn then parterr(car rest,cdr rest)
    else if indx=1 then revalsetp1(car expn,ptlist,rep) . cdr expn
    else car expn . ssl(cdr expn,indx-1,ptlist,rep,rest);
+++ ssl compiled, 43 + 20 bytes
ssl

put('part,'rtypefn,'rtypepart);rtypepart

symbolic procedure rtypepart u;
   if getrtypecar u then 'yetunknowntype else nil;
+++ rtypepart redefined
+++ rtypepart compiled, 9 + 16 bytes
rtypepart

% symbolic procedure rtypepart(u);
%   if null cdr u then getrtypecar u
%    else begin scalar x,n;
%       x := car u;
%       if idp x then <<x := get(car u,'avalue);
%                       if x then x := cadr x>>;
%       if eqcar(x,'list) and numberp (n := aeval cadr u)
%         then return rtypepart(nth(cdr x,n) . cddr u)
%    end;

% put('part,'setqfn,'(lambda (u v w) (setpart!* u v w)));

put('setpart!*,'psopfn,'revalsetpart);revalsetpart

symbolic procedure arglength u;
   begin scalar !*intstr,x;
      if null u then return 0;
      !*intstr := t;
      x := reval u;
      return if atom x then -1 else length cdr x
   end;
+++ arglength redefined
+++ arglength compiled, 25 + 32 bytes
arglength

flag('(arglength),'opfn);nil

flag('(arglength),'noval);nil

put('partlength,'psopfn,'partlengthreval);partlengthreval

symbolic procedure partlengthreval u;
   (if atom expn then 0 else length cdr expn)
      where expn = (if getrtype car u eq 'list then listeval0 car u
                     else reval car u) where !*intstr = t;
+++ partlengthreval compiled, 28 + 40 bytes
partlengthreval

% "unhold" undoes the effect of "hold", and I define it here because
% this file (in procedure revalpart) has a major fraction of the
% code that supports "hold".

algebraic procedure unhold u; u where !*hold(~x) => x;
+++ unhold compiled, 22 + 32 bytes
unhold

endmodule;nil

end;nilmodule map;nil  % Mapping univariate functions to composite objects.

% Author: Herbert Melenk.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% Syntax: map(unary-function,linear-structure-or-matrix)
%
%           map(sqrt ,{1,2,3,4});
%           map(df(~u,x),mat((x^2,sin x)));
%
%         select(unary-predicate,linear-structure)
%
%           select(evenp,{1,2,3,4,5,6,7});
%           select(evenp deg(~u,x),(x+y)^5);
%
%  The function/predicate may contain one free variable.

put('!~map,'oldnam,'map);map

put('map,'newnam,'!~map);~map

put('!~map,'psopfn,'map!-eval);map-eval

put('!~map,'rtypefn,'getrtypecadr);getrtypecadr

put('select,'rtypefn,'getrtypecadr);getrtypecadr

symbolic procedure getrtypecadr u; getrtype cadr u;
+++ getrtypecadr compiled, 4 + 12 bytes
getrtypecadr

symbolic procedure map!-eval u;
  <<if length u neq 2 then rederr "illegal number of arguments for map";
    map!-eval1(reval cadr u,car u,
         function identity!-function,'aeval)>>;
+++ map!-eval compiled, 22 + 36 bytes
map-eval

symbolic procedure !~map(b,a);
 % Called only inside matrix expressions.
   cdr map!-eval1('mat . matsm a,b,
     function (lambda w; list('!*sq,w,t)),'simp);
+++ lambda_q7i3la0xei3g1 compiled, 6 + 16 bytes
+++ !~map compiled, 20 + 28 bytes
~map

symbolic procedure map!-eval1(o,q,fcn1,fcn2);
 % o       structure to be mapped.
 % q       map expression (univariate function).
 % fcn1    function for evaluating members of o.
 % fcn2    function computing results (e.g. aeval).
  begin scalar v,w;
    v := '!&!&x;
    if idp q
      and (get(q,'simpfn) or get(q,'number!-of!-args)=1)
    then <<w:=v; q:={q,v}>>
    else if eqcar(q,'replaceby) then
      <<w:=cadr q; q:=caddr q>>
    else
      <<w:=map!-frvarsof(q,nil);
        if null w then rederr "map/select: no free variable found" else
        if cdr w then rederr "map/select: free variable ambiguous";
        w := car w;
      >>;
    if eqcar(w,'!~) then w:=cadr w;
    q := sublis({w.v,{'!~,w}.v},q);
    if atom o then rederr "cannot map for atom";
    return if car o ='mat then
     'mat . for each row in cdr o collect
             for each w in row collect
              map!-eval2(w,v,q,fcn1,fcn2)
     else car o . for each w in cdr o collect
       map!-eval2(w,v,q,fcn1,fcn2);
  end;
+++ map!-eval1 compiled, 341 + 56 bytes
map-eval1

symbolic procedure map!-eval2(w,v,q,fcn1,fcn2);
  begin scalar r;
   r :=evalletsub2({{{'replaceby ,v,apply1(fcn1,w)}},
        {fcn2,mkquote q}},nil);
   if errorp r then rederr "error during map";
   return car r;
  end;
+++ map!-eval2 compiled, 35 + 32 bytes
map-eval2

symbolic procedure map!-frvarsof(q,l);
  if atom q then l
  else if car q eq '!~ then
     if q member l then l else q.l
  else map!-frvarsof(cdr q,map!-frvarsof(car q,l));
+++ map!-frvarsof compiled, 25 + 12 bytes
map-frvarsof

symbolic procedure formselect(u,vars,mode);
   begin scalar c;
     c := cadr u;
     c := if idp c and get(c,'number!-of!-args) = 1
        then quote!-select!-bool(freequote formbool({c,{'!~,'!&!&}},
                                                    vars,mode),vars)
      else if eqcar(c,'replaceby)
        then {'list,mkquote car c,form1(cadr c,vars,mode),
              quote!-select!-bool(freequote !*s2arg(formbool(caddr c,
                                                    vars,mode),vars),vars)}
      else quote!-select!-bool(freequote formbool(c,vars,mode),vars);
     return {'list,''select,c,form1(caddr u,vars,mode)}
   end;
+++ formselect compiled, 100 + 68 bytes
formselect

symbolic procedure quote!-select!-bool(u,vars);
   'list . for each j in u collect 
               if atom j 
                  then if atsoc(j,vars) then {'mkquote,j}
                        else mkquote j
                else quote!-select!-bool(j,vars);
+++ quote!-select!-bool compiled, 78 + 16 bytes
quote-select-bool

symbolic procedure select!-eval u;
 % select from a list l members according to a boolean test.
   begin scalar l,w,r;
     w := car u;
     l := reval cadr u;
     if atom l or (car l neq'list and not flagp(car l,'nary)) then
           typerr(l,"select operand");
     r := for each q in
           pair(cdr map!-eval1(l,w,function identity!-function,'lispeval),
                cdr l)
            join if car q and car q neq 0 then {cdr q};
     if r then return car l . r;
     if (r := atsoc(car l,'((plus . 0)
                           (times . 1)
                           (and . 1)
                           (or . 0)
                           (list . (list)))))
        then return cdr r
      else rederr {"empty selection for operator ",car l}
 end;
+++ select!-eval compiled, 120 + 60 bytes
select-eval

symbolic procedure freequote u;
  % Preserve structure where possible.
  if atom u then u
  else if car u eq 'list and cdr u and cadr u = '(quote !~)
   then mkquote{'!~,cadr caddr u}
  else (if v=u then u else v)
        where v = freequote car u . freequote cdr u;
+++ freequote compiled, 36 + 24 bytes
freequote

put('select,'formfn,'formselect);formselect

put('select,'psopfn,'select!-eval);select-eval

put('select,'number!-of!-args,2);2

endmodule;nil

end;nilmodule spcfnint;nil % Simplification rules for special functions.

% Copyright (c) 1993 The RAND Corporation. All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


symbolic;nil

% from specfn/specfn.red

fluid '(!*savesfs);nil

switch savesfs=on;nil

% from specfn/simplede.red

switch tracefps;nil

% from specfn/meijerg.red

switch tracespecfns;nil


algebraic;nil


% from specfn/dilog.red

operator Lerch_phi, polylog, zeta;nil

let { 
   Lerch_phi(~z,~s,1) => polylog(s,z)/z,
   Lerch_phi(1,~s,1) => zeta(s),
   Lerch_phi(1,~s,1/2) => (2^s-1)*zeta(s),
   Lerch_phi(~z,0,~a) => 1/(1-z),
   Lerch_phi(-1,2,1/2) => 4*Catalan,
   df(Lerch_phi(~z,~s,~a),~a) => s * Lerch_phi(z,s,a),
   df(Lerch_phi(~z,~s,~a),~z) => (Lerch_phi(z,s-1,a) -a*Lerch_phi(z,s,a))/z
};nil

let { dilog(exp(-~t)) => - dilog(exp t) - t^2/2,
      dilog(1/e^(~t)) => - dilog(exp t) - t^2/2,
      dilog(-~x+1) => - dilog(x) -log x * log (1-x) + pi^2/6
                        when numberp x and geq(x,0) and geq(1,x),
      dilog(~x)   => - dilog(1-x) - log (x) * log(1-x) + pi^2/6
                        when numberp x and (x > 0) and geq(1,x)
                        and not fixp(1/x),
      dilog(1/~x) => - dilog(x) -(log x)^2/2
                        when numberp x and geq(x,0),
      dilog(~x) =>   dilog(x-1) - log (x - 1) *
                        log (x)-pi^2/12-dilog( (x-1)^2)/2
                        when numberp x and geq(x,1) and geq(2,x)
                        and not (x = 0) and not fixp(1/x),
      dilog(~x) => compute!:dilog(x)
                 when numberp x and lisp !*rounded and x>=0
};nil

let { polylog(1,~z) => -log(1-z),
      polylog(~n,~z) => z*df(polylog(n+1,z),z) when fixp n and n<=0,
      polylog(~n,0) => 0,
      polylog(1,1/2) => log(2),
      polylog(2,-1) => -pi^2/12,
      polylog(2,1/2) => (pi^2 - 6*log(2)^2)/12,
      polylog(2,1) => pi^2/6,
      polylog(2,2) => pi^2/4-i*pi*log(2),
      polylog(2,i) => -pi^2/48 + i*Catalan,
      polylog(2,-i) => -pi^2/48 - i*Catalan,
      polylog(3,1/2) => (4*log(2)^3 - 2*pi^2*log(2) + 21*zeta(3))/24,
      polylog(~s,1) => zeta(s),
      df(polylog(~n,~z),~z) => polylog(n-1,z)/z when fixp n and n>1
};nil

let { Lerch_phi (~z,~s,~a) => compute!:lerch_phi(z,s,a)
              when lisp !*rounded and numberp z and abs(z)<1
                     and numberp s and numberp a,
      polylog(~n,~z) =>  z*compute!:lerch_phi(z,n,1)
              when lisp !*rounded and numberp z and abs(z)<1 and numberp n
 };nil


% from specfn/sfconsts.red

let  golden_ratio = (1 + sqrt(5))/2;nil % for Architects



% Khinchin's constant =(prod((1+1/(n*(n+2)))^(ln n/ln2),n,1,infinity))
%
% translated from a (Maple code) posting by Paul Zimmermann
%       in sci.math.symbolic
%

symbolic procedure compute!:khinchin();
 (if not(!*rounded) then mk!*sq('((((Khinchin . 1) . 1)) . 1)) else
    aeval ('compute!:khinchin1 . nil)) where !:prec!: = !:prec!: ;
+++ compute!:khinchin compiled, 17 + 36 bytes
compute:khinchin

symbolic operator compute!:khinchin;nil

let Khinchin => compute!:khinchin();nil

flag('(Euler_gamma golden_ratio Catalan Khinchin),'reserved);nil
flag('(Euler_gamma golden_ratio Catalan Khinchin),'constant);nil
flag('(Euler_gamma golden_ratio Catalan Khinchin),'realvalued);nil
%let {
%   sign(Euler_gamma) => 1,
%   sign(golden_ratio) => 1,
%   sign(Catalan) => 1,
%   sign(Khinchin) => 1
% };
put('Euler_gamma,'!:rd!:,'rd_euler!*);rd_euler*
put('Euler_gamma,'!:cr!:,'cr_euler!*);cr_euler*
put('Catalan,'!:rd!:,'rd_catalan!*);rd_catalan*
put('Catalan,'!:cr!:,'cr_catalan!*);cr_catalan*

% from specfn/sfgen.red

operator bernoulli;nil
symbolic operator bernoulli!*calc;nil

bernoullirules := {

   bernoulli(~n)  =>  1 when numberp n and n = 0,
   bernoulli(~n)  =>  -1/2 when numberp n and n = 1,
   bernoulli(~n)  =>  0 when numberp n and impart n = 0
      and n = floor n and n/2 neq floor (n/2) and n > 0,
   bernoulli(~n)  =>  bernoulli!*calc n when numberp n
      and impart n = 0 and n = floor n and n > 0

};(list (replaceby (bernoulli (~ n)) (when 1 (and (numberp n) (equal n 0)))) (
replaceby (bernoulli (~ n)) (when (minus (quotient 1 2)) (and (numberp n) (equal
n 1)))) (replaceby (bernoulli (~ n)) (when 0 (and (numberp n) (equal (impart n)
0) (equal n (floor n)) (neq (quotient n 2) (floor (quotient n 2))) (greaterp n 0
)))) (replaceby (bernoulli (~ n)) (when (bernoulli*calc n) (and (numberp n) (
equal (impart n) 0) (equal n (floor n)) (greaterp n 0)))))

let bernoullirules;nil

operator Euler;nil

let {   Euler(0)  => 1,
        Euler(~n) => euler!:aux(n) when fixp n and n > 0};nil

symbolic operator euler!:aux;nil


% Gamma function and friends

algebraic operator gamma,psi,m_gamma;nil % m_gamma is the incomplete gamma
 % function which happens to be produced by definite integration.

flag('(gamma),'realvalued);nil

symbolic (operator do!*gamma);nil

gamma!*rules := {

   gamma(~x)  =>  1 when numberp x and x = 1,
   gamma(~x)  =>  sqrt(pi) when numberp x and x = (1/2),

   gamma(~x)  =>  factorial (x-1)
      when numberp x and impart x = 0
         and x = floor x and x > 0,

%  gamma(~x)  =>  infinity
%     when numberp x and impart x = 0
%        and x = floor x and x < 1,

   gamma(~x)  =>  gamma(x-1) * (x-1)
      when numberp x and not symbolic !*rounded
       and impart x = 0 and (64*x) = floor(64*x) and x > 1 and x < 50,

   gamma(~x)  =>  pi / (sin(pi*x) * gamma(-x) * (-x))
      when numberp x and x < 0 and not (fixp x and x < 1),

   gamma(~x)  =>  do!*gamma(x)
      when numberp x and not (fixp x and x < 1) and symbolic !*rounded,

   df(gamma(~x), x)  =>  gamma(x) * psi(x),

   df(m_gamma(~a,~x),~x) => x^(a-1)*exp(-x)
};(list (replaceby (gamma (~ x)) (when 1 (and (numberp x) (equal x 1)))) (
replaceby (gamma (~ x)) (when (sqrt pi) (and (numberp x) (equal x (quotient 1 2)
)))) (replaceby (gamma (~ x)) (when (factorial (difference x 1)) (and (numberp x
) (equal (impart x) 0) (equal x (floor x)) (greaterp x 0)))) (replaceby (gamma (
~ x)) (when (times (gamma (difference x 1)) (difference x 1)) (and (numberp x) (
not (symbolic *rounded)) (equal (impart x) 0) (equal (times 64 x) (floor (times
64 x))) (greaterp x 1) (lessp x 50)))) (replaceby (gamma (~ x)) (when (quotient
pi (times (sin (times pi x)) (gamma (minus x)) (minus x))) (and (numberp x) (
lessp x 0) (not (and (fixp x) (lessp x 1)))))) (replaceby (gamma (~ x)) (when (
do*gamma x) (and (numberp x) (not (and (fixp x) (lessp x 1))) (symbolic *rounded
)))) (replaceby (df (gamma (~ x)) x) (times (gamma x) (psi x))) (replaceby (df (
m_gamma (~ a) (~ x)) (~ x)) (times (expt x (difference a 1)) (exp (minus x)))))

let gamma!*rules;nil


% beta function

flag('(beta),'realvalued);nil

operator beta;nil

beta!*rules := {

beta(~z,~w)  =>  (gamma(z) * gamma(w)) / gamma(z+w)
   when (numberp z and numberp w and impart z = 0 and impart w = 0
         and not ((z = floor z and z < 1)
               or (w = floor w and w < 1)
               or (z+w = floor (z+w) and (z+w) < 1)))
     or (numberp z and numberp w
         and (impart z neq 0 or impart w neq 0))
     or not (numberp z and numberp w),

beta(~z,~w)  =>  0
   when numberp z and numberp w and impart z = 0 and impart w = 0
      and not ((z = floor z and z < 1)
            or (w = floor w and w < 1))
      and (z+w = floor (z+w) and (z+w) < 1)

%beta(~z,~w)  =>  Infinity
%   when numberp z and numberp w and impart z = 0 and impart w = 0
%      and ((z = floor z and z < 1)
%        or (w = floor w and w < 1))
%      and not (z+w = floor (z+w) and (z+w) < 1)

};(list (replaceby (beta (~ z) (~ w)) (when (quotient (times (gamma z) (gamma w)
) (gamma (plus z w))) (or (and (numberp z) (numberp w) (equal (impart z) 0) (
equal (impart w) 0) (not (or (and (equal z (floor z)) (lessp z 1)) (and (equal w
(floor w)) (lessp w 1)) (and (equal (plus z w) (floor (plus z w))) (lessp (plus
z w) 1))))) (and (numberp z) (numberp w) (or (neq (impart z) 0) (neq (impart w)
0))) (not (and (numberp z) (numberp w)))))) (replaceby (beta (~ z) (~ w)) (when
0 (and (numberp z) (numberp w) (equal (impart z) 0) (equal (impart w) 0) (not (
or (and (equal z (floor z)) (lessp z 1)) (and (equal w (floor w)) (lessp w 1))))
(equal (plus z w) (floor (plus z w))) (lessp (plus z w) 1)))))

let beta!*rules;nil


COMMENT Ruleset for calculating the Pochhammer symbol
        Author:  Wolfram Koepf, Freie Universitaet Berlin 1992,
        Translated to Reduce syntax by Winfried Neun, ZIB Berlin.
        Made generally safer (and uglier) by Chris Cannam, ZIB.
        ;


algebraic operator Pochhammer;nil
symbolic operator do!*pochhammer;nil

pochhammer!*rules := {

df(Pochhammer(~z,~k),~z) => Pochhammer(~z,~k) * (psi(z+k)-psi(z)),

Pochhammer(~z,~k)  =>  ( for i:=0:(k-1) product(z + i))
   when fixp k and k < 20 and k > 0,

Pochhammer(~z,~k)  =>  1
   when numberp k and k = 0,

Pochhammer(~z,~k)  => factorial(z+k-1)/factorial(z-1)
   when fixp z and z > 0 and (fixp k and k > 0 or not numberp k),

Pochhammer(~z,~k)  => (-1)^k*factorial(-z)/factorial(-z-k)
   when fixp z and z < 0 and fixp k and z+k < 0,

Pochhammer(~z,~k -1)  =>
   2 * Pochhammer(1/2,k) / (2*k -1)
      when numberp z and z = 1/2,

Pochhammer(~a,~k)  =>
   factorial(2k)/((4^k) * factorial(k))
      when numberp a and a = 1/2,

Pochhammer(~n,~k)  =>
   do!*pochhammer(n,k)
      when numberp n and numberp k
         and impart n = 0 and impart k = 0
            and n = floor n and k = floor k
               and n > -1 and k > 0,

Pochhammer(~a,~k)  =>
   do!*pochhammer(a,k)
      when symbolic !*rounded
         and numberp k and numberp a
            and impart a = 0 and impart k = 0
               and ((a neq floor a) or (a > 0))
                  and k = floor k and k > 0,

Pochhammer(~n,~k)  =>
   (-1)^k * factorial(-n) / factorial(-n-k)
      when numberp n and numberp k
         and impart n = 0
            and n = floor n and n < 1 and (-n-k) >= 0,

Pochhammer(~a,~k)  =>
   Pochhammer(2*a-1,2k)/((4^k) * Pochhammer((2 a -1)/2,k))
      when numberp a and impart a = 0
         and (a+1/2) = floor (a+1/2) and a > 0,

Pochhammer(~a,~k)  =>
   (-1)^(-a+1/2) * Pochhammer(1-a-(-a+1/2),(-a+1/2)) *
                   Pochhammer(a+(-a+1/2),k-(-a+1/2))
      when numberp a and impart a = 0
         and (a+1/2) = floor (a+1/2) and a < 0

};(list (replaceby (df (pochhammer (~ z) (~ k)) (~ z)) (times (pochhammer (~ z)
(~ k)) (difference (psi (plus z k)) (psi z)))) (replaceby (pochhammer (~ z) (~ k
)) (when (prog (i forall-result) (setq i 0) (setq forall-result 1) lab1 (cond ((
aminusp: (list (quote difference) (aeval* (list (quote difference) (quote k) 1))
i)) (return forall-result))) (setq forall-result (aeval* (list (quote times) (
aeval* (list (quote plus) (quote z) i)) forall-result))) (setq i ((lambda (
forall-result) (aeval* (list (quote plus) forall-result 1))) i)) (go lab1)) (and
(fixp k) (lessp k 20) (greaterp k 0)))) (replaceby (pochhammer (~ z) (~ k)) (
when 1 (and (numberp k) (equal k 0)))) (replaceby (pochhammer (~ z) (~ k)) (when
(quotient (factorial (plus z (difference k 1))) (factorial (difference z 1))) (
and (fixp z) (greaterp z 0) (or (and (fixp k) (greaterp k 0)) (not (numberp k)))
))) (replaceby (pochhammer (~ z) (~ k)) (when (times (expt -1 k) (quotient (
factorial (minus z)) (factorial (difference (minus z) k)))) (and (fixp z) (lessp
z 0) (fixp k) (lessp (plus z k) 0)))) (replaceby (pochhammer (~ z) (difference (
~ k) 1)) (when (times 2 (quotient (pochhammer (quotient 1 2) k) (difference (
times 2 k) 1))) (and (numberp z) (equal z (quotient 1 2))))) (replaceby (
pochhammer (~ a) (~ k)) (when (quotient (factorial (times 2 k)) (times (expt 4 k
) (factorial k))) (and (numberp a) (equal a (quotient 1 2))))) (replaceby (
pochhammer (~ n) (~ k)) (when (do*pochhammer n k) (and (numberp n) (numberp k) (
equal (impart n) 0) (equal (impart k) 0) (equal n (floor n)) (equal k (floor k))
(greaterp n (minus 1)) (greaterp k 0)))) (replaceby (pochhammer (~ a) (~ k)) (
when (do*pochhammer a k) (and (symbolic *rounded) (numberp k) (numberp a) (equal
(impart a) 0) (equal (impart k) 0) (or (neq a (floor a)) (greaterp a 0)) (equal
k (floor k)) (greaterp k 0)))) (replaceby (pochhammer (~ n) (~ k)) (when (times
(expt -1 k) (quotient (factorial (minus n)) (factorial (difference (minus n) k))
)) (and (numberp n) (numberp k) (equal (impart n) 0) (equal n (floor n)) (lessp
n 1) (geq (difference (minus n) k) 0)))) (replaceby (pochhammer (~ a) (~ k)) (
when (quotient (pochhammer (difference (times 2 a) 1) (times 2 k)) (times (expt
4 k) (pochhammer (quotient (difference (times 2 a) 1) 2) k))) (and (numberp a) (
equal (impart a) 0) (equal (plus a (quotient 1 2)) (floor (plus a (quotient 1 2)
))) (greaterp a 0)))) (replaceby (pochhammer (~ a) (~ k)) (when (times (expt -1
(plus (minus a) (quotient 1 2))) (pochhammer (difference (difference 1 a) (plus
(minus a) (quotient 1 2))) (plus (minus a) (quotient 1 2))) (pochhammer (plus a
(minus a) (quotient 1 2)) (difference k (plus (minus a) (quotient 1 2))))) (and
(numberp a) (equal (impart a) 0) (equal (plus a (quotient 1 2)) (floor (plus a (
quotient 1 2)))) (lessp a 0)))))

special!*pochhammer!*rules := {

        % these special rules are normally disabled because
        % they produce a lot of load for the algebraic mode

Pochhammer(~a,~k)*Pochhammer(~b,~k)  =>
   Pochhammer(2a,2k)/(4^k)
      when (b-a)=1/2,

Pochhammer(~a,~k)  =>
   (-1)^(-a+1/2) * Pochhammer(1-a-(-a+1/2),-a+1/2) *
      Pochhammer(a +(-a +1/2),k-(-a+1/2))
         when numberp a and impart a = 0
            and (a+1/2) = floor (a+1/2) and a<0,

Pochhammer(~z,~k) * Pochhammer(~cz,~k)  =>
   do!*poch!*conj!*calc(z,k)
      when numberp z and numberp cz and numberp k
         and not(impart z = 0) and z = conj cz
            and impart k = 0 and k = floor k and k >= 0,

Pochhammer(~a,~k)*Pochhammer(~aa,~k)  =>
   factorial(3 k)/(factorial(k) * 27^k)
      when numberp a and a = 1/3 and numberp aa and aa = 2/3,

Pochhammer(~a,~k) * Pochhammer(~aa,~k)  =>
   factorial(1 + 3 k)/(27 ^k * factorial(k))
      when numberp a and a = 2/3 and numberp aa and aa = 4/3,

Pochhammer(~b,~k) * Pochhammer(~c,~k)  =>
   Pochhammer(3*b,3*k)/( 27^k * Pochhammer(b +2/3,k))
      when numberp b and numberp c
         and (c-b)=1/3 and (b-1/3) = floor (b-1/3) and not (b-1/3 = 0),

Pochhammer(~a,~k)*Pochhammer(~aa,~k)*Pochhammer(~aaa,~k)  =>
   factorial(4*k)/(factorial(k) * 64^k)
      when numberp a and numberp aa and numberp aaa
         and a = 1/4 and aa = 1/2 and aaa = 3/4,

Pochhammer(~a,~k)*Pochhammer(~aa,~k)*
      Pochhammer(~aaa,~k)*Pochhammer(~aaaa,~k)  =>
   factorial(5*k)/(factorial(k) * 3125^k)
      when numberp a and numberp aa
         and numberp aaa and numberp aaaa
            and a = 1/5 and aa = 2/5 and aaa = 3/5 and aaaa = 4/5,

Pochhammer(~a,~k)*Pochhammer(~aa,~k)*
      Pochhammer(~aaa,~k)*Pochhammer(~aaaa,~k)  =>
   5*(1/5 +k)*factorial(5*k)/(factorial(k) * 3125^k)
      when numberp a and numberp aa
         and numberp aaa and numberp aaaa
            and a = 2/5 and aa = 3/5 and aaa = 4/5 and aaaa = 6/5,

Pochhammer(~a,~k)*Pochhammer(~aa,~k)*
      Pochhammer(~aaa,~k)*Pochhammer(~aaaa,~k)  =>
   (25 *(1/5+k)*(2/5 +k)*factorial(5*k)) / (factorial(k) * 2* 3125^k)
      when numberp a and numberp aa
         and numberp aaa and numberp aaaa
            and a = 3/5 and aa = 4/5 and aaa = 6/5 and aaaa = 7/5,

Pochhammer(~a,~k)*Pochhammer(~aa,~k)*
      Pochhammer(~aaa,~k)*Pochhammer(~aaaa,~k)  =>
   (125*(1/5+k)*(2/5+k)*(3/5+k)*factorial(5*k)) /
      (factorial(k) * 6 *3125^k)
         when numberp a and numberp aa
            and numberp aaa and numberp aaaa
               and a = 4/5 and aa = 6/5 and aaa = 7/5 and aaaa = 8/5,

Pochhammer(~a,~k)*Pochhammer(~aa,~k)*
      Pochhammer(~aaa,~k)*Pochhammer(~aaaa,~k)  =>
   (625*(1/5+k)*(2/5+k)*(3/5+k)*(4/5+k)*factorial(5*k)) /
      (factorial(k) * 24 *3125^k)
         when numberp a and numberp aa
            and numberp aaa and numberp aaaa
               and a = 6/5 and aa = 7/5 and aaa = 8/5 and aaaa = 9/5,

Pochhammer(~a,~k)//Pochhammer(~b,~k)  => (a + k -1)/(a - 1)
                        when (a - b)=1,

Pochhammer(~a,~k)//Pochhammer(~b,~k)  => (b - 1)/(b + k -1)
                        when (b - a)=1
};(list (replaceby (times (pochhammer (~ a) (~ k)) (pochhammer (~ b) (~ k))) (
when (quotient (pochhammer (times 2 a) (times 2 k)) (expt 4 k)) (equal (
difference b a) (quotient 1 2)))) (replaceby (pochhammer (~ a) (~ k)) (when (
times (expt -1 (plus (minus a) (quotient 1 2))) (pochhammer (difference (
difference 1 a) (plus (minus a) (quotient 1 2))) (plus (minus a) (quotient 1 2))
) (pochhammer (plus a (minus a) (quotient 1 2)) (difference k (plus (minus a) (
quotient 1 2))))) (and (numberp a) (equal (impart a) 0) (equal (plus a (quotient
1 2)) (floor (plus a (quotient 1 2)))) (lessp a 0)))) (replaceby (times (
pochhammer (~ z) (~ k)) (pochhammer (~ cz) (~ k))) (when (do*poch*conj*calc z k)
(and (numberp z) (numberp cz) (numberp k) (not (equal (impart z) 0)) (equal z (
conj cz)) (equal (impart k) 0) (equal k (floor k)) (geq k 0)))) (replaceby (
times (pochhammer (~ a) (~ k)) (pochhammer (~ aa) (~ k))) (when (quotient (
factorial (times 3 k)) (times (factorial k) (expt 27 k))) (and (numberp a) (
equal a (quotient 1 3)) (numberp aa) (equal aa (quotient 2 3))))) (replaceby (
times (pochhammer (~ a) (~ k)) (pochhammer (~ aa) (~ k))) (when (quotient (
factorial (plus 1 (times 3 k))) (times (expt 27 k) (factorial k))) (and (numberp
a) (equal a (quotient 2 3)) (numberp aa) (equal aa (quotient 4 3))))) (replaceby
(times (pochhammer (~ b) (~ k)) (pochhammer (~ c) (~ k))) (when (quotient (
pochhammer (times 3 b) (times 3 k)) (times (expt 27 k) (pochhammer (plus b (
quotient 2 3)) k))) (and (numberp b) (numberp c) (equal (difference c b) (
quotient 1 3)) (equal (difference b (quotient 1 3)) (floor (difference b (
quotient 1 3)))) (not (equal (difference b (quotient 1 3)) 0))))) (replaceby (
times (pochhammer (~ a) (~ k)) (pochhammer (~ aa) (~ k)) (pochhammer (~ aaa) (~
k))) (when (quotient (factorial (times 4 k)) (times (factorial k) (expt 64 k)))
(and (numberp a) (numberp aa) (numberp aaa) (equal a (quotient 1 4)) (equal aa (
quotient 1 2)) (equal aaa (quotient 3 4))))) (replaceby (times (pochhammer (~ a)
(~ k)) (pochhammer (~ aa) (~ k)) (pochhammer (~ aaa) (~ k)) (pochhammer (~ aaaa)
(~ k))) (when (quotient (factorial (times 5 k)) (times (factorial k) (expt 3125
k))) (and (numberp a) (numberp aa) (numberp aaa) (numberp aaaa) (equal a (
quotient 1 5)) (equal aa (quotient 2 5)) (equal aaa (quotient 3 5)) (equal aaaa
(quotient 4 5))))) (replaceby (times (pochhammer (~ a) (~ k)) (pochhammer (~ aa)
(~ k)) (pochhammer (~ aaa) (~ k)) (pochhammer (~ aaaa) (~ k))) (when (times 5 (
plus (quotient 1 5) k) (quotient (factorial (times 5 k)) (times (factorial k) (
expt 3125 k)))) (and (numberp a) (numberp aa) (numberp aaa) (numberp aaaa) (
equal a (quotient 2 5)) (equal aa (quotient 3 5)) (equal aaa (quotient 4 5)) (
equal aaaa (quotient 6 5))))) (replaceby (times (pochhammer (~ a) (~ k)) (
pochhammer (~ aa) (~ k)) (pochhammer (~ aaa) (~ k)) (pochhammer (~ aaaa) (~ k)))
(when (quotient (times 25 (plus (quotient 1 5) k) (plus (quotient 2 5) k) (
factorial (times 5 k))) (times (factorial k) 2 (expt 3125 k))) (and (numberp a)
(numberp aa) (numberp aaa) (numberp aaaa) (equal a (quotient 3 5)) (equal aa (
quotient 4 5)) (equal aaa (quotient 6 5)) (equal aaaa (quotient 7 5))))) (
replaceby (times (pochhammer (~ a) (~ k)) (pochhammer (~ aa) (~ k)) (pochhammer
(~ aaa) (~ k)) (pochhammer (~ aaaa) (~ k))) (when (quotient (times 125 (plus (
quotient 1 5) k) (plus (quotient 2 5) k) (plus (quotient 3 5) k) (factorial (
times 5 k))) (times (factorial k) 6 (expt 3125 k))) (and (numberp a) (numberp aa
) (numberp aaa) (numberp aaaa) (equal a (quotient 4 5)) (equal aa (quotient 6 5)
) (equal aaa (quotient 7 5)) (equal aaaa (quotient 8 5))))) (replaceby (times (
pochhammer (~ a) (~ k)) (pochhammer (~ aa) (~ k)) (pochhammer (~ aaa) (~ k)) (
pochhammer (~ aaaa) (~ k))) (when (quotient (times 625 (plus (quotient 1 5) k) (
plus (quotient 2 5) k) (plus (quotient 3 5) k) (plus (quotient 4 5) k) (
factorial (times 5 k))) (times (factorial k) 24 (expt 3125 k))) (and (numberp a)
(numberp aa) (numberp aaa) (numberp aaaa) (equal a (quotient 6 5)) (equal aa (
quotient 7 5)) (equal aaa (quotient 8 5)) (equal aaaa (quotient 9 5))))) (
replaceby (slash (pochhammer (~ a) (~ k)) (pochhammer (~ b) (~ k))) (when (
quotient (plus a (difference k 1)) (difference a 1)) (equal (difference a b) 1))
) (replaceby (slash (pochhammer (~ a) (~ k)) (pochhammer (~ b) (~ k))) (when (
quotient (difference b 1) (plus b (difference k 1))) (equal (difference b a) 1))
))

let pochhammer!*rules;nil


% from specfn/sfpsi.red

algebraic operator polygamma;nil

flag('(psi polygamma),'realvalued);nil

symbolic operator psi!:error;nil

psi!*rules := {

   psi(~n,~z) => polygamma(n,z),

   psi(~z)  =>  psi!:error(z)
      when repart z = floor repart z and impart z = 0 and z < 1,

   psi(1)   =>  -Euler_gamma,
   psi(1/2) =>  -Euler_gamma - 2 * log(2),

%   psi(~z)  =>  -Euler_gamma
%      when numberp z and z = 1
%               and symbolic !*rounded and precision(0) < 501,
%
%   psi(~z)  =>  -Euler_gamma - 2 * log(2)
%      when numberp z and z = (1/2)
%               and symbolic !*rounded and precision(0) < 501,
%
%   psi(~z)  =>  do!*psi(z)
%      when numberp z and impart z = 0 and symbolic !*rounded,

   psi(~z)  =>  (psi(z/2) + psi((z+1)/2) + 2 * log(2)) / 2
      when numberp z and impart z = 0
               and (z/2) = floor (z/2)
                  and z > 0, % and not symbolic !*rounded,

   psi(~z)  =>  psi(z-1) + (1 / (z-1))
      when numberp z and impart z = 0
               and z > 1, % and not symbolic !*rounded,

   psi(~z)  =>  psi(1-z) + pi*cot(pi*(1-z))
      when numberp z and impart z = 0
               and (z < 0 and not fixp z or z > 1/2 and z < 1), % and not symbolic !*rounded,

   df(psi(~z),z)  =>  polygamma(1, z)

%% moved to int/driver.red
%%   int(psi(~z),z)  =>  log gamma(~z)

};(list (replaceby (psi (~ n) (~ z)) (polygamma n z)) (replaceby (psi (~ z)) (
when (psi:error z) (and (equal (repart z) (floor (repart z))) (equal (impart z)
0) (lessp z 1)))) (replaceby (psi 1) (minus euler_gamma)) (replaceby (psi (
quotient 1 2)) (difference (minus euler_gamma) (times 2 (log 2)))) (replaceby (
psi (~ z)) (when (quotient (plus (psi (quotient z 2)) (psi (quotient (plus z 1)
2)) (times 2 (log 2))) 2) (and (numberp z) (equal (impart z) 0) (equal (quotient
z 2) (floor (quotient z 2))) (greaterp z 0)))) (replaceby (psi (~ z)) (when (
plus (psi (difference z 1)) (quotient 1 (difference z 1))) (and (numberp z) (
equal (impart z) 0) (greaterp z 1)))) (replaceby (psi (~ z)) (when (plus (psi (
difference 1 z)) (times pi (cot (times pi (difference 1 z))))) (and (numberp z)
(equal (impart z) 0) (or (and (lessp z 0) (not (fixp z))) (and (greaterp z (
quotient 1 2)) (lessp z 1)))))) (replaceby (df (psi (~ z)) z) (polygamma 1 z)))

let psi!*rules;nil

psi_rules := {
   % Rule for integer shifts (x + 3), and non-integer shifts (x + 3/2)in
   % a non-integer number domain (on rational) or with "on intstr, div":
   psi(~x+~n) => psi(x+n-1) + 1/(x+n-1) when numberp n and n >= 1,
   psi(~x+~n) => psi(x+n+1) - 1/(x+n) when numberp n and n < 0,
   polygamma(~m,~x+~n) => polygamma(m,x+n-1)+(-1)^m*factorial(m)
        /(x+n-1)^(m+1) when numberp n and fixp m and n >= 1,
   polygamma(~m,~x+~n) => polygamma(m,x+n+1)-(-1)^(m)*factorial(m)
        /(x+n)^(m+1) when numberp n and fixp m and n < 0,
   % Rule for rational shifts (x + 3/2) in the default (integer) number
   % domain and rational arguments (x/y + 3):
   psi((~x+~n)/~d) => psi((x+n-d)/d) + d/(x+n-d) when
      numberp(n/d) and n/d >= 1,
   psi((~x+~n)/~d) => psi((x+n+d)/d) - d/(x+n) when
      numberp(n/d) and n/d < 0,
   polygamma(~m,(~x+~n)/~d) => polygamma(m,(x+n-d)/d) +
      (-1)^m*factorial(m)*d^(m+1)/(x+n-d)^(m+1) when
      fixp m and numberp(n/d) and n/d >= 1,
   polygamma(~m,(~x+~n)/~d) => polygamma(m,(x+n+d)/d) -
      (-1)^m*factorial(m)*d^(m+1)/(x+n)^(m+1) when
      fixp m and numberp(n/d) and n/d < 0
};(list (replaceby (psi (plus (~ x) (~ n))) (when (plus (psi (plus x (difference
n 1))) (quotient 1 (plus x (difference n 1)))) (and (numberp n) (geq n 1)))) (
replaceby (psi (plus (~ x) (~ n))) (when (difference (psi (plus x n 1)) (
quotient 1 (plus x n))) (and (numberp n) (lessp n 0)))) (replaceby (polygamma (~
m) (plus (~ x) (~ n))) (when (plus (polygamma m (plus x (difference n 1))) (
times (expt -1 m) (quotient (factorial m) (expt (plus x (difference n 1)) (plus
m 1))))) (and (numberp n) (fixp m) (geq n 1)))) (replaceby (polygamma (~ m) (
plus (~ x) (~ n))) (when (difference (polygamma m (plus x n 1)) (times (expt -1
m) (quotient (factorial m) (expt (plus x n) (plus m 1))))) (and (numberp n) (
fixp m) (lessp n 0)))) (replaceby (psi (quotient (plus (~ x) (~ n)) (~ d))) (
when (plus (psi (quotient (plus x (difference n d)) d)) (quotient d (plus x (
difference n d)))) (and (numberp (quotient n d)) (geq (quotient n d) 1)))) (
replaceby (psi (quotient (plus (~ x) (~ n)) (~ d))) (when (difference (psi (
quotient (plus x n d) d)) (quotient d (plus x n))) (and (numberp (quotient n d))
(lessp (quotient n d) 0)))) (replaceby (polygamma (~ m) (quotient (plus (~ x) (~
n)) (~ d))) (when (plus (polygamma m (quotient (plus x (difference n d)) d)) (
times (expt -1 m) (factorial m) (quotient (expt d (plus m 1)) (expt (plus x (
difference n d)) (plus m 1))))) (and (fixp m) (numberp (quotient n d)) (geq (
quotient n d) 1)))) (replaceby (polygamma (~ m) (quotient (plus (~ x) (~ n)) (~
d))) (when (difference (polygamma m (quotient (plus x n d) d)) (times (expt -1 m
) (factorial m) (quotient (expt d (plus m 1)) (expt (plus x n) (plus m 1))))) (
and (fixp m) (numberp (quotient n d)) (lessp (quotient n d) 0)))))
% NOTE: The rational-shift rule does not work with "on intstr, div".

let psi_rules;nil

put('psi,'!:rd!:,'rdpsi!*);rdpsi*
put('psi,'!:cr!:,'crpsi!*);crpsi*

symbolic operator polygamma!*calc, trigamma!*halves, polygamma!:error,
                  polygamma_aux;nil

polygamma!*rules := {

   polygamma(~n,~x)  =>  polygamma!:error(n,x)
        when numberp n and (not fixp n or n < -1),

   polygamma(0,~x) => psi(x),
%   polygamma(~n,~x)  =>  psi(x)
%      when numberp n and n = 0,

   polygamma(~n,~x)  =>  polygamma!:error(n,x)
      when numberp x and impart x = 0 and x = floor x and x < 1,

   polygamma(~n,~x)  =>  do!*trigamma!*halves(x)
      when numberp n and n = 1 and numberp x and impart x = 0
               and (not (x = floor x) and ((2*x) = floor (2*x))) and x > 1,

   polygamma(~n,~x)  =>  ((-1) ** (n)) * (factorial n) * (- zeta(n+1) +
                         polygamma_aux(x,n))
      when fixp x and x >= 1 and not symbolic !*rounded,

   polygamma(~n,~x)  => ((-1)**n) * factorial n * (-2 * (2**n) *
               zeta(n+1) + 2 * (2**n) + zeta(n+1))
      when numberp x and x = (3/2) and not symbolic !*rounded,

   polygamma(~n,~x)  =>  do!*polygamma(n,x)
      when numberp x and symbolic !*rounded
               and not (fixp x and x <= 0)
               and numberp n and impart n = 0 and n = floor n,

   df(polygamma(~n,~x), ~x)  =>  polygamma(n+1, x)

%% moved to int/driver.red
%%   int(polygamma(~n,~x),~x)  =>  polygamma(n-1,x)

};(list (replaceby (polygamma (~ n) (~ x)) (when (polygamma:error n x) (and (
numberp n) (or (not (fixp n)) (lessp n (minus 1)))))) (replaceby (polygamma 0 (~
x)) (psi x)) (replaceby (polygamma (~ n) (~ x)) (when (polygamma:error n x) (and
(numberp x) (equal (impart x) 0) (equal x (floor x)) (lessp x 1)))) (replaceby (
polygamma (~ n) (~ x)) (when (do*trigamma*halves x) (and (numberp n) (equal n 1)
(numberp x) (equal (impart x) 0) (and (not (equal x (floor x))) (equal (times 2
x) (floor (times 2 x)))) (greaterp x 1)))) (replaceby (polygamma (~ n) (~ x)) (
when (times (expt -1 n) (factorial n) (plus (minus (zeta (plus n 1))) (
polygamma_aux x n))) (and (fixp x) (geq x 1) (not (symbolic *rounded))))) (
replaceby (polygamma (~ n) (~ x)) (when (times (expt -1 n) (factorial n) (plus (
minus (times 2 (expt 2 n) (zeta (plus n 1)))) (times 2 (expt 2 n)) (zeta (plus n
1)))) (and (numberp x) (equal x (quotient 3 2)) (not (symbolic *rounded))))) (
replaceby (polygamma (~ n) (~ x)) (when (do*polygamma n x) (and (numberp x) (
symbolic *rounded) (not (and (fixp x) (leq x 0))) (numberp n) (equal (impart n)
0) (equal n (floor n))))) (replaceby (df (polygamma (~ n) (~ x)) (~ x)) (
polygamma (plus n 1) x)))

let polygamma!*rules;nil


symbolic operator zeta!*calc, zeta!*pos!*intcalc;nil

zeta!*rules := {

   zeta(~x)  =>  (- (1/2))
      when numberp x and x = 0,

   zeta(~x)  =>  (pi ** 2) / 6
      when numberp x and x = 2,

   zeta(~x)  =>  (pi ** 4) / 90
      when numberp x and x = 4,

   zeta(~x)  =>  infinity
      when numberp x and x = 1,

   zeta(~x)  =>  0
      when numberp x and impart x = 0 and x < 0 and (x/2) = floor(x/2),

   zeta(~x)  =>  ((2*pi)**x) / (2*factorial x)*(abs bernoulli!*calc x)
      when numberp x and impart x = 0 and x > 0
               and (x/2) = floor (x/2) and x < 31,

   zeta(~x)  =>  - (bernoulli!*calc (1-x)) / (1-x)
      when numberp x and impart x = 0 and x < 0
               and x = floor x and x > -31,

   zeta(~x)  =>  ((2*pi)**x)/(2 * factorial x)*(abs bernoulli!*calc x)
      when numberp x and impart x = 0 and x > 0
               and (x/2) = floor(x/2) and x < 201 and symbolic !*rounded,

   zeta(~x)  =>  - (bernoulli!*calc (1-x)) / (1-x)
      when numberp x and impart x = 0 and x < 0
               and x = floor x and x > -201 and symbolic !*rounded,

   zeta(~x)  =>  (2**x)*(pi**(x-1))*sin(pi*x/2)*gamma(1-x)*zeta(1-x)
      when numberp x and impart x = 0 and x < 0
               and (x neq floor x or x < -200) and symbolic !*rounded,

   zeta(~x)  =>  do!*zeta!*pos!*intcalc(fix x)
      when symbolic !*rounded and numberp x and impart(x) = 0 and x > 1
               and x = floor x and (x <= 15 or precision 0 > 100
                  or 2*x < precision 0),

   zeta(~x)  =>  do!*zeta(x)
      when numberp x and impart x = 0% and x > 1
               and symbolic !*rounded,

   df(zeta(~x),x)  =>  -(1/2)*log(2*pi)
      when numberp x and x = 0

};(list (replaceby (zeta (~ x)) (when (minus (quotient 1 2)) (and (numberp x) (
equal x 0)))) (replaceby (zeta (~ x)) (when (quotient (expt pi 2) 6) (and (
numberp x) (equal x 2)))) (replaceby (zeta (~ x)) (when (quotient (expt pi 4) 90
) (and (numberp x) (equal x 4)))) (replaceby (zeta (~ x)) (when infinity (and (
numberp x) (equal x 1)))) (replaceby (zeta (~ x)) (when 0 (and (numberp x) (
equal (impart x) 0) (lessp x 0) (equal (quotient x 2) (floor (quotient x 2))))))
(replaceby (zeta (~ x)) (when (times (quotient (expt (times 2 pi) x) (times 2 (
factorial x))) (abs (bernoulli*calc x))) (and (numberp x) (equal (impart x) 0) (
greaterp x 0) (equal (quotient x 2) (floor (quotient x 2))) (lessp x 31)))) (
replaceby (zeta (~ x)) (when (minus (quotient (bernoulli*calc (difference 1 x))
(difference 1 x))) (and (numberp x) (equal (impart x) 0) (lessp x 0) (equal x (
floor x)) (greaterp x (minus 31))))) (replaceby (zeta (~ x)) (when (times (
quotient (expt (times 2 pi) x) (times 2 (factorial x))) (abs (bernoulli*calc x))
) (and (numberp x) (equal (impart x) 0) (greaterp x 0) (equal (quotient x 2) (
floor (quotient x 2))) (lessp x 201) (symbolic *rounded)))) (replaceby (zeta (~
x)) (when (minus (quotient (bernoulli*calc (difference 1 x)) (difference 1 x)))
(and (numberp x) (equal (impart x) 0) (lessp x 0) (equal x (floor x)) (greaterp
x (minus 201)) (symbolic *rounded)))) (replaceby (zeta (~ x)) (when (times (expt
2 x) (expt pi (difference x 1)) (sin (times pi (quotient x 2))) (gamma (
difference 1 x)) (zeta (difference 1 x))) (and (numberp x) (equal (impart x) 0)
(lessp x 0) (or (neq x (floor x)) (lessp x (minus 200))) (symbolic *rounded))))
(replaceby (zeta (~ x)) (when (do*zeta*pos*intcalc (fix x)) (and (symbolic
*rounded) (numberp x) (equal (impart x) 0) (greaterp x 1) (equal x (floor x)) (
or (leq x 15) (greaterp (precision 0) 100) (lessp (times 2 x) (precision 0))))))
(replaceby (zeta (~ x)) (when (do*zeta x) (and (numberp x) (equal (impart x) 0)
(symbolic *rounded)))) (replaceby (df (zeta (~ x)) x) (when (minus (times (
quotient 1 2) (log (times 2 pi)))) (and (numberp x) (equal x 0)))))

let zeta!*rules;nil


% from specfn/sfigamma.red

operator igamma, ibeta;nil

% Set up rule definitions for igamma and ibeta functions.

let
{
 igamma(~a,~x) => igamma!:eval(a,x)
        when numberp(a) and numberp(x) and a>0 and x>=0 and lisp !*rounded,

% The following is only true for a>0
 igamma(~a,0) => 0 when numberp(a) and a>0,

% igamma(0,~x) => -ei(-x),

 igamma(~a,~x) => erf(sqrt(x)) when numberp(a) and a=1/2,

 igamma(1,~x) => 1-exp(-x),

 df(igamma(~a,~x),~x) => x^(a-1)*exp(-x) / gamma(a)
};nil

let
{
 ibeta(~a,~b,~x) => ibeta!:eval(a,b,x)
        when numberp(a) and numberp(b) and numberp(x) and lisp !*rounded
             and repart(a)>0 and repart(b)>0 and x>=0 and x<=1,

 ibeta(~a,1,~x) => x^a,
 ibeta(1,~b,~x) => 1 - (1-x)^b,

 df(ibeta(~a,~b,~x),~x) => (1-x)^(b-1)*x^(a-1) / beta(a,b),

 ibeta(~a,~b,~x) => int(t^(a-1)*(1-t)^(b-1),t,0,x) / beta(a,b)
        when numberp a and fixp a and a>0 and a<6 and
             numberp b and fixp b and b>0 and b<6

};nil

endmodule;nil

end;nil
nil


(load!-package!-sources 'arith 'arith)module arith;nil  % Header module for real arith package.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% Last updated Dec 14, 1992

% Assumptions being made on the underlying arithmetic:
%
% (1) The integer arithmetic is binary.
%
% (2) It is possible to convert any lisp float into an integer
%     by applying fix, and this yields the result with the full
%     precision of the float.
%


create!-package('(arith smlbflot bfauxil paraset math rounded comprd
                  rdelem crelem bfelem), nil);
+++ Creating a package: arith
arith

flag('(arith),'core_package);nil

exports ashift, bfloat, bfminusp, bfnzp, bfp!:, bfzp, crim, crrl,
        divbf, ep!:, gfzerop, i2bf!:, lshift, make!:cr, make!:ibf,
        make!:rd, msd!:, mt!:, oddintp, preci!:, rdp, retag, rndpwr,
        sgn, tagrl, tagim, timbf;nil

imports eqcar, round!:mt;nil

global '(!!minnorm !!minnegnorm);nil

fluid '(!*noconvert !:bprec!: dmode!*);nil


switch noconvert;nil

symbolic inline procedure mt!: u;
   % This function selects the mantissa of U, a binary bigfloat
   % representation of a number.
   cadr u;
+++ Record new inline definition:
(de mt!: (u) (cadr u))
(progn (de mt!: (u) (cadr u)) (put (quote mt!:) (quote number!-of!-args) 1) (put
(quote mt!:) (quote procedure_type) (quote (arrow general general))) (putc (
quote mt!:) (quote inline) (quote (lambda (u) (cadr u)))))
+++ mt!: compiled as link to cadr
(lambda (u) (cadr u))

symbolic inline procedure ep!: u;
   % This function selects the exponent of U, a binary bigfloat
   % representation of a number.
   cddr u;
+++ Record new inline definition:
(de ep!: (u) (cddr u))
(progn (de ep!: (u) (cddr u)) (put (quote ep!:) (quote number!-of!-args) 1) (put
(quote ep!:) (quote procedure_type) (quote (arrow general general))) (putc (
quote ep!:) (quote inline) (quote (lambda (u) (cddr u)))))
+++ ep!: compiled as link to cddr
(lambda (u) (cddr u))

symbolic inline procedure make!:ibf (mt, ep);
   '!:rd!: . (mt . ep);
*** make:ibf not defined (LOSE flag) 
nil

symbolic inline procedure i2bf!: u; make!:ibf (u, 0);
+++ Record new inline definition:
(de i2bf!: (u) (cons (quote !:rd!:) (cons u 0)))
(progn (de i2bf!: (u) (cons (quote !:rd!:) (cons u 0))) (put (quote i2bf!:) (
quote number!-of!-args) 1) (put (quote i2bf!:) (quote procedure_type) (quote (
arrow general general))) (putc (quote i2bf!:) (quote inline) (quote (lambda (u)
(cons (quote !:rd!:) (cons u 0))))))
+++ i2bf!: compiled, 6 + 16 bytes
(lambda (u) (cons (quote :rd:) (cons u 0)))

symbolic inline procedure make!:rd u;
   '!:rd!: . u;
+++ Record new inline definition:
(de make!:rd (u) (cons (quote !:rd!:) u))
(progn (de make!:rd (u) (cons (quote !:rd!:) u)) (put (quote make!:rd) (quote
number!-of!-args) 1) (put (quote make!:rd) (quote procedure_type) (quote (arrow
general general))) (putc (quote make!:rd) (quote inline) (quote (lambda (u) (
cons (quote !:rd!:) u)))))
+++ make!:rd compiled, 4 + 12 bytes
(lambda (u) (cons (quote :rd:) u))

symbolic inline procedure rdp x;
   % This function returns true if X is a rounded number
   % representation, else NIL.  X is any Lisp entity.
   eqcar(x,'!:rd!:);
+++ Record new inline definition:
(de rdp (x) (eqcar x (quote !:rd!:)))
(progn (de rdp (x) (eqcar x (quote !:rd!:))) (put (quote rdp) (quote
number!-of!-args) 1) (put (quote rdp) (quote procedure_type) (quote (arrow
general general))) (putc (quote rdp) (quote inline) (quote (lambda (x) (eqcar x
(quote !:rd!:))))))
+++ rdp compiled, 4 + 12 bytes
(lambda (x) (eqcar x (quote :rd:)))

symbolic inline procedure float!-bfp x; atom cdr x;
+++ Record new inline definition:
(de float!-bfp (x) (atom (cdr x)))
(progn (de float!-bfp (x) (atom (cdr x))) (put (quote float!-bfp) (quote
number!-of!-args) 1) (put (quote float!-bfp) (quote procedure_type) (quote (
arrow general general))) (putc (quote float!-bfp) (quote inline) (quote (lambda
(x) (atom (cdr x))))))
+++ float!-bfp compiled, 4 + 8 bytes
(lambda (x) (atom (cdr x)))

symbolic inline procedure rd2fl x; cdr x;
+++ Record new inline definition:
(de rd2fl (x) (cdr x))
(progn (de rd2fl (x) (cdr x)) (put (quote rd2fl) (quote number!-of!-args) 1) (
put (quote rd2fl) (quote procedure_type) (quote (arrow general general))) (putc
(quote rd2fl) (quote inline) (quote (lambda (x) (cdr x)))))
+++ rd2fl compiled as link to cdr
(lambda (x) (cdr x))

symbolic inline procedure fl2rd x; make!:rd x;
+++ Record new inline definition:
(de fl2rd (x) (cons (quote !:rd!:) x))
(progn (de fl2rd (x) (cons (quote !:rd!:) x)) (put (quote fl2rd) (quote
number!-of!-args) 1) (put (quote fl2rd) (quote procedure_type) (quote (arrow
general general))) (putc (quote fl2rd) (quote inline) (quote (lambda (x) (cons (
quote !:rd!:) x)))))
+++ fl2rd compiled, 4 + 12 bytes
(lambda (x) (cons (quote :rd:) x))

symbolic inline procedure bfp!:(x);
   % This function returns true if X is a binary bigfloat
   % representation, else NIL.  X is any Lisp entity.
   rdp x and not float!-bfp x;
+++ Record new inline definition:
(de bfp!: (x) (and (eqcar x (quote !:rd!:)) (not (atom (cdr x)))))
(progn (de bfp!: (x) (and (eqcar x (quote !:rd!:)) (not (atom (cdr x))))) (put (
quote bfp!:) (quote number!-of!-args) 1) (put (quote bfp!:) (quote
procedure_type) (quote (arrow general general))) (putc (quote bfp!:) (quote
inline) (quote (lambda (x) (and (eqcar x (quote !:rd!:)) (not (atom (cdr x))))))
))
+++ bfp!: compiled, 11 + 16 bytes
(lambda (x) (and (eqcar x (quote :rd:)) (not (atom (cdr x)))))

symbolic inline procedure retag u;
   if atom u then u else '!:rd!: . u;
+++ Record new inline definition:
(de retag (u) (cond ((atom u) u) (t (cons (quote !:rd!:) u))))
(progn (de retag (u) (cond ((atom u) u) (t (cons (quote !:rd!:) u)))) (put (
quote retag) (quote number!-of!-args) 1) (put (quote retag) (quote
procedure_type) (quote (arrow general general))) (putc (quote retag) (quote
inline) (quote (lambda (u) (cond ((atom u) u) (t (cons (quote !:rd!:) u)))))))
+++ retag compiled, 7 + 12 bytes
(lambda (u) (cond ((atom u) u) (t (cons (quote :rd:) u))))

symbolic inline procedure rndpwr j; normbf round!:mt(j,!:bprec!:);
*** rndpwr not defined (LOSE flag) 
nil

symbolic procedure msd!: m;
  % returns the position n of the most significant (binary) digit
  % of a positive binary integer m, i.e. floor(log2 m) + 1
  begin integer i,j,k;
    j := m;
    while (j := ((k := j) / 65536)) neq 0 do i := i + 16;
    j := k;
    while (j := ((k := j) / 256)) neq 0 do i := i + 8;
    j := k;
    while (j := ((k := j) / 16)) neq 0 do i := i + 4;
    j := k;
    while (j := ((k := j) / 2)) neq 0 do i := i + 1;
    return (i + 1);
  end;
*** msd: not defined (LOSE flag) 
nil

% For both PSL and CSL this is a built-in, so making it inline here is not
% useful and at one time it cause me pain.

symbolic procedure ashift(m,d);
   % This procedure resembles loosely an arithmetic shift.
   %  It returns m*2**d
   if d=0 then m
    else if d<0 then m/2**(-d)
    else m*2**d;
*** ashift not defined (LOSE flag) 
nil

symbolic inline procedure lshift(m,d);
   % Variant of ashift that is called ONLY when m>=0.
   %  This should be redefined for Lisp systems that provide
   %  an efficient logical shift.
   ashift(m,d);
*** lshift not defined (LOSE flag) 
nil

symbolic inline procedure oddintp n; not evenp n;
+++ Record new inline definition:
(de oddintp (n) (not (evenp n)))
(progn (de oddintp (n) (not (evenp n))) (put (quote oddintp) (quote
number!-of!-args) 1) (put (quote oddintp) (quote procedure_type) (quote (arrow
general general))) (putc (quote oddintp) (quote inline) (quote (lambda (n) (not
(evenp n))))))
+++ oddintp compiled, 5 + 12 bytes
(lambda (n) (not (evenp n)))

symbolic inline procedure preci!: nmbr;
   % This function counts the precision of a number "n". NMBR is a
   % binary bigfloat representation of "n".
   msd!: abs mt!: nmbr;
+++ Record new inline definition:
(de preci!: (nmbr) (msd (abs (cadr nmbr))))
(progn (de preci!: (nmbr) (msd (abs (cadr nmbr)))) (put (quote preci!:) (quote
number!-of!-args) 1) (put (quote preci!:) (quote procedure_type) (quote (arrow
general general))) (putc (quote preci!:) (quote inline) (quote (lambda (nmbr) (
msd (abs (cadr nmbr)))))))
+++ preci!: compiled, 6 + 12 bytes
(lambda (nmbr) (msd (abs (cadr nmbr))))


symbolic inline procedure divbf(u,v); normbf divide!:(u,v,!:bprec!:);
+++ Record new inline definition:
(de divbf (u v) (normbf (divide!: u v !:bprec!:)))
(progn (de divbf (u v) (normbf (divide!: u v !:bprec!:))) (put (quote divbf) (
quote number!-of!-args) 2) (put (quote divbf) (quote procedure_type) (quote (
arrow (times general general) general))) (putc (quote divbf) (quote inline) (
quote (lambda (u v) (normbf (divide!: u v !:bprec!:))))))
+++ divbf compiled, 9 + 20 bytes
(lambda (u v) (normbf (divide: u v :bprec:)))

symbolic inline procedure timbf(u,v); rndpwr times!:(u,v);
*** timbf not defined (LOSE flag) 
nil

symbolic inline procedure bfminusp u;
  if atom u then minusp u else minusp!: u;
+++ Record new inline definition:
(de bfminusp (u) (cond ((atom u) (minusp u)) (t (minusp!: u))))
(progn (de bfminusp (u) (cond ((atom u) (minusp u)) (t (minusp!: u)))) (put (
quote bfminusp) (quote number!-of!-args) 1) (put (quote bfminusp) (quote
procedure_type) (quote (arrow general general))) (putc (quote bfminusp) (quote
inline) (quote (lambda (u) (cond ((atom u) (minusp u)) (t (minusp!: u)))))))
+++ bfminusp compiled, 9 + 12 bytes
(lambda (u) (cond ((atom u) (minusp u)) (t (minusp: u))))

% The following function is not intended for very general use - it should
% only be needed within code that evaluates elementary functions of
% complex arguments. It differs from the regulat bfminusp function in that
% a native floating point value of -0.0 is reported as being negative.
% checking for this may be expensive!

symbolic procedure special_bfminusp u;
  if atom u then
    if floatp u and u = 0.0 then
% If I am checking of a floating point zero is "negative" in thie special
% manner I want to detect an IEEE "-0.0" value. At present the Lisp systems
% I use do not provide direct ways of achieving this, however using atan2
% does the job. I hope that this case arises infrequently so that the
% apparent costs are unimportant.
      atan2(1.0, u) < 0.0      % atan2(1.0, -0.0) => -pi/2, while
                               % atan2(1.0, +0.0) => pi/2
    else minusp u
  else minusp!: u;
+++ special_bfminusp compiled, 26 + 24 bytes
special_bfminusp

symbolic inline procedure bfzp u;
  if atom u then zerop u else mt!: u=0;
+++ Record new inline definition:
(de bfzp (u) (cond ((atom u) (zerop u)) (t (equal (cadr u) 0))))
(progn (de bfzp (u) (cond ((atom u) (zerop u)) (t (equal (cadr u) 0)))) (put (
quote bfzp) (quote number!-of!-args) 1) (put (quote bfzp) (quote procedure_type)
(quote (arrow general general))) (putc (quote bfzp) (quote inline) (quote (
lambda (u) (cond ((atom u) (zerop u)) (t (equal (cadr u) 0)))))))
+++ bfzp compiled, 11 + 12 bytes
(lambda (u) (cond ((atom u) (zerop u)) (t (equal (cadr u) 0))))

symbolic inline procedure bfnzp u; not bfzp u;
+++ Record new inline definition:
(de bfnzp (u) (not (cond ((atom u) (zerop u)) (t (equal (cadr u) 0)))))
(progn (de bfnzp (u) (not (cond ((atom u) (zerop u)) (t (equal (cadr u) 0))))) (
put (quote bfnzp) (quote number!-of!-args) 1) (put (quote bfnzp) (quote
procedure_type) (quote (arrow general general))) (putc (quote bfnzp) (quote
inline) (quote (lambda (u) (not (cond ((atom u) (zerop u)) (t (equal (cadr u) 0)
)))))))
+++ bfnzp compiled, 13 + 16 bytes
(lambda (u) (not (cond ((atom u) (zerop u)) (t (equal (cadr u) 0)))))

symbolic inline procedure bfloat x;
  if floatp x then fl2bf x
   else normbf(if not atom x then x
                else if fixp x then i2bf!: x
                else read!:num x);
+++ Record new inline definition:
(de bfloat (x) (cond ((floatp x) (fl2bf x)) (t (normbf (cond ((not (atom x)) x)
((fixp x) (cons (quote !:rd!:) (cons x 0))) (t (read!:num x)))))))
(progn (de bfloat (x) (cond ((floatp x) (fl2bf x)) (t (normbf (cond ((not (atom
x)) x) ((fixp x) (cons (quote !:rd!:) (cons x 0))) (t (read!:num x))))))) (put (
quote bfloat) (quote number!-of!-args) 1) (put (quote bfloat) (quote
procedure_type) (quote (arrow general general))) (putc (quote bfloat) (quote
inline) (quote (lambda (x) (cond ((floatp x) (fl2bf x)) (t (normbf (cond ((not (
atom x)) x) ((fixp x) (cons (quote !:rd!:) (cons x 0))) (t (read!:num x)))))))))
)
+++ bfloat compiled, 29 + 28 bytes
(lambda (x) (cond ((floatp x) (fl2bf x)) (t (normbf (cond ((not (atom x)) x) ((
fixp x) (cons (quote :rd:) (cons x 0))) (t (read:num x)))))))

symbolic inline procedure rdfl2rdbf x; fl2bf rd2fl x;
+++ Record new inline definition:
(de rdfl2rdbf (x) (fl2bf (cdr x)))
(progn (de rdfl2rdbf (x) (fl2bf (cdr x))) (put (quote rdfl2rdbf) (quote
number!-of!-args) 1) (put (quote rdfl2rdbf) (quote procedure_type) (quote (arrow
general general))) (putc (quote rdfl2rdbf) (quote inline) (quote (lambda (x) (
fl2bf (cdr x))))))
+++ rdfl2rdbf compiled, 3 + 12 bytes
(lambda (x) (fl2bf (cdr x)))

symbolic inline procedure rd!:forcebf x;
   % forces rounded number x to binary bigfloat representation
   if float!-bfp x then rdfl2rdbf x else x;
+++ Record new inline definition:
(de rd!:forcebf (x) (cond ((atom (cdr x)) (fl2bf (cdr x))) (t x)))
(progn (de rd!:forcebf (x) (cond ((atom (cdr x)) (fl2bf (cdr x))) (t x))) (put (
quote rd!:forcebf) (quote number!-of!-args) 1) (put (quote rd!:forcebf) (quote
procedure_type) (quote (arrow general general))) (putc (quote rd!:forcebf) (
quote inline) (quote (lambda (x) (cond ((atom (cdr x)) (fl2bf (cdr x))) (t x))))
))
+++ rd!:forcebf compiled, 8 + 12 bytes
(lambda (x) (cond ((atom (cdr x)) (fl2bf (cdr x))) (t x)))

symbolic inline procedure crrl x; cadr x;
+++ Record new inline definition:
(de crrl (x) (cadr x))
(progn (de crrl (x) (cadr x)) (put (quote crrl) (quote number!-of!-args) 1) (put
(quote crrl) (quote procedure_type) (quote (arrow general general))) (putc (
quote crrl) (quote inline) (quote (lambda (x) (cadr x)))))
+++ crrl compiled as link to cadr
(lambda (x) (cadr x))

symbolic inline procedure crim x; cddr x;
+++ Record new inline definition:
(de crim (x) (cddr x))
(progn (de crim (x) (cddr x)) (put (quote crim) (quote number!-of!-args) 1) (put
(quote crim) (quote procedure_type) (quote (arrow general general))) (putc (
quote crim) (quote inline) (quote (lambda (x) (cddr x)))))
+++ crim compiled as link to cddr
(lambda (x) (cddr x))

symbolic inline procedure make!:cr (re,im);
   '!:cr!: . (re . im);
+++ Record new inline definition:
(de make!:cr (re im) (cons (quote !:cr!:) (cons re im)))
(progn (de make!:cr (re im) (cons (quote !:cr!:) (cons re im))) (put (quote
make!:cr) (quote number!-of!-args) 2) (put (quote make!:cr) (quote
procedure_type) (quote (arrow (times general general) general))) (putc (quote
make!:cr) (quote inline) (quote (lambda (re im) (cons (quote !:cr!:) (cons re im
))))))
+++ make!:cr compiled, 5 + 12 bytes
(lambda (re im) (cons (quote :cr:) (cons re im)))

symbolic inline procedure crp x;
   % This function returns true if X is a complex rounded number
   % representation, else NIL.  X is any Lisp entity.
   eqcar(x,'!:cr!:);
+++ Record new inline definition:
(de crp (x) (eqcar x (quote !:cr!:)))
(progn (de crp (x) (eqcar x (quote !:cr!:))) (put (quote crp) (quote
number!-of!-args) 1) (put (quote crp) (quote procedure_type) (quote (arrow
general general))) (putc (quote crp) (quote inline) (quote (lambda (x) (eqcar x
(quote !:cr!:))))))
+++ crp compiled, 4 + 12 bytes
(lambda (x) (eqcar x (quote :cr:)))

symbolic inline procedure tagrl x; make!:rd crrl x;
+++ Record new inline definition:
(de tagrl (x) (cons (quote !:rd!:) (cadr x)))
(progn (de tagrl (x) (cons (quote !:rd!:) (cadr x))) (put (quote tagrl) (quote
number!-of!-args) 1) (put (quote tagrl) (quote procedure_type) (quote (arrow
general general))) (putc (quote tagrl) (quote inline) (quote (lambda (x) (cons (
quote !:rd!:) (cadr x))))))
+++ tagrl compiled, 5 + 12 bytes
(lambda (x) (cons (quote :rd:) (cadr x)))

symbolic inline procedure tagim x; make!:rd crim x;
+++ Record new inline definition:
(de tagim (x) (cons (quote !:rd!:) (cddr x)))
(progn (de tagim (x) (cons (quote !:rd!:) (cddr x))) (put (quote tagim) (quote
number!-of!-args) 1) (put (quote tagim) (quote procedure_type) (quote (arrow
general general))) (putc (quote tagim) (quote inline) (quote (lambda (x) (cons (
quote !:rd!:) (cddr x))))))
+++ tagim compiled, 5 + 12 bytes
(lambda (x) (cons (quote :rd:) (cddr x)))

symbolic inline procedure gfrl u; car u;
+++ Record new inline definition:
(de gfrl (u) (car u))
(progn (de gfrl (u) (car u)) (put (quote gfrl) (quote number!-of!-args) 1) (put
(quote gfrl) (quote procedure_type) (quote (arrow general general))) (putc (
quote gfrl) (quote inline) (quote (lambda (u) (car u)))))
+++ gfrl compiled as link to car
(lambda (u) (car u))

symbolic inline procedure gfim u; cdr u;
+++ Record new inline definition:
(de gfim (u) (cdr u))
(progn (de gfim (u) (cdr u)) (put (quote gfim) (quote number!-of!-args) 1) (put
(quote gfim) (quote procedure_type) (quote (arrow general general))) (putc (
quote gfim) (quote inline) (quote (lambda (u) (cdr u)))))
+++ gfim compiled as link to cdr
(lambda (u) (cdr u))

symbolic inline procedure mkgf (rl,im); rl . im;
+++ Record new inline definition:
(de mkgf (rl im) (cons rl im))
(progn (de mkgf (rl im) (cons rl im)) (put (quote mkgf) (quote number!-of!-args)
2) (put (quote mkgf) (quote procedure_type) (quote (arrow (times general general
) general))) (putc (quote mkgf) (quote inline) (quote (lambda (rl im) (cons rl
im)))))
+++ mkgf compiled as link to cons
(lambda (rl im) (cons rl im))

symbolic inline procedure gfzerop u;
  if not atom gfrl u then mt!: gfrl u = 0 and mt!: gfim u = 0
   else u = '(0.0 . 0.0);
+++ Record new inline definition:
(de gfzerop (u) (cond ((not (atom (car u))) (and (equal (cadr (car u)) 0) (equal
(cadr (cdr u)) 0))) (t (equal u (quote (0.0 . 0.0))))))
(progn (de gfzerop (u) (cond ((not (atom (car u))) (and (equal (cadr (car u)) 0)
(equal (cadr (cdr u)) 0))) (t (equal u (quote (0.0 . 0.0)))))) (put (quote
gfzerop) (quote number!-of!-args) 1) (put (quote gfzerop) (quote procedure_type)
(quote (arrow general general))) (putc (quote gfzerop) (quote inline) (quote (
lambda (u) (cond ((not (atom (car u))) (and (equal (cadr (car u)) 0) (equal (
cadr (cdr u)) 0))) (t (equal u (quote (0.0 . 0.0)))))))))
+++ gfzerop compiled, 17 + 16 bytes
(lambda (u) (cond ((not (atom (car u))) (and (equal (cadr (car u)) 0) (equal (
cadr (cdr u)) 0))) (t (equal u (quote (0.0 . 0.0))))))

% symbolic inline procedure sgn x;
%   if x>0 then 1 else if x<0 then -1 else 0;


global '(bfz!* bfhalf!* bfone!* bftwo!* bfthree!* bffive!* bften!*
         !:bf60!* !:180!* !:bf1!.5!*);nil

global '(!:bf!-0!.25        %0.25
         !:bf!-0!.0625      %0.0625
         !:bf0!.419921875   %0.419921875
        );nil

%Miscellaneous constants

bfz!* := make!:ibf(0,0);(:rd: 0 . 0)

bfhalf!* := make!:ibf(1,-1);(:rd: 1 . -1)

bfone!* := make!:ibf(1,0);(:rd: 1 . 0)

!:bf1!.5!* := make!:ibf (3, -1);(:rd: 3 . -1)

bftwo!* := make!:ibf (2, 0);(:rd: 2 . 0)

bfthree!* := make!:ibf (3, 0);(:rd: 3 . 0)

bffive!* := make!:ibf (5, 0);(:rd: 5 . 0)

bften!* := make!:ibf (5, 1);(:rd: 5 . 1)

!:bf60!* := make!:ibf (15, 2);(:rd: 15 . 2)

!:180!* := make!:ibf (45, 2);(:rd: 45 . 2)

!:bf!-0!.25 := make!:ibf(1,-2);(:rd: 1 . -2)

!:bf!-0!.0625 := make!:ibf (1, -4);(:rd: 1 . -4)

!:bf0!.419921875 := make!:ibf(215, -9);(:rd: 215 . -9)

% These need to be added to other modules.

symbolic procedure dn!:simp u;
  if car u = 0 then nil ./ 1
   else if u = '(10 . -1) and null !*noconvert then 1 ./ 1
   else if dmode!* memq '(!:rd!: !:cr!:)
    then rd!:simp cdr decimal2internal (car u, cdr u)
   else if cdr u >= 0 then !*f2q (car u * 10**cdr u)
   else simp {'quotient, car u, 10**(-cdr u)};
+++ dn!:simp compiled, 70 + 52 bytes
dn:simp

put ('!:dn!:, 'simpfn, 'dn!:simp);dn:simp

symbolic procedure dn!:prin u;
  bfprin0x (cadr u, cddr u);
+++ dn!:prin compiled, 6 + 12 bytes
dn:prin

put ('!:dn!:, 'prifn, 'dn!:prin);dn:prin

endmodule;nil

end;nilmodule smlbflot;nil   % Basic support for bigfloat arithmetic.

% Authors: S.L. Kameny and T. Sasaki.
% Modified for binary bigfloat arithmetic by Iain Beckingham and Rainer
% Schoepf.
% Modified for double precision printing by Herbert Melenk.
% Modified to allow *very* large numbers to be compressed (for PSL) by
% Winfried Neun.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% Last change made Oct 6, 1999.

exports abs!:, bfexplode0, bflerrmsg, bfprin!:, bftrim!:, bfzerop!:,
        conv!:mt, cut!:ep, cut!:mt, decimal2internal, decprec!:,
        difference!:, divide!:, equal!:, fl2bf, greaterp!:, incprec!:,
        leq!:, lessp!:, max!:, max!:, max2!:, min!:, min2!:, minus!:,
        minusp!:, order!:, plus!:, read!:num, round!:mt, round!:last,
        times!:;nil

imports aconc, ashift, bfp!:, ceiling, conv!:bf2i, ep!:, eqcar, floor,
        geq, i2bf!:, leq, lshift, make!:ibf, msd!:, mt!:, neq, normbf,
        oddintp, preci!:, precision, prin2!*, rerror, retag, reversip;nil

fluid '(!*bfspace !*fullprec !*nat !:prec!: !:bprec!: !:print!-prec!:
        !:upper!-sci!: !:lower!-sci!:);nil

global '(!!nfpd !!nbfpd bften!* bfz!* fort_exponent);nil

switch bfspace,fullprec;nil

flag('(fort_exponent),'share);nil

!*bfspace := nil;nil

% !*fullprec := t;

!:lower!-sci!: := 10;10

!:upper!-sci!: := 5;5

symbolic procedure bflerrmsg u;
   % Revised error message for BFLOAT module, using error, not rederr.
   error(0,{"Invalid argument to",u});
+++ bflerrmsg compiled, 9 + 20 bytes
bflerrmsg

symbolic procedure bfzerop!: u;
   % This is possibly too restricted a definition.
   mt!: u = 0;
+++ bfzerop!: redefined
+++ bfzerop!: compiled, 5 + 12 bytes
bfzerop:

symbolic procedure fl2bf x;
  (if zerop x then bfz!* else
   if not fp!-finite x then rederr "Floating point infinity or NaN" else
   begin scalar s,r; integer d;
     if x<0 then <<x := -x; s := t>>;
     % convert x to an integer equivalent;
      r := normbf read!:num x;
      d := ep!: r+msd!: mt!: r;
      x := x*2.0**-d; x := x + 0.5/2.0**!:bprec!:;
      x := fix(x*2.0**!:bprec!:);
      return make!:ibf (if s then -x else x, d - !:bprec!:) end)
        where !:bprec!:=!!nbfpd;
*** fl2bf not defined (LOSE flag) 
nil

symbolic procedure bfprin!: u;
%  if preci!: u>!!nbfpd then bfprin0 u
%   else (bfprin0 u where !*bfspace=nil);
   bfprin0 u;
+++ bfprin!: compiled as link to bfprin0
bfprin:

symbolic procedure divide!-by!-power!-of!-ten (x, n);
  if n < 0 then bflerrmsg 'divide!-by!-power!-of!-ten
   else <<
     while n > 0 do <<
       if oddintp n then x := normbf divide!: (x, f, !:bprec!:);
       n := lshift (n, -1);
       f := normbf cut!:mt (times!: (f, f), !:bprec!:) >>;
     x >> where f := bften!*;
+++ divide!-by!-power!-of!-ten redefined
+++ divide!-by!-power!-of!-ten compiled, 46 + 48 bytes
divide-by-power-of-ten

symbolic procedure multiply!-by!-power!-of!-ten (x, n);
  if n < 0 then bflerrmsg 'multiply!-by!-power!-of!-ten
   else <<
     while n > 0 do <<
       if oddintp n then x := normbf times!: (x, f);
       n := lshift (n, -1);
       f := normbf cut!:mt (times!: (f, f), !:bprec!:) >>;
     normbf cut!:mt (x, !:bprec!:) >> where f := bften!*;
+++ multiply!-by!-power!-of!-ten redefined
+++ multiply!-by!-power!-of!-ten compiled, 47 + 44 bytes
multiply-by-power-of-ten

global '(!!log2of10);nil

symbolic procedure round!:dec (x, p);
  %
  % rounds bigfloat x to p decimal places
  %
  begin scalar setpr; integer m, ex;
    if null p then p := if !:print!-prec!: then !:print!-prec!:
                         else !:prec!: - 2
     else if p > precision 0 then setpr := precision p;
    x := round!:dec1 (x,p);
    m := car x; ex := cdr x;
    x := i2bf!: m;
    if ex < 0 then x := divide!-by!-power!-of!-ten (x, -ex)
     else if ex > 0 then x := multiply!-by!-power!-of!-ten (x, ex);
    if setpr then precision setpr;
    return round!:mt (x, ceiling (p * !!log2of10))
  end;
+++ round!:dec compiled, 86 + 56 bytes
round:dec

symbolic procedure round!:dec1 (x, p);
  %
  % rounds bigfloat x to p decimal places
  % returns pair (m . ex) of mantissa and exponent to base 10,
  % m having exactly p digits
  % performs all calculations at at least current precision,
  % but increases the precision of the calculations to log10(x)
  % if this is larger
  %
  if bfzerop!: x then cdr x
   else (begin scalar exact, lo, sign; integer ex, k, m, n, l;
    %
    % We need to calculate the number k so that 10^(k+1) > |x| >= 10^k
    %  k = floor (log10 |x|) = floor (log2 |x| / log2of10);
    % We can easily compute n so that 2^(n+1) > |x| >= 2^n,
    %  i.e., n = floor (log2 |x|), since this is just order!:(x).
    % Since n+1 > log2 |x| >= n, it follows that
    %  floor ((n+1) / log2of10) >= k >= floor (n / log2of10)
    % I.e., if both bounds agree, we know k, otherwise we have to check.
    %
    if mt!: x < 0 then <<sign := t; x := minus!: x>>;
    n := order!: x;
    %
    % The division by log2of10 has to be done with precision larger than
    % the precision of n. In particular, log2of10 has to be calculated
    % to a larger precision.  Instead of dividing by log2of10, we
    % multiply by log10of2.
    %
    l := msd!: abs n;
    <<lo := divide!: (!:log2 !:bprec!:, !:log10 !:bprec!:, !:bprec!:);
      k := conv!:bf2i times!: (i2bf!: n, lo);
      if k = conv!:bf2i times!: (i2bf!: (n+1), lo) then exact := t>>
        where !:bprec!: := max (!!nbfpd, l + 7);
    %
    % For the following calculation the precision must be increased by
    % the precision of n. The is necessary to ensure that the mantissa
    % is calculated correctly for large values of the exponent. This is
    % due to the fact that if we multiply the number x by 10^n its
    % precision will be decreased by n.
    %
    !:bprec!: := !:bprec!: + l;
    %
    % since conv!:bf2i rounds always towards 0, we must correct for n<0
    %
    if n < 0 then k := k - 1;
    ex := k - p + 1;
    if ex < 0 then x := multiply!-by!-power!-of!-ten (x, -ex)
     else if ex > 0 then x := divide!-by!-power!-of!-ten (x, ex);
    if exact then nil
     else <<l := length explode conv!:bf2i x;
            if l < p then <<x := times!: (x, bften!*); ex := ex - 1>>
             else if l > p then <<x := divide!: (x, bften!*, !:bprec!:);
                                  ex := ex + 1>>>>;
    %
    % do rounding
    %
    x := plus!:(x, bfhalf!*);
    % Add an "epsilon" just to be sure (e.g., for on complex,rounded;
    % print_precision 15; 3.23456789012345+7).
    x := plus!:(x,fl2bf(0.1^18));
    m := conv!:bf2i x;
    if length explode m > p then <<m := (m + 5) / 10; ex := ex + 1>>;
    if sign then m := -m;
    return (m . ex);
  end) where !:bprec!: := !:bprec!:;
+++ round!:dec1 compiled, 253 + 116 bytes
round:dec1

% symbolic procedure internal2decimal (x, p);
  %
  % converts bigfloat x to decimal format, with precision p
  % Result is a pair (m . e), so that x = m*10^e, with
  % m having exactly p decimal digits.
  % Calculation is done with the current precision,
  % but at least with p + 2.
  %
%   begin scalar setpr;
%     if null p then p := if !:print!-prec!: then !:print!-prec!:
%                          else !:prec!: - 2
%      else if p > precision 0 then setpr := precision p;
%     x := round!:dec1 (x,p);
%     if setpr then precision setpr;
%     return x
%   end;


symbolic procedure bfprin0 u;
  begin scalar r; integer m, ex;
    r := round!:dec1 (u, if !:print!-prec!: then !:print!-prec!:
                          else !:prec!: - 2);
    m := car r; ex := cdr r;
    bfprin0x (m, ex)
  end;
+++ bfprin0 compiled, 26 + 32 bytes
bfprin0

symbolic procedure bfprin0x(m,ex);
  begin scalar lst; integer dotpos;
    lst := bfexplode0x(m,ex);
    ex := cadr lst;
    dotpos := caddr lst;
    lst := car lst;
    return bfprin!:lst (lst,ex,dotpos)
  end;
+++ bfprin0x redefined
+++ bfprin0x compiled, 17 + 20 bytes
bfprin0x

symbolic procedure bfexplode0 u;
  % returns a list (lst ex dotpos) where
  %  lst    = list of characters in mantissa
  %            (ie optional sign and digits)
  %  ex     = decimal exponent
  %  dotpos = position of decimal point in lst
  %            (note that the sign is counted)
  begin scalar r; integer m, ex;
    r := round!:dec1 (u,if !:print!-prec!: then !:print!-prec!:
                         else !:prec!: - 2);
    m := car r; ex := cdr r;
    return bfexplode0x (m, ex)
  end;
+++ bfexplode0 compiled, 25 + 32 bytes
bfexplode0


symbolic procedure bfexplode0x (m, ex);
  begin scalar lst, s; integer dotpos, l;
    if m<0 then <<s := t; m := -m>>;
    lst := explode m;
    l := length lst;
    if ex neq 0 and (l+ex < -!:lower!-sci!: or l+ex > !:upper!-sci!:)
      then <<dotpos := 1;
             ex := ex + l - 1>>
     else <<dotpos := l + ex;
            ex := 0;
            if dotpos > l - 1
              %
              % add dotpos - l + 1 zeroes at the end
              %
              then lst := nconc!*(lst,nlist('!0,dotpos - l + 1))
             else while dotpos < 1 do <<lst := '!0 . lst;
                                        dotpos := dotpos + 1>>>>;
    if s then <<lst := '!- . lst; dotpos := dotpos + 1>>;
    if null !*fullprec
      then <<lst := reversip lst;
             while lst and car lst eq '!0 and length lst > dotpos + 1 do
                lst := cdr lst;
             lst := reversip lst>>;
    return {lst, ex, dotpos}
  end;
+++ bfexplode0x compiled, 149 + 48 bytes
bfexplode0x

symbolic procedure bfprin!:lst (lst, ex, dotpos);
  begin scalar result,ee,w; integer j;
    ee:='e;
    if !*fort and liter(w:=reval fort_exponent) then ee:=w else w:=nil;
    if car lst eq '!- and dotpos = 1 then <<dotpos := 2; ex := ex - 1>>;
    if ex neq 0 then if car lst eq '!- then <<ex := ex + dotpos - 2;
                                              dotpos := 2>>
                      else <<ex := ex + dotpos - 1; dotpos := 1>>
     else if dotpos = length lst then dotpos := -1;
    for each char in lst do <<
      result := char . result; j := j + 1; dotpos := dotpos - 1;
      if j=5 then <<if !*nat and !*bfspace then result := '!  . result;
                    j := 0>>;
      if dotpos = 0 then <<result := '!. . result; j := j + 1>>;
      if j=5 then <<if !*nat and !*bfspace then result := '!  . result;
                    j := 0>>>>;
    if ex neq 0 or w then <<
    if not (!*nat and !*bfspace) then result := ee . result
     else if j=0 then <<result := '!  . ee . result; j := 2>>
     else if j=1 then <<result := '!  . ee . '!  . result; j := 4>>
     else if j=2
      then <<result := '!  . '!  . ee . '!  . result; j := 0>>
     else if j=3 then <<result := '!  . ee . '!  . result; j := 0>>
     else if j=4 then <<result := '!  . ee . '!  . result; j := 2>>;
    lst := if ex > 0 then '!+ . explode ex else explode ex;
    for each char in lst do <<
      result := char . result; j := j + 1;
      if j=5 then <<if !*nat and !*bfspace then result := '!  . result;
                    j := 0>>>>>>;
 %  if !*nat then for each char in reversip result do prin2!* char else
    prin2!* smallcompress reversip result
  end;
+++ bfprin!:lst compiled, 325 + 84 bytes
bfprin:lst

symbolic procedure smallcompress (li);
   begin scalar ll;
      if (ll := length li)>1000
        then <<li := smallsplit(li,ll/2);
              return concat(smallcompress car li,smallcompress cdr li)>>
       else return compress ('!" . reversip('!" .  reversip li))
   end;
+++ smallcompress compiled, 45 + 28 bytes
smallcompress

symbolic procedure smallsplit (li,ln);
    begin scalar aa;
       for i:=1:ln do <<aa := car li . aa; li := rest li>>;
       return (reversip aa) . li
    end;
+++ smallsplit compiled, 27 + 12 bytes
smallsplit

symbolic procedure scientific_notation n;
   begin scalar oldu,oldl;
     oldu := !:upper!-sci!:; oldl := !:lower!-sci!: + 1;
     if fixp n
       then <<
         if n<0
           then rerror(arith,1,
                       {"Invalid argument to scientific_notation:",n});
         !:lower!-sci!: := n - 1; !:upper!-sci!: := n;
      >>
      else if eqcar(n,'list) and length n=3
       then if not (fixp cadr n and fixp caddr n)
              then rerror(arith,2,
                        {"Invalid argument to scientific_notation:",n})
             else <<!:upper!-sci!: := cadr n;
                    !:lower!-sci!: := caddr n - 1 >>;
     return {'list,oldu,oldl}   % Return previous range.
  end;
+++ scientific_notation compiled, 81 + 44 bytes
scientific_notation

flag('(scientific_notation), 'opfn);nil

symbolic procedure order!: nmbr;
   % This function counts the order of a number "n".  NMBR is a bigfloat
   %  representation of "n".
   % **** ORDER(n)=k if 2**k <= ABS(n) < 2**(k+1)
   % ****     when n is not 0, and ORDER(0)=0.
   %
   if mt!: nmbr = 0 then 0 else preci!: nmbr + ep!: nmbr - 1;
+++ order!: redefined
+++ order!: compiled, 18 + 16 bytes
order:

symbolic inline procedure decprec!:(nmbr, k);
   make!:ibf(ashift(mt!: nmbr,-k), ep!: nmbr + k);
+++ Record new inline definition:
(de decprec!: (nmbr k) (cons (quote !:rd!:) (cons (ashift (cadr nmbr) (minus k))
(plus (cddr nmbr) k))))
(progn (de decprec!: (nmbr k) (cons (quote !:rd!:) (cons (ashift (cadr nmbr) (
minus k)) (plus (cddr nmbr) k)))) (put (quote decprec!:) (quote number!-of!-args
) 2) (put (quote decprec!:) (quote procedure_type) (quote (arrow (times general
general) general))) (putc (quote decprec!:) (quote inline) (quote (lambda (nmbr
k) (cons (quote !:rd!:) (cons (ashift (cadr nmbr) (minus k)) (plus (cddr nmbr) k
)))))))
+++ decprec!: compiled, 20 + 16 bytes
(lambda (nmbr k) (cons (quote :rd:) (cons (ashift (cadr nmbr) (minus k)) (plus (
cddr nmbr) k))))

symbolic inline procedure incprec!:(nmbr, k);
   make!:ibf(ashift(mt!: nmbr,k), ep!: nmbr - k);
+++ Record new inline definition:
(de incprec!: (nmbr k) (cons (quote !:rd!:) (cons (ashift (cadr nmbr) k) (
difference (cddr nmbr) k))))
(progn (de incprec!: (nmbr k) (cons (quote !:rd!:) (cons (ashift (cadr nmbr) k)
(difference (cddr nmbr) k)))) (put (quote incprec!:) (quote number!-of!-args) 2)
(put (quote incprec!:) (quote procedure_type) (quote (arrow (times general
general) general))) (putc (quote incprec!:) (quote inline) (quote (lambda (nmbr
k) (cons (quote !:rd!:) (cons (ashift (cadr nmbr) k) (difference (cddr nmbr) k))
)))))
+++ incprec!: compiled, 15 + 16 bytes
(lambda (nmbr k) (cons (quote :rd:) (cons (ashift (cadr nmbr) k) (difference (
cddr nmbr) k))))

symbolic procedure conv!:mt(nmbr, k);
   % This function converts a number "n" to an equivalent number of
   % binary precision K by rounding "n" or adding "0"s to "n".
   % NMBR is a binary bigfloat representation of "n".
   %  K is a positive integer.
   if bfp!: nmbr and fixp k and k > 0
     then if (k := preci!: nmbr - k) = 0 then nmbr
           else if k < 0 then incprec!:(nmbr, -k)
           else round!:last(decprec!:(nmbr, k - 1))
    else bflerrmsg 'conv!:mt;
+++ conv!:mt redefined
+++ conv!:mt compiled, 85 + 32 bytes
conv:mt

symbolic procedure round!:mt(nmbr, k);
   % This function rounds a number "n" at the (K+1)th place and returns
   % an equivalent number of binary precision K if the precision of "n"
   % is greater than K, else it returns the given number unchanged.
   % NMBR is a bigfloat representation of "n".  K is a positive integer.
   if bfp!: nmbr and fixp k and k > 0 then
      if (k := preci!: nmbr - k - 1) < 0 then nmbr
      else if k = 0 then round!:last nmbr
      else round!:last decprec!:(nmbr, k)
   else bflerrmsg 'round!:mt;
+++ round!:mt redefined
+++ round!:mt compiled, 67 + 32 bytes
round:mt

symbolic procedure round!:ep(nmbr, k);
% This function rounds a number "n" and returns an
%      equivalent number having the exponent K if
%      the exponent of "n" is less than K, else
%      it returns the given number unchanged.
% NMBR is a BINARY BIG-FLOAT representation of "n".
% K is an integer (positive or negative).
  if bfp!: nmbr and fixp k then
    if (k := k - 1 - ep!: nmbr) < 0 then nmbr
      else if k = 0 then round!:last nmbr
      else round!:last decprec!:(nmbr, k)
   else bflerrmsg 'round!:ep$
+++ round!:ep compiled, 56 + 28 bytes
round:ep

symbolic procedure round!:last nmbr;
   % This function rounds a number "n" at its last place.
   % NMBR is a binary bigfloat representation of "n".
   << if m < 0 then << m := -m; s := t >>;
      m := if oddintp m then lshift (m, -1) + 1
            else lshift (m, -1);
      if s then m := -m;
      make!:ibf (m, e) >>
       where m := mt!: nmbr, e := ep!: nmbr + 1, s := nil;
+++ round!:last redefined
+++ round!:last compiled, 43 + 24 bytes
round:last

symbolic procedure cut!:mt(nmbr,k);
% This function returns a given number "n" unchanged
%      if its binary precision is not greater than K, else it
%      cuts off its mantissa at the (K+1)th place and
%      returns an equivalent number of precision K.
% **** CAUTION!  No rounding is made.
% NMBR is a BINARY BIG-FLOAT representation of "n".
% K is a positive integer.
  if bfp!: nmbr and fixp k and k > 0 then
     if (k := preci!: nmbr - k) <= 0 then nmbr
             else decprec!:(nmbr, k)
   else bflerrmsg 'cut!:mt$
+++ cut!:mt redefined
+++ cut!:mt compiled, 57 + 28 bytes
cut:mt

symbolic procedure cut!:ep(nmbr, k);
% This function returns a given number "n" unchanged
%      if its exponent is not less than K, else it
%      cuts off its mantissa and returns an equivalent
%      number of exponent K.
% **** CAUTION!  No rounding is made.
% NMBR is a BINARY BIG-FLOAT representation of "n".
% K is an integer (positive or negative).
  if bfp!: nmbr and fixp k then
     if (k := k - ep!: nmbr) <= 0 then nmbr
        else decprec!:(nmbr, k)
   else bflerrmsg 'cut!:ep$
+++ cut!:ep redefined
+++ cut!:ep compiled, 45 + 24 bytes
cut:ep

symbolic procedure bftrim!: v;
   normbf round!:mt(v,!:bprec!: - 3);
+++ bftrim!: redefined
+++ bftrim!: compiled, 10 + 24 bytes
bftrim:

symbolic procedure decimal2internal (base10,exp10);
  if exp10 >= 0 then i2bf!: (base10 * 10**exp10)
   else divide!-by!-power!-of!-ten (i2bf!: base10, -exp10);
+++ decimal2internal redefined
+++ decimal2internal compiled, 31 + 24 bytes
decimal2internal

symbolic procedure read!:num(n);
   % This function reads a number or a number-like entity N
   %      and constructs a bigfloat representation of it.
   % N is an integer, a floating-point number, or a string
   %      representing a number.
   % **** If the system does not accept or may incorrectly
   % ****      accept the floating-point numbers, you can
   % ****      input them as strings such as "1.234E-56",
   % ****      "-78.90 D+12" , "+3456 B -78", or "901/234".
   % **** A rational number in a string form is converted
   % ****      to a bigfloat of precision !:PREC!: if
   % ****      !:PREC!: is not NIL, else the precision of
   % ****      the result is set 170.
   % **** Some systems set the maximum size of strings.  If
   % ****      you want to input long numbers exceeding
   % ****      such a maximum size, please use READ!:LNUM.
   if fixp n then make!:ibf(n, 0)
    else if not(numberp n or stringp n) then bflerrmsg 'read!:num
    else begin integer j,m,sign;  scalar ch,u,v,l,appear!.,appear!/;
          j := m := 0;
          sign := 1;
          u := v := appear!. := appear!/ := nil;
          l := explode n;
    loop: ch := car l;
          if digit ch then << u := ch . u; j := j + 1 >>
           else if ch eq '!. then << appear!. := t; j := 0 >>
           else if ch eq '!/ then << appear!/ := t; v := u; u := nil >>
           else if ch eq '!- then sign := -1
           else if ch memq '(!E !D !B !e !d !b) then go to jump;  %JBM
           if l := cdr l then goto loop else goto make;
    jump: while l := cdr l do
            <<if digit(ch := car l) or ch eq '!-
                 then v := ch . v >>;
          l := reverse v;
          % Was erroneously smallcompress.
          if car l eq '!- then m := - compress cdr l
                          else m:= compress l;
    make: u := reverse u;
          v := reverse v;
          if appear!/ then
            return conv!:r2bf(make!:ratnum(sign*compress v,compress u),
                              if !:bprec!: then !:bprec!: else 170);
          if appear!. then j := - j else j := 0;
          if sign = 1 then u := compress u else u := - compress u;
          return round!:mt (decimal2internal (u, j + m), !:bprec!:)
                   where !:bprec!: := if !:bprec!: then !:bprec!:
                                       else msd!: abs u
    end;
+++ read!:num compiled, 233 + 80 bytes
read:num

symbolic procedure abs!: nmbr;
   % This function makes the absolute value of "n".  N is a binary
   % bigfloat representation of "n".
   if mt!: nmbr > 0 then nmbr else make!:ibf(- mt!: nmbr, ep!: nmbr);
+++ abs!: redefined
+++ abs!: compiled, 17 + 16 bytes
abs:

symbolic procedure minus!: nmbr;
   % This function makes the minus number of "n".  N is a binary
   % bigfloat representation of "n".
   make!:ibf(- mt!: nmbr, ep!: nmbr);
+++ minus!: redefined
+++ minus!: compiled, 10 + 12 bytes
minus:

symbolic procedure plus!:(n1,n2);
   begin scalar m1,m2,e1,e2,d; return
      if (m1 := mt!: n1)=0 then n2
      else if (m2 := mt!: n2)=0 then n1
      else if (d := (e1 := ep!: n1)-(e2 := ep!: n2))=0
         then make!:ibf(m1+m2, e1)
      else if d>0 then make!:ibf(ashift(m1,d)+m2,e2)
      else make!:ibf(m1+ashift(m2,-d),e1) end;
+++ plus!: redefined
+++ plus!: compiled, 68 + 20 bytes
plus:

symbolic procedure difference!:(n1,n2);
   begin scalar m1,m2,e1,e2,d; return
      if (m1 := mt!: n1)=0 then minus!: n2
      else if (m2 := mt!: n2)=0 then n1
      else if (d := (e1 := ep!: n1)-(e2 := ep!: n2))=0
         then make!:ibf(m1 - m2, e1)
      else if d>0 then make!:ibf(ashift(m1,d) - m2,e2)
      else make!:ibf(m1 - ashift(m2,-d),e1) end;
+++ difference!: redefined
+++ difference!: compiled, 70 + 24 bytes
difference:

symbolic procedure times!:(n1, n2);
   % This function calculates the product of "n1" and "n2".
   % N1 and N2 are bigfloat representations of "n1" and "n2".
   make!:ibf(mt!: n1 * mt!: n2, ep!: n1 + ep!: n2);
+++ times!: redefined
+++ times!: compiled, 17 + 12 bytes
times:

symbolic procedure divide!:(n1,n2,k);
   % This function calculates the quotient of "n1" and "n2", with the
   % precision K, by rounding the ratio of "n1" and "n2" at the (K+1)th
   % place.  N1 and N2 are bigfloat representations of "n1" and "n2".
   % K is any positive integer.
   begin
      n1 := conv!:mt(n1, k + preci!: n2 + 1);
      n1 := make!:ibf(mt!: n1 / mt!: n2, ep!: n1 - ep!: n2);
      return round!:mt(n1, k)
   end;
+++ divide!: redefined
+++ divide!: compiled, 37 + 24 bytes
divide:

symbolic procedure max2!:(a,b);
   % This function returns the larger of "n1" and "n2".
   % N1 and N2 are bigfloat representations of "n1" and "n2".
   if greaterp!:(a,b) then a else b;
+++ max2!: compiled, 8 + 12 bytes
max2:

macro procedure max!: x; expand(cdr x,'max2!:);
+++ max!:_qgaciq77cjtn2 compiled, 6 + 16 bytes
max:

symbolic procedure min2!:(a,b);
   % This function returns the smaller of "n1" and "n2".
   % N1 and N2 are binary bigfloat representations of "n1" and "n2".
   if greaterp!:(a,b) then b else a;
+++ min2!: compiled, 8 + 12 bytes
min2:

macro procedure min!: x; expand(cdr x,'min2!:);
+++ min!:_k5gdgsjbhu3c compiled, 6 + 16 bytes
min:

symbolic procedure greaterp!:(a,b);
% this function calculates the a > b, but avoids
% generating large numbers if magnitude difference is large.
    if mt!: a=0 then mt!: b<0
     else if mt!: b=0 then mt!: a>0
     else if ep!: a=ep!: b then mt!: a>mt!: b else
       (((if d=0 then ma>mb else
          ((if d>p2 then ma>0 else if d<-p2 then mb<0
            else if d>0 then ashift(ma,d)>mb
            else ma>ashift(mb,-d))
          where p2=2*!:bprec!:))
         where d=ep!: a - ep!: b, ma=mt!: a, mb=mt!: b)
        where a= normbf a, b=normbf b);
+++ greaterp!: redefined
+++ greaterp!: compiled, 105 + 28 bytes
greaterp:

symbolic procedure equal!:(a,b);
  %tests bfloats for a=b rapidly without generating digits. %SK
   zerop mt!: a and zerop mt!: b or
   ep!:(a := normbf a)=ep!:(b := normbf b) and mt!: a=mt!: b;
+++ equal!: redefined
+++ equal!: compiled, 32 + 12 bytes
equal:

symbolic procedure lessp!:(n1, n2);
   % This function returns T if "n1" < "n2" else returns NIL.
   % N1 and N2 are bigfloat representations of "n1" and "n2".
   greaterp!:(n2, n1);
+++ lessp!: redefined
+++ lessp!: compiled, 3 + 12 bytes
lessp:

symbolic procedure leq!:(n1, n2);
   % This function returns T if "n1" <= "n2" else returns NIL.
   % N1 and N2 are bigfloat representations of "n1" and "n2".
   not greaterp!:(n1, n2);
+++ leq!: compiled, 5 + 16 bytes
leq:

symbolic procedure minusp!: x;
   % This function returns T if "x"<0 else returns NIL.
   % X is any Lisp entity.
   bfp!: x and mt!: x < 0;
+++ minusp!: redefined
+++ minusp!: compiled, 13 + 12 bytes
minusp:

symbolic procedure make!:ratnum(nm,dn);
   % This function constructs an internal representation
   %      of a rational number composed of the numerator
   %      NM and the denominator DN.
   % NM and DN are any integers (positive or negative).
   % **** Four routines in this section are temporary.
   % ****      That is, if your system has own routines
   % ****      for rational number arithmetic, you can
   % ****      accommodate our system to yours only by
   % ****      redefining these four routines.
   if zerop dn then rerror(arith,3,"Zero divisor in make:ratnum")
    else if dn > 0 then '!:ratnum!: . (nm . dn)
    else '!:ratnum!: . (-nm . -dn);
+++ make!:ratnum compiled, 38 + 32 bytes
make:ratnum

symbolic procedure ratnump!:(x);
   % This function returns T if X is a rational number
   % representation, else NIL.
   % X is any Lisp entity.
   eqcar(x,'!:ratnum!:);
+++ ratnump!: compiled, 4 + 12 bytes
ratnump:                   %JBM Change to EQCAR.

symbolic inline procedure numr!: rnmbr;
   % This function selects the numerator of a rational number "n".
   % RNMBR is a rational number representation of "n".
   cadr rnmbr;
+++ Record new inline definition:
(de numr!: (rnmbr) (cadr rnmbr))
(progn (de numr!: (rnmbr) (cadr rnmbr)) (put (quote numr!:) (quote
number!-of!-args) 1) (put (quote numr!:) (quote procedure_type) (quote (arrow
general general))) (putc (quote numr!:) (quote inline) (quote (lambda (rnmbr) (
cadr rnmbr)))))
+++ numr!: compiled as link to cadr
(lambda (rnmbr) (cadr rnmbr))

symbolic inline procedure denm!: rnmbr;
   % This function selects the denominator of a rational number "n".
   % RNMBR is a rational number representation of "n".
   cddr rnmbr;
+++ Record new inline definition:
(de denm!: (rnmbr) (cddr rnmbr))
(progn (de denm!: (rnmbr) (cddr rnmbr)) (put (quote denm!:) (quote
number!-of!-args) 1) (put (quote denm!:) (quote procedure_type) (quote (arrow
general general))) (putc (quote denm!:) (quote inline) (quote (lambda (rnmbr) (
cddr rnmbr)))))
+++ denm!: compiled as link to cddr
(lambda (rnmbr) (cddr rnmbr))

symbolic procedure conv!:r2bf(rnmbr,k);
   % This function converts a rational number RNMBR to a bigfloat of
   % precision K, i.e., a bigfloat representation with a given
   % precision.  RNMBR is a rational number representation.  K is a
   % positive integer.
   if ratnump!: rnmbr and fixp k and k > 0
     then divide!:(make!:ibf( numr!: rnmbr, 0),
                   make!:ibf( denm!: rnmbr, 0),k)
    else bflerrmsg 'conv!:r2bf;
+++ conv!:r2bf compiled, 37 + 28 bytes
conv:r2bf

endmodule;nil

end;nilmodule bfauxil;nil % Support for the roots package and ROUNDED domain.

% Author: Stanley L. Kameny <valley!stan@rand.org>.
% Definitions of ilog2, irootn, icbrt, isqrt and support supplied by
% John Abbott.

% Copyright (c) 1988,1989,1990. Stanley L. Kameny. All Rights Reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


COMMENT   support for modules allroot and isoroot, and for ROUNDED
 domain logic;

exports !!shbinflp, bf2flr, bfdiffer, bfdivide, bfinverse, bflessp,
        bfminus, bfsqrt, cflot, conv!:bf2i, difbf, exptbf, fl2int,
        gf2bf, gf2fl, gfdiffer, gfdot, gfminus, gfplus, gfquotient,
        gfsqrt, gftimes, grpbf, icbrt, ilog2, invbf, irootn, isqrt,
        normbf, plubf, r2bf, r2fl, realrat;nil

imports abs!:, ashift, bflerrmsg, bfloat, bfminusp, bfnzp, bfp!:,
        bfzerop!:, bfzp, conv!:mt, cut!:ep, decprec!:, difference!:,
        divbf, divide!:, ep!:, eqcar, error1, errorp, errorset!*,
        evenp, fl2bf, gcdn, geq, gfim, gfrl, gfzerop, greaterp!:,
        hypot, i2bf!:, leq, lshift, make!:ibf, minus!:, minusp!:,
        msd!:, mt!:, order!:, plus!:, preci!:, read!:num, rndpwr,
        round!:mt, sgn, sqrt, terrlst, timbf, times!:, typerr;nil

fluid '(!:prec!: !:bprec!:);nil

global '(bfone!* bfhalf!* bfz!*);nil

global '(!!nfpd !!nbfpd !!shbinfl vv!! !!flbint);nil


global '(!!minflbf !!maxflbf);nil

symbolic procedure normbf x;
   begin scalar mt,s,r;integer ep,ep1;
      if (mt := mt!: x)=0 then go to ret;
      if mt<0 then <<mt := -mt; s := t>>;
      ep := ep!: x;
      while remainder(mt,1073741824)=0 do << % 2**30
        mt := lshift(mt,-30);
        ep := ep+30 >>;
      while remainder(mt,256)=0 do <<
        mt := lshift(mt,-8);
        ep := ep+8 >>;
      while not oddintp mt do <<
        mt := lshift(mt,-1);
        ep := ep+1>>;
      if s then mt := -mt;
ret:    return make!:ibf(mt,ep) end;
*** normbf not defined (LOSE flag) 
nil

%symbolic procedure divbf(u,v); normbf divide!:(u,v,!:bprec!:);

symbolic procedure bfdivide(u,v);
   if atom u then u/v else divbf(u,v);
+++ bfdivide redefined
+++ bfdivide compiled, 15 + 20 bytes
bfdivide

%symbolic procedure timbf(u,v); rndpwr times!:(u,v);

symbolic procedure bftimes(u,v); if atom u then u*v else timbf(u,v);
+++ bftimes compiled, 8 + 12 bytes
bftimes

symbolic procedure plubf(a,b);
% this function calculates the normalized rounded sum of a and b,
% but avoids generating large numbers if magnitude difference is large.
  rndpwr
    begin scalar ma,mb,ea,eb,d,ld,p;
      if (ma:=mt!: a)=0 then return b;
      if (mb:=mt!: b)=0 then return a;
      if (d := (ea := ep!: a)-(eb := ep!: b))=0
        then return make!:ibf(ma+mb,ea);
      ld := d+msd!: abs ma - msd!: abs mb;
      p := !:bprec!:+1;
      if ld>p then return a;
      if ld<-p then return b;
      if d>0 then return make!:ibf(ashift(ma,d)+mb,eb)
        else return make!:ibf(ma+ashift(mb,-d),ea) end;
+++ plubf redefined
+++ plubf compiled, 157 + 32 bytes
plubf

symbolic procedure bfplus(u,v); if atom u then u+v else plubf(u,v);
+++ bfplus compiled, 8 + 12 bytes
bfplus

symbolic procedure difbf(a,b);
% this function calculates the normalized rounded difference of a and b,
% but avoids generating large numbers if magnitude difference is large.
  rndpwr
    begin scalar ma,mb,ea,eb,d,ld,p;
      if (ma:=mt!: a)=0 then return minus!: b;
      if (mb:=mt!: b)=0 then return a;
      if (d := (ea := ep!: a)-(eb := ep!: b))=0
        then return make!:ibf(ma - mb,ea);
      ld := d+msd!: abs ma - msd!: abs mb;
      p := !:bprec!:+1;
      if ld>p then return a;
      if ld<-p then return minus!: b;
      if d>0 then return make!:ibf(ashift(ma,d) - mb,eb)
        else return make!:ibf(ma - ashift(mb,-d),ea) end;
+++ difbf redefined
+++ difbf compiled, 160 + 36 bytes
difbf

symbolic procedure bfdiffer(u,v); if atom u then u - v else difbf(u,v);
+++ bfdiffer compiled, 8 + 12 bytes
bfdiffer

symbolic procedure invbf u; divbf(bfone!*,u);
+++ invbf redefined
+++ invbf compiled, 9 + 24 bytes
invbf

symbolic procedure bfinverse u; if atom u then 1.0/u else invbf u;
+++ bfinverse compiled, 10 + 16 bytes
bfinverse

symbolic procedure bfminus u; if atom u then -u else minus!: u;
+++ bfminus redefined
+++ bfminus compiled, 9 + 12 bytes
bfminus

symbolic procedure bflessp(a,b); if atom a then a<b else grpbf(b,a);
+++ bflessp redefined
+++ bflessp compiled, 8 + 12 bytes
bflessp

symbolic procedure grpbf(a,b);
  % this function calculates a > b, but avoids generating large numbers
  % if magnitude difference is large.
   <<if ma=0 then mb<0
     else if mb=0 then ma>0
     else if ma>0 and mb<0 then t
     else if ma<0 and mb>0 then nil
     else (if do>0 then ma>0           % the case |a| > |b|
            else if do<0 then ma<0     % the case |a| < |b|
            else if de=0 then ma>mb    % exponents are the same
            else if de>0 then ashift(ma,de)>mb
            else ma>ashift(mb,-de))
          where do=order!: a - order!: b,
                de=ep!: a - ep!: b>>
    where ma=mt!: a,mb=mt!: b;
+++ grpbf compiled, 104 + 24 bytes
grpbf

%symbolic procedure bfminusp u; if atom u then minusp u else minusp!: u;

%symbolic procedure bfzp u; if atom u then zerop u else mt!: u=0;

%symbolic procedure bf!:zerop u; if atom u then zerop u else mt!: u=0;

%symbolic procedure bfnzp u; not bfzp u;

%symbolic procedure bfloat x; if floatp x then fl2bf x else
%normbf(if atom x then if fixp x then i2bf!: x else read!:num x else x);

symbolic procedure !!shbinflp;
   begin integer n; vv!! := 9.0;
     while n<300 and not errorp errorset!*('(vv!!!*1e10),nil)
        do n := n+10;
     return n<300 end;
+++ !!shbinflp compiled, 29 + 40 bytes
!shbinflp

symbolic procedure vv!!!*1e10; vv!! := vv!!*1.0e10;
+++ vv!!!*1e10 compiled, 5 + 16 bytes
vv!*1e10

symbolic (!!shbinfl := !!shbinflp());nil

symbolic procedure bfsqrt x;
 % computes sqrt x by Newton's method.
  if minusp!: x then terrlst(x,'bfsqrt) else
  begin  scalar nx,dx,dc,k7,nf;
         if bfzerop!: x then return bfz!*;
         k7 := !:bprec!: + 7;
         dc := make!:ibf (1, (-k7+(order!: x + 10)/2));
         nx := if not oddintp ep!:(nx := conv!:mt(x,2))
            then make!:ibf((2+3*mt!: nx)/5, (ep!: nx/2))
            else make!:ibf((9+5*mt!: nx)/10, ((ep!: nx - 1)/2));
         nf := 1;
   loop: if (nf := 2*nf)>k7 then nf := k7;
         dx := times!:(bfhalf!*,plus!:(divide!:(x,nx,nf),nx));
         if nf>=k7 and not greaterp!:(abs!: difference!:(dx,nx),dc)
            then return rndpwr nx;
         nx := dx; go to loop end;
+++ bfsqrt compiled, 185 + 104 bytes
bfsqrt

symbolic procedure realrat x;
   begin scalar d,g;
         if bfp!: x then go to bf;
         if eqcar(x,'quotient) then
            if fixp cadr x and fixp caddr x then
               <<x := if (d := caddr x)<0 then -cadr x else cadr x;
                 d := abs d; go to ret>>
            else x := cadr x/caddr x;
         if zerop x then return (0 . 1);
         if not floatp x then return (x . 1);
         x := bfloat x;
     bf: d := cddr(x := normbf x); x := cadr x;
         if x=0 then return (0 . 1);
         if d< 0 then d := lshift(1,-d)
          else <<x := ashift(x,d); d := 1>>;
    ret: g := gcdn(abs x,d); return (x/g) . (d/g) end;
+++ realrat compiled, 151 + 44 bytes
realrat

remflag ('(fl2int),'lose);nil

symbolic procedure fl2int x;
   <<x := fl2bf x;
     (if d=0 then m else ashift(m,d))
      where m=mt!: x,d=ep!: x>>;
+++ fl2int compiled, 17 + 20 bytes
fl2int

flag ('(fl2int),'lose);nil

symbolic procedure cflot x;
   if floatp x then x else if atom x then float x else bf2flr x;
+++ cflot redefined
+++ cflot compiled, 14 + 12 bytes
cflot

symbolic procedure conv!:bf2i nmbr;
% This function converts a <BIG-FLOAT>, i.e., a BINARY BIG-FLOAT
%      representation of "n", to an integer.  The result
%      is the integer part of "n".
% **** For getting the nearest integer to "n", please use
% ****      the combination MT!:( CONV!:EP(NMBR,0)).
% NMBR is a BIG-FLOAT representation of the number "n".
%   if ep!:(nmbr := cut!:ep(nmbr, 0)) = 0 then mt!: nmbr
%    else
     ashift (mt!: nmbr, ep!: nmbr);
+++ conv!:bf2i redefined
+++ conv!:bf2i compiled, 6 + 12 bytes
conv:bf2i

symbolic procedure bf2flr u;
   % u is always bigfloat.
   % Converts bfloat to float by rounding at !!nbfpd binary digits.
   % We use error1 rather than rerror, because we want to catch such an
   % error in an errorset.
   begin scalar ep,m,y;
      if bfzerop!: u then return 0.0;
      ep := ep!:(u := round!:mt(u,!!nbfpd));
      if grpbf(!!minflbf,y := abs!: u) or grpbf(y,!!maxflbf)
        then error1();
      if ep<0 then <<ep := ep+!!nbfpd; m := t>>;
      ep := 2.0**ep;
      if ep = 0.0 then error1(); % underflow
      return if not m then ep * mt!: u else ep * mt!: u / !!flbint
   end;
+++ bf2flr compiled, 76 + 52 bytes
bf2flr

symbolic procedure gf2fl a; % force into float format.
   if atom a then a else if bfp!: a then bf2flr a
      else (gf2fl car a) . gf2fl cdr a;
+++ gf2fl compiled, 31 + 16 bytes
gf2fl

symbolic procedure gf2bf a; if a then % force into bfloat format.
   if atom a then bfloat a else if bfp!: a then a
      else (gf2bf car a) . gf2bf cdr a;
+++ gf2bf compiled, 65 + 32 bytes
gf2bf

symbolic procedure r2bf u;
  % translate any real number object to bigfloat.
    if atom u then bfloat u
       else if bfp!: u then u
       else if numberp car u then divbf(i2bf!: car u,i2bf!: cdr u)
       else if eqcar(u,'quotient) then
            divbf(i2bf!: cadr u,i2bf!: caddr u)
       else if eqcar(u,'!:rn!:) then r2bf cdr u
       else r2bf cadr u;
+++ r2bf compiled, 93 + 44 bytes
r2bf

symbolic procedure r2fl u;
 % translate any real number object to float.
   if u=0 then 0.0
      else if atom u then float u
      else if numberp car u then (float car u)/cdr u
      else if eqcar(u,'quotient) then (float cadr u)/caddr u
      else if bfp!: u then bf2flr u
      else if eqcar(u,'!:rn!:) then r2fl cdr u
      else r2fl cadr u;
+++ r2fl compiled, 58 + 32 bytes
r2fl

symbolic procedure gfplus(u,v);
   if atom car u then gffplus(u,v) else gbfplus(u,v);
+++ gfplus redefined
+++ gfplus compiled, 11 + 16 bytes
gfplus

symbolic procedure gffplus(u,v); (car u+car v) . (cdr u+cdr v);
+++ gffplus compiled, 11 + 8 bytes
gffplus

symbolic procedure gbfplus(u,v);
   (plubf(car u,car v)) . plubf(cdr u,cdr v);
+++ gbfplus redefined
+++ gbfplus compiled, 11 + 12 bytes
gbfplus

symbolic procedure gfdiffer(u,v);
   if atom car u then gffdiff(u,v) else gbfdiff(u,v);
+++ gfdiffer redefined
+++ gfdiffer compiled, 11 + 16 bytes
gfdiffer

symbolic procedure gffdiff(u,v); (car u - car v) . (cdr u - cdr v);
+++ gffdiff compiled, 11 + 8 bytes
gffdiff

symbolic procedure gbfdiff(u,v);
   (difbf(car u,car v)) . difbf(cdr u,cdr v);
+++ gbfdiff redefined
+++ gbfdiff compiled, 11 + 12 bytes
gbfdiff

symbolic procedure gftimes(u,v);
   if atom car u then gfftimes(u,v) else gbftimes(u,v);
+++ gftimes redefined
+++ gftimes compiled, 11 + 16 bytes
gftimes

symbolic procedure gfftimes(u,v);
   begin scalar ru,iu,rv,iv;
         ru := car u; iu := cdr u; rv := car v; iv := cdr v;
         return (ru*rv - iu*iv) . (ru*iv+iu*rv) end;
+++ gfftimes redefined
+++ gfftimes compiled, 34 + 8 bytes
gfftimes

symbolic procedure gbftimes(u,v);
   begin scalar ru,iu,rv,iv;
         ru := car u; iu := cdr u; rv := car v; iv := cdr v;
         return (difbf(timbf(ru,rv),timbf(iu,iv))) .
            plubf(timbf(ru,iv),timbf(iu,rv)) end;
+++ gbftimes redefined
+++ gbftimes compiled, 35 + 20 bytes
gbftimes

symbolic procedure gfquotient(u,v);
   if atom car u then gffquot(u,v) else gbfquot(u,v);
+++ gfquotient redefined
+++ gfquotient compiled, 11 + 16 bytes
gfquotient

symbolic procedure gffquot(u,v);
   begin scalar ru,iu,rv,iv,d;
         ru := car u; iu := cdr u; rv := car v; iv := cdr v;
         d := rv*rv+iv*iv;
         return ((ru*rv+iu*iv)/d) . ((iu*rv - ru*iv)/d) end;
+++ gffquot compiled, 50 + 8 bytes
gffquot

symbolic procedure gbfquot(u,v);
   begin scalar ru,iu,rv,iv,d;
         ru := car u; iu := cdr u; rv := car v; iv := cdr v;
         d := plubf(timbf(rv,rv),timbf(iv,iv));
         return divbf(plubf(timbf(ru,rv),timbf(iu,iv)),d) .
            divbf(difbf(timbf(iu,rv),timbf(ru,iv)),d) end;
+++ gbfquot compiled, 58 + 32 bytes
gbfquot

symbolic procedure gfminus u; (bfminus car u) . (bfminus cdr u);
+++ gfminus compiled, 9 + 12 bytes
gfminus

symbolic procedure gfrotate u; (bfminus cdr u) . (car u);
+++ gfrotate compiled, 5 + 12 bytes
gfrotate

%symbolic procedure gfrl u; car u;

%symbolic procedure gfim u; cdr u;

%symbolic procedure gfzerop u;
%   if not atom gfrl u then mt!: gfrl u = 0 and mt!: gfim u = 0
%      else equal(u,(0.0 . 0.0));

symbolic procedure gfdot(u,v);
   if atom car u then gffdot(u,v) else gbfdot(u,v);
+++ gfdot redefined
+++ gfdot compiled, 11 + 16 bytes
gfdot

symbolic procedure gffdot(u,v); car u*car v+cdr u*cdr v;
+++ gffdot redefined
+++ gffdot compiled, 10 + 8 bytes
gffdot

symbolic procedure gbfdot(u,v);
   plubf(timbf(car u,car v),timbf(cdr u,cdr v));
+++ gbfdot redefined
+++ gbfdot compiled, 11 + 16 bytes
gbfdot

symbolic procedure gfrsq u; gfdot(u,u);
+++ gfrsq redefined
+++ gfrsq compiled, 4 + 12 bytes
gfrsq

symbolic procedure gffrsq u; car u*car u+cdr u*cdr u;
+++ gffrsq compiled, 10 + 8 bytes
gffrsq

symbolic procedure gbfrsq u;
   plubf(timbf(car u,car u),timbf(cdr u,cdr u));
+++ gbfrsq compiled, 11 + 16 bytes
gbfrsq

symbolic procedure gffmult(r,u); (r*car u) . (r*cdr u);
+++ gffmult compiled, 11 + 8 bytes
gffmult

symbolic procedure gffsqrt x;
   begin scalar x0,nx,xd,xd0,rl,im; rl := gfrl x; im := gfim x;
     rl := sqrt(hypot(rl,im)/2+rl/2); im := im/(2*rl); nx := rl . im;
     repeat
       <<x0 := nx;
         nx := gffmult(0.5,gffplus(x0,gffquot(x,x0)));
         xd0 := xd; xd := gffrsq gffdiff(x,gfftimes(nx,nx))>>
     until xd0 and xd0 - xd<=0.0; return x0 end;
+++ gffsqrt compiled, 78 + 52 bytes
gffsqrt

symbolic procedure gbfmult(r,u);
   <<r := bfloat r; (timbf(r,car u)) . (timbf(r,cdr u))>>;
+++ gbfmult compiled, 40 + 32 bytes
gbfmult

symbolic procedure gbfsqrt x;
   begin scalar x0,nx,xd,xd0,rl;
     nx :=
      <<rl := (bfsqrt timbf(bfhalf!*,plubf(bfsqrt gfrsq x,gfrl x)));
        rl . timbf(bfhalf!*,divbf(gfim x,rl))>>;
     repeat
       <<x0 := nx;
         nx := gbfmult(bfhalf!*,gbfplus(x0,gbfquot(x,x0)));
         xd0 := xd; xd := gbfrsq gbfdiff(x,gbftimes(nx,nx))>>
     until xd0 and mt!: difbf(xd0,xd)<=0; return x0 end;
+++ gbfsqrt compiled, 80 + 72 bytes
gbfsqrt

symbolic inline procedure rl2gfc x;
   x . if atom x then 0.0 else bfz!*;
+++ Record new inline definition:
(de rl2gfc (x) (cons x (cond ((atom x) 0.0) (t bfz!*))))
(progn (de rl2gfc (x) (cons x (cond ((atom x) 0.0) (t bfz!*)))) (put (quote
rl2gfc) (quote number!-of!-args) 1) (put (quote rl2gfc) (quote procedure_type) (
quote (arrow general general))) (putc (quote rl2gfc) (quote inline) (quote (
lambda (x) (cons x (cond ((atom x) 0.0) (t bfz!*)))))))
+++ rl2gfc compiled, 12 + 16 bytes
(lambda (x) (cons x (cond ((atom x) 0.0) (t bfz*))))

symbolic procedure gfsqrt x;
 % computes gfsqrt x by Newton's method, for both gf and gbf.
   begin scalar xn,neg,negi;
         if gfzerop x then return x;
         if bfminusp gfrl x
           then <<x := gfminus x; neg := t;
                  if special!_bfminusp gfim x then nil else negi := t >>;
         if bfzp gfim x then
            <<x := gfrl x;
              xn := rl2gfc(if atom x then sqrt x else bfsqrt x);
              go to ret>>;
         xn := if atom gfrl x then gffsqrt x else gbfsqrt x;
         if negi then xn := gfminus xn;
    ret: return if neg then gfrotate xn else xn end;
+++ gfsqrt compiled, 119 + 60 bytes
gfsqrt

symbolic procedure sgn x; if x>0 then 1 else if x<0 then -1 else 0;
+++ sgn redefined
+++ sgn compiled, 15 + 20 bytes
sgn

symbolic procedure exptbf(x,n,a);
  % Computes a*x**n in bfloat arithmetic for positive x
  % and positive integer n.
   begin
  lp: if oddintp n then a := timbf(a,x); % not evenp n
      n := lshift (n, -1);
      if n=0 then return a;
      x := timbf(x,x); go to lp end;
+++ exptbf redefined
+++ exptbf compiled, 21 + 24 bytes
exptbf

symbolic procedure icbrt(x);
   % x is a number : result is integer s approx cube root of x,
   % i.e. if x > 0 then s**3 <= n < (s+1)**3 o/w s**3 >= n > (s-1)**3.
   irootn(fix2(x),3);
+++ icbrt compiled, 6 + 16 bytes
icbrt

symbolic procedure fix2 x; if fixp x then x else fl2int x;
*** fix2 not defined (LOSE flag) 
nil

symbolic procedure ilog2 n;
   % n is an integer.  Result is an integer r, s.t. 2**r <= abs(n)
   %  < 2**(r+1).
   begin scalar ans, powers!-of!-2, pwr;
      if n<=0 then terrlst(n,'ilog2);
      pwr := 2;
      powers!-of!-2 := pwr . nil;
      while n>pwr do
         <<powers!-of!-2 := pwr . powers!-of!-2; pwr := pwr*pwr>>;
      ans := 0;
      while(pwr := car(powers!-of!-2)) neq 2 do
        <<powers!-of!-2 := cdr(powers!-of!-2);
          if n >= pwr then << n := n/pwr; ans := ans + 1; >>;
          ans := ans*2>>;
      if n >= 2 then ans := ans + 1;
      return ans
   end;
+++ ilog2 redefined
+++ ilog2 compiled, 63 + 20 bytes
ilog2

symbolic procedure isqrt(x);
   % x is a number : result is integer s approx square root of x,
   % i.e. if x > 0 then s**2 <= n < (s+1)**2 o/w s**2 >= n > (s-1)**2.
   if x<=0 then terrlst(x,'isqrt) else irootn(fix2(x), 2);
+++ isqrt compiled, 18 + 24 bytes
isqrt

symbolic procedure qroundup(m,n);
   % m, n are integers, n>0 : result is least integer >= m/n.
   if m<0 then -((-m)/n) else (m+n-1)/n;
+++ qroundup redefined
+++ qroundup compiled, 23 + 8 bytes
qroundup

symbolic procedure irootn(n,r);
    % n, r are integers : result is integer s approx r'th root of n,
    % i.e. if n > 0 then s**r <= n < (s+1)**r o/w s**r >= n > (s-1)**r.
    if not fixp n then typerr(n,"integer")
     else if not fixp r or r<=0 then typerr(r,"positive integer")
     else if n<0
      then if evenp r then typerr(r,"odd integer") else -irootn(-n,r)
     else if r = 1 then n
     else if n = 0 then 0
     else begin scalar ans;
             ans := irootn1(n,r,ilog2 n,(ilog2 r)/2);
             if ans**r>n then return ans - 1 else return ans
       end;
+++ irootn compiled, 89 + 44 bytes
irootn

symbolic procedure irootn!-power2(p, q);
   % p, q are positive integers.
   % Result is an integer (slightly) greater than 2**(p/q).
   % Uses the first few terms of the Taylor expansion (tweaked a bit).
   % Error (of numans/denans) is at most 0.03%.
   begin scalar whole!-part, p1, numans, denans;
      whole!-part := (p+q/2)/q;
      p1 := p-q*whole!-part;
      numans := q^3/100 + 1000*q^3 + 693*q^2*p1 + 243*q*p1^2 + 57*p1^3;
      denans := 1000*q^3;
      return 1+ (2^whole!-part * numans)/denans
      % add 1 to force rounding up
   end;
+++ irootn!-power2 compiled, 101 + 36 bytes
irootn-power2

symbolic procedure irootn1(n,r,logn,xs);
   % n, r integers >0, logn is ilog2(n), xs is the excess # bits in the
   % top 1/2.
   % result is s, s.t. s**r <= n < (s+1)**r or (s-1)**r <= n < s**r.
   begin scalar x, upb, size, tmp;
      size := logn / r;
      if size < 17 then upb := irootn!-power2(1+logn, r)
       else <<x := size/2 - xs;
              upb := irootn1(n/2**(x*r), r, logn-r*x, xs)*2**x;
              tmp := upb**(r-1);
              return (((r-1)*upb)*tmp+n)/(r*tmp)>>;
      repeat <<x := upb; upb := x - qroundup(x - n/x**(r-1),r)>>
         until upb >= x;
      return x
   end;
+++ irootn1 compiled, 119 + 24 bytes
irootn1

put('irootn,'number!-of!-args,2);2   %  For VALUECHK.

endmodule;nil

end;nilmodule paraset;nil   % Parameter determining module.

% Author: Stanley L. Kameny.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% Last change date: 25 June 2015.

% Paraset.red determines the parameters !!nfpd, !!nbfpd, and !!maxbflexp
% for floating point numbers.  !!nfpd, !!nbfpd, and !!maxbflexp are
% computed at load, but !!maxbflexp may have to be fixed up at run time
% if !!flexperr is true.
% [March 2015] also compute !!minnorm the smallest normalised floating
% point number. This will mostly be relevant for IEEE arithmetic and will
% end up as just the smallest non-zero number if subnorms are not in use.
% Provide (more or less) portable definitions of tests for infinity, NaN and
% subnorms... with the one for infinity being cheaper than the use of
% explode.

imports errorp, errorset!*, neq, roundconstants;nil

exports !!mfefix, find!!nbfpd, find!!nfpd, infinityp;nil

global '(!!nfpd !!nbfpd !!!~xx !!yy !!maxbflexp !!flexperr !!plumax
         !!epsqrt !!flint !!flbint !!floatbits);nil

flag('(!!nfpd !!nbfpd !!maxflexp),'share);nil

symbolic procedure find!!nfpd;
   begin scalar x,y,z;integer i; x:=y:=9.0;
      repeat <<x := 10.0*x+y; i := i+1>> until (z := x+1.0)=x;
% The following line and the corresponding one in find!!nbfpd can call
% FIX on a a value that is around 10^16 (if floats are IEEE 64-bit values) and
% that might lead to unreliable conseqences. If arithmetic is IEEE (as maybe
% it mostly will be these days) then the test would fail anyway, so
% in that case commenting it out can not have adverse effects!
%     if 10.0*fix(z/10) - 1.0 neq x then i := i - 1;
      return !!nfpd:=i end;
+++ find!!nfpd compiled, 32 + 32 bytes
find!nfpd

symbolic procedure find!!nbfpd;
   begin scalar x,y,z;integer i; x:=y:=1.0;
      repeat <<x := 2.0*x+y; i := i+1>> until (z := x+1.0)=x;
%     if 2.0*fix(z/2) - 1.0 neq x then i := i-1;
      return !!nbfpd:=i end;
+++ find!!nbfpd compiled, 32 + 28 bytes
find!nbfpd

symbolic procedure find!!maxbflexp;
   begin scalar z; integer n;
      !!!~xx := 1.0;
      while not errorp
       (z := errorset!*(
          '(progn (setq !!yy (plus 1.0 (times !!!~xx 2.0)))
                  (and (not (infinityp !!yy))
                       (greaterp !!yy !!!~xx))),nil))
         and car z do
            <<n := n+1; !!!~xx := !!yy>>;
      !!flexperr := not errorp z and not car z;
      return !!maxbflexp := n end;
*** find!maxbflexp not defined (LOSE flag) 
nil

symbolic procedure find!!minnorm();
   begin scalar a, b, c;
     a := 1.0;
     b := 0.0;
     repeat <<
       c := b;
       b := a;
       a := 2.0*a + 1.0 >> until a/2.0 = b;
% Now c should be a numbers whose mantissa has all possible bits set.
     repeat <<
       b := c;
       c := c/2.0 >> until 2.0*c neq b;
% If my computer does not provide denormalised numbers this loop
% will end on an underflow with c zero.
     if c = 0.0 then !!minnorm := b
     else !!minnorm := c;
     !!minnegnorm := -!!minnorm
   end;
+++ find!!minnorm compiled, 51 + 28 bytes
find!minnorm

% I believe I might now retire this in favour of fp!-infinite but BEWARE
% that this code will also reply "true" on NaNs as well as infinities.

symbolic procedure infinityp u;
   % Check for a representation of an IEEE floating point infinity.
   % YUK this might also return true on a NaN!
   not(x eq '!- or digit x) where x=car explode u;
+++ infinityp compiled, 16 + 20 bytes
infinityp

symbolic procedure !!mfefix;
  <<if !!flexperr then
      begin integer n;
        !!flexperr := !!plumax := nil;
        while errorp errorset!*('(explode !!!~xx),nil) do
          <<!!!~xx := !!!~xx/2.0; n := n+1>>;
        !!maxbflexp := !!maxbflexp - n;
      end;
    if not !!plumax then roundconstants()>>;
+++ !!mfefix compiled, 42 + 48 bytes
!mfefix

find!!nfpd();15 find!!nbfpd();53
find!!maxbflexp();1022 find!!minnorm();nil

!!epsqrt := 10.0**((-1 - !!nfpd)/2);1.0e-08

!!flint := 10.0**!!nfpd;1.0e+15

!!flbint := 2.0 ** !!nbfpd;9.0072e+15

!!floatbits := (10*(!!nfpd + 1))/3;53  % Smallest power of 2 that does
               % not fit in mantissa.  Note that 10/3 > log(10)/log(2).


% The following should only ever be used on floating point values. Note
% that it may be important to use EQN not EQUAL here in case EQUAL treats
% things that are EQ as being equal, while NaN must not be treated as
% equal even to itself.

% I pre-check for zero so that I do not attempt to compute 1.0/0.0. This
% is because on systems that do not actually have infinities that attempt at
% division could raise an exception. Well even without that situation I can
% worry because if x is a sub-normalised number (eg 1.0e-311) its reciprocal
% could be an IEEE infinity. So my first attempt here was not good enough to
% be safe for PSL. Hence the fact that I only do the division if the absolute
% value of x is at least 1.0e300. So almost all non-infinities will be
% detected by the range check and only the extreme ones fall to the
% reciprocal test.

symbolic inline procedure fp!-infinite x;
  (x > 1.0e300 or x < -1.0e300) and eqn(1.0/x, 0.0);
*** fp-infinite not defined (LOSE flag) 
nil

symbolic inline procedure fp!-nan x;
  not eqn(x, x);
*** fp-nan not defined (LOSE flag) 
nil

symbolic inline procedure fp!-finite x;
  eqn(x-x, 0.0);
*** fp-finite not defined (LOSE flag) 
nil

symbolic inline procedure fp!-subnorm x;
  x < !!minnorm and x > !!minnegnorm;
*** fp-subnorm not defined (LOSE flag) 
nil


endmodule;nil

end;nilmodule math;nil  % Mathematical Package for REDUCE.

% Author: Stanley L. Kameny <valley!stan@rand.org>,
% and Arthur C. Norman.

% Modifications by: John Abbott.

% Version and Date:  Mod 1.63, 23 June 1993.

% Copyright (c) 1987, 1988, 1989, 1990, 1991, 1993 Stanley L. Kameny.
% All Rights Reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


%*******************************************************************
%**                                                               **
%**  This math package will compute the floating point values of  **
%**  the usual elementary functions, namely:                      **
%**     sin     asin     sind    asind     sinh    asinh          **
%**     cos     acos     cosd    acosd     cosh    acosh          **
%**     tan     atan     tand    atand     tanh    atanh          **
%**     cot     acot     cotd    acotd     coth    acoth          **
%**     sec     asec     secd    asecd     sech    asech          **
%**     csc     acsc     cscd    acscd     csch    acsch          **
%**             atan2            atan2d                           **
%**     exp     ln       sqrt    factorial                        **
%**     expt    log      cbrt                                     **
%**     logb    hypot                                             **
%**     log10   floor                                             **
%**             ceiling                                           **
%**             round                                             **
%**                                                               **
%**  All functions are computed to the accuracy of the floating-  **
%**  point precision of the system set up at the time.            **
%**                                                               **
%*******************************************************************

% Revisions:

%    22 Jul 18  Correctly handle non-finite IEEE floats.
%     1 May 93  expt improved; fix2 eliminated (not needed).
%    15 Sep 92  expt, hypot, log improved. factorial added.
%    25 May 91  atan2d added.  Function list updated.
%     6 Feb 90  exp, expt, and hyperbolic functions improved.
%     6 Nov 90  find!!nfpd improved; fl2int eliminated (now in bfauxil.)
%    31 Mar 90  fl2int speeded up for very large argument.
%    25 Feb 90  expt modified.
%    15 Oct 89  atan2 and sind,asind family added.
%     8 Oct 89  !!scalsintan,sqrt,expt,and hyperbolics modified.
%     8 Oct 89  hypot,floor,ceiling,round added
%    26 Aug 89  zerop test used in expt
%    20 Jul 89  !!scalsintan revised: same limits for deg and rad
%    17 May 89  find!!nfpd revised (for binary or decimal floats)
%    18 Apr 89  global log10 -> logten (to avoid name conflict)
%    18 Apr 89  !!scalsintan revised (per: Rainer Schoepf)
%    27 Nov 88  log,expt,sqrt revised for speed
%     5 Jun 88  log -> log10; ln -> log; exptfp -> expt (revised)
%    11 Nov 87  hyperbolic fns rewritten: speeded up; improved
%     6 Nov 87  ln,atan rewritten: speeded up. sq!-1  eliminated
%    30 Oct 87  sin,(cos),tan,(cot),exp  rewritten; speeded up

%*******************************************************************
%**                       Basic functions                         **
%*******************************************************************

exports acos, acosd, acosh, acot, acotd, acoth, acsc, acscd, acsch,
        asec, asecd, asech, asin, asind, asinh, atan, atan2, atan2d,
        atand, atanh, cbrt, ceiling, cos, cosd, cosh, cot, cotd, coth,
        csc, cscd, csch, exp, factorial, floor, hypot, log, log10,
        logb, sec, secd, sech, sin, sind, sinh, sqrt, tan, tand, tanh,
        terrlst;nil

imports !!shbinflp, fl2int, geq, leq, neq, rerror, sgn;nil

global '(math!!label);nil
math!!label := "Math package mod 1.7, 1 May 93";Math package mod 1.7, 1 May 93

symbolic procedure terrlst (x,y); error(0,list(x," invalid for ",y));
+++ terrlst compiled, 11 + 20 bytes
terrlst

global '(!!nfpd !!flint !!epsqrt !!flprec !!floatbits);nil

if not !!nfpd then flag('(!!nfpd),'share);nil

symbolic procedure sqrt x;
 % Computes sqrt x by Newton's method, avoiding magnitude problems.
   if x<0 then terrlst(x,'sqrt) else
   begin  scalar trv,nx,g,l,o,c1,c2,f1; f1 := nx := o := 1.0;
          x := float x;
          if not fp!-finite x or x=0.0 or x=o then return x;
          if x<o then <<x := o/x; l := t>>;
          c1 := 8192.0; c2 := c1*c1;
          while x>c2 do <<x := x/c2; f1 := f1*c1>>;
    loop: trv := nx; nx := (trv + x/trv)/2;
          if g and nx>=trv then go to ret;
          g := t; go to loop;
     ret: nx := nx*f1; return if l then o/nx else nx end;
*** sqrt not defined (LOSE flag) 
nil

symbolic procedure cbrt x;
   begin scalar s,l,o,g,trv,nx,c1,c2,f1; f1 := nx := o := 1.0;
         x := float x;
         if not fp!-finite x or x=0.0 or abs x=o then return x
         else if x<0 then x := -x else s := t;
         if x<o then <<x := o/x; l := t>> else if x=o then go to ret;
         c1 := 1024.0; c2 := c1*c1*c1;
         while x>c2 do <<x := x/c2; f1 := f1*c1>>;
   loop: trv := nx; nx := trv/1.5+x/(trv*trv*3);
         if g and nx>=trv then go to ret;
         g := t; go to loop;
    ret: nx := nx*f1; if l then nx := o/nx;
         return if s then nx else -nx end;
*** cbrt not defined (LOSE flag) 
nil

symbolic procedure hypot(p,q);
   % Hypot(p,q)=sqrt(p*p+q*q) but avoids intermediate overflow.
   if floatp p and not fp!-finite p then p
   else if floatp q and not fp!-finite q then q
   else begin scalar r;
         p := float p; if not fp!-finite p then return abs p;
         q := float q; if not fp!-finite q then return abs q;
         if p<0 then p := -p;
         if q<0 then q := -q;
         if zerop p then return q
         else if zerop q then return p
         else if p<q then <<r := p; p := q; q := r>>;
         if p+q=p then return p else r := q/p;
         return if r<!!epsqrt then p else p*sqrt(1+r*r) end;
*** hypot not defined (LOSE flag) 
nil

symbolic procedure floor x;
   % Returns the largest integer less than or equal to x
   % (i.e. the "greatest integer" function.)
   % Note the trickiness to compensate for fact that (unlike APL's
   % "FLOOR" function) FIX truncates towards zero.
   % A definition of fix(x+sgn(x)*0.5) has also been suggested.
   if fixp x then x
   else if not fp!-finite x then terrlst(x,'floor)
    else (if x = float n then n else if x >= 0 then n else n - 1)
       where n = fix x;
*** floor not defined (LOSE flag) 
nil

symbolic procedure ceiling x;
   % Returns the smallest integer greater than or equal to X.
   % Note the trickiness to compensate for fact that (unlike APL's
   % "FLOOR" function) FIX truncates towards zero.
   if fixp x then x
    else if not fp!-finite x then terrlst(x,'ceiling)
    else (if x = float n then n else if x >= 0 then n+1 else n)
       where n = fix x;
*** ceiling not defined (LOSE flag) 
nil

symbolic procedure round x;
   % Rounds to the closest integer.
   % Kind of sloppy -- it's biased when the digit causing rounding is a
   % five.  (Changed to work properly for X<0.  SLK)
   if fixp x then x
    else if not fp!-finite x then terrlst(x,'round)
    else if x<0 then -round(-x) else floor(x+0.5);
*** round not defined (LOSE flag) 
nil

symbolic procedure rounddec (x,p);
   % Rounds x to p decimal places, unless x must already be an integer.
   if abs x>=!!flint then x
    else  begin scalar xl,xr,sc;
            sc := 10.0**p; xl := fix(x := x*sc); xr := x - xl;
            if x>0 and xr>=0.5 then xl := xl+1;
            if x<0 and xr<-0.5 then xl := xl - 1;
            return xl/sc
          end;
+++ rounddec compiled, 55 + 28 bytes
rounddec

global '(!!log!&2list);nil

global(!!log!&2list := '(!!log2 !!sq2 !!sq2!-1 !!logsq2 
      	       	         !!logten !!log1000 !!log1e9 !!log1e81 !!log1e27));nil

remflag(!!log!&2list,'reserved);nil

!!sq2 := sqrt 2.0;1.41421 !!sq2!-1 := 1/(1+!!sq2);0.414214

symbolic procedure log x;
   begin scalar s,lx; integer p;
      if fixp(x) and (lx := ilog2(x)) > !!floatbits
        then return !!log2*(lx - !!floatbits)
                      + log(x/2^(lx - !!floatbits))
       else if fp!-nan x then return x
       else if (x := float x)<=0.0 then terrlst(x,'log)
       else if fp!-infinite x then return x
       else if x - 1<0 then x := 1/x else s := t;
      lx := 0.0;
      while x>1.0e81 do <<x := x/1.0e81; lx := lx+!!log1e81>>;
      while x>1.0e27 do <<x := x/1.0e27; lx := lx+!!log1e27>>;
      while x>1.0e9 do <<x := x/1.0e9; lx := lx+!!log1e9>>;
      while x>1000 do <<x := x/1000; lx := lx+!!log1000>>;
      while x>10 do <<x := x/10; lx := lx+!!logten>>;
      while x>2 do <<x := x/2; lx := lx+!!log2>>;
      if x>!!sq2 then <<x := x/!!sq2; lx := lx+!!logsq2>>;
      lx := lx+sclogx!-1(x - 1);
      return if s then lx else -lx end;
*** log not defined (LOSE flag) 
nil

symbolic procedure sclogx!-1 x;
   begin scalar tx,px,lx,st,sl; integer p;
         tx := px := x; p := 1; lx := 0.0;
         st := x*(1 - x/2);
         while st+abs tx>st do
            <<sl := tx . sl; tx := (px:=-px*x)/(p := p+1)>>;
         for each i in sl do lx := lx+i;
         return lx end;
+++ sclogx!-1 compiled, 76 + 24 bytes
sclogx-1

!!log2 := 2*(!!logsq2 := sclogx!-1 !!sq2!-1);0.693147
!!log1e81 := 3*(!!log1e27 := 3*(!!log1e9 := 3*(!!log1000 := 3*(!!logten := log 10.0))));
186.509

flag(!!log!&2list,'reserved);nil

global '(!!pilist);nil

global(!!pilist := '(!!pii !!pii2 !!pii3 !!pii4 !!pii6 !!twopi
                     !!rad2deg !!deg2rad));nil

remflag(!!pilist,'reserved);nil

symbolic procedure atan x;
   begin scalar arg,term,termp,trv,s,g,y;
      integer p;
      x := float x;
      if fp!-nan x then return x;
      if x < 0 then x := -x
       else s := t;
      if x > 1 then x:=1/x else g:=t;
      if x < !!epsqrt then go to quad;
      term := if x<0.43 then (arg := x)
         else (arg := x/(1+sqrt(1+x*x)))*2;
      arg := arg*arg; p := 1; trv := (termp := term)*(1 - arg/3);
      while trv+abs termp >trv do
        <<y := termp . y; termp := (term := -term*arg)/(p := p+2)>>;
      x := 0;
      for each i in y do x := x+i;
quad: if not g then x := !!pii2 - x;
      if not s then x := -x;
      return x end;
*** atan not defined (LOSE flag) 
nil

symbolic procedure atand x; !!rad2deg * atan x;
*** atand not defined (LOSE flag) 
nil

!!twopi := 2*(!!pii := 2*(!!pii2 := 2*(!!pii4:=atan 1.0)));6.28319
!!pii3 := 2*(!!pii6 := !!pii2/3);1.0472
!!deg2rad:=!!pii4/45;0.0174533 !!rad2deg:=45/!!pii4;57.2958

flag(!!pilist,'reserved);nil

fluid '(!*ddf!* !*df!* !*sf!* !*qf!*);nil

symbolic procedure sin x;
  % return NaN for non-finite argument
  if floatp x and not fp!-finite x then (x-x)
   else begin scalar !*sf!*,!*qf!*;integer p;
   % test for 90 deg -> 1.0
      x := !!scalsintan(x,t);
      if !*qf!* then <<x := 1.0; go to ret>>;
   % for x>45, compute cos of complement, else compute sin.
      if x>!!pii4 then x := !!pii2 - x else p := 1;
      x := !!sints(x,p);
   ret: return if !*sf!* then x else -x end;
*** sin not defined (LOSE flag) 
nil

symbolic procedure sind x;
  % return NaN for non-finite argument
  if floatp x and not fp!-finite x then (x-x)
   else begin scalar !*sf!*,!*qf!*;integer p;
   % test for 90 deg -> 1.0
      x := !!scalsintand(x,t);
      if !*qf!* then <<x := 1.0; go to ret>>;
   % for x>45, compute cos of complement, else compute sin.
      if x>45.0 then x := 90.0 - x else p := 1;
      x := !!sints(x*!!deg2rad,p);
   ret: return if !*sf!* then x else -x end;
*** sind not defined (LOSE flag) 
nil

symbolic procedure tan x;
   if floatp x and not fp!-finite x then (x-x)
    else begin scalar y,inv,!*sf!*,!*qf!*;
      y:=x; x:= !!scalsintan(x,nil);
      if !*qf!* then terrlst(y,'tan);
      if x>!!pii4 then x := !!pii2 - x else inv := t;
 % For scaled x>45, compute cot else compute tan.
      if x>!!epsqrt then <<x := !!sints(x,1); x := x/sqrt(1 - x*x)>>;
      if not inv then x := 1/x;
      return if !*sf!* then -x else x end;
*** tan not defined (LOSE flag) 
nil

symbolic procedure tand x;
  % return NaN for non-finite argument
   if floatp x and not fp!-finite x then (x-x)
    else begin scalar y,inv,!*sf!*,!*qf!*;
      y:=x; x:= !!scalsintand(x,nil);
      if !*qf!* then terrlst(y,'tand);
      if x>45.0 then x := 90.0 - x else inv := t;
 % For scaled x>45, compute cot else compute tan.
      x := x*!!deg2rad;
      if x>!!epsqrt then <<x := !!sints(x,1); x := x/sqrt(1 - x*x)>>;
      if not inv then x := 1.0/x;
      return if !*sf!* then -x else x end;
*** tand not defined (LOSE flag) 
nil

global '(max!-trig!-fact);nil max!-trig!-fact := 10**(!!nfpd/2);10000000

fluid '(!:prec!:);nil

symbolic procedure !!scalsintan(x,w);
% x is scaled to 0<=x<=90 deg, with !*sf!* = {sin>0 or tan<0}.
% w true for sin, false for tan.
%modified to avoid infinite loop for large x, after Rainer Schoepf's
%suggestion, adjusted so degree and radian input agrees- SLK.
   begin scalar xf,x0;
      if x<0 then x := -x else !*sf!* := t; x0 := x;
      if (xf := fix(x/!!twopi))>max!-trig!-fact then
         terrlst(if !*sf!* then x else -x,if w then 'sin else 'tan);
      x := x - float xf * !!twopi;
      if x>!!pii then (if w then
           <<x := !!twopi - x; !*sf!* := not !*sf!*>>
       else x := x - !!pii);
      if x>!!pii2 then x:=!!pii - x
       else if not w then !*sf!*:=not !*sf!*;
      !*qf!* := x>=!!pii2;
 % the remaining tests and scaling are done separately by sin and tan
      if x<x0/10.0**(!:prec!: - 3) then x := 0.0;
      return x end;
+++ !!scalsintan compiled, 128 + 68 bytes
!scalsintan

symbolic procedure !!scalsintand(x,w);
% x is scaled to 0<=x<=90 deg, with !*sf!* = {sin>0 or tan<0}.
% w true for sin, false for tan.
%modified to avoid infinite loop for large x, after Rainer Schoepf's
%suggestion, adjusted so degree and radian input agrees- SLK.
   begin scalar xf,x0;
      if x<0 then x := -x else !*sf!* := t; x0 := x;
      if (xf := fix(x/360.0))>max!-trig!-fact then
         terrlst(if !*sf!* then x else -x,if w then 'sin else 'tan);
      x := x - float xf * 360.0;
      if x>180.0 then (if w then
           <<x := 360.0 - x; !*sf!* := not !*sf!*>> else x:= x - 180.0);
      if x>90.0 then x:=180.0 - x else if not w then !*sf!*:=not !*sf!*;
      !*qf!* := x>=90.0;
 % the remaining tests and scaling are done separately by sin and tan
      if x<x0/10.0**(!:prec!: - 3) then x := 0.0;
      return x end;
+++ !!scalsintand compiled, 128 + 68 bytes
!scalsintand

symbolic procedure !!sints (x,p);
 % Does the actual computation of the sin or cos series.
   begin scalar sl,sq,st,term;
        x := float x;
        if x<!!epsqrt then return if p=1 then x else 1.0;
        sq := x*x;
        st := if p=1 then (term:=x)*(1 - sq/6)
               else (term:=1.0)*(1 - sq/2);
        while st + abs term > st do
           <<sl:=term . sl;
             p:=p+2.0;
             term:=-term*sq/((p - 1.0)*p) >>;
        x:=0.0;
        for each i in sl do x:=x+i;
        return x end;
+++ !!sints compiled, 116 + 36 bytes
!sints

symbolic procedure !!sinhts x;
 % Does the actual computation of the sinh for 0<x<0.91.
   begin scalar p,sl,sq,st,term;
        if x<2*!!epsqrt then return x;
        st:= (term := x)*(1 - (sq := x*x)/6); p := 1;
        while st + term > st do
           <<sl:=term . sl;
             p:=p+2.0;
             term:=term*sq/((p - 1.0)*p) >>;
        x := 0.0;
        for each i in sl do x := x+i;
        return x end;
+++ !!sinhts compiled, 89 + 36 bytes
!sinhts

global '(!!ee);nil

symbolic procedure exp v;
   begin scalar d,nr,mr,fr,st;integer p,ip;
         mr := fr := 1.0; v := float v;
	 if fp!-nan v then return v
          else if fp!-infinite v then return << if fp!-signbit v then 0.0 else v >>;
         if abs v>1 then <<ip := fix v; v := v - ip; fr := !!ee**ip>>;
         if abs v>0.5 then v := v/2 else d := t;
         if v=0.0 then go to ret;
         st := mr+v;
         while st+abs mr > st do
               <<nr := mr . nr; mr := mr*v/(p := p+1)>>;
         mr := 0.0;
         for each i in nr do mr := mr+i;
    ret: if not d then mr := mr*mr;
         return fr*mr end;
*** exp not defined (LOSE flag) 
nil

remflag('(!!ee),'reserved);nil !!ee := exp 1.0;2.71828 flag('(!!ee),'reserved);
nil

put('expt,'number!-of!-args,2);2

% NOTE that any Lisp system with a very good implementation of EXPT is
% entitled to replace the following definition of EXPT with it, but they
% should also arrange that fexpt gets redirected to the same good
% built-in function.

symbolic procedure iexpt(x,n);
   % Calculate x**n where n is a strictly positive integer.  This uses
   % repeated squaring.  It is appropriate for use when x is an integer,
   % and can be used for floating x provided that n is not too large.
   % John Abbott reported some slow calculations.  He added: The
   % problem is the line containing "lshift".  I tried replacing
   % remainder(x,2)=0 with evenp(x), and that made it go about twice as
   % fast.  Then I removed the line altogether, and the problem went
   % away.  I think that line would be useful only if n is quite large
   % and x is divisible by a moderately high power of 2.
   if not (n > 0) then error(0, "iexpt argument <= 0")
    else if n=1 or x=1 then x
%   else if fixp x and remainder(x,2)=0 then lshift(iexpt(x/2,n),n)
    else if remainder(n,2)=0 then (y*y) where y=iexpt(x,n/2)
%   else if evenp n then (y*y) where y=iexpt(x,n/2)
    else (x*y*y) where y=iexpt(x,(n - 1)/2) ;
+++ iexpt compiled, 58 + 28 bytes
iexpt

symbolic procedure expt(x,y);
   % Computes x**y.  Valid for any x provided that y is an integer,
   % but only for positive x if y is floating.
   begin integer iy,p; scalar sy,fy,r;
      % Some of the initial tests here are subsumed by those in rexpt,
      % and could be removed - but I prefer to implement a proper
      % general version of expt, even though doing so adds (slightly)
      % to the cost of using this portable version.  Note that getting
      % accurate answers from expt in a portable way is a real pain,
      % and I will not do a 100% good job here... see Cody and Waite
      % for a discussion of the issues involved.
      if zerop y then
         if zerop x then error(0,"0**0 undefined")
          else return if floatp x or floatp y then 1.0 else 1
       else if zerop x then
         if y>0 then return if floatp x or floatp y then 0.0 else 0
          else error(0,"divide by zero in EXPT")
       else if fixp y then
         return if fixp x then
                  if y < 0 then 0 else if x = 1 then 1 else iexpt(x,y)
      % See comments with the function FEXPT for an explanation of the
      % tests here - I deem exponents of less than 50 to be small
      % enough to handle the simple (and cheap) way.
                   else if y > 50 then fexpt(x, y)
                   else if y > 0 then iexpt(x, y)
                   else if y < -50 then 1.0/fexpt(x,-y)
                 else 1.0/iexpt(x,-y);
      % Since y is floating, float x if fixed.
      if fixp x then x := float x;
      if x<0.0 then
        error(0,"attempt to raise negative value to floating power");
      % Record the sign of y, but do not invert x yet, since it is
      % important not to corrupt the value of x by even one unit in the
      % last place.  Note that this will leave me with a risk that
      % (e.g.) 10.0**(-1000.0) will try to compute 10.0**1000.0 (which
      % will overflow) and only then take its reciprocal, while
      % possible had I inverted x here I would have had a silent
      % arithmetic underflow.  For now I will argue that arithmetic
      % underflow is really an error too and that the exception
      % deserved to be raised.
      if y < 0.0 then <<sy := t; y := -y>>;
      % Still use multiplication if y has integral value.
      iy := fix y;
      fy := float iy;
      if y = fy then <<
         if iy > 50 then x := fexpt(x, iy)
          else x := iexpt(x, iy);
         if sy then return 1.0/x
          else return x>>;
      % For x fairly close to 1.0 and smallish values of y I can use
      % the simple formula with exp and log, and I will not lose
      % overmuch accuracy.  The limits I apply here are a compromise
      % between wanting to use this cheap recipe as often as possible
      % and the desire to get best possible accuracy.
      if 0.1 < x and x < 10.0 and y < 5.0
        then <<if sy then y := -y; return exp(y*log x)>>;
      % Now scale x as 2^p * something
      p := 0;
      while x < 0.005524 do <<x := x*256.0; p := p - 8>>;
      while x < 0.707106781 do <<x := x*2.0; p := p - 1>>;
      while x >= 181.02 do <<x := x/256.0; p := p+8>>;
      while x >= 1.414213562 do <<x := x/2.0; p := p+1>>;
      % Now x is in the range 0.707 <= x < 1.414, so log x is fairly
      % small.  I can compute x**iy my multiplication, x**(y - iy) by
      % logs, and that just leaves 2**(y*p) to worry about.
      if (y - fy) > 0.5 then <<fy := fy+1.0; iy := iy+1>>;
      r := exp((y - fy)*log x);
      if iy > 50 then r := r*fexpt(x, iy)
       else if iy > 0 then r := r*iexpt(x, iy);
      y := p*y;
      iy := fix y;
      fy := y - float iy; % fractional part of y.
      % Now I need to compute 2**iy * 2**fy.
      r := r * exp(fy*!!log2);
      % I can afford to use iexpt() here since powers of 2.0 have exact
      % representations as floats (with binary machines!) so there
      % should be no rounding errors in what follows.
      if iy > 0 then r := r*iexpt(2.0, iy)
       else if iy < 0 then r := r*iexpt(0.5, -iy);
      if sy then r := 1.0/r;
      return r
   end;
*** expt not defined (LOSE flag) 
nil

COMMENT
   Consider the calculation z = 1.01 ** 16384.  I have chosen the
   exponent to be a power of 2 for simplicity of explanation, but other
   values will suffer the same way.  The value of z will be computed as
   (1.01*1.01) raised to the power 8192.  The multiplication 1.01*1.01
   will introduce an error of about e = 1/2 unit in the last place
   (around 1.0e-16 perhaps).  If all calculations after that very first
   multiplication are then performed exactly, the final result (6.3e70
   or so) will have a relative error of around 8000 units in the last
   place.  To avoid this sort of trouble it is necessary to use extra
   precision in the multiplications - something that slows us down but
   which is needed.  I only use this expensive code if I am going to
   raise a float to a power greater than 50 (a rather arbitrary
   cut-off) so that speed of calculation involving small powers is not
   hurt too badly;

symbolic procedure fsplit x;
   % This decomposes a floating point value x into two parts x1 and x2
   % such that x = x1+x2 and x1 is a number with at most 12 significant
   % bits in its mantissa.  I choose to keep 12 bits here since I then
   % expect (i.e., REQUIRE) that products of pairs of such numbers get
   % formed without any rounding at all.  This should be so even on
   % IEEE single precision arithmetic (25 bits of mantissa).  For IBM
   % mainframe single precision even more effort would be needed, but I
   % think I am now moving to a stance that only IEEE floats will ever be
   % used.
   begin scalar xx, n;
      if not fp!-finite x then return (x . 0.0);
      if x = 0.0 then return (0.0 . 0.0);
      xx := x; n := 1.0;
      if x < 0.0 then xx := -xx;
      while xx < 8.0 do << xx := xx*256.0; n := n*256.0>>;
      while xx < 2048.0 do << xx := xx*2.0; n := n*2.0>>;
      while xx >= 4096.0 do << xx := xx*0.5; n := n*0.5>>;
      xx := float fix xx/n;
      if x < 0.0 then xx := -xx;
      return (xx . (x - xx))
   end;
+++ fsplit compiled, 106 + 44 bytes
fsplit

symbolic procedure f_multiply(a, b);
   % a and b are split-up floating point values as generated by fsplit.
   % Multiply them together and return the result as an fsplit-num.
   begin scalar h, l;
      h := fsplit(car a*car b);
      l := cdr h + car a*cdr b + (car b + cdr b)*cdr a;
      return (car h . l)
   end;
+++ f_multiply compiled, 26 + 12 bytes
f_multiply

symbolic procedure fexpt(x, n);
   % Like iexpt, this raises x to the (positive integer) power n.  But
   % it uses fplit-num arithmetic to get about 12 bits of extra
   % precision in the calculation, which should preserve reasonable
   % accuracy until n gets to be much bigger than 5000.
   begin scalar w;
      w := fexpt1(fsplit x, n);
      return car w + cdr w
   end;
+++ fexpt compiled, 10 + 16 bytes
fexpt

symbolic procedure fexpt1(x, n);
   % Calculate x**n where n is a strictly positive integer, using extra
   % precision arithmetic.
   if not (n > 0) then error(0, "fexpt1 argument <= 0")
    else if n = 1 then x
    else if remainder(n, 2) = 0 then fexpt1(f_multiply(x, x), n/2)
    else f_multiply(x, fexpt1(f_multiply(x, x), (n - 1)/2));
+++ fexpt1 compiled, 48 + 32 bytes
fexpt1

symbolic procedure rexpt(x,y);
   % Computes x**y in for argument sets that yield real values.  In
   % particular if x is negative but y is a floating point value that
   % is sufficiently close to a rational number then a real result will
   % be computed, where the system-level expt function might have
   % reported an error.  This also picks up various marginal or error
   % cases (e.g. 0**0) so that their treatment is precisely defined in
   % REDUCE.
   begin scalar s,q; integer p;
      if zerop y then
         if zerop x then error(0,"0**0 undefined")
         else return if floatp x or floatp y then 1.0 else 1
      else if zerop x then
         if y>0 then return if floatp x or floatp y then 0.0 else 0
         else error(0,"divide by zero in EXPT")
      else if fixp y then <<
         if fixp x then <<
            if y<0 then return 0
            else if x = 1 then return 1
            else return iexpt(x, y) >>;
      % Floating numbers raised to integer powers are still pretty
      % painful.  If the base is negative then the sign of the result
      % depends on whether the power was odd or even.  For large
      % exponents I use fexpt() for extra accuracy (but at significant
      % extra cost).
         s := 0;
         if y < 0 then <<s:=1; y := -y>>;
         if x < 0 then <<s:=s+2; x := -x>>;
         if y > 50 then x := fexpt(x, y) else x := iexpt(x, y);
         if s=1 or s=3 then x := 1.0/x;
         if s>1 and remainder(y,2) neq 0 then x := -x;
         return x>>;
      % Since y is floating, float x if fixed.
      if fixp x then x := float x;
      % Invert here if exponent is negative float.
      if y<0.0 then <<x := 1.0/x; y := -y>>;
      % Still use integer exponentiation if y has integral value.
      if zerop(y - (p := fix y)) then return iexpt(x, p);
      % If y=0.5 use sqrt function, which may be easier
      if y = 0.5 then return sqrt x;
      % If x < 0 then x**y only yields a real result if y is a rational
      % number.  We already know that y is not an integer, so call
      % ft2rn1 to see if a good rational approximation to y exists.  A
      % previous version of this code called ft2rn1 for all floating
      % point values of y and then used combination sof sqrt/cbrt to
      % evaluate x**y in some cases.  This version bets that the cost
      % of ft2rn1 would exceed the savings of using sqrt, and so only
      % does the expensive thing when x < 0 and thus when there might
      % otherwise have been an error.
      if x<0.0 then <<
         q := ft2rn1 y; p := car q; q := cdr q;
         x := -x;
         if not(abs p<10 or q<10
             or 2*max(length explode q,length explode p) < !!flprec+1)
             or remainder(q,2)=0
               then error (0,list (-x,"**",y," not real"))
           else if remainder(p,2)=1 then s := t >>;
      if y = 0.5 then x := sqrt x  % sqrt safer if applicable?
      else x := expt(x, y);        % Use the lower level expt function
      return (if s then -x else x)
 end;
+++ rexpt compiled, 318 + 100 bytes
rexpt

symbolic procedure ft2rn1 n;
  if n < 0.0 then ((-car r) . cdr r) where r = ft2rn2(-n)
   else ft2rn2 n;
+++ ft2rn1 compiled, 21 + 16 bytes
ft2rn1

symbolic procedure ft2rn2 n;
  % Here, the positive input n is a float.
   begin scalar a,p0,p1,q0,q1,w,nn,r0,r1,flpr;
      flpr := abs n*100.0/!!flint;
      a := fix n;
      nn := n - a;
      p0 := 1; p1 := a; q0 := 0; q1 := 1;
      r0 := n + 1.0;
 top: r1 := abs(n - float p1/float q1);
      if nn=0.0 or r1=0.0 or not (r1 > flpr) then return p1 . q1
       else if not (r1 < r0) then return p0 . q0;
      nn := 1.0/nn;
      a := fix nn;
      nn := nn - a;
      w := p0 + a*p1; p0 := p1; p1 := w;
      w := q0 + a*q1; q0 := q1; q1 := w;
      r0 := r1;
      go to top
  end;
+++ ft2rn2 compiled, 119 + 32 bytes
ft2rn2


%**********************************************************************
%**             Functions derived from basic functions               **
%**********************************************************************

symbolic procedure cos x; sin(!!pii2 - x);
*** cos not defined (LOSE flag) 
nil

symbolic procedure cot x; tan(!!pii2 - x);
*** cot not defined (LOSE flag) 
nil

symbolic procedure sec x; 1.0/cos x;
*** sec not defined (LOSE flag) 
nil

symbolic procedure csc x; 1.0/sin x;
*** csc not defined (LOSE flag) 
nil

symbolic procedure acot x; !!pii2 - atan x;
*** acot not defined (LOSE flag) 
nil

symbolic procedure asin x;
   if abs x<1 then
      atan(if abs x<!!epsqrt then x else x/sqrt(1 - x*x))
   else if abs x>1 then terrlst (x,'asin)
   else if x>0 then !!pii2 else -!!pii2;
*** asin not defined (LOSE flag) 
nil

symbolic procedure acos x; !!pii2 - asin x;
*** acos not defined (LOSE flag) 
nil

symbolic procedure acsc x;
   if abs x>=1 then asin(1.0/x) else terrlst(x,'acsc);
*** acsc not defined (LOSE flag) 
nil

symbolic procedure asec x;
   if abs x<1 then terrlst(x,'asec) else !!pii2 - asin(1.0/x);
*** asec not defined (LOSE flag) 
nil

symbolic procedure cosd x; sind(90.0 - x);
*** cosd not defined (LOSE flag) 
nil

symbolic procedure cotd x; tand(90.0 - x);
*** cotd not defined (LOSE flag) 
nil

symbolic procedure secd x; 1/cosd x;
*** secd not defined (LOSE flag) 
nil

symbolic procedure cscd x; 1/sind x;
*** cscd not defined (LOSE flag) 
nil

symbolic procedure acotd x; 90.0 - atand x;
*** acotd not defined (LOSE flag) 
nil

symbolic procedure asind x; !!rad2deg * asin x;
*** asind not defined (LOSE flag) 
nil

symbolic procedure acosd x; 90.0 - asind x;
*** acosd not defined (LOSE flag) 
nil

symbolic procedure acscd x;
   if abs x>=1 then asind(1.0/x) else terrlst(x,'acscd);
*** acscd not defined (LOSE flag) 
nil

symbolic procedure asecd x;
   if abs x<1 then terrlst(x,'asecd) else 90.0 - asind(1.0/x);
*** asecd not defined (LOSE flag) 
nil

symbolic procedure sinh x;
   if floatp x and not fp!-finite x then x
    else begin scalar s;
      if x<0.0 then x:=-x else s:=t;
      if (x := float x)<0.91 then <<x := !!sinhts x; go to ret>>;
      x := exp(-x); x := (1.0/x - x)/2;
 ret: return if s then x else -x end;
*** sinh not defined (LOSE flag) 
nil

symbolic procedure cosh x; <<x := exp(-abs x),(x+1.0/x)/2>>;
*** cosh not defined (LOSE flag) 
nil

symbolic procedure tanh x;
   if x<0.0 then -tanh(-x) else
      <<x := exp(-2.0*x); (1.0 - x)/(1.0+x)>>;
*** tanh not defined (LOSE flag) 
nil

symbolic procedure coth x;
   if x<0.0 then -coth(-x) else
      <<x := exp(-2.0*x); (1.0+x)/(1.0 - x)>>;
*** coth not defined (LOSE flag) 
nil

symbolic procedure asinh x; begin scalar s;
   if x<0 then x:=-x else s:=t;
   x:=if x<!!epsqrt then x else log (x+if x<2 then sqrt(x*x+1)
           else if 1/x<!!epsqrt then x else x*sqrt(1+1/(x*x)));
   return if s then x else -x end;
*** asinh not defined (LOSE flag) 
nil

symbolic procedure acosh x; if x<1 then terrlst(x,'acosh)
   else log (x+if 1/x<!!epsqrt then x else x*sqrt(1 - 1/(x*x)));
*** acosh not defined (LOSE flag) 
nil

symbolic procedure atanh x; if abs x>=1 then terrlst(x,'atanh)
   else if abs x<!!epsqrt then x else 0.5*log((1+x)/(1 - x));
*** atanh not defined (LOSE flag) 
nil

symbolic procedure acoth x;
   if abs x<=1 then terrlst(x,'acoth) else atanh (1.0/x);
*** acoth not defined (LOSE flag) 
nil

symbolic procedure sech x;1/cosh x;
*** sech not defined (LOSE flag) 
nil

symbolic procedure csch x;1/sinh x;
*** csch not defined (LOSE flag) 
nil

symbolic procedure asech x;
   if x<=0 or x>1 then terrlst(x,'asech) else acosh (1.0/x);
*** asech not defined (LOSE flag) 
nil

symbolic procedure acsch x;
   if (x:= float x)=0.0 then terrlst(x,'acsch) else asinh(1/x);
*** acsch not defined (LOSE flag) 
nil

symbolic procedure ln x; log x;
*** ln not defined (LOSE flag) 
nil

symbolic procedure log10 x;
   if x>0 then log x/!!logten else terrlst(x,'log10);
*** log10 not defined (LOSE flag) 
nil

symbolic procedure logb (x,b); %log x to base b;
   begin scalar a,s; a:=x>0; s:=not(b<=0 or zerop(b - 1));
         if a and s then return log x/log b
         else terrlst((if a then list ('base,b)
            else if s then list('arg,x) else list(x,b)),'logb) end;
*** logb not defined (LOSE flag) 
nil

symbolic procedure atan2(y,x);
   if zerop x then !!pii2*sgn y else
   <<(if x>0 then a else if y<0 then a - !!pii else a+!!pii)
     where a=atan(y/x)>>;
*** atan2 not defined (LOSE flag) 
nil

symbolic procedure atan2d(y,x);
   if zerop x then 90.0*sgn y else
   <<(if x>0 then a else if y<0 then a - 180.0 else a+180.0)
     where a=!!rad2deg*atan(y/x)>>;
*** atan2d not defined (LOSE flag) 
nil

% A numerical factorial function.

symbolic procedure factorial n;
   if not fixp n or n<0
     then rerror(arith,4,list(n,"invalid factorial argument"))
    else nfactorial n;
+++ factorial redefined
+++ factorial compiled, 24 + 28 bytes
factorial

symbolic procedure nfactorial n;
   % Numerical factorial function.  It is assumed that n is numerical
   % and non-negative.
   if n>20 then fac!-part(1,n)
    else begin scalar m;
       m:=1;
       for i:=1:n do m:=m*i;
       return m;
     end;
+++ nfactorial redefined
+++ nfactorial compiled, 31 + 20 bytes
nfactorial

symbolic procedure fac!-part (m,n);
    if m=n then m
     else if m=n - 1 then m*n
     else (fac!-part(m,p)*fac!-part(p+1,n)) where p=(m+n)/2;
+++ fac!-part compiled, 31 + 12 bytes
fac-part

endmodule;nil

end;nilmodule rounded;nil % *** Support for Arbitrary Rounded Arithmetic.

% Authors: Anthony C. Hearn and Stanley L. Kameny.

% Last updated: 23 June 1993.

% Copyright (c) 2000, Anthony C. Hearn.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


COMMENT this module defines a rounded object as a list with two fields:

      (<tag>.<structure>).

The <structure> depends on the precision.  It is either a floating point
number or the stripped bfloat (mt . ep);

exports chkint!*, chkrn!*, convprec, convprec!*, deg2rad!*,
        i2rd!*, logfp, mkround, rd!:difference, rd!:minus, rd!:minusp,
        rd!:onep, rd!:plus, rd!:prep, rd!:prin, rd!:quotient,
        rd!:simp, rd!:times, rd!:zerop, rdprep1, rdqoterr, rdzchk,
        rndbfon, round!*, roundbfoff, roundbfon, roundconstants,
        safe!-fp!-plus, safe!-fp!-times, safe!-fp!-quot;nil

imports !*d2q, !:difference, !:minus, !:minusp, !:zerop, abs!:, aeval,
        apply1, bf2flr, bfdiffer, bfexplode0, bfinverse, bflessp,
        bfloat, bfminus, bfminusp, bfprin!:, bftrim!:, bfzerop!:,
        bfzp, ceiling, copyd, deg2rad!*, difbf, divbf, dmoderr,
        ep!:, eqcar, equal!:, errorp, errorset!*, fl2int,
        fl2rd, float!-bfp, floor, ft2rn1, geq, greaterp!:, grpbf,
        i2bf!:, initdmode, invbf, leq, lessp!:, log, lprim, lshift,
        make!:ibf, make!:rd, minus!:, minusp!:, mkquote, msgpri, mt!:,
        neq, normbf, off1, on1, over, plubf, preci!:, r2bf, rd2fl,
        rd!:forcebf, realrat, rerror, retag, rmsubs, round!:mt, setk,
        sqrt, timbf, times!:, union;nil

fluid '(!:prec!: !:bprec!: !:print!-prec!: minprec!# rootacc!#!#);nil

fluid '(dmode!* !*bfspace !*numval !*roundbf !*!*roundbf !*norndbf);nil

fluid '(!*noconvert);nil

global '(bfone!* epsqrt!* !!log2of10 !!log2);nil

global '(domainlist!* !!nfpd !!nbfpd !!flprec !!rdprec mxflbf!!
         mnflbf!!);nil

global '(!!plumax !!plumin !!timmax !!timmin !!maxflbf !!minflbf
         !!fleps1 !!fleps2 !!flint !!maxbflexp !!maxarg);nil

global '(rd!-tolerance!* cr!-tolerance!* yy!! bfz!* !!smlsin);nil

switch rounded;nil

%Set value for !!flprec. It never changes.
!!flprec := !!nfpd - 3;12

!!smlsin := 10.0^-(2+!!flprec);1.0e-14

symbolic procedure logfp x;
  % floating log of x**(1/n) using bfloat logic as boost.
  (log(m/float lshift(1,p))+(p+ep!: x)*!!log2)
    where p=(preci!: x - 1) where m=mt!: x;
+++ logfp compiled, 32 + 28 bytes
logfp

symbolic procedure roundconstants;
   <<!!plumax := 2.0**(!!maxbflexp -1);
     !!minflbf := invbf(!!maxflbf := make!:ibf (1,!!maxbflexp));
    % plumin must be large enough to avoid underflow from difference.
     !!plumin := 10.0**!!flprec/!!plumax;
     !!timmin := 1/(!!timmax := sqrt(!!plumax));
     !!maxarg := logfp !!maxflbf>>;
+++ roundconstants compiled, 49 + 72 bytes
roundconstants

switch bfspace,numval,roundbf;nil % norndbf.

!*bfspace := nil;nil
!*numval := t;t

put('roundbf,'simpfg,'((t (roundbfon)) (nil (roundbfoff))));((t (roundbfon)) (
nil (roundbfoff)))

symbolic procedure roundbfon; !*!*roundbf := t;
+++ roundbfon compiled, 3 + 16 bytes
roundbfon

symbolic procedure roundbfoff; !*!*roundbf := !!rdprec > !!flprec;
+++ roundbfoff compiled, 5 + 20 bytes
roundbfoff

%  put('rounded,'package!-name,'arith);  % Use if ARITH autoloaded.

domainlist!* := union('(!:rd!:),domainlist!*);(:rd: :mod: :crn: :gi: :rn:)

put('rounded,'tag,'!:rd!:);:rd:
put('!:rd!:,'dname,'rounded);rounded
flag('(!:rd!:),'field);nil
put('!:rd!:,'i2d,'i2rd!*);i2rd*
put('!:rd!:,'minusp,'rd!:minusp);rd:minusp
put('!:rd!:,'plus,'rd!:plus);rd:plus
put('!:rd!:,'times,'rd!:times);rd:times
put('!:rd!:,'difference,'rd!:difference);rd:difference
put('!:rd!:,'quotient,'rd!:quotient);rd:quotient
put('!:rd!:,'zerop,'rd!:zerop);rd:zerop
put('!:rd!:,'onep,'rd!:onep);rd:onep
put('!:rd!:,'prepfn,'rd!:prep);rd:prep
put('!:rd!:,'prifn,'rd!:prin);rd:prin
put('!:rd!:,'minus,'rd!:minus);rd:minus
put('!:rd!:,'rootfn,'rd!:root);rd:root
put('!:rd!:,'!:rn!:,'!*rd2rn);*rd2rn
put('!:rn!:,'!:rd!:,'!*rn2rd);*rn2rd

symbolic procedure round!* x;
   % Returns actual number representation, as either float or bfloat.
%   retag cdr x;
   if float!-bfp x then rd2fl x else x;
+++ round!* redefined
+++ round!* compiled, 6 + 8 bytes
round*

symbolic procedure mkround u;
   % inverse operation to round!*, i.e. tags a naked float
   if atom u then make!:rd u else u;
+++ mkround redefined
+++ mkround compiled, 7 + 12 bytes
mkround

%symbolic procedure roundbfp; !*roundbf or !!rdprec > !!flprec;

symbolic procedure print!-precision n;
   % Set the system printing precision !:print!-prec!:.
   % Returns previous value.
   begin scalar oldprec;
      if n=0 then return !:print!-prec!:;
      if n<0 then
         << oldprec := !:print!-prec!:;
            !:print!-prec!: := nil;
            return oldprec >>;
      if n > !:prec!: then
         << msgpri(nil,"attempt to set print!-precision greater than",
                       "precision ignored",nil,nil);
            return nil >>;
      oldprec := !:print!-prec!:;
      !:print!-prec!: := n;
      return oldprec
   end;
+++ print!-precision compiled, 38 + 32 bytes
print-precision

symbolic procedure print_precision n;
   % Alternative name.
   print!-precision n;
+++ print_precision compiled as link to print-precision
print_precision

symbolic procedure precision0 n;
  % called from algebraic call of precision.
   if n member '((nil) () (reset))
      then <<rootacc!#!# := nil; precision !!flprec>>
   else if cdr n
     or not numberp(n := prepsq simp!* aeval {'fix,prepsq simp!* car n})
     or n<0 then
       rerror(arith,5,"positive numeric value or `RESET' required")
   else <<if n>0 then rootacc!#!# := max(n,6); precision n>>;
+++ precision0 compiled, 65 + 68 bytes
precision0

put('precision,'psopfn,'precision0);precision0

symbolic procedure precision n;
   % Set the system precision !!rdprec, bfloat precision !:prec!:,
   % and rd!:onep tolerance. Returns previous value.
   <<if not numberp n or n<0
       then rerror(arith,6,"positive number required");
     precision1(n,t)>>;
+++ precision redefined
+++ precision compiled, 22 + 32 bytes
precision

!!log2of10 := log 10 / log 2;3.32193

symbolic procedure decprec2internal p;
   ceiling(p * !!log2of10) + 3;
+++ decprec2internal redefined
+++ decprec2internal compiled, 7 + 20 bytes
decprec2internal

% symbolic procedure internal2decprec p;
%    floor ((p - 3) / !!log2of10);

symbolic procedure precision1(n,bool);
   begin scalar oldprec;
      if n=0 then return !!rdprec;
      if bool then rmsubs();  % So that old results are resimplified.
      oldprec := !!rdprec;
      !:prec!: :=
        (!!rdprec := if !*roundbf then n else max(n,minprec!#))+2;
      if !:print!-prec!: and n < !:print!-prec!:+2
         then !:print!-prec!: := nil; %unset
      !:bprec!: := decprec2internal !:prec!:;
      epsqrt!* := make!:ibf(1, -!:bprec!:/2);
      rd!-tolerance!* := make!:ibf(1, 6-!:bprec!:);
      cr!-tolerance!* := make!:ibf(1, 2*(6-!:bprec!:));
%     if !!rdprec <= !!flprec then
%        <<!!fleps1 := 1.0/float(2.0**(!:bprec!: - 2));
%          !!fleps2 := !!fleps1**2>>;
      !*!*roundbf := !!rdprec > !!flprec or !*roundbf;
      return oldprec end;
+++ precision1 redefined
+++ precision1 compiled, 105 + 84 bytes
precision1

flag('(print!-precision),'opfn);nil % Symbolic operator print!-precision.
flag('(print_precision),'opfn);nil  % Symbolic operator print_precision.

symbolic procedure !*rd2rn x;
 % Converts a rounded number N into a rational to the system precision.
 % Elegant form: uses both rd2rn1 and realrat... and choses the best,
 %  but uses a heuristic to avoid the extra work when not needed.
   begin scalar n,p,r,r1,r2,d1,d2,ov;
     if rd!:zerop x then return '!:rn!: . (0 . 1);
     p := precision 0;
     r := rd2rn1 x;
     r1 := '!:rn!: . r;
     if abs car r<10 or cdr r<10
       or 2*max(length explode cdr r,length explode abs car r)<p+1
         then go to ret;
     r2 := '!:rn!: . realrat bftrim!: rd!:forcebf x;
     precision(2+p);
     d1 := !:difference(x,r1); if !:minusp d1 then d1 := !:minus d1;
     d2 := !:difference(x,r2); if !:minusp d2 then d2 := !:minus d2;
     if !:zerop d2 or !:minusp !:difference(d2,d1) then ov := t;
     precision p;
ret: return if ov then r2 else r1 end;
*** local variable n in procedure *rd2rn not used 
+++ !*rd2rn compiled, 135 + 76 bytes
*rd2rn

symbolic procedure rd2rn1 n;
   if float!-bfp n then ft2rn1 rd2fl n else bf2rn1 n;
+++ rd2rn1 compiled, 11 + 16 bytes
rd2rn1

symbolic procedure bf2rn1 n;
  % Here, the nonzero input n is always a binary bigfloat
   begin scalar negp,a,p0,p1,q0,q1,w,flagg,nn,r0,r1;
      if mt!: n<0 then <<negp := t; n := minus!: n>>;
      nn := n;
 top: a := ((if d=0 then m else lshift(m,d))
              where m=mt!: n,d=ep!: n);
      n := difbf(n,normbf i2bf!: a);
      if not flagg
        then <<flagg := t; p0 := 1; p1 := a; q0 := 0; q1 := 1>>
       else <<w := p0 + a*p1; p0 := p1; p1 := w; r0 := r1;
              w := q0 + a*q1; q0 := q1; q1 := w>>;
      r1 := abs!: difbf(nn,divbf(i2bf!: p1,i2bf!: q1));
     % temporary write statement here
    % if !*trrd2rn1 then << write p1 . q1," -> ",r1; terpri()>>;
      if bfzerop!: n or bfzerop!: r1
          then return if negp then (-p1) . q1 else p1 . q1
       else if r0 and not greaterp!:(r0,r1)
          then return if negp then (-p0) . q0 else p0 . q0;
      n := invbf n;
      go to top
  end;
+++ bf2rn1 redefined
+++ bf2rn1 compiled, 162 + 64 bytes
bf2rn1

symbolic procedure !*rn2rd u;
   % Converts the (tagged) rational u/v into a (tagged) rounded
   % number to the system precision, after testing to number
   mkround chkrn!* r2bf cdr u;
+++ !*rn2rd redefined
+++ !*rn2rd compiled, 6 + 20 bytes
*rn2rd


minprec!# := min(6,!!flprec-2);6

precision1(!!flprec,nil);nil        % Initial value = effective float prec.

%  !!fleps1 seems to be a fixed value 2^(-44) always...

%!!fleps1 := 1.0/float(2.0**(!:bprec!: - 6));
!!fleps1 := 2.0**(6 - !:bprec!:);5.68434e-14
!!fleps2 := !!fleps1**2;3.23117e-27

symbolic procedure precmsg pr;
   if pr>!!rdprec then
      <<msgpri(nil,"precision increased to",pr,nil,nil);
        precision1(pr,t)>>;
+++ precmsg compiled, 25 + 28 bytes
precmsg

symbolic procedure rd!:simp u;
   if null atom u and car u=0 then nil ./ 1
    else if null dmode!* or dmode!* eq '!:gi!:
     then (if eqcar(x,'!:rn!:) then cdr x else x ./ 1)
           where x = !*rd2rn make!:rd u
    else if dmode!* memq '(!:rd!: !:cr!:)
     then (mkround convprec!* u) ./ 1 % Must call convprec!*, since
                                      % precision may have changed.
    else (if y then !*d2q apply1(y,make!:rd u)
           else dmoderr('!:rd!:,dmode!*))
          where y = get('!:rd!:,dmode!*);
+++ rd!:simp compiled, 67 + 56 bytes
rd:simp

put('!:rd!:,'simpfn,'rd!:simp);rd:simp

symbolic procedure rndbfon; if not !*norndbf then
   <<!*!*roundbf := t;
     if !:prec!:<!!flprec+3 then
         <<!*roundbf := t;
           lprim "ROUNDBF turned on to increase accuracy">>>>;
+++ rndbfon compiled, 25 + 44 bytes
rndbfon

symbolic procedure i2rd!* u;
% Converts integer U to tagged rounded form.
 mkround chkint!* u;
+++ i2rd!* redefined
+++ i2rd!* compiled, 5 + 16 bytes
i2rd*

symbolic procedure chkint!* u;
    if !*!*roundbf then bfloat u else
     ((if floatp u then u   % Added by ACN to make i2rd!* work with floats.
       else if msd!: x <= !!maxbflexp then float u
       else <<rndbfon(); bfloat u>>) where x=abs u);
+++ chkint!* redefined
+++ chkint!* compiled, 83 + 44 bytes
chkint*

mnflbf!! := invbf(mxflbf!! := make!:ibf (1, 800));(:rd: 1 . -800)

symbolic procedure chkrn!* u;
   if !*!*roundbf then u else bf2flck u;
+++ chkrn!* redefined
+++ chkrn!* compiled, 6 + 16 bytes
chkrn*

symbolic procedure bf2flck u;
   if !*!*roundbf then u
   else if mt!: u=0 then 0.0 else
    ((if not grpbf(!!minflbf,r) and not grpbf(r,!!maxflbf)
         then bf2flr u
      else <<rndbfon(); u>>) where r := abs!: u);
+++ bf2flck compiled, 30 + 44 bytes
bf2flck

symbolic procedure convchk x;
   if !*!*roundbf then if atom x then bfloat x else x
   else if atom x then x else bf2flck x;
+++ convchk redefined
+++ convchk compiled, 44 + 36 bytes
convchk

symbolic procedure convprec!* u;
   convchk retag u;
+++ convprec!* redefined
+++ convprec!* compiled, 10 + 16 bytes
convprec*

symbolic procedure convprec u; convchk round!* u;
+++ convprec redefined
+++ convprec compiled, 5 + 16 bytes
convprec

symbolic procedure rd!:minusp u;
  % bfminusp round!* u;
   if float!-bfp u then minusp rd2fl u else minusp!: u;
+++ rd!:minusp redefined
+++ rd!:minusp compiled, 10 + 12 bytes
rd:minusp

symbolic procedure convprc2(u,v);
   <<u := convprec u; yy!! := convprec v;
     if !*roundbf then <<yy!! := bfloat yy!!; bfloat u>> else u>>;
+++ convprc2 redefined
+++ convprc2 compiled, 73 + 40 bytes
convprc2

symbolic procedure rdzchk(u,x,y);
 if atom u then
    if u=0.0 or x>0.0 and y>0.0 or x<0.0 and y<0.0 then u
    else if abs u<(abs x)*!!fleps1 then 0.0 else u
 else
    if mt!: u=0 or mt!: x>0 and mt!: y>0 or mt!: x<0 and mt!: y<0 then u
    else if lessp!:(abs!: u,times!:(abs!: x,rd!-tolerance!*)) then bfz!*
    else u;
+++ rdzchk redefined
+++ rdzchk compiled, 92 + 40 bytes
rdzchk

symbolic procedure rd!:plus(u,v);
  (if not !*!*roundbf and atom cdr u and atom cdr v
      and (z := safe!-fp!-plus(cdr u,cdr v)) then make!:rd z else
   begin scalar x,y;
      x := convprc2(u,v); y := yy!!;
      u := if not atom x then plubf(x,y) else
%
% There are issues and uncertainties at present as to whether floating point
% overflow should lead to and IEEE infinity or to the raising of an
% exception. I view use of errorset (and hence the need for it) as
% liable to be clumsy and  expensive, so I tend to believe that I want
% Lisp-level arithmetic to make overflow soft. But potentially some segments
% of code elsewhere in Reduce assume or expect an error to be raised and
% try to rely on it... For the present I will leave the conditional here
% based on CSL vs PSL.
%
#if (member 'csl lispsystem!*)
         <<z := safe!-fp!-plus(x, y);
           if null z
             then <<rndbfon(); plubf(x := bfloat x,y := bfloat y)>>
             else z>>;
#else
         <<z := errorset!*(list('plus2,mkquote x,mkquote y),nil);
           if errorp z
             then <<rndbfon(); plubf(x := bfloat x,y := bfloat y)>>
             else car z>>;
#endif
      return mkround rdzchk(u,x,y) end) where z=nil;
+++ rd!:plus compiled, 114 + 60 bytes
rd:plus

symbolic procedure rd!:difference(u,v);
  (if not !*!*roundbf and atom cdr u and atom cdr v
      and (z := safe!-fp!-plus(cdr u, safe!-fp!-minus cdr v)) then
       make!:rd z else
   begin scalar x,y;
      x := convprc2(u,v); y := yy!!;
      u := if not atom x then difbf(x,y) else
#if (member 'csl lispsystem!*)
         <<z := safe!-fp!-plus(x, -y);
           if null z
             then <<rndbfon(); difbf(x := bfloat x,y := bfloat y)>>
             else z>>;
#else
         <<z := errorset!*(list('difference,mkquote x,mkquote y),nil);
           if errorp z
             then <<rndbfon(); difbf(x := bfloat x,y := bfloat y)>>
             else car z>>;
#endif
      return mkround rdzchk(u,x,if atom y then -y else minus!: y) end)
   where z=nil;
+++ rd!:difference compiled, 136 + 68 bytes
rd:difference

symbolic procedure rd!:times(u,v);
  (if not !*!*roundbf and atom cdr u and atom cdr v
      and (z := safe!-fp!-times(cdr u,cdr v)) then make!:rd z else
   begin scalar x,y;
      x := convprc2(u,v); y := yy!!;
      return mkround if not atom x then timbf(x,y) else
#if (member 'csl lispsystem!*)
         <<z := safe!-fp!-times(x, y);
           if null z then <<rndbfon(); timbf(bfloat x,bfloat y)>>
              else z>> end) where z=nil;
+++ rd!:times compiled, 107 + 56 bytes
rd:times
#else
         <<z := errorset!*(list('times2,mkquote x,mkquote y),nil);
           if errorp z then <<rndbfon(); timbf(bfloat x,bfloat y)>>
              else car z>> end) where z=nil;
#endif

symbolic procedure rd!:quotient(u,v);
  if !:zerop v then rerror(arith,7,"division by zero") else
  (if not !*!*roundbf and atom cdr u and atom cdr v
      and (z := safe!-fp!-quot(cdr u,cdr v)) then make!:rd z else
   begin scalar x,y;
      x := convprc2(u,v); y := yy!!;
      if atom x and zerop y then rdqoterr();
      return mkround if not atom x then
         if mt!: y=0 then rdqoterr() else divbf(x,y)
         else
#if (member 'csl lispsystem!*)
           <<z := safe!-fp!-quot(x,y);
             if null z then <<rndbfon(); divbf(bfloat x,bfloat y)>>
                else z>> end) where z=nil;
+++ rd!:quotient compiled, 147 + 84 bytes
rd:quotient
#else
           <<z := errorset!*(list('quotient,mkquote x,mkquote y),nil);
             if errorp z then <<rndbfon(); divbf(bfloat x,bfloat y)>>
                else car z>> end) where z=nil;
#endif

symbolic procedure rdqoterr; error(0,"zero divisor in quotient");
+++ rdqoterr compiled, 4 + 20 bytes
rdqoterr

% There are three functions here - safe-!fp!-plus, times and quot. They
% must be given floating point arguments and they return the sum, product
% or quotient of the arguments. If the result would either overflow to
% yield an IEEE infinity or underflow to yield a sub-normalised number
% then they return nil. I observe that sometimes even if a result is
% too small to be normalised it can be 100% accurate. I will neverthless
% reject all cases where the result is a non-zero sub-normalised value.
%
% Earlier versions of these procedures where to various extents built in to
% PSL and CSL, and were more conservative, returning nil for some calculations
% that fall well short of underflow or overflow. The versions here now
% insist that 64-bit IEEE arithmetic is used, and build in definite ideas
% related to the exact range of numbers supported there. A consequence is
% that earlier (eg) VAX and IBM360 floating point models are no longer
% supported. Also any Lisp that used 32-bit rather than 64-bit IEEE floats
% would be out of luck.
%
% A real issue for the code here is that at the time that thie is being
% written PSL treats overflow as and error (rather than generating an
% IEEE infinity). I wish to avoid any such errors. So in the PSL case
% I test the values of the operands. For addition there could only be
% overflow if signs match (so I have two sign tests as overhead). For
% multiplication and division I compare against 2^511, which is a value
% whose square is still within range. The overall effect is a messy split
% on cases, but each path through it has only 3 or 4 extra arithmetic
% operations.

% The value "-0.0" can cause trouble as regards branch cuts for complex
% functions, or at least its handling calls for care there. So FOR NOW I
% will set !*nonegzero to true and these primitives will then not
% create that value, and they will cause it to turn into a +0.0 on any
% arithmetic. That should preserve old behaviour. But I hope that people
% will experiment with switching this flag off and when eveything works well
% without it then it can be removed.
%

global '(!*nonegzerominus !*nonegzerotimes);nil
!*nonegzerominus := nil;nil
!*nonegzerotimes := t;t

symbolic procedure safe!-fp!-minus u;
  if !*nonegzerominus and u = 0.0 then 0.0
  else -u;
+++ safe!-fp!-minus redefined
+++ safe!-fp!-minus compiled, 11 + 16 bytes
safe-fp-minus

#if (memq 'csl lispsystem!*)

symbolic procedure safe!-fp!-plus(u, v);
  begin
    scalar r, s := trap!-floating!-overflow nil;
% CSL (and Jlisp, which uses this code too) add two huge numbers an IEEE
% infinity is generated rather than an exception.
    r := u + v;
    trap!-floating!-overflow s;
    if fp!-infinite r then return nil;
% If the result was exactly 0.0 all is well. Well there is hidden delicacy
% here in that -0.0 + -0.0 will return -0.0 (but 0.0 + -0.0 and -0.0 + 0.0
% both return 0.0). I do not have a !*nonegzeroplus because the only way that
% safe!-fp!-add could possibly give a -0.0 output would be if both inputs
% had been -0.0.
    if r = 0.0 then return r
% If the result is sub-normalised I reject it.
    else if r < !!minnorm and r > !!minnegnorm then return nil
% The next test is required if behaviour is to be close to that which
% applied prior to this version of the code, but I view it as badly
% arbitrary and rather unsatisfactory and would like to get rid of it! The
% scheme checks if two values had just been subtracted in such a way that
% about 44 leading bits cancel out. In the original code this had been
% implemented as abs r < !!fleps1*abs u where !!fleps1 has the value
% 2.0^(-44), but the test here that sees if adding a small fraction of
% r to u makes no difference avoids the absolute value conversions.
% The largest possible value for the LHS arises if u is the biggest possible
% number and v the most negative possible value. This is still in range
% (ie it does not overflow to give an infinity). That is a plausible reason
% for the test having a "-" not a "+" in it.
% I *REALLY think that returning 0.0 here rather than the value that would
% naturally be computed is WRONG.
    else if u - r*0.001953125 = u then return 0.0
% I want to test if the result is infinite. To do this I subtract it
% from itself. Any finite number will lead to 0.0, but (infinity-infinity)
% yields a NaN which is not equal to 0.0.
    else if r-r = 0.0 then return r
% ... the result overflowed and r was an IEEE infinity.
    else return nil;
  end;
+++ safe!-fp!-plus compiled, 51 + 32 bytes
safe-fp-plus

symbolic procedure safe!-fp!-times(u, v);
  begin
    scalar r, s := trap!-floating!-overflow nil;
    r := u * v;
    trap!-floating!-overflow s;
    if fp!-infinite r then return nil;
% If the result is sub-normalised or zero I reject it, unless either u or
% v was zero in which case the zero result is proper.
    if r < !!minnorm and r > !!minnegnorm and
       u neq 0.0 and v neq 0.0 then return nil
    else if !*nonegzerotimes and r = 0.0 then return 0.0
% If r is infinite than r-r evaluates to a NaN which will not be equal to
% 0.0.
    else if r-r = 0.0 then return r
    else return nil;
  end;
+++ safe!-fp!-times compiled, 50 + 32 bytes
safe-fp-times

symbolic procedure safe!-fp!-quot(u, v);
  begin
    scalar r, s;
    if v = 0.0 then return nil
    else if !*nonegzerotimes and u = 0.0 then return 0.0;
    s := trap!-floating!-overflow nil;
    r := u / v;
    trap!-floating!-overflow s;
    if fp!-infinite r then return nil;
    if r < !!minnorm and r > !!minnegnorm and u neq 0.0 then return nil
    else if r-r = 0.0 then return r
    else return nil;
  end;
+++ safe!-fp!-quot compiled, 52 + 32 bytes
safe-fp-quot

#else

global '(!!maxfloatq2 !!two511 !!two513);

remprop('!!maxfloatq2, 'constant!?);
remprop('!!two511, 'constant!?);
remprop ('!!two513, 'constant!?);

begin
  scalar r, w;
% I know the numeric value I want expressed in powers of 2, so I compute
% it here building on initial values that are small enough that I can
% be confident that they read in exactly.
  r := 8388608.0;
  w := r*r*r;
  r := r*w*w;
  r := r*r*r;
  r := 8.0*r*r;
% The value I produce here is 2^53-1 times a huge power of 2 and is the
% largest finite IEEE double precision value.
  !!maxfloatq2 := r*(134217728.0*134217728.0-2.0);
  r := 2.0;
  for i := 1:9 do r := r*r;
  !!two511 := r/2.0;
  !!two513 := 2.0*r
end;

put('!!maxfloatq2, 'constant!?, !!maxfloatq2);
put('!!two511, 'constant!?, !!two511);
put('!!two513, 'constant!?, !!two513);

symbolic procedure safe!-fp!-plus(u, v);
% I can only get overflow if u and v have the same sign. If u and
% v are normalised to start with I can only end up with a sub-normal
% number if their signs differ. Note that both +0.0 and -0.0 count as >= 0.0
% and so do not go through the code that checks for underflow.
  if u < 0.0 then
    if v < 0.0 then <<
% I want to see if u+v > would overflow. If u and v are large then I can
% compute u/2 and v/2 with no loss of anything (if say u/2 was sub-normal
% it might lose accuracy here). In this case both operands are negative
% so comparing against half the most negative possible value does the
% checking that I need. It I pass this test it will be safe to perform
% a simple addition.
      if 0.5*u + 0.5*v < -!!maxfloatq2 then nil
      else u + v >>
    else begin
% u and v have different signs, so adding them can not lead to overflow
% but might result in underflow. So do the arithmetic directly and check.
      scalar r;
      r := u + v;
      if r = 0.0 then return r
       else if r < !!minnorm and r > !!minnegnorm then return nil
% As in the CSL case I dislike and would like to remove this next line.
% Note that in the CSL case I only make this extra test if u and v have
% different signs. The calculation performed can never cause an overflow!
% This premature underflow to 0.0 just loses accuracy in a way I find
% really disturbing, but I am leaving the behaviour here as it is for
% compatibility with older versions of the code.
      else if u - r*0.001953125 = u then return 0.0
      else return r
    end
  else if v < 0.0 then begin
% A second case where signs differ. When writing this I felt that the
% duplicated code here was ugly but that adjusting the tree of tests to
% have just one copy of this led to worse mess.
    scalar r;
    r := u + v;
    if r = 0.0 then return r
     else if r < !!minnorm and r > !!minnegnorm then return nil
    else if u - r*0.001953125 = u then return 0.0
    else return r
  end
  else <<
% Adding two positive values.
    if 0.5*u + 0.5*v > !!maxfloatq2 then nil
    else u + v >>;

symbolic procedure safe!-fp!-times(u, v);
  begin
% Now the real business. I will have essentially three cases, based on
% the magnitude of the numbers.
% (a) numbers are big and I may risk overflow.
% (b) numbers are small and I may risk underflow.
% (c) numbers are such that I have no great risk.
    scalar u1, v1;
    if !*nonegzerotimes and (u = 0.0 or v = 0.0) then return 0.0;
    if u < 0.0 then u1 := -u else u1 := u;
    if v < 0.0 then v1 := -v else v1 := v;
% I now have the absolute values of the operands. I will check for all
% potential bad cases.
    if u1 < !!two511 then
      if v1 < !!two511 then <<
% Here both numbers are fairly small, so I can afford to multiply them
% directly. Since I have filtered out multiplication by zero I can then
% detect (gradual) underflow with a simple comparison.
        if u1*v1 < !!minnorm and u neq 0.0 and v neq 0.0 then return nil >>
      else <<
% Here u is small but v is big. If I divide v by 2^511 it ends up in the
% range 1 to 2^513, and in particular multiplying by u will not overflow.
% Furthermore it can not underflow either because (v/2^511) is at least 1.0.
        if u1*(v1/!!two511) >= !!two513 then return nil >>
    else if v1 < !!two511 then <<
% Here u is large but v is not... so similar arguments apply.
      if (u1/!!two511)*v1 >= !!two513 then return nil >>
    else <<
% Finally both u and v are greater than or equal to 2^511 so overflow is possible.
      if (u1/!!two511)*(v1/!!two511) >= 4.0 then return nil >>;
    return u*v
  end;

symbolic procedure safe!-fp!-quot(u, v);
% The logic for division is essentially the same as that for multiplication.
  if v = 0.0 then nil
  else begin
    scalar u1, v1;
    if !*nonegzerotimes and u = 0.0 then return 0.0;
    if u < 0.0 then u1 := -u else u1 := u;
    if v < 0.0 then v1 := -v else v1 := v;
% I now have the absolute values of the operands.
    if u1 < !!two511 then
      if v1 > 1.0/!!two511 then <<
% Divide a not huge number by a not tiny one, so quotient will not
% overflow, but could underflow.
        if u1/v1 < !!minnorm and u neq 0.0 then return nil >>
      else <<
% Here u is reasonable but v is tiny.
        if u1/(v1*!!two511) >= !!two513 then return nil >>
    else if v1 > 1.0/!!two511 then <<
% Here u is large but v is not too tiny...
      if (u1/!!two511)/v1 >= !!two513 then return nil >>
    else <<
% Finally u is big and v is tiny...
      if (u1/!!two511)/(v1*!!two511) >= 4.0 then return nil >>;
    return u/v;
  end;
    
#endif % PSL

symbolic procedure rd!:zerop u;
  % bfzp round!* u;
   if float!-bfp u then zerop rd2fl u else mt!: u = 0;
+++ rd!:zerop redefined
+++ rd!:zerop compiled, 12 + 12 bytes
rd:zerop

symbolic procedure rd!:minus u;
  % mkround bfminus round!* u;
   if float!-bfp u then fl2rd (safe!-fp!-minus rd2fl u) else minus!: u;
+++ rd!:minus redefined
+++ rd!:minus compiled, 16 + 20 bytes
rd:minus

symbolic procedure rd!:onep u;
   % We need the tolerance test since some LISPs (e.g. PSL) can print
   % a number as 1.0, but it doesn't equal 1.0!
   if float!-bfp u then abs(1.0 - rd2fl u)<!!fleps1
    else equal!:(bfone!*,bftrim!: u);
+++ rd!:onep redefined
+++ rd!:onep compiled, 19 + 28 bytes
rd:onep

symbolic procedure rd!:root(u,n);
   if float!-bfp u then fl2rd expt(rd2fl u,recip float n)
    else texpt!:any(u,quotient!:(bfone!*,i2bf!: n));
+++ rd!:root compiled, 35 + 32 bytes
rd:root

% Since decimal input -> :rd: in all dmodes, dmode!* must be used to
% determine whether to round to current precision,  but input never gets
% truncated, since precision is always increased at input time.
% to avoid inaccuracies in floating point representation, rd!:prep
% returns values in bfloat format.

symbolic procedure rd!:prep u;
   if !*noconvert then rdprep1 u
    else if rd!:onep u then 1
   else if rd!:onep rd!:minus u then -1 else rdprep1 u;
+++ rd!:prep redefined
+++ rd!:prep compiled, 25 + 32 bytes
rd:prep

%symbolic procedure rdprep1 u;
%   if float!-bfp u then
%     if not dmode!* memq '(!:rd!: !:cr!:) or !*!*roundbf
%       then round!:mt(bfloat rd2fl u,min(!:bprec!:,!!nbfpd))
%      else if !:bprec!:>!!nbfpd then u
%      else fl2rd bf2flr round!:mt(bfloat rd2fl u,!:bprec!:)
%    else round!:mt(u,!:bprec!:);

symbolic procedure rdprep1 u;
   % Using cdr u to get actual float leads to various glitches.
   if float!-bfp u then u else round!:mt(u,!:bprec!:);
+++ rdprep1 redefined
+++ rdprep1 compiled, 8 + 16 bytes
rdprep1

symbolic procedure rd!:prin u;
   if float!-bfp u and not fp!-finite rd2fl u then prin2!* rd2fl u
   else 
  % Printed output is rounded to 2 fewer places than internal value.
   bfprin!: bftrim!: rd!:forcebf u;
+++ rd!:prin compiled, 25 + 28 bytes
rd:prin

symbolic procedure rd!:explode u;
   bfexplode0 bftrim!: rd!:forcebf u;
+++ rd!:explode compiled, 12 + 20 bytes
rd:explode

initdmode 'rounded;nil

put('evalf,'psopfn,'evalf0);evalf0

procedure evalf0(u);
   % Return first argument as a float wrt. the current precision even
   % with off rounded. Optional second argument overrides the current
   % precision.
   begin scalar sp,w;
      if cdr u then
	 sp := precision0 cdr u;
      if !*rounded then
      	 w := aeval car u
      else <<
      	 on1 'rounded;
      	 w := aeval car u;
      	 off1 'rounded;
      >>;
      if cdr u then <<
	 if cadr u > sp then <<
	    prin2 "*** required accuracy exceeds current precision (";
	    prin2 sp;
	    prin2t ")";
 	    prin2t "*** printing with required accuracy ...";
	    mathprint w;
	    prin2t "*** finished printing"
	 >>;
	 precision0 {sp}
      >>;
      return w
   end;
+++ evalf0 compiled, 54 + 60 bytes
evalf0

put('evalnum,'psopfn,'evalnum0);evalnum0

procedure evalnum0(u);
   % Return the exact algebraic representation of the first argument
   % rounded to the current precision. Optional second argument
   % overrides the current precision.
   begin scalar sp,w;
      if cdr u then
	 sp := precision0 cdr u;
      if !*rounded then
      	 w := aeval car u
      else <<
      	 on1 'rounded;
      	 w := aeval car u;
      	 off1 'rounded;
      	 w := aeval w
      >>;
      if cdr u then
      	 precision0 {sp};
      return w
   end;
+++ evalnum0 compiled, 32 + 32 bytes
evalnum0


symbolic procedure hexfloat1 w1;
% hexfloat may be useful from symbolic mode
  if floatp w1 then
    begin
      scalar w, s, x, m1, m2, m3, m4, n;
      if not numberp w1 then return w1
      else if w1 = 0.0 then return "0.0";
% The test that follows appears to behave OK on at least CSL and PSL on
% some Linux systems...
      if not eqn(w1, w1) then return "NaN"
      else if w1 = 0.5*w1 then <<
         if w1 > 0.0 then return "inf"
         else if w1 < 0.0 then return "-inf"
         else return "NaN" >>;
      if w1 < 0.0 then << s := t; w1 := -w1 >>;
      x := 0;
      n := 0;
      while w1 < 0.5 and n < 5000 do << w1 := 2.0*w1; x := x-1; n := n + 1 >>;
      while w1 >= 1.0 and n < 5000 do << w1 := w1/2.0; x := x+1; n := n + 1 >>;
      if n >= 5000 then return "hexfloat failed";
      w1 := w1 * 32.0;
      m1 := fix w1;
      w1 := w1 - float m1;
      w1 := w1 * 65536.0;
      m2 := fix w1;
      w1 := w1 - float m2;
      w1 := w1 * 65536.0;
      m3 := fix w1;
      w1 := w1 - float m3;
      w1 := w1 * 65536.0;
      m4 := fix w1;
      w1 := w1 - float m4;
      if not zerop w1 then error(1, "Floating point oddity in hexfloat");
% I should now have 5+16+16+16=53 bits of mantissa;
      m1 := explodehex m1;
      m2 := cdr explodehex (m2 + 65536);
      m3 := cdr explodehex (m3 + 65536);
      m4 := cdr explodehex (m4 + 65536);
      w := '!B . explode x;
      w := append(m4, '!_ . w);
      w := append(m3, '!_ . w);
      w := append(m2, '!_ . w);
      w := append(m1, '!_ . w);
      if s then w := '!- . w;
      return list2string w
    end
  else if atom w1 then w1
  else hexfloat1 car w1 . hexfloat1 cdr w1;
+++ hexfloat1 compiled, 336 + 100 bytes
hexfloat1

symbolic procedure hexfloat u;
% hexfloat tries to be a little generous about its args since it will
% be used in debugging context - but it is inteded to be given a rounded
% value and it returns a string...
  begin
    scalar w, w1;
    if numberp u then return hexfloat1 u
    else if atom u then return u
    else <<
      w := aeval car u;
      w1 := prepsq simp w >>;
    if eqcar(w1, '!:rd!:) and floatp cdr w1 then return hexfloat1 cdr w1
    else return w;
  end;
+++ hexfloat compiled, 29 + 28 bytes
hexfloat

put('hexfloat, 'psopfn, 'hexfloat);hexfloat

endmodule;nil

end;nilmodule comprd;nil % *** Support for Complex Rounded Arithmetic.

% Authors: Anthony C. Hearn and Stanley L. Kameny.

% Last updated: 23 June 1993.

% Copyright (c) 1989, 1993 The RAND Corporation.  All rights reserved.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


COMMENT this module defines a complex rounded as:

  (<tag>. (<structure> . <structure>>)  or  ('!:cr!: . (rl . im))

The <structure> depends on the precision.  It is either a floating point
number or the stripped bfloat (mt . ep);


exports !*cr2crn, !*cr2rd, !*cr2rn, !*crn2cr, !*gi2cr, !*rd2cr,
        !*rn2cr, cr!:differ, cr!:minus, cr!:minusp, cr!:onep,
        cr!:plus, cr!:prep, cr!:prin, cr!:quotient, cr!:times,
        cr!:zerop, cr2i!*, crhalf!*, cri!*, cri!/2, crone!*, crprcd,
        gf2cr!:, i2cr!*, mkcr;nil

imports bfloat, bfnzp, bftrim!:, bfzp, chkint!*, chkrn!*, convprec,
        convprec!*, crim, crrl, ep!:, errorp, errorset!*,
        gf2bf, gfdiffer, gfminus, gfplus, gfquotient, gftimes,
        gfzerop, initdmode, leq, lessp!:, make!:cr, make!:rd, maprin,
        mkcrn, mkquote, mkrn, mkround, normbf, over, plubf, preci!:,
        prin2!*, r2bf, rd!:minus, rd!:minusp, rd!:onep, rd!:prep,
        rd!:zerop, rdprep1, rdhalf!*, rdone!*, rdqoterr, rdtwo!*,
        rdzchk, rdzero!*, realrat, retag, rndbfon, round!:mt,
        safe!-fp!-plus, safe!-fp!-times, timbf, union;nil

fluid '(!:prec!: !:bprec!:);nil

global '(bfone!* epsqrt!*);nil

fluid '(dmode!* !*bfspace !*numval !*roundbf !*!*roundbf);nil

global '(cr!-tolerance!* domainlist!* !!nfpd !!flprec !!rdprec bfz!*
         yy!!);nil

domainlist!* := union('(!:cr!:),domainlist!*);(:cr: :rd: :mod: :crn: :gi: :rn:)

fluid '(!*complex!-rounded);nil

put('complex!-rounded,'tag,'!:cr!:);:cr:
put('!:cr!:,'dname,'complex!-rounded);complex-rounded
flag('(!:cr!:),'field);nil
put('!:cr!:,'i2d,'i2cr!*);i2cr*
put('!:cr!:,'plus,'cr!:plus);cr:plus
put('!:cr!:,'times,'cr!:times);cr:times
put('!:cr!:,'difference,'cr!:differ);cr:differ
put('!:cr!:,'quotient,'cr!:quotient);cr:quotient
put('!:cr!:,'zerop,'cr!:zerop);cr:zerop
put('!:cr!:,'onep,'cr!:onep);cr:onep
put('!:cr!:,'prepfn,'cr!:prep);cr:prep
put('!:cr!:,'prifn,'cr!:prin);cr:prin
put('!:cr!:,'minus,'cr!:minus);cr:minus
put('!:cr!:,'minusp,'cr!:minusp);cr:minusp
% put('!:cr!:,'rationalizefn,'girationalize!:);  % Needs something
                                                 % different.
put('!:cr!:,'!:rn!:,'!*cr2rn);*cr2rn
put('!:rn!:,'!:cr!:,'!*rn2cr);*rn2cr
put('!:rd!:,'!:cr!:,'!*rd2cr);*rd2cr
put('!:cr!:,'!:rd!:,'!*cr2rd);*cr2rd
put('!:cr!:,'!:crn!:,'!*cr2crn);*cr2crn
put('!:crn!:,'!:cr!:,'!*crn2cr);*crn2cr
put('!:gi!:,'!:cr!:,'!*gi2cr);*gi2cr
put('!:cr!:,'cmpxfn,'mkcr);mkcr
put('!:cr!:,'ivalue,'mkdcrn);mkdcrn
put('!:cr!:,'realtype,'!:rd!:);:rd:
put('!:rd!:,'cmpxtype,'!:cr!:);:cr:

symbolic procedure cr!:minusp u;
   (if atom x then zerop y and x<0 else zerop car y and car x<0)
    where x=cadr u,y=cddr u;
+++ cr!:minusp redefined
+++ cr!:minusp compiled, 27 + 8 bytes
cr:minusp

symbolic procedure striptag u; if atom u then u else cdr u;
+++ striptag redefined
+++ striptag compiled, 5 + 8 bytes
striptag

symbolic procedure mkcr(u,v); make!:cr (striptag u, striptag v);
+++ mkcr redefined
+++ mkcr compiled, 11 + 16 bytes
mkcr

symbolic procedure gf2cr!: x;
   make!:cr (striptag car x, striptag cdr x);
+++ gf2cr!: redefined
+++ gf2cr!: compiled, 11 + 16 bytes
gf2cr:

symbolic procedure crprcd u;
   (rl . im) where rl=convprec!* crrl u,im=convprec!* crim u;
+++ crprcd redefined
+++ crprcd compiled, 11 + 12 bytes
crprcd

symbolic procedure crprcd2(x,y);
   <<x := crprcd x; yy!! := crprcd y; x>>;
+++ crprcd2 redefined
+++ crprcd2 compiled, 8 + 16 bytes
crprcd2

% simp must call convprec!*, since precision may have changed.
symbolic procedure cr!:simp u; (gf2cr!: crprcd u) ./ 1;
+++ cr!:simp compiled, 6 + 20 bytes
cr:simp

put('!:cr!:,'simpfn,'cr!:simp);cr:simp

%symbolic procedure mkdcr u; cri!*() ./ 1;

symbolic procedure i2cr!* u;
   %converts integer U to tagged cr form.
   <<u := chkint!* u; mkcr(u,if atom u then 0.0 else bfz!*)>>;
+++ i2cr!* compiled, 16 + 24 bytes
i2cr*

symbolic procedure trimcrrl n; trimcr crrl n;
+++ trimcrrl compiled, 4 + 12 bytes
trimcrrl

symbolic procedure trimcr n;
   bftrim!: if atom n then bfloat n else retag n;
+++ trimcr compiled, 42 + 32 bytes
trimcr

symbolic procedure cr2rderr;
   error(0,
   "complex to real type conversion requires zero imaginary part");
+++ cr2rderr redefined
+++ cr2rderr compiled, 4 + 20 bytes
cr2rderr

symbolic procedure !*cr2rn n;
   % Converts a cr number n into a rational if possible.
   if bfnzp retag crim n then cr2rderr() else
   <<n := realrat trimcrrl n; mkrn(car n,cdr n)>>;
+++ !*cr2rn compiled, 41 + 36 bytes
*cr2rn

symbolic procedure !*rn2cr u;
   % Converts the (tagged) rational u/v into a (tagged) rounded complex
   % number to the system precision.
   <<u := chkrn!* r2bf cdr u; mkcr(u,if atom u then 0.0 else bfz!*)>>;
+++ !*rn2cr compiled, 17 + 28 bytes
*rn2cr

symbolic procedure !*cr2crn u;
   % Converts a (tagged) cr number u into a (tagged) crn.
   mkcrn(realrat trimcrrl u,realrat trimcr crim u);
+++ !*cr2crn compiled, 12 + 24 bytes
*cr2crn

symbolic procedure !*crn2cr u;
   % Converts a (tagged) crn number u into a (tagged) cr.
    mkcr(rl,if !*roundbf then bfloat im else im)
     where rl=chkrn!* r2bf cadr u where im=chkrn!* r2bf cddr u;
+++ !*crn2cr compiled, 50 + 44 bytes
*crn2cr

symbolic procedure !*cr2rd n;
   if bfnzp retag crim n then cr2rderr() else make!:rd crrl n;
+++ !*cr2rd compiled, 37 + 24 bytes
*cr2rd

symbolic procedure !*rd2cr u;
   mkcr(x,if atom x then 0.0 else bfz!*) where x=convprec u;
+++ !*rd2cr compiled, 15 + 24 bytes
*rd2cr

symbolic procedure !*gi2cr u;
   mkcr(rl,if !*roundbf then bfloat im else im)
    where rl=chkint!* cadr u where im=chkint!* cddr u;
+++ !*gi2cr compiled, 46 + 40 bytes
*gi2cr

symbolic procedure bfrsq u;
   (if atom x then x*x+y*y else plubf(timbf(x,x),timbf(y,y)))
    where x=car u,y=cdr u;
+++ bfrsq redefined
+++ bfrsq compiled, 27 + 16 bytes
bfrsq

symbolic procedure crzchk(u,x,y);
 begin
    if atom car u then
      if bfrsq u<(bfrsq x)*!!fleps2 then return 0.0 . 0.0 else go to ck;
    if lessp!:(bfrsq u,timbf(bfrsq x,cr!-tolerance!*)) then
      return bfz!* . bfz!*;
ck: return rdzchk(car u,car x,car y) . rdzchk(cdr u,cdr x,cdr y) end;
+++ crzchk compiled, 55 + 40 bytes
crzchk

symbolic procedure cr!:plus(u,v);
 begin scalar x,y; x := crprcd2(u,v); y := yy!!;
   u := if !*!*roundbf then gfplus(x,y)
        else if (v := safe!-crfp!-plus(x,y)) then v else
     ((if errorp r then
       <<rndbfon(); gfplus(x := gf2bf x,y := gf2bf y)>> else car r)
     where r=errorset(list('gfplus,mkquote x,mkquote y),nil,nil));
   return gf2cr!: crzchk(u,x,y) end;
+++ cr!:plus compiled, 65 + 52 bytes
cr:plus

symbolic procedure cr!:differ(u,v);
 begin scalar x,y; x := crprcd2(u,v); y := yy!!;
   u := if !*!*roundbf then gfdiffer(x,y)
        else if (v := safe!-crfp!-diff(x,y)) then v else
     ((if errorp r then
       <<rndbfon(); gfplus(x := gf2bf x,y := gf2bf y)>> else car r)
     where r=errorset(list('gfdiffer,mkquote x,mkquote y),nil,nil));
   return gf2cr!: crzchk(u,x,gfminus y) end;
+++ cr!:differ compiled, 71 + 60 bytes
cr:differ

symbolic procedure cr!:times(u,v);
 gf2cr!:
 (if !*!*roundbf then gftimes(x,yy!!)
  else if (u := safe!-crfp!-times(x,yy!!)) then u else
 ((if errorp r then <<rndbfon(); gftimes(gf2bf x,gf2bf yy!!)>>
      else car r)
    where r=errorset!*(list('gftimes,mkquote x,mkquote yy!!),nil)))
   where x=crprcd2(u,v);
+++ cr!:times compiled, 56 + 52 bytes
cr:times

symbolic procedure cr!:quotient(u,v);
 gf2cr!:
 (if gfzerop yy!! then rdqoterr()
  else if !*!*roundbf then gfquotient(x,yy!!)
  else if (u := safe!-crfp!-quot(x,yy!!)) then u else
 ((if errorp r then
      <<rndbfon(); gfquotient(gf2bf x,gf2bf yy!!)>> else car r)
    where r=errorset!*(list('gfquotient,mkquote x,mkquote yy!!),nil)))
   where x=crprcd2(u,v);
+++ cr!:quotient compiled, 86 + 64 bytes
cr:quotient

symbolic procedure safe!-crfp!-plus(u,v);
   (if x and y then crzchk(x . y,u,v))
   where x=safe!-fp!-plus(car u,car v),y=safe!-fp!-plus(cdr u,cdr v);
+++ safe!-crfp!-plus compiled, 20 + 16 bytes
safe-crfp-plus

symbolic procedure safe!-crfp!-diff(u,v);
   (if x and y then crzchk(x . y,u,gfminus v))
   where x=safe!-fp!-plus(car u,-car v),y=safe!-fp!-plus(cdr u,-cdr v);
+++ safe!-crfp!-diff compiled, 34 + 20 bytes
safe-crfp-diff

symbolic procedure safe!-crfp!-times(u,v);
   begin scalar ru,iu,rv,iv,a,b;
      ru := car u; iu := cdr u; rv := car v; iv := cdr v;
      if not (a := safe!-fp!-times(ru,rv)) or
         not (b := safe!-fp!-times(iu,iv)) then return nil;
      if not(u := safe!-fp!-plus(a,-b)) then return nil;
      u := rdzchk(u,a,safe!-fp!-minus b);
      if not (a := safe!-fp!-times(ru,iv)) or
         not (b := safe!-fp!-times(iu,rv)) then return nil;
      if not(v := safe!-fp!-plus(a,b)) then return nil;
      return u . rdzchk(v,a,b) end;
+++ safe!-crfp!-times compiled, 79 + 24 bytes
safe-crfp-times

symbolic procedure safe!-crfp!-quot(u,v);
  % compute u * inverse v.
   begin scalar ru,iu,rv,iv,a,b,dd;
      ru := car u; iu := cdr u; rv := car v; iv := cdr v;
      if not (a := safe!-fp!-times(rv,rv)) or
         not (b := safe!-fp!-times(iv,iv)) or
         not (dd := safe!-fp!-plus(a,b)) then return nil;
      rv := rv/dd; iv := iv/dd;
      if not (a := safe!-fp!-times(ru,rv)) or
         not (b := safe!-fp!-times(iu,iv)) or
         not (u := safe!-fp!-plus(a,b)) then return nil;
      u := rdzchk(u,a,b);
      if not (a := safe!-fp!-times(ru,-iv)) or
         not (b := safe!-fp!-times(iu,rv)) or
         not (v := safe!-fp!-plus(a,b)) then return nil;
      return u . rdzchk(v,a,b) end;
+++ safe!-crfp!-quot compiled, 104 + 20 bytes
safe-crfp-quot

symbolic procedure cr!:minus u; gf2cr!: gfminus crprcd u;
+++ cr!:minus compiled, 6 + 20 bytes
cr:minus

symbolic procedure cr!:zerop u;
   bfzp retag crrl u and bfzp retag crim u;
+++ cr!:zerop redefined
+++ cr!:zerop compiled, 52 + 16 bytes
cr:zerop

symbolic procedure cr!:onep u;
   bfzp retag crim u and rd!:onep mkround retag crrl u;
+++ cr!:onep compiled, 43 + 24 bytes
cr:onep

% prep works entirely in bfloat, to avoid floating point conversion
% errors.

symbolic procedure cr!:prep u;
   crprep1((rd!:prep tagrl u) . rd!:prep tagim u);
+++ cr!:prep redefined
+++ cr!:prep compiled, 17 + 20 bytes
cr:prep

symbolic procedure crprep1 u;
 % a and d are 1,-1,or rounded.
  (if not numberp d and rd!:zerop d then a else
     <<d := if numberp d or not rd!:minusp d
        then crprimp d else {'minus,crprimp rd!:minus d};
       if not numberp a and rd!:zerop a then d else
         <<if a = -1 then a := {'minus,1}
             else if not numberp a and rd!:minusp a
               then a := {'minus,rd!:minus a};
           {'plus,a,d}>> >>) where a=car u,d=cdr u;
+++ crprep1 compiled, 77 + 40 bytes
crprep1

symbolic procedure crprimp u;
   if u=1 then 'i else if u= -1 then {'minus,'i} else {'times,u,'i};
+++ crprimp redefined
+++ crprimp compiled, 21 + 28 bytes
crprimp

symbolic procedure cr!:prin v;
   if atom (v := cr!:prep v)
     or car v eq 'times or car v memq domainlist!*
      then maprin v
    else <<prin2!* "("; maprin v; prin2!* ")">>;
+++ cr!:prin compiled, 28 + 36 bytes
cr:prin

initdmode 'complex!-rounded;nil

symbolic procedure crone!*; mkcr(rdone!*(),rdzero!*());
+++ crone!* compiled, 7 + 20 bytes
crone*

symbolic procedure crhalf!*; mkcr(rdhalf!*(),rdzero!*());
+++ crhalf!* compiled, 7 + 20 bytes
crhalf*

symbolic procedure cri!*; mkcr(rdzero!*(),rdone!*());
+++ cri!* compiled, 7 + 20 bytes
cri*

symbolic procedure cri!/2; mkcr(rdzero!*(),rdhalf!*());
+++ cri!/2 compiled, 7 + 20 bytes
cri/2

symbolic procedure cr2i!*; mkcr(rdzero!*(),rdtwo!*());
+++ cr2i!* compiled, 7 + 20 bytes
cr2i*

endmodule;nil

end;nilmodule rdelem;nil  % Elementary functions in rounded domain.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


exports deg2rad!*, quotient!:, rad2deg!*, rdacos!*, rdacosd!*,
        rdacosh!*, rdacot!*, rdacotd!*, rdacoth!*, rdacsc!*, rdacscd!*,
        rdacsch!*, rdarg!*, rdasec!*, rdasecd!*, rdasech!*, rdasin!*,
        rdasind!*, rdasinh!*, rdatan!*, rdatan2!*, rdatan2d!*,
        rdatand!*, rdatanh!*, rdcbrt!*, rdcos!*, rdcosd!*, rdcosh!*,
        rdcot!*, rdcotd!*, rdcoth!*, rdcsc!*, rdcscd!*, rdcsch!*,
        rde!*, rdexp!*, rdexpt!*, rdhalf!*, rdhypot!*, rdlog!*,
        rdlog10!*, rdlogb!*, rdnorm!*, rdone!*, rdpi!*, rdsec!*,
        rdsecd!*, rdsech!*, rdsin!*, rdsind!*, rdsinh!*,
        rdsqrt!*, rdtan!*, rdtand!*, rdtanh!*, rdtwo!*, rdzero!*,
        texpt!:, texpt!:any;nil

imports !*f2q, abs!:, acos, acos!*, acosd, acosh, acot, acotd, acoth,
        acsc, acscd, acsch, asec, asecd, asech, asin, asin!*, asind,
        asinh, atan, atan!*, atan2, atan2d, atand, atanh, bflerrmsg,
        bfloat, bfp!:, bfsqrt, cbrt, conv!:bf2i, conv!:bf2i, conv!:mt,
        convprec, cos, cos!*, cosd, cosh, cot, cotd, coth, csc, cscd,
        csch, difbf, divbf, e!*, ep!:, eqcar, equal!:, exp, exp!*,
        exp!:, exptbf, geq, greaterp!:, hypot, i2rd!*, incprec!:,
        invbf, leq, leq!:, lessp!:, log, log!*, log10, log!:,
        logb, logfp, lshift, make!:ibf, minus!:, minusp!:, mk!*sq,
        mkround, mt!:, neq, pi!*, plubf, preci!:, rd!:minus,
        rd!:minusp, read!:num, rndbfon, round!*, round!:last,
        round!:mt, sec, secd, sech, sgn, simprd, sin, sin!*, sind,
        sinh, sqrt, sqrt!:, tan, tan!*, tand, tanh, terrlst, timbf,
        times!:;nil

fluid '(!:prec!: !:bprec!: !*!*roundbf);nil

global '(bfz!* bfone!* bften!* bfhalf!* !:180!* !:bf1!.5!* bfthree!*
 !:bf60!* epsqrt!* bftwo!* !!pii !!pii2 !!flprec !!rdprec !!shbinfl
 pi!/180 !180!/pi !!ee !!maxarg);nil

pi!/180 := !!pii/180;0.0174533  !180!/pi := 180/!!pii;57.2958

fluid '(!*numval);nil

deflist('((exp rdexp!*) (expt rdexpt!*) (log rdlog!*) (sin rdsin!*)
   (cos rdcos!*) (tan rdtan!*) (asin rdasin!*) (acos rdacos!*)
   (atan rdatan!*) (sqrt rdsqrt!*) (sinh rdsinh!*) (cosh rdcosh!*)
   (sec rdsec!*) (csc rdcsc!*) (cot rdcot!*) (tanh rdtanh!*)
   (coth rdcoth!*) (sech rdsech!*) (csch rdcsch!*) (asinh rdasinh!*)
   (acosh rdacosh!*) (acot rdacot!*) (asec rdasec!*) (acsc rdacsc!*)
   (atanh rdatanh!*) (acoth rdacoth!*) (asech rdasech!*)
   (acsch rdacsch!*) (logb rdlogb!*) (log10 rdlog10!*) (ln rdlog!*)
   (atan2 rdatan2!*) (hypot rdhypot!*) % (cbrt rdcbrt!*)
   (deg2rad deg2rad!*) (rad2deg rad2deg!*) (deg2dms deg2dms!*)
   (rad2dms rad2dms!*) (dms2deg dms2deg!*) (dms2rad dms2rad!*)
   (norm rdnorm!*) (arg rdarg!*) (e rde!*) (pi rdpi!*)),
   '!:rd!:);(exp expt log sin cos tan asin acos atan sqrt sinh cosh sec csc cot
tanh coth sech csch asinh acosh acot asec acsc atanh acoth asech acsch logb
log10 ln atan2 hypot deg2rad rad2deg deg2dms rad2dms dms2deg dms2rad norm arg e
pi)

% deflist('((sind rdsind!*) (cosd rdcosd!*) (asind rdasind!*) (acosd
%    rdacosd!*) (tand rdtand!*) (cotd rdcotd!*) (atand rdatand!*) (acotd
%    rdacotd!*) (secd rdsecd!*) (cscd rdcscd!*) (asecd rdasecd!*) (acscd
%    rdacscd!*) (atan2d rdatan2d!*)),'!:rd!:);



for each n in '(exp sin cos tan asin acos atan sinh cosh  % log
    sec csc cot tanh coth sech csch asinh acosh acot asec acsc atanh
    acoth asech acsch ln hypot % logb log10
%   sind cosd asind acosd tand cotd atand acotd secd cscd asecd acscd
%   atan2 atan2d cbrt
    deg2rad rad2deg deg2dms rad2dms dms2deg dms2rad norm arg argd)
       do put(n,'simpfn,'simpiden);nil

flag('(dms2deg dms2rad),'listargp);nil

deflist('((dms2deg!* simpdms) (dms2rad!* simpdms)), 'simparg);(dms2deg* dms2rad*
)

deflist('((atan2 2) (hypot 2) (atan2d 2) (logb 2)),
  'number!-of!-args);(atan2 hypot atan2d logb)

flag('(acsc sind asind tand atand cotd cscd acscd csch
       acsch deg2rad rad2deg),'odd);nil   % sgn, acotd.

flag('(cosd secd),'even);nil

flag('(cotd sech),'nonzero);nil

symbolic procedure rdexp!* u; mkround
  (if not atom x then exp!* x
   else if x>!!maxarg then <<rndbfon(); exp!* bfloat x>>
   else if x<-!!maxarg then 0.0 else exp x)
   where x=convprec u;
+++ rdexp!* compiled, 68 + 56 bytes
rdexp*

symbolic procedure rdsqrt!* u;
   mkround(if atom x then sqrt x else bfsqrt x)
   where x=convprec u;
+++ rdsqrt!* compiled, 13 + 24 bytes
rdsqrt*

symbolic procedure rdexpt!*(u,v);
   mkround
     (if not atom x then texpt!:any(x,y) else
       if zerop x then if zerop y then rederr "0**0 formed" else u else
      ((if z>!!maxarg then <<rndbfon(); texpt!:any(bfloat x,bfloat y)>>
        else if z<-!!maxarg then 0.0 else rexpt(x,y))
        where z=y*logfp bfloat abs x))
      where x=convprec u,y=convprec v;
+++ rdexpt!* compiled, 160 + 68 bytes
rdexpt*

symbolic procedure rdlog!* u;
   mkround(if atom x then log x else log!* x)
   where x=convprec u;
+++ rdlog!* compiled, 13 + 24 bytes
rdlog*

% symbolic procedure rdsgn!* u;
%   (if atom x then sgn x else sgn mt!: x) where x=round!* u;

symbolic procedure rdatan2!*(u,v);
   if !:zerop u and !:zerop v
     then rerror(arith,8,"0/0 formed")
    else (mkround(if atom x then atan2(x,y) else atan2!*(x,y))
          where x=convprec u,y=convprec v);
+++ rdatan2!* compiled, 35 + 44 bytes
rdatan2*

% symbolic procedure rdatan2d!*(u,v);
%    mkround(if atom x then atan2d(x,y) else rad2deg!: atan2!*(x,y))
%    where x=convprec u,y=convprec v;

symbolic procedure atan2!*(y,x);
   if mt!: x=0 then if (y := mt!: y)=0 then bfz!* else
      <<x := pi!/2!*(); if y<0 then minus!: x else x>>
   else <<(if mt!: x>0 then a
      else if mt!: y<0 then difbf(a,pi!*())
         else plubf(a,pi!*()))
     where a=atan!* divbf(y,x)>>;
+++ atan2!* compiled, 63 + 52 bytes
atan2*

% symbolic procedure atan2d!*(y,x);
%    if mt!: x=0 then if (y := mt!: y)=0 then bfz!* else
%       <<x := timbf(!:180!*,bfhalf!*); if y<0 then minus!: x else x>>
%    else <<(if mt!: x>0 then a
%       else if mt!: y<0 then difbf(a,!:180!*) else plubf(a,!:180!*))
%      where a=rad2deg!: atan!* divbf(y,x)>>;

symbolic procedure rde!*; mkround if !*!*roundbf then e!*() else !!ee;
+++ rde!* compiled, 9 + 24 bytes
rde*

symbolic procedure rdpi!*;
   mkround if !*!*roundbf then pi!*() else !!pii;
+++ rdpi!* compiled, 10 + 24 bytes
rdpi*

symbolic procedure pi!/2!*; 
   mkround if !*!*roundbf then timbf(bfhalf!*,pi!*()) else !!pii2;
+++ pi!/2!* compiled, 15 + 32 bytes
pi/2*

symbolic procedure deg2rad!* u;
   mkround(if atom x then deg2rad x else deg2rad!: x)
   where x=convprec u;
+++ deg2rad!* compiled, 13 + 24 bytes
deg2rad*

symbolic procedure rad2deg!* u;
   mkround(if atom x then rad2deg x else rad2deg!: x)
   where x=convprec u;
+++ rad2deg!* compiled, 13 + 24 bytes
rad2deg*

symbolic procedure deg2rad x; x*pi!/180;
+++ deg2rad compiled, 4 + 12 bytes
deg2rad

symbolic procedure rad2deg x; x*!180!/pi;
+++ rad2deg compiled, 4 + 12 bytes
rad2deg

symbolic procedure deg2rad!: x; divbf(timbf(x,pi!*()),!:180!*);
+++ deg2rad!: compiled, 15 + 32 bytes
deg2rad:

symbolic procedure rad2deg!: x; divbf(timbf(x,!:180!*),pi!*());
+++ rad2deg!: compiled, 13 + 32 bytes
rad2deg:

symbolic procedure rdsin!* u;
   mkround (if atom x then sin x else sin!* x)
   where x=convprec u;
+++ rdsin!* compiled, 13 + 24 bytes
rdsin*

% symbolic procedure rdsind!* u;
%    mkround (if atom x then sind x else sin!* deg2rad!: x)
%    where x=convprec u;

symbolic procedure rdcos!* u;
   mkround(if atom x then cos x else cos!* x)
   where x=convprec u;
+++ rdcos!* redefined
+++ rdcos!* compiled, 13 + 24 bytes
rdcos*

% symbolic procedure rdcosd!* u;
%    mkround(if atom x then cosd x else cos!* deg2rad!: x)
%   where x=convprec u;

symbolic procedure rdtan!* u;
   mkround(if atom x then tan x else tan!* x)
   where x=convprec u;
+++ rdtan!* compiled, 13 + 24 bytes
rdtan*

% symbolic procedure rdtand!* u;
%    mkround(if atom x then tand x else tan!* deg2rad!: x)
%   where x=convprec u;

symbolic procedure rdasin!* u;
   mkround(if atom x then asin x else asin!* x)
   where x=convprec u;
+++ rdasin!* compiled, 13 + 24 bytes
rdasin*

% symbolic procedure rdasind!* u;
%    mkround(if atom x then asind x else rad2deg!: asin!* x)
%    where x=convprec u;

symbolic procedure rdacos!* u;
   mkround(if atom x then acos x else acos!* x)
   where x=convprec u;
+++ rdacos!* compiled, 13 + 24 bytes
rdacos*

% symbolic procedure rdacosd!* u;
%    mkround(if atom x then acosd x else rad2deg!: acos!* x)
%    where x=convprec u;

symbolic procedure rdatan!* u;
   mkround(if atom x then atan x else atan!* x)
   where x=convprec u;
+++ rdatan!* compiled, 14 + 20 bytes
rdatan*

% symbolic procedure rdatand!* u;
%    mkround(if atom x then atand x else rad2deg!: atan!* x)
%   where x=convprec u;

symbolic procedure rdsinh!* u;
   mkround(if atom x then sinh x else sinh!* x)
   where x=convprec u;
+++ rdsinh!* compiled, 13 + 24 bytes
rdsinh*

symbolic procedure rdcosh!* u;
   mkround(if atom x then cosh x else cosh!* x)
   where x=convprec u;
+++ rdcosh!* compiled, 13 + 24 bytes
rdcosh*

% these redefine functions that are in bfelem, and are faster.

symbolic procedure sinh!* x;
   timbf(bfhalf!*,difbf(y,invbf y)) where y=exp!* x;
+++ sinh!* compiled, 16 + 28 bytes
sinh*

symbolic procedure cosh!* x;
   timbf(bfhalf!*,plubf(y,invbf y)) where y=exp!* x;
+++ cosh!* compiled, 16 + 28 bytes
cosh*


% no bfelem functions after this point.

symbolic procedure rdsec!* u;
   mkround(if atom x then sec x else invbf cos!* x)
   where x=convprec u;
+++ rdsec!* compiled, 14 + 28 bytes
rdsec*

% symbolic procedure rdsecd!* u;
%    mkround(if atom x then secd x else invbf cos!* deg2rad!: x)
%    where x=convprec u;

symbolic procedure rdcsc!* u;
   mkround(if atom x then csc x else invbf sin!* x)
   where x=convprec u;
+++ rdcsc!* compiled, 14 + 28 bytes
rdcsc*

% symbolic procedure rdcscd!* u;
%    mkround(if atom x then cscd x else invbf sin!* deg2rad!: x)
%   where x=convprec u;

symbolic procedure rdcot!* u;
   mkround(if atom x then cot x else tan!* difbf(pi!/2!*(),x))
   where x=convprec u;
+++ rdcot!* compiled, 17 + 32 bytes
rdcot*

% symbolic procedure rdcotd!* u;
%   mkround(if atom x then cotd x else tan!* difbf(pi!/2!*(),
%           deg2rad!: x))
%    where x=convprec u;

symbolic procedure rdtanh!* u;
   mkround(if atom x then tanh x else divbf(sinh!* x,cosh!* x))
   where x=convprec u;
+++ rdtanh!* compiled, 22 + 40 bytes
rdtanh*

symbolic procedure rdcoth!* u;
   mkround(if atom x then coth x else divbf(cosh!* x,sinh!* x))
   where x=convprec u;
+++ rdcoth!* compiled, 22 + 40 bytes
rdcoth*

symbolic procedure rdsech!* u;
   mkround(if atom x then sech x else invbf cosh!* x)
   where x=convprec u;
+++ rdsech!* compiled, 14 + 28 bytes
rdsech*

symbolic procedure rdcsch!* u;
   mkround(if atom x then csch x else invbf sinh!* x)
   where x=convprec u;
+++ rdcsch!* compiled, 14 + 28 bytes
rdcsch*

symbolic procedure rdasinh!* u;
   mkround(if atom x then asinh x else asinh!* x)
   where x=convprec u;
+++ rdasinh!* compiled, 13 + 24 bytes
rdasinh*

symbolic procedure rdacosh!* u;
   mkround(if atom x then acosh x else acosh!* x)
   where x=convprec u;
+++ rdacosh!* compiled, 13 + 24 bytes
rdacosh*

symbolic procedure asinh!* x; begin scalar s;
   if minusp!: x then x := minus!: x else s := t;
   x := if leq!:(x,epsqrt!*) then x
      else log!* plubf(x,
         if lessp!:(x,bftwo!*) then bfsqrt plubf(timbf(x,x),bfone!*)
         else if lessp!:(invbf x,epsqrt!*) then x
         else timbf(x,bfsqrt plubf(bfone!*,divbf(bfone!*,timbf(x,x)))));
   return if s then x else minus!: x end;
+++ asinh!* compiled, 88 + 72 bytes
asinh*

symbolic procedure acosh!* x;
   if lessp!:(x,bfone!*) then terrlst(x,'acosh)
   else log!* plubf(x,if leq!:(invbf x,epsqrt!*) then x
      else timbf(x,bfsqrt difbf(bfone!*,divbf(bfone!*,timbf(x,x)))));
+++ acosh!* compiled, 55 + 68 bytes
acosh*

symbolic procedure rdacot!* u;
   mkround(if atom x then acot x
      else difbf(pi!/2!*(),atan!* x))
   where x=convprec u;
+++ rdacot!* compiled, 19 + 32 bytes
rdacot*

% symbolic procedure rdacotd!* u;
%   mkround(if atom x then acotd x
%       else rad2deg!: difbf(pi!/2!*(),atan!* x))
%    where x=convprec u;

symbolic procedure rdasec!* u;  % not yet
   mkround(if atom x then asec x else
      difbf(pi!/2!*(),asin!* invbf x))
   where x=convprec u;
+++ rdasec!* compiled, 20 + 36 bytes
rdasec*

% symbolic procedure rdasecd!* u;  % not yet
%    mkround(if atom x then asecd x else
%       rad2deg!: difbf(pi!/2!*(),asin!* invbf x))
%    where x=convprec u;

symbolic procedure rdacsc!* u;
   mkround(if atom x then acsc x else asin!* invbf x)
   where x=convprec u;
+++ rdacsc!* compiled, 14 + 28 bytes
rdacsc*

% symbolic procedure rdacscd!* u;
%   mkround(if atom x then acscd x else rad2deg!: asin!* invbf x)
%   where x=convprec u;

symbolic procedure rdatanh!* u;
   mkround(if atom x then atanh x else atanh!* x)
   where x=convprec u;
+++ rdatanh!* compiled, 13 + 24 bytes
rdatanh*

symbolic procedure atanh!* x;
   if not greaterp!:(bfone!*,abs!: x) then terrlst(x,'atanh)
   else if leq!:(abs!: x,epsqrt!*) then x
   else timbf(bfhalf!*,
      log!* divbf(plubf(bfone!*,x),difbf(bfone!*,x)));
+++ atanh!* compiled, 49 + 68 bytes
atanh*

symbolic procedure rdacoth!* u;
   mkround(if atom x then acoth x else atanh!* invbf x)
   where x=convprec u;
+++ rdacoth!* compiled, 14 + 28 bytes
rdacoth*

symbolic procedure rdasech!* u;   % not from here down
   mkround(if atom x then asech x
      else if leq!:(x,bfz!*) or greaterp!:(x,bfone!*)
         then terrlst(x,'asech) else acosh!* invbf x)
   where x=convprec u;
+++ rdasech!* compiled, 33 + 48 bytes
rdasech*

symbolic procedure rdacsch!* u;
   mkround(if atom x then acsch x
      else if mt!: x=0 then terrlst(x,'acsh) else asinh!* invbf x)
   where x=convprec u;
+++ rdacsch!* compiled, 25 + 40 bytes
rdacsch*

symbolic procedure rdlogb!*(u,v);
   mkround(if atom x then logb(x,b) else logb!*(x,b))
   where x=convprec u,b=convprec v;
+++ rdlogb!* compiled, 16 + 24 bytes
rdlogb*

symbolic procedure rdlog10!* u;
   mkround(if atom x then log10 x else logb!*(x,bften!*))
   where x=convprec u;
+++ rdlog10!* compiled, 15 + 28 bytes
rdlog10*

symbolic procedure logb!* (x,b); %log x to base b;
   begin scalar a,s;
      a := greaterp!:(x,bfz!*);
      s := not(leq!:(b,bfz!*) or equal!:(b,bfone!*));
      if a and s then return divbf(log!* x,log!* b)
         else terrlst((if a then list ('base,b)
            else if s then list('arg,x) else list(x,b)),'logb) end;
+++ logb!* compiled, 55 + 64 bytes
logb*

% symbolic procedure rdcbrt!* u;
%    mkround(if atom x then cbrt x else cbrt!* x)
%    where x=convprec u;

% symbolic procedure cbrt!* x;
%    begin scalar s,l,g,u,nx,r; u := bfone!*;
%          if mt!: x=0 or equal!:(abs!: x,u) then return x
%          else if minusp!: x then x := minus!: x else s := t;
%          if lessp!:(x,u) then <<x := divbf(u,x); l := t>>
%             else if equal!:(x,u) then go to ret;
%          nx := '!:bf!: .
%             <<r := remainder(ep!:(nx := conv!:mt(x,3)),3);
%               if r=0 then (5+mt!: nx/179) . (ep!: nx/3)
%               else if r=1 or r=-2
%                then (10+mt!: nx/74) . ((ep!: nx-1)/3)
%               else (22+mt!: nx/35) . ((ep!: nx-2)/3)>>;
%    loop: r := nx;
%          nx := plubf(divbf(r,!:bf1!.5!*),
%             divbf(x,timbf(r,timbf(r,bfthree!*))));
%          if g and leq!:(r,nx) then go to ret;
%          g := t; go to loop;
%     ret: if l then nx := divbf(u,nx);
%          return if s then nx else minus!: nx end;

symbolic procedure rdhypot!*(u,v);
   mkround(if atom p then hypot(p,q) else hypot!*(p,q))
   where p=convprec u,q=convprec v;
+++ rdhypot!* compiled, 16 + 24 bytes
rdhypot*

symbolic procedure hypot!*(p,q);
 % Hypot(p,q)=sqrt(p*p+q*q) but avoids intermediate swell.
 begin scalar r;
   if minusp!: p then p := minus!: p; if minusp!: q then q := minus!: q;
   if mt!: p=0 then return q else if mt!: q=0 then return p
   else if lessp!:(p,q) then <<r := p; p := q; q := r>>;
   r := divbf(q,p);
   return if lessp!:(r,epsqrt!*) then p
      else timbf(p,bfsqrt plubf(bfone!*,timbf(r,r))) end;
+++ hypot!* compiled, 70 + 56 bytes
hypot*

symbolic procedure simpdms l;
   % Converts argument of form ({d,m,s}) to rd ((d m s)) if possible.
   if cdr l or atom (l := car l) or not eqcar(l,'list)
      or length l neq 4 then nil else
   begin scalar fl;
      l := for each a in cdr l collect
          if not (null(a := simprd list a) and (fl := t))
             then a := car a;
      if not fl then return list l end;
+++ simpdms compiled, 85 + 24 bytes
simpdms

symbolic procedure round2a!* a; if atom a then a else round!* a;
+++ round2a!* compiled, 6 + 12 bytes
round2a*

symbolic procedure dms2rad!* u; deg2rad!* dms2deg!* u;
+++ dms2rad!* compiled, 5 + 16 bytes
dms2rad*

symbolic procedure dms2deg!* u;
   mkround(if atom caddr l then dms2deg l else dms2deg!: l)
   where l=list(round2a!* car u,round2a!* cadr u,round!* caddr u);
+++ dms2deg!* compiled, 26 + 28 bytes
dms2deg*

symbolic procedure dms2deg l; ((caddr l/60.0+cadr l)/60.0+car l);
+++ dms2deg compiled, 14 + 12 bytes
dms2deg

symbolic procedure dms2deg!: l;
   plubf(bfloat car l,divbf(plubf(bfloat cadr l,
      divbf(bfloat caddr l,!:bf60!*)),!:bf60!*));
+++ dms2deg!: compiled, 123 + 44 bytes
dms2deg:

symbolic procedure rad2dms x; deg2dms rad2deg x;
+++ rad2dms compiled, 5 + 16 bytes
rad2dms

symbolic procedure rad2dms!* u; deg2dms!* rad2deg!* u;
+++ rad2dms!* compiled, 5 + 16 bytes
rad2dms*

symbolic procedure deg2dms!* u;
   mklist3!*(if atom x then deg2dms x else deg2dms!: x)
   where x=round2a!* u;
+++ deg2dms!* compiled, 13 + 24 bytes
deg2dms*

symbolic procedure mklist3!* x; % floats seconds if not integer.
   'list . list(car x,cadr x,
      <<(if atom s and zerop(s-fix s) then fix s
         else if not atom s and integerp!: s then conv!:bf2i s
         else mk!*sq !*f2q mkround s) where s=caddr x>>);
+++ mklist3!* compiled, 51 + 32 bytes
mklist3*

symbolic procedure deg2dms x; % dms output in form list(d,m,s);
   begin integer d,m;
%     m := fix(x := 60.0*(x-(d := fix2 x)));
      m := fix(x := 60.0*(x-(d := fix x)));
      return list(d,m,60.0*(x-m)) end;
+++ deg2dms compiled, 36 + 16 bytes
deg2dms

symbolic procedure deg2dms!: x; % dms output in form list(d,m,s).
   begin integer d,m;
      d := conv!:bf2i x;
      m := conv!:bf2i(x := timbf(!:bf60!*,difbf(x,bfloat d)));
      return list(d,m,timbf(!:bf60!*,difbf(x,bfloat m))) end;
+++ deg2dms!: compiled, 94 + 44 bytes
deg2dms:

symbolic procedure rdnorm!* u; if rd!:minusp u then rd!:minus u else u;
+++ rdnorm!* compiled, 11 + 16 bytes
rdnorm*

symbolic procedure rdarg!* u;
   if rd!:minusp u then rdpi!*() else rdzero!*();
+++ rdarg!* compiled, 10 + 20 bytes
rdarg*

% the following bfloat definitions are needed in addition to files
% smbflot and bfelem.red to support rdelem.

global '(!:bfone!* bftwo!* bfhalf!* bfz!* !:bf!-0!.25);nil

symbolic procedure rdone!*; if !*!*roundbf then bfone!* else 1.0;
+++ rdone!* compiled, 6 + 20 bytes
rdone*

symbolic procedure rdtwo!*; if !*!*roundbf then bftwo!* else 2.0;
+++ rdtwo!* compiled, 6 + 20 bytes
rdtwo*

symbolic procedure rdhalf!*; if !*!*roundbf then bfhalf!* else 0.5;
+++ rdhalf!* compiled, 6 + 20 bytes
rdhalf*

symbolic procedure rdzero!*; if !*!*roundbf then bfz!* else 0.0;
+++ rdzero!* compiled, 6 + 20 bytes
rdzero*

symbolic procedure texpt!:(nmbr, k);
% This function calculates the Kth power of "n" up to the
% binary precision specified by !:BPREC!:. %SK
% NMBR is a BINARY BIG-FLOAT representation of "n" and K an integer.
   if not fixp k then bflerrmsg 'texpt!:  % use texpt!:any in this case.
    else if k=0 then bfone!*
    else if k=1 then nmbr
    else if k<0 then invbf texpt!:(nmbr,-k) %SK
    else exptbf(nmbr,k,bfone!*);
+++ texpt!: compiled, 44 + 32 bytes
texpt: %SK

symbolic procedure quotient!:(n1, n2);
% This function calculates the integer quotient of "n1"
%      and "n2", just as the "QUOTIENT" for integers does.
% **** For calculating the quotient up to a necessary
% ****      precision, please use DIVIDE!:.
% N1 and N2 are BIG-FLOAT representations of "n1" and "n2".
begin integer e1, e2;
  if (e1 := ep!: n1) = (e2 := ep!: n2) then return
             make!:ibf(mt!: n1 / mt!: n2, 0)
   else if e1 > e2 then return
             quotient!:(incprec!:(n1, e1 - e2) , n2)
   else return
             quotient!:(n1, incprec!:(n2, e2 - e1));
end$
+++ quotient!: compiled, 74 + 20 bytes
quotient:

symbolic procedure texpt!:any(x, y);
  %modified by SK to use bfsqrt and exp!*, invbf and timbf.
% This function calculates the power x**y, where "x"
%      and "y" are any numbers.  The precision of
%      the result is specified by !:PREC!:. % SK
% **** For a negative "x", this function returns
% ****      -(-x)**y unless "y" is an integer.
% X is a BIG-FLOAT representation of "x".
% Y is either an integer, a floating-point number,
%      or a BIG-FLOAT number, i.e., a BIG-FLOAT
%      representation of "y".
    if equal!:(x,e!*()) then exp!* bfloat y
    else if fixp y then texpt!:(x, y)
    else if integerp!: y then texpt!:(x,conv!:bf2i y)
    else if not(bfp!: y or bfp!:(y := read!:num y))
     then bflerrmsg 'texpt!:any     % read!:num probably not necessary.
    else if minusp!: y then invbf texpt!:any(x,minus!: y) %SK
    else if equal!:(y,bfhalf!*) then bfsqrt x   %SK
    else if equal!:(y,!:bf!-0!.25) then bfsqrt bfsqrt x   %SK
    else begin integer n;  scalar xp, yp;
          n := (if !:bprec!: then !:bprec!:
                else max(preci!: x, preci!: y));
%          if minusp!: x then xp:=minus!: x else xp := x;
          if minusp!: x then bflerrmsg 'texpt!:any
           else xp := x;
          if integerp!: times!:(y,bftwo!*) then
             << xp := incprec!:(xp, 1);
                yp := texpt!:(xp, conv!:bf2i y);
                yp := times!:(yp, sqrt!:(xp, n + 1));
                yp := round!:mt(yp, n) >>
          else
             << yp := timbf(y, log!:(xp, n + 1)); %SK
                yp := exp!:(yp, n) >>;
          return (if minusp!: x then minus!: yp else yp);
     end;
+++ texpt!:any compiled, 257 + 132 bytes
texpt:any

symbolic procedure integerp!: x;
% This function returns T if X is a BINARY BIG-FLOAT
%      representing an integer, else it returns NIL.
% X is any LISP entity.
bfp!: x and
  (ep!: x >= 0 or
    preci!: x > - ep!: x and remainder(mt!: x,lshift(1,-ep!: x)) = 0);
+++ integerp!: compiled, 50 + 28 bytes
integerp:

endmodule;nil

end;nilmodule crelem;nil % Complex elementary functions for complex rounded.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%

imports !*rd2cr, bflessp, bfminusp, cr!:differ, cr!:minus, cr!:plus,
        cr!:quotient, cr!:times, cr!:zerop, cr2i!*, crhalf!*, cri!*,
        cri!/2, crprcd, crrl, deg2rad!*, gf2cr!:, gfsqrt, i2cr!*,
        i2rd!*, mkcr, rad2deg!*, rd!:minus, rd!:quotient, rd!:times,
        rdatan2!*, rdatan2d!*, rdcos!*, rdcosd!*, rdcosh!*, rde!*,
        rdexp!*, rdhalf!*, rdhypot!*, rdlog!*, rdone!*, rdpi!*,
        rdsin!*, rdsind!*, rdsinh!*, rdtwo!*, rdzero!*, retag,
        round!*, tagim, tagrl, bfminus, bflessp;nil

fluid '(!*!*roundbf);nil

global '(!!flprec !!rdprec bfz!* bftwo!* bfone!* bfhalf!*);nil

deflist('((expt crexpt!*) (sin crsin!*) (cos crcos!*) (tan crtan!*)
          (asin crasin!*) (acos cracos!*) (atan cratan!*)
          (cot crcot!*) (acot cracot!*) (sec crsec!*) (asec crasec!*)
          (csc crcsc!*) (acsc cracsc!*) (sinh crsinh!*) (cosh crcosh!*)
          (asinh crasinh!*) (acosh cracosh!*) (tanh crtanh!*)
          (coth crcoth!*) (atanh cratanh!*) (acoth cracoth!*)
          (sech crsech!*) (csch crcsch!*) (asech crasech!*)
          (acsch cracsch!*) (atan2 cratan2!*) (arg crarg!*)
          (sqrt crsqrt!*) (norm crnorm!*) (arg crarg!*) (log crlog!*) 
          (log10 crlog10!*) (exp crexp!*) (logb crlogb!*) 
          (e cre!*) (pi crpi!*)),'!:cr!:);(expt sin cos tan asin acos atan cot
acot sec asec csc acsc sinh cosh asinh acosh tanh coth atanh acoth sech csch
asech acsch atan2 arg sqrt norm arg log log10 exp logb e pi)

symbolic procedure cre!*; mkcr(rde!*(),rdzero!*());
+++ cre!* compiled, 7 + 20 bytes
cre*

symbolic procedure crpi!*; mkcr(rdpi!*(),rdzero!*());
+++ crpi!* compiled, 7 + 20 bytes
crpi*

symbolic procedure crexpt!*(u,v);
   if cr!:zerop(cr!:differ(v,crhalf!*())) then crsqrt!* u
   else crexp!* cr!:times(v,crlog!* u);
+++ crexpt!* compiled, 25 + 36 bytes
crexpt*

symbolic procedure crnorm!* u; rdhypot!*(tagrl u,tagim u);
+++ crnorm!* compiled, 13 + 16 bytes
crnorm*

symbolic procedure crarg!* u; rdatan2!*(tagim u,tagrl u);
+++ crarg!* compiled, 13 + 16 bytes
crarg*

symbolic procedure crsqrt!* u; gf2cr!: gfsqrt crprcd u;
+++ crsqrt!* compiled, 6 + 20 bytes
crsqrt*

symbolic procedure crr2d!* u; mkcr(rad2deg!* tagrl u,rad2deg!* tagim u);
+++ crr2d!* compiled, 15 + 20 bytes
crr2d*

symbolic procedure crd2r!* u; mkcr(deg2rad!* tagrl u,deg2rad!* tagim u);
+++ crd2r!* compiled, 15 + 20 bytes
crd2r*

symbolic procedure crsin!* u;
   mkcr(rd!:times(rdsin!* rl,rdcosh!* im),
        rd!:times(rdcos!* rl,rdsinh!* im))
    where rl=tagrl u,im=tagim u;
+++ crsin!* compiled, 32 + 36 bytes
crsin*

symbolic procedure crcos!* u;
   mkcr(rd!:times(rdcos!* rl,rdcosh!* im),
        rd!:minus rd!:times(rdsin!* rl,rdsinh!* im))
    where rl=tagrl u,im=tagim u;
+++ crcos!* compiled, 34 + 40 bytes
crcos*

symbolic procedure crtan!* u;
   cr!:times(cri!*(),cr!:quotient(cr!:differ(y,x),cr!:plus(y,x)))
   where x=crexp!*(cr!:times(cr2i!*(),u)),y=i2cr!* 1;
+++ crtan!* compiled, 25 + 44 bytes
crtan*

symbolic procedure crcot!* u;
   cr!:times(cri!*(),cr!:quotient(cr!:plus(x,y),cr!:differ(x,y)))
   where x=crexp!*(cr!:times(cr2i!*(),u)),y=i2cr!* 1;
+++ crcot!* compiled, 25 + 44 bytes
crcot*

symbolic procedure cratan2!*(y,x);
    begin scalar q,p;
       q := crsqrt!* cr!:plus(cr!:times(y,y),cr!:times(x,x));
      if cr!:zerop q then error(0,list("invalid arguments to ",'atan2));
       y := cr!:quotient(y,q); x := cr!:quotient(x,q); p := rdpi!*();
       if cr!:zerop x then
          <<q := rd!:quotient(p,i2rd!* 2);
            return if bfminusp retag crrl y then rd!:minus q else q>>;
       q := cratan!* cr!:quotient(y,x);
       if bfminusp retag crrl x then
          <<p := !*rd2cr p;
            q := if bfminusp retag crrl y
               then cr!:differ(q,p) else cr!:plus(q,p)>>;
          %  bfzp x is probably impossible?
       return q end;
+++ cratan2!* compiled, 153 + 84 bytes
cratan2*

symbolic procedure crlog!* u;
   mkcr(rdlog!* crnorm!* u,crarg!* u);
+++ crlog!* compiled, 10 + 24 bytes
crlog*

symbolic procedure crlog10!* u; cr!:quotient(crlog!* u,crlog!* i2cr!* 10);
+++ crlog10!* compiled, 10 + 24 bytes
crlog10*

symbolic procedure crlogb!*(u,b); cr!:quotient(crlog!* u,crlog!* b);
+++ crlogb!* compiled, 9 + 16 bytes
crlogb*

symbolic procedure timesi!* u; cr!:times(cri!*(),u);
+++ timesi!* compiled, 5 + 16 bytes
timesi*

symbolic procedure crsec!* u; cr!:quotient(i2cr!* 1,crcos!* u);
+++ crsec!* compiled, 9 + 24 bytes
crsec*

symbolic procedure crcsc!* u; cr!:quotient(i2cr!* 1,crsin!* u);
+++ crcsc!* compiled, 9 + 24 bytes
crcsc*

symbolic procedure crsinh!* u;
   cr!:times(crhalf!*(),cr!:differ(y,cr!:quotient(i2cr!* 1,y)))
   where y=crexp!* u;
+++ crsinh!* compiled, 19 + 36 bytes
crsinh*

symbolic procedure crcosh!* u;
   cr!:times(crhalf!*(),cr!:plus(y,cr!:quotient(i2cr!* 1,y)))
   where y=crexp!* u;
+++ crcosh!* compiled, 19 + 36 bytes
crcosh*

symbolic procedure crtanh!* u;
   cr!:quotient(cr!:differ(x,y),cr!:plus(x,y))
   where x=crexp!*(cr!:times(i2cr!* 2,u)),y=i2cr!* 1;
+++ crtanh!* compiled, 21 + 40 bytes
crtanh*

symbolic procedure crcoth!* u;
   cr!:quotient(cr!:plus(x,y),cr!:differ(x,y))
   where x=crexp!*(cr!:times(i2cr!* 2,u)),y=i2cr!* 1;
+++ crcoth!* compiled, 21 + 40 bytes
crcoth*
symbolic procedure crsech!* u;
   cr!:quotient(i2cr!* 2,cr!:plus(y,cr!:quotient(i2cr!* 1,y)))
   where y=crexp!* u;
+++ crsech!* compiled, 19 + 32 bytes
crsech*

symbolic procedure crcsch!* u;
   cr!:quotient(i2cr!* 2,cr!:differ(y,cr!:quotient(i2cr!* 1,y)))
   where y=crexp!* u;
+++ crcsch!* compiled, 19 + 32 bytes
crcsch*

symbolic procedure crexp!* u;
   <<u := tagim u; mkcr(rd!:times(r,rdcos!* u),rd!:times(r,rdsin!* u))>>
   where r=rdexp!* tagrl u;
+++ crexp!* compiled, 30 + 32 bytes
crexp*

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Inverse trig and hyperbolic functions
% The principal values necessarily have discontinuities (on the branch-cuts)
% owing to the periodicty of the trig and hyperbolic functions 
% and the multi-valued nature of their inverses.
% The choice of cuts is to a large extent arbitrary. Below they are chosen
% always to lie on the real or imaginary axes and to maintain conditions
% such as oddness on the cut and continuity along the cut.
% 
% Except for acot, they agree with the cuts recommended by Kahan.
% This exception is necessary as in Reduce acot(-z) = pi - acot z
%
% Beware of 'simplifications' such as log(a/b)=log(a)-log(b) as these
% in general change the cut structure.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% a utility procedure used to calculate the arguments for acos and acosh 
% used in the four procedures for acos, asin, acosh and asinh. 
symbolic procedure invfnargs(x, y);
begin scalar ssq, hyp, n, s;
  ssq := rd!:plus(rd!:times(x, x), rd!:times(y, y));
  % n = 2(x^2-y^2)-1
  n := rd!:difference(rd!:times(rd!:difference (x, y),
                                rd!:times(i2rd!* 2, rd!:plus(x, y))),
                      i2rd!* 1 );
                                   
  hyp := rdhypot!*(rd!:difference(ssq, i2rd!* 1),
                   rd!:times(i2rd!* 2, y));
  s := rd!:plus(ssq, hyp);
  % NB n/s = ssq-hyp, but this method reduces rounding errors somewhat
  % at the expense of a few extra arithmetic operations.
  return s . rd!:quotient(n, s);
end;
+++ invfnargs compiled, 64 + 40 bytes
invfnargs

symbolic procedure crasin!* z;
% This version uses the formula for the real and imag parts u & v of asin z
%   u = acos(sqrt((x^2+y^2-1)^2+4x^2)-x^2-y^2)/2
%                                                where z = x+i*y
%   v = acosh(x^2+y^2+sqrt((x^2+y^2-1)^2+4y^2))/2
% involving only calls to versions of acos, acosh and sqrt from rdelem.red.
% It is faster than the  method using complex logarithm and sqrt
% by a factor of around 4 for the default precision
% and a factor of about 1.25 for bigfloats
begin scalar rp, ip, args, u, v;
  rp := tagrl z; ip := tagim z;
  args := invfnargs(rp, ip);
  v := rd!:quotient(rdacosh!* car args, i2rd!* 2);
  % the test for zero real part of z avoids problems than occur when
  % the argument of rdacos!* is greater than the exact result 1 due to rounding
  u := if rd!:zerop rp then i2rd!* 0 
       else rd!:quotient(rdacos!* rd!:minus cdr args, i2rd!* 2);

  return mkcr(if rd!:minusp rp then rd!:minus u else u,
              if rd!:minusp ip or (rd!:zerop ip and not rd!:minusp rp)
              then rd!:minus v else v);
end;
+++ crasin!* compiled, 77 + 56 bytes
crasin*

% symbolic procedure crasin!* u; 
% Branch-cut is {r | r real & (r>=1 or r<=-1)}
% cr!:minus timesi!* crasinh!* timesi!* u;

symbolic procedure cracos!* z;
% This version uses the formula for the real and imag parts u & v of acos z
%   u = acos(x^2+y^2-sqrt((x^2+y^2-1)^2+4y^2))/2
%                                                   where z = x+i*y
%   v = acosh(x^2+y^2+sqrt((x^2+y^2-1)^2+4y^2))/2
% involving only calls to versions of acos, acosh and sqrt from rdelem.red.
% It is faster than the  method using complex logarithm and sqrt
% by a factor of around 4 for the default precision
% and a factor of about 1.25 for bigfloats
begin scalar rp, ip, args,  u, v;
  rp := tagrl z; ip := tagim z;
  args := invfnargs(rp, ip);
  % the test for zero real part of z avoids problems than occur when
  % the argument of rdacos!* is less than the exact result -1 due to rounding
  u := rd!:quotient(if rd!:zerop rp then rdpi!*() 
                    else rdacos!* cdr args,
                    i2rd!* 2);
  v := rd!:quotient(rdacosh!* car args, i2rd!* 2);
  return mkcr(if rd!:minusp rp then  rd!:difference(rdpi!*(), u) else u,
              if rd!:minusp ip or (rd!:zerop ip and not rd!:minusp rp)
              then v else rd!:minus v);
end;
+++ cracos!* compiled, 79 + 60 bytes
cracos*
  
% symbolic procedure cracos!* u;
%   cr!:plus(cr!:times(crhalf!*(),crpi!*()),
%      timesi!* crasinh!* timesi!* u);

symbolic procedure cratan!* u;
% Branch points at +i and -i are singular
% The branch cut is taken to be {r*i | r real and (r>1 or r <-1)}
% Adds pi if u lies on upper branch-cut (r>1)
% This maintains the condition atan(-u)= -atan(u) on the branch-cut
% The upper-cut lies in the first quadrant and the lower-cut in the third.
%
% Produces the same result as Kahan's formula below, but is faster.
  (if rd!:zerop tagrl u and  bflessp(rdone!*(), round!* tagim u) then
     cr!:plus(val, crpi!*()) else val)
  where val =  cr!:times(cri!/2(),crlog!* cr!:quotient(
                      cr!:plus(cri!*(),u),cr!:differ(cri!*(),u)));
+++ cratan!* compiled, 50 + 60 bytes
cratan*

% symbolic procedure cratan1!* u;
% % Branch points and branch cuts are as above
%   cr!:minus timesi!* cratanh!* timesi!* u;

symbolic procedure cracot!* u;
% Branch points and branch-cut is as for atan
% definition uses acot u =pi/2-atan u
% NB acot is NOT odd unlike acoth so identities relating 
% acot(i*z)  with acoth(z) need care!
   cr!:differ(cr!:times(crhalf!*(),crpi!*()), cratan!*  u);
+++ cracot!* compiled, 13 + 28 bytes
cracot*

symbolic procedure crasec!* u; cracos!* cr!:quotient(i2cr!* 1,u);
+++ crasec!* compiled, 7 + 24 bytes
crasec*

symbolic procedure cracsc!* u; crasin!* cr!:quotient(i2cr!* 1,u);
+++ cracsc!* compiled, 7 + 24 bytes
cracsc*

symbolic procedure crasinh!* z;
% This version uses the formula for the real and imag parts u & v of asinh z
%   u = acosh(x^2+y^2+sqrt((x^2+y^2-1)^2+4x^2))/2 
%                                                   where z = x+i*y
%   v = acos(sqrt((x^2+y^2-1)^2+4x^2)-x^2-y^2)/2
% involving only calls to versions of acos, acosh and sqrt from rdelem.red.
% It is faster than the  method using complex logarithm and sqrt
% by a factor of around 4 for the default precision
% and a factor of about 1.25 for bigfloats
begin scalar rp, ip, args, u, v;
  rp := tagrl z; ip := tagim z;
  args := invfnargs(ip, rp);
  u := rd!:quotient(rdacosh!* car args, i2rd!* 2);
  % the test for zero imaginary part of z avoids problems than occur when
  % the argument of rdacos!* is greater than the exact result 1 due to rounding
  v := if rd!:zerop ip then i2rd!* 0 
       else rd!:quotient(rdacos!* rd!:minus cdr args, i2rd!* 2);

  return mkcr(if rd!:minusp rp or (rd!:zerop rp and rd!:minusp ip)
              then rd!:minus u else u,
              if rd!:minusp ip then rd!:minus v else v);
end;
+++ crasinh!* compiled, 77 + 56 bytes
crasinh*

% symbolic procedure crasinh!* u;
% Branch-cut is taken to be {r*i |r real & (r>=1 or r<= -1)}
% The upper-half belongs to the first quadrant and the lower-half to the third
% The condition asinh(-z) =-asinh z is maintained on the cut.
%
% This (Kahan's) simple formula is faster than the 'optimised' versions below
%  and seems to produce equally accurate results.
%    crlog!* cr!:plus(u, crsqrt!* cr!:plus(i2cr!* 1,cr!:times(u,u)));

% symbolic procedure crasinh!* u;
%    crlog!* cr!:plus(u,
%      if bflessp(round!* crnorm!* u,rdtwo!*())
%          then crsqrt!* cr!:plus(i2cr!* 1,s)
%          else cr!:times(u,
%             crsqrt!* cr!:plus(i2cr!* 1,cr!:quotient(i2cr!* 1,s))))
%   where s=cr!:times(u,u);

% symbolic procedure crasinh1!* u;
% % Returns essentially the same result as
%%   crlog!* cr!:plus(u,crsqrt!* cr!:plus(cr!:times(u,u),i2cr!* 1));
% % but optimises the sqrt calculation for large z without altering the cut.
% %
% % The original optimisation above had the effect of altering the branch cut
% % to {r*i | r real & 1<= |r| <= 2} union {z | real z <0 & |z| =2}
% % and destroying the oddness condition for most of the region |z| > 2.
% % Beware of such rearrangements; these may alter the cuts.
% 
% (if bflessp(round!* crnorm!* u,rdtwo!*()) then
%         crlog!* cr!:plus(u, crsqrt!* cr!:plus(i2cr!* 1,s))
%    else (if rd!:minusp rl  or (rd!:zerop  rl and rd!:minusp tagim u) then
%             crlog!* cr!:differ(u, cr!:times(u, sroot))
%          else
%              crlog!* cr!:plus(u, cr!:times(u, sroot)))
%          where sroot = crsqrt!* cr!:plus(i2cr!* 1,cr!:quotient(i2cr!* 1,s)),
%                rl = tagrl u)
%      where s = cr!:times(u,u);

symbolic procedure cracosh!* z;
% This version uses the formula for the real and imag parts u & v of acosh z
%   u = acosh(x^2+y^2+sqrt((x^2+y^2-1)^2+4y^2))/2
%                                                    where z = x+i*y
%   v = acos(x^2+y^2-sqrt((x^2+y^2-1)^2+4y^2))/2
% involving only calls to versions of acos, acosh and sqrt from rdelem.red.
% It is faster than the  method using complex logarithm and sqrt
% by a factor of around 4 for the default precision
% and a factor of about 1.25 for bigfloats
begin scalar rp, ip, args, u, v;
  rp := tagrl z; ip := tagim z;
  args := invfnargs(rp, ip);
  u := rd!:quotient(rdacosh!* car args, i2rd!* 2);
  % the test for zero real part of z avoids problems than occur when
  % the argument of rdacos!* is less than the exact result -1 due to rounding
  v := rd!:quotient(if rd!:zerop rp then rdpi!*() 
                    else rdacos!* cdr args, 
                    i2rd!* 2);
  return mkcr(u, if rd!:minusp ip then rd!:minus v1 else v1)
          where v1 = if rd!:minusp rp then rd!:difference(rdpi!*(), v) else v;
end;
+++ cracosh!* compiled, 72 + 60 bytes
cracosh*

% symbolic procedure cracosh!* u;
%    crlog!* cr!:plus(u,crsqrt!* cr!:differ(cr!:times(u,u),i2cr!* 1));

% symbolic procedure cracosh!* u;
% The original version above used the formula
%     acosh z = log(z+sqrt(z^2-1))
% The branch cuts were the portions of the real axis |r| >=1  
% and the whole of the imaginary axis.
%
% The improved version uses the formula
%     acosh z = log(z+sqrt(z-1)*sqrt(z+1))
% the branch-cut is {r | r real and r< 1} 
% For r>0 cut is in 1st quadrant and when r<0  in the 2nd quadrant.
% Beware of 'simplifications' such as combining sqrts; these may alter the cuts
%
% Produces same result as Kahan's formula below, but is faster.
%   crlog!* cr!:plus(u,cr!:times(crsqrt!* cr!:differ(u, i2cr!* 1),
%                                crsqrt!* cr!:plus(u, i2cr!* 1)));

% symbolic procedure cracosh1!* u;
% % This improved version uses Kahan's formula
% %     acosh z = 2log(sqrt((z-1)/2) +sqrt((z+1)/2))
% % the branch-cut should be the same as above
%    cr!:times(two, crlog!*
%               cr!:plus(crsqrt!* cr!:quotient(cr!:differ(u, i2cr!* 1), two),
%                       crsqrt!* cr!:quotient(cr!:plus(u, i2cr!* 1), two)))
%      where two = i2cr!* 2;

symbolic procedure cratanh!* u;
% The branch-points at u=+1 and u=-1  are singularities
% Branch cut is taken to be {r | r real and (r>1 or r<-1)}
% Subtracts i*pi if u lies on right-hand branch-cut {r | r real & r>1}
% This maintains the condition atanh(-u)= -atanh(u) on the branch-cut
% The rh-cut lies in the fourth quadrant and the lh-cut in the second.
%
% Produces same result as Kahan's formula below, but is faster.
  (if rd!:zerop tagim u and  bflessp(rdone!*(), round!* tagrl u) then
     cr!:differ(val, cr!:times(cri!*(), crpi!*())) else val)
 where  val=cr!:times(crhalf!*(),crlog!* cr!:quotient(cr!:plus(i2cr!* 1,u),
      cr!:differ(i2cr!* 1,u)));
+++ cratanh!* compiled, 59 + 68 bytes
cratanh*

% symbolic procedure cratanh1!* u;
% %  Uses Kahan's formula 1/2(log(1+z)-log(1-z))
% % The branch cuts are as as above  
%  cr!:times(crhalf!*(),cr!:differ(crlog!* cr!:plus(i2cr!* 1,u),
%                                 crlog!* cr!:differ(i2cr!* 1,u)));

symbolic procedure cracoth!* u;
% The branch-points at u=+1 and u=-1  are singularities
% Branch cut is taken to be the interval of the real axis (-1, +1)
% Subtracts i*pi if u lies on right half of branch-cut {r | r real & 0<r<1}
% This maintains the condition acoth(-u)= -acoth(u) on the branch-cut
% The rh half-cut lies in the fourth quadrant and the lh half-cut in the second.
% There is a discontinuity as r --> 0  along the rh half-cut
%
% Produces the same result as atanh(1/u) except at u=0 when i*pi/2 is returned.
  (if rd!:zerop tagim u and (bflessp(rdzero!*(), rp)  and 
              bflessp(rp, rdone!*())) where rp = round!* tagrl u
   then cr!:differ(val, cr!:times(cri!*(), crpi!*())) else val)
  where val = cr!:times(crhalf!*(),crlog!* 
                 cr!:quotient(cr!:plus(i2cr!* 1,u), cr!:differ(u,i2cr!* 1)));
+++ cracoth!* compiled, 71 + 72 bytes
cracoth*

symbolic procedure crasech!* u; cracosh!* cr!:quotient(i2cr!* 1,u);
+++ crasech!* compiled, 7 + 24 bytes
crasech*

symbolic procedure cracsch!* u; crasinh!* cr!:quotient(i2cr!* 1,u);
+++ cracsch!* compiled, 7 + 24 bytes
cracsch*

endmodule;nil
end;nilmodule bfelem;nil  % Bigfloat elementary constants and functions.

% Last change date: 1 Jan 1993.

% Author: T. Sasaki, 1979.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% Modifications by: Anthony C. Hearn, Jed B. Marti, Stanley L. Kameny.
% Changed for binary arithmetic by Iain Beckingham and Rainer M. Schoepf

exports !:cbrt10, !:cbrt2, !:cbrt3, !:cbrt5, !:cbrte, !:cbrtpi,
        !:e, !:log10, !:log2, !:log3, !:log5, !:logpi, !:pi, !:sqrt10,
        !:sqrt2, !:sqrt3, !:sqrt5, !:sqrte, !:sqrtpi, acos!*,
        asin!*, atan!*, cos!*, e!*,
        exp!*, exp!:, get!:const, log!*, log!:, pi!*,
        sin!*, sqrt!:, tan!*;nil

imports !*q2f, abs!:, bflerrmsg, bfp!:, bfzerop!:, conv!:bf2i,
        conv!:mt, cut!:ep, cut!:mt, decimal2internal, difference!:,
        divide!:, ep!:, equal!:, geq, greaterp!:, i2bf!:, leq, lessp!:,
        lshift, make!:ibf, minus!:, minusp!:, mksq, mt!:, multd, neq,
        numr, order!:, plus!:, preci!:, quotient!:, round!:mt, simp,
        texpt!:, texpt!:any, times!:;nil


fluid '(!:prec!: !:bprec!: !!scls !!sclc);nil

global '(bfsaveprec!*);nil

global '(bfz!* bfhalf!* bfone!* bftwo!* bfthree!* bffive!* bften!*
         !:bf!-0!.0625 !:bf!-0!.25 !:bf0!.419921875);nil

% *** Tables for Elementary Function and Constant Values ***

symbolic procedure allfixp l;
   % Returns T if all of L are FIXP.
   null l or fixp car l and allfixp cdr l;
+++ allfixp compiled, 13 + 12 bytes
allfixp

symbolic procedure read!:lnum(l);
% This function reads a long number "n" represented by a list in a way
% described below, and constructs a BIG-FLOAT representation of "n".
% L is a list of integers, the first element of which gives the order of
% "n" and all the next elements when concatenated give the mantissa of
% "n".
% **** ORDER(n)=k if 10**k <= ABS(n) < 10**(k+1).
% **** Except for the first element, all integers in L
% ****      should not begin with "0" because some
% ****      systems suppress leading zeros.
% JBM: Fix some kludgy coding here.
% JBM: Add BFSAVEPREC!* precision saver.
if not allfixp l then bflerrmsg 'read!:lnum
 else begin scalar mt, ep, k, sign, u, v, dcnt;
          mt := dcnt := 0;      %JBM
          u := l;
          ep := add1 car u;
          sign := if minusp cadr l then -1 else 1;   %JBM
          while u:=cdr u do
            << k := length explode(v := abs car u);  %JBM
               mt := mt * 10**k + v; %JBM
               ep := ep - k;
               dcnt := dcnt +  k;    % JBM
               if bfsaveprec!* and dcnt > bfsaveprec!* then  %JBM
                  u := '(nil) >>;     %JBM
          return decimal2internal (sign * mt, ep)
                   where !:bprec!: := msd!: mt;
    end;
+++ read!:lnum compiled, 92 + 56 bytes
read:lnum


%symbolic procedure bfexpt!:(u,v);
%   % Calculates u**v, including case u<0.
%   if minusp!: u
%     then multd(texpt!:any(minus!: u,v),
%                !*q2f if null numr simp list('difference,v,
%                                             '(quotient 1 2))
%                        then simp 'i
%                       else mksq(list('expt,'(minus 1),v),1))
%    else texpt!:any(u,v);

symbolic procedure exp!* u; exp!:(u,!:bprec!:);
+++ exp!* redefined
+++ exp!* compiled, 4 + 16 bytes
exp*

symbolic procedure log!* u; log!:(u,!:bprec!:);
+++ log!* compiled, 4 + 16 bytes
log*

symbolic procedure sin!* u; sin!:(u,!:bprec!:);
+++ sin!* compiled, 4 + 16 bytes
sin*

symbolic procedure cos!* u; cos!:(u,!:bprec!:);
+++ cos!* redefined
+++ cos!* compiled, 4 + 16 bytes
cos*

symbolic procedure tan!* u; tan!:(u,!:bprec!:);
+++ tan!* compiled, 4 + 16 bytes
tan*

symbolic procedure asin!* u; asin!:(u,!:bprec!:);
+++ asin!* compiled, 4 + 16 bytes
asin*

symbolic procedure acos!* u; acos!:(u,!:bprec!:);
+++ acos!* compiled, 4 + 16 bytes
acos*

symbolic procedure atan!* u; atan!:(u,!:bprec!:);
+++ atan!* compiled, 4 + 16 bytes
atan*

symbolic procedure sqrt!* u; sqrt!:(u,!:bprec!:);
+++ sqrt!* compiled, 4 + 16 bytes
sqrt*

symbolic procedure pi!*;
   if !:prec!:>1000 then !:bigpi !:bprec!: else !:pi !:bprec!:;
+++ pi!* compiled, 13 + 28 bytes
pi*

symbolic procedure e!*; !:e !:bprec!:;
+++ e!* redefined
+++ e!* compiled, 3 + 16 bytes
e*


%*************************************************************
%**                                                         **
%** 3-1. Elementary CONSTANTS.                              **
%**                                                         **
%*************************************************************

symbolic procedure !:pi k;
% This function calculates the value of the circular
%      constant "PI", with the precision K, by
%      using Machin's well known identity:
%         PI = 16*atan(1/5) - 4*atan(1/239).
%      Calculation is performed mainly on integers.
% K is a positive integer.
if not fixp k or k <= 0 then bflerrmsg '!:pi
 else
    begin integer k3,s,ss,m,n,x,test;  scalar u;
          u := get!:const('!:pi, k);
% The original version of this code used the string "NOT FOUND" as the
% marker value that get!;const could return. An effect of that was two
% very minor uglinesses. Firstly there will have been multiple copies of
% the string using up space, and secondly it relied on NEQ being the
% converse of EQUAL not EQ and that that then checked string contents.
% By using a symbol 'not_found there will be a very very minor improvement
% in both speed and code clarity! 
          if u neq 'not_found then return u;
          ss := n := 2 ** (k3 := k + 3) / 5;
          x := -5 ** 2;
          m := 1;
          while n neq 0 do <<n := n/x; ss := ss + n/(m := m + 2)>>;
          s := n := 2 ** k3 / 239;
          x := -239 ** 2;
          m := 1;
          while n neq 0 do << n := n / x; s := s + n / (m := m + 2) >>;
          u := round!:mt(make!:ibf(test := 16 * ss - 4 * s, - k3), k);
          save!:const('!:pi, u);
          return u;
    end;
+++ !:pi compiled, 161 + 64 bytes
:pi

symbolic procedure !:bigpi k;
% This function calculates the value of the circular
%      constant "PI", with the binary precision K, by the
%      arithmetic-geometric mean method.  (See,
%      R. Brent, JACM Vol.23, #2, pp.242-251(1976).)
% K is a positive integer.
% **** This function should be used only when you
% ****      need "PI" of precision higher than 1000.
if not fixp k or k <= 0 then bflerrmsg '!:bigpi
 else begin integer k7, n;  scalar dcut, half, x, y, u, v;
          u := get!:const('!:pi, k);
          if u neq 'not_found then return u;
          k7 := k + 7;
          half := bfhalf!*;    %JBM
          dcut := make!:ibf(2, - k7);
          n := 1;
          x := bfone!*;
          y := divide!:(x, !:sqrt2 k7, k7);
          u := !:bf!-0!.25;    %JBM
          while greaterp!:(abs!: difference!:(x, y), dcut) do
            << v := x;
               x := times!:(plus!:(x, y), half);
               y := sqrt!:(cut!:ep(times!:(y, v), - k7), k7);
               v := difference!:(x, v);
               v := times!:(times!:(v, v),i2bf!: n);
               u := difference!:(u, cut!:ep(v, - k7));
               n := 2*n>> ;
          v := cut!:mt(texpt!:(plus!:(x, y), 2), k7);
          u := divide!:(v, times!:(i2bf!: 4, u), k);
          save!:const('!:pi, u);
          return u;
    end;
+++ !:bigpi compiled, 166 + 108 bytes
:bigpi

symbolic procedure !:e k;
% This function calculates the value of "e", the base
%      of the natural logarithm, with the binary precision K,
%      by summing the Taylor series for exp(x=1).
%      Calculation is performed mainly on integers.
% K is a positive integer.
if not fixp k or k <= 0 then bflerrmsg '!:e
 else begin integer k7, ans, m, n;  scalar u;
          u := get!:const('!:e, k);
          if u neq 'not_found then return u;
          k7 := k + 7;
          m := 1;
          n := lshift (1, k7); % 2**k7
          ans := 0;
          while n neq 0  do ans := ans + (n := n / (m := m + 1));
          ans := ans + lshift (1, k7 + 1); % 2 * 2**k7
          u := round!:mt(make!:ibf(ans, - k7), k);
          save!:const('!:e2, u);
          return u;
       end;
+++ !:e compiled, 96 + 52 bytes
:e

symbolic procedure !:e0625(k);
% This function calculates exp(0.0625), the value of the
%      exponential function at the point 0.0625, with
%      the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:e0625, k);
  if u neq 'not_found then return u;
  u := exp!:(!:bf!-0!.0625, k);    %JBM
  save!:const('!:e0625, u);
  return u;
end;
+++ !:e0625 compiled, 19 + 28 bytes
:e0625

symbolic procedure !:log2 k;
% This function calculates log(2), the natural
%      logarithm of 2, with the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:log2, k);
  if u neq 'not_found then return u;
  u := log!:(bftwo!*, k);
  save!:const('!:log2, u);
  return u;
end;
+++ !:log2 redefined
+++ !:log2 compiled, 19 + 28 bytes
:log2

symbolic procedure !:log3 k;
% This function calculates log(3), the natural
%      logarithm of 3, with the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:log3, k);
  if u neq 'not_found then return u;
  u := log!:(bfthree!*, k);
  save!:const('!:log3, u);
  return u;
end;
+++ !:log3 compiled, 19 + 28 bytes
:log3

symbolic procedure !:log5 k;
% This function calculates log(5), the natural
%      logarithm of 5, with the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:log5, k);
  if u neq 'not_found then return u;
  u := log!:(bffive!*, k);
  save!:const('!:log5, u);
  return u;
end;
+++ !:log5 compiled, 19 + 28 bytes
:log5

symbolic procedure !:log10 k;
% This function calculates log(10), the natural
%      logarithm of 10, with the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:log10,  k);
  if u neq 'not_found then return u;
  u := log!:(bften!*, k);
  save!:const('!:log10, u);
  return u;
end;
+++ !:log10 redefined
+++ !:log10 compiled, 19 + 28 bytes
:log10

symbolic procedure !:logpi k;
% This function calculates log(PI), the natural
%      logarithm of "PI", with the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:logpi, k);
  if u neq 'not_found then return u;
  u := log!:(!:pi(k + 2), k);
  save!:const('!:logpi, u);
  return u
end;
+++ !:logpi compiled, 23 + 32 bytes
:logpi

symbolic procedure !:sqrt2(k);
% This function calculates SQRT(2), the square root
%      of 2, with the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:sqrt2, k);
  if u neq 'not_found then return u;
  u := sqrt!:(bftwo!*, k);
  save!:const('!:sqrt2, u);
  return u;
end;
+++ !:sqrt2 compiled, 19 + 28 bytes
:sqrt2

symbolic procedure !:sqrt3(k);
% This function calculates SQRT(3), the square root
%      of 3, with the precision K.
% K is a positive integer.
begin scalar u;
  u:=get!:const('!:sqrt3, k);
  if u neq 'not_found then return u;
  u := sqrt!:(bfthree!*, k);
  save!:const('!:sqrt3, u);
  return u;
end;
+++ !:sqrt3 compiled, 19 + 28 bytes
:sqrt3

symbolic procedure !:sqrt5 k;
% This function calculates SQRT(5), the square root
%      of 5, with the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:sqrt5, k);
  if u neq 'not_found then return u;
  u := sqrt!:(bffive!*, k);
  save!:const('!:sqrt5, u);
  return u;
end;
+++ !:sqrt5 compiled, 19 + 28 bytes
:sqrt5

symbolic procedure !:sqrt10 k;
% This function calculates SQRT(10), the square root
%      of 10, with the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:sqrt10, k);
  if u neq 'not_found then return u;
  u := sqrt!:(bften!*, k);
  save!:const('!:sqrt10, u);
  return u;
end;
+++ !:sqrt10 compiled, 19 + 28 bytes
:sqrt10

symbolic procedure !:sqrtpi k;
% This function calculates SQRT(PI), the square root
%      of "PI", with the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:sqrtpi, k);
  if u neq 'not_found then return u;
  u := sqrt!:(!:pi(k + 2), k);
  save!:const('!:sqrtpi, u);
  return u;
end;
+++ !:sqrtpi compiled, 23 + 32 bytes
:sqrtpi

symbolic procedure !:sqrte k;
% This function calculates SQRT(e), the square root
%      of "e", with the precision K.
% K is a positive integer.
begin scalar u;
  u:=get!:const('!:sqrte, k);
  if u neq 'not_found then return u;
  u := sqrt!:(!:e(k + 2), k);
  save!:const('!:sqrte, u);
  return u;
end;
+++ !:sqrte compiled, 23 + 32 bytes
:sqrte

symbolic procedure !:cbrt2 k;
% This function calculates CBRT(2), the cube root
%      of 2, with the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:cbrt2, k);
  if u neq 'not_found then return u;
  u := cbrt!:(bftwo!*, k);
  save!:const('!:cbrt2, u);
  return u;
end;
+++ !:cbrt2 compiled, 19 + 28 bytes
:cbrt2

symbolic procedure !:cbrt3 k;
% This function calculates CBRT(3), the cube root
%      of 3, with the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:cbrt3, k);
  if u neq 'not_found then return u;
  u := cbrt!:(bfthree!*, k);
  save!:const('!:cbrt3, u);
  return u;
end;
+++ !:cbrt3 compiled, 19 + 28 bytes
:cbrt3

symbolic procedure !:cbrt5 k;
% This function calculates CBRT(5), the cube root
%    of 5, with the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:cbrt5, k);
  if u neq 'not_found then return u;
  u := cbrt!:(bffive!*, k);
  save!:const('!:cbrt5, u);
  return u;
end;
+++ !:cbrt5 compiled, 19 + 28 bytes
:cbrt5

symbolic procedure !:cbrt10 k;
% This function calculates CBRT(10), the cube root
%      of 10, with the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:cbrt10, k);
  if u neq 'not_found then return u;
  u := cbrt!:(bften!*, k);
  save!:const('!:cbrt10, u);
  return u;
end;
+++ !:cbrt10 compiled, 19 + 28 bytes
:cbrt10

symbolic procedure !:cbrtpi k;
% This function calculates CBRT(PI), the cube root
%      of "PI", with the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:cbrtpi, k);
  if u neq 'not_found then return u;
  u := cbrt!:(!:pi(k + 2), k);
  save!:const('!:cbrtpi, u);
  return u;
end;
+++ !:cbrtpi compiled, 23 + 32 bytes
:cbrtpi

symbolic procedure !:cbrte k;
% This function calculates CBRT(e), the cube root
%      of "e", with the precision K.
% K is a positive integer.
begin scalar u;
  u := get!:const('!:cbrte, k);
  if u neq 'not_found then return u;
  u := cbrt!:(!:e(k + 2), k);
  save!:const('!:cbrte, u);
  return u;
end;
+++ !:cbrte compiled, 23 + 32 bytes
:cbrte

%*************************************************************
%**                                                         **
%** 3-2. Routines for saving CONSTANTS.                     **
%**                                                         **
%*************************************************************

symbolic procedure get!:const(cnst, k);
% This function returns the value of constant CNST
%      of the precision K, if it was calculated
%      previously with, at least, the precision K,
%      else it returns 'not_found.
% CNST is the name of the constant (to be quoted).
% K is a positive integer.
  if atom cnst and fixp k and k > 0 then
    begin scalar u;
          u := get(cnst, 'save!:c);
          if null u or car u < k then return 'not_found
           else if car u = k then return cdr u
                             else return round!:mt(cdr u, k);
    end
   else bflerrmsg 'get!:const$
+++ get!:const redefined
+++ get!:const compiled, 41 + 28 bytes
get:const

symbolic procedure save!:const(cnst, nmbr);
% This function saves the value of constant CNST
%      for the later use.
% CNST is the name of the constant (to be quoted).
% NMBR is a BIG-FLOAT representation of the value.
  if atom cnst and bfp!: nmbr then
       put(cnst, 'save!:c, preci!: nmbr . nmbr)
   else bflerrmsg 'save!:const$
+++ save!:const compiled, 31 + 28 bytes
save:const

symbolic procedure set!:const(cnst, l);
% This function sets the value of constant CNST.
% CNST is the name of the constant (to be quoted).
% L is a list of integers, which represents the
%      value of the constant in the way described
%      in the function READ!:LNUM.
     save!:const(cnst, read!:lnum l)$
+++ set!:const compiled, 8 + 16 bytes
set:const


% Setting the constants.

set!:const( '!:pi    , '( 0   3141 59265 35897 93238 46264
     33832 79502 88419 71693 99375 105820 9749 44592 30781
     64062 86208 99862 80348 25342 11706 79821 48086 51328
     23066 47093 84460 95505 82231 72535 94081 28481 1174
    5028410 2701 93852 11055 59644 62294 89549 30381 96442
     88109 8) )$(693 :rd:
32275789658570886958156186740185430035207321153362338386082868836372441170262918772578584747851174923149878504151407927049194948238790383959946719335828357694428215050317306695934166355248914491511797113061591
. -691)

set!:const( '!:e     , '( 0   2718 28182 84590 45235 36028
     74713 52662 49775 72470 93699 95957 49669 67627 72407
     66303 53547 59457 13821 78525 16642 74274 66391 93200
     30599 21817 41359 66290 43572 90033 42952 60595 63073
     81323 28627 943490 7632 33829 88075 31952 510190 1157
     38341 9) )$(696 :rd:
223414559943812204541299691543817774952446626078955845183474074928994140646542202630297581777052042918617043584281846658404080952838738755044958604987321549025362902884163241093707622384220567344910829214455753
. -694)

set!:const( '!:e0625   , '( 0 1064 49445 89178 59429 563390
      5946 42889 673100 7254 43649 35330 151930 7510 63556
     39368 2816600 633 42934 35506 87662 43755 1) );(345 :rd:
38147133879018916226726161754238056000235647349641966973643839209814212240981324997881509318028130379359
. -344)

set!:const( '!:log2  , '(-1   6931 47180 55994 53094 17232
     12145 81765 68075 50013 43602 55254 1206 800094 93393
     62196 96947 15605 86332 69964 18687 54200 2) )$(344 :rd:
24839564051432105757030187307432255962232015093166539115572437354016218101313667760974422926251785557331
. -344)

set!:const( '!:log3  , '( 0   1098 61228 866810 9691 39524
     52369 22525 70464 74905 57822 74945 17346 94333 63749
     42932 18608 96687 36157 54813 73208 87879 7) )$(346 :rd:
78739555111562328162466601559210101903369880761600796068692519487892757296836330825859826335560157422575
. -345)

set!:const( '!:log5  , '( 0   1609 43791 2434100 374 60075
     93332 26187 63952 56013 54268 51772 19126 47891 47417
     898770 7657 764630 1338 78093 179610 7999 7) )$(343 :rd:
14418920408943590291895376801231811103435110839037170382760291138100527377344006226693362638634878438263
. -342)

set!:const( '!:log10 , '( 0   2302 58509 29940 456840 1799
     14546 84364 20760 11014 88628 77297 60333 27900 96757
     26096 77352 48023 599720 5089 59829 83419 7) )$(347 :rd:
165030491374412933849223389024719000751944916898630441293227203812836655221379385335495746961582598620767
. -345)

set!:const( '!:logpi , '( 0   1144 72988 5849400 174 14342
     73513 53058 71164 72948 12915 31157 15136 23071 47213
     77698 848260 7978 36232 70275 48970 77020 1) )$(346 :rd:
82044887777439745201490860134149724327740508022373333934496464660706775280894235524870788720107408621657
. -345)

set!:const( '!:sqrt2 , '( 0   1414 21356 23730 95048 80168
     872420 96980 7856 96718 75376 94807 31766 79737 99073
     24784 621070 38850 3875 34327 64157 27350 1) )$(345 :rd:
50679638250266908861395072713544592150266848458327253776136968282930880401586871730484368125324019459069
. -344)

set!:const( '!:sqrt3 , '( 0   17320 5080 75688 77293 52744
     634150 5872 36694 28052 53810 38062 805580 6979 45193
     301690 88000 3708 11461 86757 24857 56756 3) )$(347 :rd:
248278508123981609440413003268423058724784449908208567741775698889111072126561909541155538505338450234411
. -346)

set!:const( '!:sqrt5 , '( 0   22360 6797 74997 89696 40917
     36687 31276 235440 6183 59611 52572 42708 97245 4105
    209256 37804 89941 441440 8378 78227 49695 1) )$(347 :rd:
160263087864233938564171191044014407532380117773343723184267574989151211701991419780657973200450208209937
. -345)

set!:const( '!:sqrt10, '( 0   3162 277660 1683 79331 99889
     35444 32718 53371 95551 39325 21682 685750 4852 79259
     44386 39238 22134 424810 8379 30029 51873 47))$(351 :rd:
3626339718486249843935062318460017099107964674038984464624974694918453710375278122937439447990585581769517
. -349)

set!:const( '!:sqrtpi, '( 0   1772 453850 9055 16027 29816
     74833 41145 18279 75494 56122 38712 821380 7789 85291
     12845 91032 18137 49506 56738 54466 54162 3) )$(346 :rd:
127035014186189798996721691704828281211780805781345795619730198926133233346870142241668189685941500845293
. -345)

set!:const( '!:sqrte , '( 0   1648 721270 7001 28146 8486
    507878 14163 57165 3776100 710 14801 15750 79311 64066
     10211 94215 60863 27765 20056 36664 30028 7) )$(343 :rd:
14770859189469281038386275396043606714604333497923750655344249075728152412325839111562307376508616809399
. -342)

set!:const( '!:cbrt2 , '( 0   1259 92104 98948 73164 7672
    106072 78228 350570 2514 64701 5079800 819 75112 15529
     96765 13959 48372 93965 62436 25509 41543 1) )$(346 :rd:
90300849505957794917936684197096299653509935569780592611890608283374605465644997058723193304239168600451
. -345)

set!:const( '!:cbrt3 , '( 0   1442 249570 30740 8382 32163
     83107 80109 58839 18692 53499 35057 75464 16194 54168
     75968 29997 33985 47554 79705 64525 66868 4) )$(346 :rd:
103368668544134889415261896114643512957939173776229308377580129710844166070396271815119166661316221761795
. -345)

set!:const( '!:cbrt5 , '( 0   1709 97594 66766 96989 35310
     88725 43860 10986 80551 105430 5492 43828 61707 44429
     592050 4173 21625 71870 10020 18900 220450 ) )$(346 :rd:
122557108346228652131261462517363494874090099635843090514908752924083688145951822513240265180899973398035
. -345)

set!:const( '!:cbrt10, '( 0   2154 4346900 318 83721 75929
     35665 19350 49525 93449 42192 10858 24892 35506 34641
     11066 48340 80018 544150 3543 24327 61012 6) )$(347 :rd:
154412280619660125997582582468881795918497944332658086037182090027508214848053363871814051517862045334163
. -345)

set!:const( '!:cbrtpi, '( 0   1464 59188 75615 232630 2014
     25272 63790 39173 85968 55627 93717 43572 55937 13839
     36497 98286 26614 56820 67820 353820 89750 ) )$(347 :rd:
209939966694540002189872523367163064276025630375546307290789337782432628385230387394034908651444438482047
. -346)

set!:const( '!:cbrte , '( 0   1395 61242 50860 89528 62812
     531960 2586 83759 79065 15199 40698 26175 167060 3173
     90156 45951 84696 97888 17295 83022 41352 1) )$(346 :rd:
100026098918546677906326139569715406271344101179735395193974120497220242360267604189519654265327644817783
. -345)


%*************************************************************
%**                                                         **
%** 4-1. Elementary FUNCTIONS.                              **
%**                                                         **
%*************************************************************

symbolic procedure sqrt!:(x, k);
% This function calculates SQRT(x), the square root
%      of "x", with the binary precision K, by Newton's
%      iteration method.
% X is a BIG-FLOAT representation of "x", x >= 0.
% K is a positive integer.
  if minusp!: x or not fixp k or k <= 0 then bflerrmsg 'sqrt!:
    else if bfzerop!: x then bfz!*
    else begin integer k7,ncut,nfig;  scalar dcut,half,dy,y,y0,u;
          k7 := k + 7;
          ncut := k7 - (order!: x + 1) / 2;
          half := bfhalf!*;    %JBM
          dcut := make!:ibf(2, - ncut);
          dy := make!:ibf(4, - ncut);
          %y0 := incprec!:(x,1);
          y0 := conv!:mt(x, 2);
          if remainder(ep!: y0, 2) = 0 then
                y0 := make!:ibf((2 + 3 * mt!: y0)/5,  ep!: y0/2)
           else y0 := make!:ibf((9 + 5 * mt!: y0)/10, (ep!: y0 - 1)/2);
          nfig := 1;
          while nfig < k7 or greaterp!:(abs!: dy, dcut) do
            << if (nfig := 2 * nfig) > k7 then nfig := k7;
               u := divide!:(x, y0, nfig);
               y := times!:(plus!:(y0, u), half);
               dy := difference!:(y, y0);
               y0 := y >>;
          return round!:mt(y, k);
    end;
+++ sqrt!: compiled, 196 + 104 bytes
sqrt:


symbolic procedure cbrt!:(x, k);
% This function calculates CBRT(x), the cube root
%      of "x", with the binary precision K, by Newton's
%      iteration method.
% X is a BIG-FLOAT representation of any real "x".
% K is a positive integer.
   if not fixp k or k <= 0 then bflerrmsg 'cbrt!:
   else if bfzerop!: x then bfz!*
   else if minusp!: x then minus!: cbrt!:(minus!: x, k)
   else begin integer k7, ncut, nfig, j;  scalar dcut, thre, dy, y, u;
          k7 := k + 7;
          ncut := k7 - (order!: x + 2) / 3;
          thre := bfthree!*;
          dcut := make!:ibf(2, - ncut);
          dy := make!:ibf(4, - ncut);
          y := conv!:mt(x, 3);
          if (j := remainder(ep!: y, 3)) = 0 then
               y := make!:ibf((12 + mt!: y ) / 10, ep!: y / 3)
           else if j = 1 or j = -2 then
                y := make!:ibf((17 + 4 * mt!: y)/16, (ep!: y - 1)/3)
           else y := make!:ibf((15 + 4 * mt!: y)/12, (ep!: y - 2)/3);
          nfig := 1;
          while nfig < k7 or greaterp!:(abs!: dy, dcut) do
            << if (nfig := 2 * nfig) > k7 then nfig := k7;
               u := cut!:mt(times!:(y, y), nfig);
               u := divide!:(x, u, nfig);
               j := order!:(u := difference!:(u, y)) + ncut - k7;
               dy := divide!:(u, thre, max(1, nfig + j));
               y := plus!:(y, dy) >>;
          return round!:mt(y, k);
    end;
+++ cbrt!: compiled, 276 + 128 bytes
cbrt:


symbolic procedure exp!:(x, k);
% This function calculates exp(x), the value of
%      the exponential function at the point "x",
%      with the binary precision K, by summing terms of
%      the Taylor series for exp(z), 0 < z < 1.
% X is a BINARY BIG-FLOAT representation of any real "x".
% K is a positive integer.
   if not fixp k or k <= 0 then bflerrmsg 'exp!:
   else if bfzerop!: x then bfone!*
   else begin integer k7, m;  scalar q, r, y, yq, yr;
          q := i2bf!:(m := conv!:bf2i(y := abs!: x));
          r := difference!:(y, q);
          k7 := k + msd!: m + 7;
          r := difference!:(y, q);
          if bfzerop!: q then yq := bfone!*
           else (yq := texpt!:(!:e k7, m) where !:bprec!: := k7);
          if bfzerop!: r then yr:=bfone!*
           else begin integer j, n;  scalar dcut, fctrial, ri, tm;
              dcut := make!:ibf(2, - k7);
              yr := ri := tm := bfone!*;
              m := 1;
              j := 0;
              while greaterp!:(tm, dcut) do
                << fctrial := i2bf!:(m := m * (j := j + 1));
                   ri := cut!:ep(times!:(ri, r), - k7);
                   n := max(1, k7 - order!: fctrial + order!: ri);
                   tm := divide!:(ri, fctrial, n);
                   yr := plus!:(yr,tm);
                   if remainder(j,10)=0 then yr := cut!:ep(yr, - k7) >>;
        end;
          y := cut!:mt(times!:(yq, yr), k + 1);
          return (if minusp!: x then divide!:(bfone!*, y, k)
                  else round!:mt (y,k));
    end;
+++ exp!: compiled, 233 + 116 bytes
exp:


symbolic procedure log!:(x, k);
% This function calculates log(x), the value of the
%      logarithmic function at the point "x", with
%      the precision K, by summing terms of the
%      Taylor series for log(1+z), 0 < z < 0.10518.
% X is a BIG-FLOAT representation of "x", x > 0.
% K is a positive integer.
   if minusp!: x or bfzerop!: x or
     not fixp k or k <= 0 then bflerrmsg 'log!:
   else if equal!:(x,bfone!*) then bfz!*
   else begin integer k7,m;  scalar eee,es,sign,l,y,z;
          k7 := k + 7;
          eee := !:e k7;
          es := !:e0625 k7;
          if greaterp!:(x, bfone!*) then << sign := bfone!*; y := x >>
           else <<sign := minus!: bfone!*;
                  y := divide!:(bfone!*, x, k7)>>;
          if lessp!:(y, eee) then << m := 0; z := y >>
           else << if (m := (order!: y * 69) / 100) = 0 then z := y
                    else (z := divide!:(y, texpt!:(eee, m), k7)
                             where !:bprec!: := k7);
                    while greaterp!:(z, eee) do
                       << m := m+1; z := divide!:(z, eee, k7) >> >>;
          l := i2bf!: m;
          y := !:bf!-0!.0625;
          while greaterp!:(z, es) do
            << l := plus!:(l, y); z := divide!:(z, es, k7) >>;
          z := difference!:(z, bfone!*);
        begin integer n;  scalar dcut, tm, zi;
              y := tm := zi := z;
              z := minus!: z;
              dcut := make!:ibf(2, - k7);
              m := 1;
              while greaterp!:(abs!: tm, dcut) do
               << zi := cut!:ep(times!:(zi, z), - k7);
                  n := max(1, k7 + order!: zi);
                  tm := divide!:(zi,i2bf!:(m := m + 1), n);
                  y := plus!:(y, tm);
                  if zerop remainder(m,10) then y := cut!:ep(y,-k7)>>;
        end;
          y := plus!:(y, l);
          return round!:mt(times!:(sign, y), k);
    end;
+++ log!: compiled, 299 + 136 bytes
log:


symbolic procedure sin!:(x, k);
% This function calculates sin(x), the value of
%      the sine function at the point "x", with
%      the binary precision K, by summing terms of the
%      Taylor series for sin(z), 0 < z < PI/4.
% X is a BIG-FLOAT representation of any real "x".
% K is a positive integer.  (revised SLK)                         %<===
   if not fixp k or k <= 0 then bflerrmsg 'sin!:
   else if bfzerop!: x then bfz!*
   else if minusp!: x then minus!: sin!:(minus!: x, k)
   else begin integer k7, m;  scalar pi4, sign, q, r, y, !!scls;  %<===
           k7 := k + 7;
          m := preci!: x;
          pi4 := times!:(!:pi(k7 + m), !:bf!-0!.25);
          if lessp!:(x, pi4) then << m := 0; r := x >>
           else << m := conv!:bf2i(q := quotient!:(x, pi4));
                   r := difference!:(x, times!:(q, pi4)) >>;
          sign := bfone!*;
          if m >= 8 then m := remainder(m, 8);
          if m >= 4 then << sign := minus!: sign; m := m - 4>>;
          if m = 0 then <<!!scls := x; go to sn>>                  %<===
           else if onep m then go to m1
           else if m = 2 then go to m2
           else go to m3;;
      m1: r := cut!:mt(difference!:(pi4, r), k7);
          return times!:(sign, cos!:(r, k));
      m2: r := cut!:mt(r, k7);
          return times!:(sign, cos!:(r, k));
      m3: r := cut!:mt(difference!:(pi4, r), k7); !!scls := x;     %<===
    sn: x := if !!sclc then !!sclc else !!scls;                    %<===
        if x and lessp!:(r,times!:(x,make!:ibf(1, 3 - k)))         %<===
          then return bfz!* else                                   %<===
        begin integer j, n, ncut;  scalar dcut, fctrial, ri, tm;
              ncut := k7 - min(0, order!: r + 1);
              dcut := make!:ibf(2, - ncut);
              y := ri := tm := r;
              r := minus!: cut!:ep(times!:(r, r), - ncut);
              m := j := 1;
              while greaterp!:(abs!: tm, dcut) do
               << j := j + 2;
                  fctrial := i2bf!:(m := m*j*(j - 1));
                  ri := cut!:ep(times!:(ri, r), - ncut);
                  n := max(1,k7 - order!: fctrial + order!: ri);
                  tm := divide!:(ri, fctrial, n);
                  y := plus!:(y, tm);
                  if zerop remainder(j,20) then y := cut!:ep(y,-ncut)>>;
        end;
          return round!:mt(times!:(sign, y), k);
    end;
+++ sin!: compiled, 415 + 156 bytes
sin:

symbolic procedure cos!:(x, k);
% This function calculates cos(x), the value of
%      the cosine function at the point "x", with
%      the binary precision K, by summing terms of the
%      Taylor series for cos(z), 0 < z < PI/4.
% X is a BIG-FLOAT representation of any real "x".
% K is a positive integer.  (revised SLK)                          %<===
   if not fixp k or k <= 0 then bflerrmsg 'cos!:
    else if bfzerop!: x then bfone!*
    else if minusp!: x then cos!:(minus!: x, k)
    else begin integer k7, m;  scalar pi4, sign, q, r, y, !!sclc;  %<===
          k7 := k + 7;
          m := preci!: x;
          pi4 := times!:(!:pi(k7 + m), !:bf!-0!.25);
          if lessp!:(x, pi4) then << m := 0; r := x >>
           else << m := conv!:bf2i(q := quotient!:(x, pi4));
                   r := difference!:(x, times!:(q, pi4)) >>;
          sign := bfone!*;
          if m >= 8 then m := remainder(m, 8);
          if m >= 4 then << sign := minus!: sign; m := m - 4 >>;
          if m >= 2 then sign := minus!: sign;
          if m = 0 then go to cs
           else if m = 1 then go to m1
           else if m = 2 then go to m2
           else go to m3;
      m1: r := cut!:mt(difference!:(pi4, r), k7); !!sclc := x;     %<===
          return times!:(sign, sin!:(r, k));
      m2: r := cut!:mt(r, k7); !!sclc := x;                        %<===
          return times!:(sign, sin!:(r, k));
      m3: r := cut!:mt(difference!:(pi4, r), k7);
    cs: begin integer j, n;  scalar dcut, fctrial, ri, tm;
              dcut := make!:ibf(2, - k7);
              y := ri := tm := bfone!*;
              r := minus!: cut!:ep(times!:(r, r), - k7);
              m := 1;
              j := 0;
              while greaterp!:(abs!: tm, dcut) do
               << j := j + 2;
                  fctrial := i2bf!:(m := m * j * (j - 1));
                  ri := cut!:ep(times!:(ri, r), - k7);
                  n := max(1, k7 - order!: fctrial + order!: ri);
                  tm := divide!:(ri, fctrial, n);
                  y := plus!:(y, tm);
                  if zerop remainder(j,20) then y := cut!:ep(y,-k7)>>;
        end;
          return round!:mt(times!:(sign, y), k);
    end;
+++ cos!: compiled, 362 + 140 bytes
cos:

symbolic procedure tan!:(x, k);
% This function calculates tan(x), the value of
%      the tangent function at the point "x",
%      with the binary precision K, by calculating
%         sin(x)  or  cos(x) = sin(PI/2-x).
% X is a BIG-FLOAT representation of any real "x",
% K is a positive integer.
   if not fixp k or k <= 0 then bflerrmsg 'tan!:
   else if bfzerop!: x then bfz!*
   else if minusp!: x then minus!: tan!:(minus!: x, k)
   else begin integer k7, m;  scalar pi4, sign, q, r;
          k7 := k + 7;
          m := preci!: x;
          pi4 := times!:(!:pi(k7 + m), !:bf!-0!.25);
          if lessp!:(x, pi4) then << m := 0; r := x >>
           else << m := conv!:bf2i(q := quotient!:(x, pi4));
                   r := difference!:(x, times!:(q, pi4)) >>;
          if m >= 4 then m := remainder(m, 4);
          if m >= 2 then sign := minus!: bfone!* else sign := bfone!*;
          if m = 1 or m = 3 then r := difference!:(pi4, r);
          r := cut!:mt(r, k7);
          if m = 0 or m = 3 then go to m03 else go to m12;
     m03: r := sin!:(r, k7);
          q := difference!:(bfone!*, times!:(r, r));
          q := sqrt!:(cut!:mt(q, k7), k7);
          return times!:(sign, divide!:(r, q, k));
     m12: r := sin!:(r, k7);
          q := difference!:(bfone!*, times!:(r, r));
          q := sqrt!:(cut!:mt(q, k7), k7);
          return times!:(sign, divide!:(q, r, k));
    end;
+++ tan!: compiled, 207 + 104 bytes
tan:

symbolic procedure asin!:(x, k);
% This function calculates asin(x), the value of
%      the arcsine function at the point "x",
%      with the binary precision K, by calculating
%         atan(x/SQRT(1-x**2))  by ATAN!:.
%      The answer is in the range [-PI/2 , PI/2].
% X is a BIG-FLOAT representation of "x", IxI <= 1;
% K is a positive integer.
   if greaterp!:(abs!: x, bfone!*) or
     not fixp k or k <= 0 then bflerrmsg 'asin!:
   else if minusp!: x then minus!: asin!:(minus!: x, k)
   else begin integer k7;  scalar y;
          k7 := k + 7;
          if lessp!:(difference!:(bfone!*, x), make!:ibf(2, - k7))
            then return round!:mt(times!:(!:pi add1 k,bfhalf!*),k);
                 %JBM
          y := cut!:mt(difference!:(bfone!*, times!:(x, x)), k7);
          y := divide!:(x, sqrt!:(y, k7), k7);
          return atan!:(y, k);
    end;
+++ asin!: compiled, 102 + 88 bytes
asin:

symbolic procedure acos!:(x, k);
% This function calculates acos(x), the value of
%      the arccosine function at the point "x",
%      with the precision K, by calculating
%         atan(SQRT(1-x**2)/x)  if  x > 0  or
%         atan(SQRT(1-x**2)/x) + PI  if  x < 0.
%      The answer is in the range [0 , PI].
% X is a BIG-FLOAT representation of "x", IxI <= 1.
% K is a positive integer.
   if greaterp!:(abs!: x, bfone!*) or
     not fixp k or k <= 0 then bflerrmsg 'acos!:
   else begin integer k7;  scalar y;
          k7 := k + 7;
          if lessp!:(abs!: x, make!:ibf(2, - k7))  %%%%% 5 * base = 5*2
           then return round!:mt(times!:(!:pi add1 k,bfhalf!*),k);
                %JBM
          y := difference!:(bfone!*, times!:(x, x));
          y := cut!:mt(y, k7);
          y := divide!:(sqrt!:(y, k7), abs!: x, k7);
          return (if minusp!: x then
                   round!:mt(difference!:(!:pi(k + 1), atan!:(y, k)), k)
                  else atan!:(y, k) );
    end;
+++ acos!: compiled, 106 + 84 bytes
acos:

symbolic procedure atan!:(x, k);
% This function calculates atan(x), the value of the
%      arctangent function at the point "x", with
%      the precision K, by summing terms of the
%      Taylor series for atan(z)  if  0 < z < 0.419921875.
%      Otherwise the following identities are used:
%         atan(x) = PI/2 - atan(1/x)  if  1 < x  and
%         atan(x) = 2*atan(x/(1+SQRT(1+x**2)))
%            if  0.419921875 <= x <= 1.
%      The answer is in the range [-PI/2 , PI/2].
% X is a BIG-FLOAT representation of any real "x".
% K is a positive integer.
   if not fixp k or k <= 0 then bflerrmsg 'atan!:
   else if bfzerop!: x then bfz!*
   else if minusp!: x then minus!: atan!:(minus!: x, k)
   else begin integer k7;  scalar pi4, y, z;
          k7 := k + 7;
          pi4 := times!:(!:pi k7, !:bf!-0!.25);    %JBM
          if equal!:(x, bfone!*) then return round!:mt(pi4, k);
          if greaterp!:(x, bfone!*) then return
           round!:mt(difference!:(plus!:(pi4, pi4),
                               atan!:(divide!:(bfone!*,x,k7),k + 1)),k);
          if lessp!:(x, !:bf0!.419921875) then go to at;
          y := plus!:(bfone!*, cut!:mt(times!:(x, x), k7));
          y := plus!:(bfone!*, sqrt!:(y, k7));
          y := atan!:(divide!:(x, y, k7), k + 1);
          return round!:mt(times!:(y, bftwo!*), k);
    at: begin integer m, n, ncut;  scalar dcut, tm, zi;
              ncut := k7 - min(0, order!: x + 1);
              y := tm := zi := x;
              z := minus!: cut!:ep(times!:(x, x), - ncut);
              dcut := make!:ibf(2, - ncut);
              m := 1;
              while greaterp!:(abs!: tm, dcut) do
               << zi := cut!:ep(times!:(zi, z), - ncut);
                  n := max(1, k7 + order!: zi);
                  tm := divide!:(zi, i2bf!:(m := m + 2), n);
                  y := plus!:(y, tm);
                  if zerop remainder(m,20) then y := cut!:ep(y,-ncut)>>;
        end;
          return round!:mt(y, k)
    end;
+++ atan!: compiled, 281 + 132 bytes
atan:

endmodule;nil


end;nil
nil
  %  Needed by roots, specfn*, (psl).

(load!-package!-sources 'entry 'support)module entry;nil   % Entry points for self-loading modules.

% Author: Anthony C. Hearn.

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


% Using a modified version of the defautoload function of Eric Benson
% and Martin L. Griss.

% Extended for algebraic operators and values by Herbert Melenk.

fluid '(varstack!*);nil

if getd 'create!-package then create!-package('(entry),'(build));
+++ Creating a package: entry
entry

symbolic procedure safe!-putd(name,type,body);
   % So that stubs will not clobber REAL entries preloaded.
   if getd name then lprim list("Autoload stub for",name,"not defined")
    else putd(name,type,body);
+++ safe!-putd compiled, 20 + 28 bytes
safe-putd

inline procedure mkfunction u; list('function,u);
+++ Record new inline definition:
(de mkfunction (u) (list (quote function) u))
(progn (de mkfunction (u) (list (quote function) u)) (put (quote mkfunction) (
quote number!-of!-args) 1) (put (quote mkfunction) (quote procedure_type) (quote
(arrow general general))) (putc (quote mkfunction) (quote inline) (quote (lambda
(u) (list (quote function) u)))))
+++ mkfunction compiled, 4 + 12 bytes
(lambda (u) (list (quote function) u))

symbolic procedure do!-autoload(name, u, loadname);
  begin
    scalar w;
    for each j in loadname do load!-package j;
    w := getd name;
    if not atom w and
       not atom (w := cdr w) and
       eqcar(w, 'lambda) and
       not atom (w := cddr w) and
       eqcar(car w, 'do!-autoload) then <<
       lprim list("Autoloading for", name, "did not defined it"); 
       error(99, list("Presumed build failure:", name, loadname)) >>;
    return lispapply(name, u)
  end;
+++ do!-autoload compiled, 56 + 48 bytes
do-autoload

symbolic macro procedure defautoload u;
% (defautoload name), (defautoload name loadname),
% (defautoload name loadname fntype), or
% (defautoload name loadname fntype numargs)
% Default is 1 Arg EXPR in module of same name.
  begin scalar name,numargs,loadname,fntype;
    u := cdr u;
    name := car u;
    u := cdr u;
    if u then <<loadname := car u; u :=cdr u>> else loadname := name;
    if eqcar(name, 'quote) then name := cadr name;
    if atom loadname then loadname := list loadname
     else if car loadname eq 'quote then loadname := cadr loadname;
    if u then <<fntype := car u; u := cdr u>> else fntype := 'expr;
    if u then numargs := car u else numargs := 1;
    u := if numargs=0 then nil
          else if numargs=1 then '(x1)
          else if numargs=2 then '(x1 x2)
          else if numargs=3 then '(x1 x2 x3)
          else if numargs=4 then '(x1 x2 x3 x4)
          else if numargs=5 then '(x1 x2 x3 x4 x5)
          else if numargs=6 then '(x1 x2 x3 x4 x5 x6)
          else if numargs=7 then '(x1 x2 x3 x4 x5 x6 x7)
          else if numargs=8 then '(x1 x2 x3 x4 x5 x6 x7 x8)
          else if numargs=9 then '(x1 x2 x3 x4 x5 x6 x7 x8 x9)
          else error(99,list(numargs,"too large in DEFAUTOLOAD"));
    name := mkquote name;
    return
       list('progn,
            list('put,name,mkquote 'number!-of!-args,numargs),
            list('safe!-putd,
                 name,
                 mkquote fntype,
                 mkfunction
                    list('lambda, u,
                       list('do!-autoload,
                            name,
                            'list . u,
                            mkquote loadname))))
  end;
+++ defautoload_b7b6e9wb8r0n compiled, 226 + 148 bytes
defautoload

% Autoload support for algebraic operators and values.
%
%    defautoload_operator(opname,package);
%    defautoload_value(varname,package);
%

symbolic macro procedure defautoload_operator u;
  begin scalar name,package;
    name := cadr u; package := caddr u;
    return subla(list('name.name,'package.package),
     '(progn
        (flag '(name) 'full)
        (put 'name 'simpfn
          '(lambda(x)(autoload_operator!* 'name 'package x)))))
  end;
+++ defautoload_operator_8yimdh4rc65p1 compiled, 23 + 20 bytes
defautoload_operator

symbolic procedure autoload_operator!*(o,p,x);
   begin scalar varstack!*;
     remflag(list o,'full);
     remprop(o,'simpfn);
     if pairp p then for each pp in p do load!-package pp
        else load!-package p;
     return simp x;
   end;
+++ autoload_operator!* compiled, 43 + 32 bytes
autoload_operator*

symbolic macro procedure defautoload_value u;
  begin scalar name,package;
    u:=cdr u; name := car u; u:=cdr u; package := car u;
    return subla(list('name.name,'package.package),
     '(progn
        (put 'name 'avalue
          '(autoload_value!* name package))))
  end;
+++ defautoload_value_7765zmrym9n7 compiled, 25 + 20 bytes
defautoload_value

symbolic procedure autoload_value!*(u,v);
   begin scalar name,p,x,varstack!*;
     x:=get(u,'avalue);
     name := cadr x; p := caddr x;
     remprop(name,'avalue);
     load!-package p;
     return reval1(name,v);
   end;
+++ autoload_value!* compiled, 27 + 28 bytes
autoload_value*

put('autoload_value!*,'evfn,'autoload_value!*);autoload_value*

COMMENT Actual Entry Point Definitions;

% Compiler and LAP entry points.

defautoload(compile,compiler);
*** Autoload stub for compile not defined 
nil

if 'psl memq lispsystem!* then defautoload(lap,compiler)
 else defautoload(faslout,compiler);
*** Autoload stub for faslout not defined 
nil


% Cross-reference module entry points.

remd 'crefon;nil  % don't use PSL version

% Protect against "off cref;" calling crefoff before the rcref module 
% is loaded.
put('cref,'simpfg,'((t (crefon))
                    (nil (and (getd (quote crefoff)) (crefoff)))));((t (crefon))
(nil (and (getd (quote crefoff)) (crefoff))))

defautoload(crefon,rcref,expr,0);
+++ crefon compiled, 7 + 16 bytes
crefon


% Input editor entry points.

defautoload cedit;
+++ cedit compiled, 8 + 16 bytes
cedit

defautoload(display,cedit);
+++ display compiled, 8 + 16 bytes
display

put('display,'stat,'rlis);rlis

defautoload(editdef,cedit);
+++ editdef compiled, 8 + 16 bytes
editdef

put('editdef,'stat,'rlis);rlis

% Functions for rebuilding parts of Reduce

defautoload(package!-remake, remake);
+++ package!-remake compiled, 8 + 16 bytes
package-remake

% Factorizer module entry points.

switch trfac, trallfac;nil

remprop('factor,'stat);nil

defautoload(ezgcdf,ezgcd,expr,2);
+++ ezgcdf compiled, 8 + 16 bytes
ezgcdf

defautoload(factorize!-primitive!-polynomial,factor);
+++ factorize!-primitive!-polynomial compiled, 8 + 16 bytes
factorize-primitive-polynomial

defautoload(pfactor,factor,expr,2);
+++ pfactor compiled, 8 + 16 bytes
pfactor

defautoload(simpnprimitive,factor);
+++ simpnprimitive compiled, 8 + 16 bytes
simpnprimitive

put('nprimitive,'simpfn,'simpnprimitive);simpnprimitive

put('factor,'stat,'rlis);rlis


% FASL module entry points.

flag('(faslout),'opfn);nil

flag('(faslout),'noval);nil


% High energy physics module entry points.

remprop('index,'stat);nil remprop('mass,'stat);nil

remprop('mshell,'stat);nil remprop('vecdim,'stat);nil

remprop('vector,'stat);nil

defautoload(index,hephys);
+++ index compiled, 8 + 16 bytes
index

defautoload(mass,hephys);
+++ mass compiled, 8 + 16 bytes
mass

defautoload(mshell,hephys);
+++ mshell compiled, 8 + 16 bytes
mshell

defautoload(vecdim,hephys);
+++ vecdim compiled, 8 + 16 bytes
vecdim

defautoload(vector,hephys);
+++ vector compiled, 8 + 16 bytes
vector

put('index,'stat,'rlis);rlis

put('mshell,'stat,'rlis);rlis

put('mass,'stat,'rlis);rlis

put('vecdim,'stat,'rlis);rlis

put('vector,'stat,'rlis);rlis


% Integrator module entry points.

fluid '(!*trint !*trintsubst !*trdint);nil

switch trint,trintsubst,trdint;nil

defautoload(simpint,int);
+++ simpint compiled, 8 + 16 bytes
simpint

put('int,'simpfn,'simpint);simpint

fluid '(!*tra);nil

switch tra;nil

switch algint;nil

put('algint,'simpfg,'((t (load!-package 'algint))));((t (load-package (quote
algint))))

fluid '(!*trdefint);nil

switch trdefint;nil

defautoload(new_defint,defint);
+++ new_defint compiled, 8 + 16 bytes
new_defint

defautoload(new_indefint,defint);
+++ new_indefint compiled, 8 + 16 bytes
new_indefint

defautoload(defint0,defint);
+++ defint0 compiled, 8 + 16 bytes
defint0


% Matrix module entry points.

switch cramer;nil

put('cramer,'simpfg,
    '((t (put 'mat 'lnrsolvefn 'clnrsolve)
     (put 'mat 'inversefn 'matinv))
      (nil (put 'mat 'lnrsolvefn 'lnrsolve)
       (put 'mat 'inversefn 'matinverse))));((t (put (quote mat) (quote
lnrsolvefn) (quote clnrsolve)) (put (quote mat) (quote inversefn) (quote matinv)
)) (nil (put (quote mat) (quote lnrsolvefn) (quote lnrsolve)) (put (quote mat) (
quote inversefn) (quote matinverse))))

defautoload(detq,'(matrix));
+++ detq compiled, 8 + 16 bytes
detq % Used by high energy physics package.

defautoload(matp,'(matrix));
+++ matp compiled, 8 + 16 bytes
matp

defautoload(matrix,'(matrix));
+++ matrix compiled, 8 + 16 bytes
matrix

put('matrix,'stat,'rlis);rlis

flag('(mat),'struct);nil

put('mat,'formfn,'formmat);formmat

defautoload(formmat,'(matrix),expr,3);
+++ formmat compiled, 10 + 16 bytes
formmat

defautoload(matstat,'(matrix),expr,0);
+++ matstat compiled, 7 + 16 bytes
matstat

put('mat,'stat,'matstat);matstat

defautoload(generateident,'(matrix));
+++ generateident compiled, 8 + 16 bytes
generateident

defautoload(lnrsolve,'(matrix),expr,2);
+++ lnrsolve compiled, 8 + 16 bytes
lnrsolve

defautoload(simpresultant,'(matrix));
+++ simpresultant compiled, 8 + 16 bytes
simpresultant

defautoload(resultant,'(matrix),expr,3);
+++ resultant compiled, 10 + 16 bytes
resultant

put('resultant,'simpfn,'simpresultant);simpresultant

defautoload(nullspace!-eval,matrix);
+++ nullspace!-eval compiled, 8 + 16 bytes
nullspace-eval

put('nullspace,'psopfn,'nullspace!-eval);nullspace-eval

defautoload(readmatproc,'(matrix),expr,0);
+++ readmatproc compiled, 7 + 16 bytes
readmatproc

put('matrixproc,'stat,'readmatproc);readmatproc

% ODESolve entry point.

put('odesolve,'psopfn,'odesolve!-eval);odesolve-eval

defautoload(odesolve!-eval,odesolve);
+++ odesolve!-eval compiled, 8 + 16 bytes
odesolve-eval

% Plot entry point.

put('plot,'psopfn,'(lambda(u) (prog (!*msg) (load!-package 'gnuplot) (ploteval u))));
(lambda (u) (prog (*msg) (load-package (quote gnuplot)) (ploteval u)))

%% define .. operator so that you don't get an error when used before autoloaded
put('!*interval!*,'simpfn,'simpiden);simpiden

newtok '((!. !.) !*interval!*);nil

put('!*interval!*,'prtch,'! !.!.! ); .. 

precedence .., or;nil

fluid '(!*trplot !*plotkeep);nil

switch force_gnuplot_term=on, trplot, plotkeep;nil


% Prettyprint module entry point (built into CSL).

if 'psl memq lispsystem!* then defautoload(prettyprint,pretty);nil

% Print module entry point.

% defautoload(horner,scope);

% global '(!*horner);

% switch horner;


% Rprint module entry point.

defautoload rprint;
+++ rprint compiled, 8 + 16 bytes
rprint


% SOLVE module entry points.

defautoload(solveeval,solve);
+++ solveeval compiled, 8 + 16 bytes
solveeval

defautoload(solve0,solve,expr,2);
+++ solve0 compiled, 8 + 16 bytes
solve0

% defautoload(solvelnrsys,solve,expr,2);      % Used by matrix routines.

% defautoload(!*sf2ex,solve,expr,2);   % Used by matrix routines.

put('solve,'psopfn,'solveeval);solveeval

switch allbranch,arbvars,fullroots,multiplicities,nonlnr,solvesingular;nil
%      varopt;

% Default values.

!*allbranch     := t;t
!*arbvars       := t;t
!*solvesingular := t;t

put('arbint,'simpfn,'simpiden);simpiden

% Since the following three switches are set on in the solve module,
% they must first load that module if they are initially turned off.

put('nonlnr,'simpfg,'((nil (load!-package 'solve))));((nil (load-package (quote
solve))))

put('allbranch,'simpfg,'((nil (load!-package 'solve))));((nil (load-package (
quote solve))))

put('solvesingular,'simpfg,'((nil (load!-package 'solve))));((nil (load-package
(quote solve))))


% Root finding package entry points.

defautoload roots;
+++ roots compiled, 8 + 16 bytes
roots

defautoload(gfnewt,roots);
+++ gfnewt compiled, 8 + 16 bytes
gfnewt

defautoload(gfroot,roots);
+++ gfroot compiled, 8 + 16 bytes
gfroot

defautoload(root_val,roots);
+++ root_val compiled, 8 + 16 bytes
root_val

defautoload(firstroot,roots);
+++ firstroot compiled, 8 + 16 bytes
firstroot

defautoload(rlrootno,roots2);
+++ rlrootno compiled, 8 + 16 bytes
rlrootno

defautoload(realroots,roots2);
+++ realroots compiled, 8 + 16 bytes
realroots

defautoload(isolater,roots2);
+++ isolater compiled, 8 + 16 bytes
isolater

defautoload(nearestroot,roots2);
+++ nearestroot compiled, 8 + 16 bytes
nearestroot

defautoload(sturm0,roots2);
+++ sturm0 compiled, 8 + 16 bytes
sturm0

defautoload(multroot1,roots2);
+++ multroot1 compiled, 8 + 16 bytes
multroot1

for each n in '(roots rlrootno realroots isolater firstroot
                nearestroot gfnewt gfroot root_val)
   do put(n,'psopfn,n);nil

put('sturm,'psopfn,'sturm0);sturm0

switch trroot,rootmsg;nil

put('multroot,'psopfn,'multroot1);multroot1

switch fullprecision,compxroots;nil

% Limits entry points.

for each c in '(limit limit!+ limit!-) do
   <<put(c,'simpfn,'simplimit);
     put(c,'number!-of!-args,3);
     flag({c},'full)>>;nil

defautoload(simplimit,limits);
+++ simplimit compiled, 8 + 16 bytes
simplimit

% Partial fractions entry point.

flag('(pf),'opfn);nil

flag('(pf),'noval);nil

defautoload(pf,pf,expr,2);
+++ pf compiled, 8 + 16 bytes
pf

% Compact entry point.

defautoload(simpcompact,compact);
+++ simpcompact compiled, 8 + 16 bytes
simpcompact

put('compact,'simpfn,'simpcompact);simpcompact

% Changevar entry point

defautoload(simpchangevar,changevr);
+++ simpchangevar compiled, 8 + 16 bytes
simpchangevar

put('changevar,'simpfn,'simpchangevar);simpchangevar

% Sum entry points.

defautoload(simp!-sum,sum);
+++ simp!-sum compiled, 8 + 16 bytes
simp-sum
defautoload(simp!-sum0,sum,expr,2);
+++ simp!-sum0 compiled, 8 + 16 bytes
simp-sum0

put('sum,'simpfn,'simp!-sum);simp-sum

defautoload(simp!-prod,sum);
+++ simp!-prod compiled, 8 + 16 bytes
simp-prod

put('prod,'simpfn,'simp!-prod);simp-prod

switch zeilberg;nil

% Taylor entry points

put('taylor,'simpfn,'simptaylor);simptaylor

defautoload(simptaylor,taylor);
+++ simptaylor compiled, 8 + 16 bytes
simptaylor

% Trigsimp  entry points

put('trigsimp,'psopfn,'trigsimp!*);trigsimp*

defautoload(trigsimp!*,trigsimp);
+++ trigsimp!* compiled, 8 + 16 bytes
trigsimp*

% Specfn entry points

flag('(compute!:dilog compute!:lerch_phi),'opfn);nil
defautoload(compute!:dilog,specfn);
+++ compute!:dilog compiled, 8 + 16 bytes
compute:dilog
defautoload(compute!:lerch_phi,specfn,expr,3);
+++ compute!:lerch_phi compiled, 10 + 16 bytes
compute:lerch_phi

flag('(compute!:khinchin1 bernoulli!*calc euler!:aux),'opfn);nil
defautoload(compute!:khinchin1,specfn,expr,0);
+++ compute!:khinchin1 compiled, 7 + 16 bytes
compute:khinchin1
defautoload(bernoulli!*calc,specfn,expr,1);
+++ bernoulli!*calc compiled, 8 + 16 bytes
bernoulli*calc
defautoload(euler!:aux,specfn,expr,1);
+++ euler!:aux compiled, 8 + 16 bytes
euler:aux
defautoload(rd_euler!*,(specfn sfgamma),expr,0);
+++ rd_euler!* compiled, 7 + 16 bytes
rd_euler*
defautoload(cr_euler!*,(specfn sfgamma),expr,0);
+++ cr_euler!* compiled, 7 + 16 bytes
cr_euler*
defautoload(rd_catalan!*,specfn,expr,0);
+++ rd_catalan!* compiled, 7 + 16 bytes
rd_catalan*
defautoload(cr_catalan!*,specfn,expr,0);
+++ cr_catalan!* compiled, 7 + 16 bytes
cr_catalan*

defautoload_operator(BesselJ,(specfn specbess));(lambda (x) (autoload_operator*
(quote besselj) (quote (specfn specbess)) x))
defautoload_operator(BesselY,(specfn specbess));(lambda (x) (autoload_operator*
(quote bessely) (quote (specfn specbess)) x))
defautoload_operator(BesselI,(specfn specbess));(lambda (x) (autoload_operator*
(quote besseli) (quote (specfn specbess)) x))
defautoload_operator(BesselK,(specfn specbess));(lambda (x) (autoload_operator*
(quote besselk) (quote (specfn specbess)) x))
defautoload_operator(hankel1,(specfn specbess));(lambda (x) (autoload_operator*
(quote hankel1) (quote (specfn specbess)) x))
defautoload_operator(hankel2,specbess);(lambda (x) (autoload_operator* (quote
hankel2) (quote specbess) x))
defautoload_operator(KummerM,specbess);(lambda (x) (autoload_operator* (quote
kummerm) (quote specbess) x))
defautoload_operator(KummerU,specbess);(lambda (x) (autoload_operator* (quote
kummeru) (quote specbess) x))
defautoload_operator(StruveH,specbess);(lambda (x) (autoload_operator* (quote
struveh) (quote specbess) x))
defautoload_operator(StruveL,specbess);(lambda (x) (autoload_operator* (quote
struvel) (quote specbess) x))
defautoload_operator(lommel1,specbess);(lambda (x) (autoload_operator* (quote
lommel1) (quote specbess) x))
defautoload_operator(lommel2,specbess);(lambda (x) (autoload_operator* (quote
lommel2) (quote specbess) x))
defautoload_operator(WhittakerM,specbess);(lambda (x) (autoload_operator* (quote
whittakerm) (quote specbess) x))
defautoload_operator(WhittakerW,specbess);(lambda (x) (autoload_operator* (quote
whittakerw) (quote specbess) x))
defautoload_operator(Airy_Ai,specbess);(lambda (x) (autoload_operator* (quote
airy_ai) (quote specbess) x))
defautoload_operator(Airy_Bi,specbess);(lambda (x) (autoload_operator* (quote
airy_bi) (quote specbess) x))
defautoload_operator(Airy_Aiprime,specbess);(lambda (x) (autoload_operator* (
quote airy_aiprime) (quote specbess) x))
defautoload_operator(Airy_Biprime,specbess);(lambda (x) (autoload_operator* (
quote airy_biprime) (quote specbess) x))

%defautoload_operator(gamma,(specfn sfgamma));
defautoload_operator(binomial,specfn);(lambda (x) (autoload_operator* (quote
binomial) (quote specfn) x))

flag('(compute!:int!:functions),'opfn);nil

defautoload(compute!:int!:functions,specfn,expr,2);
+++ compute!:int!:functions compiled, 8 + 16 bytes
compute:int:functions

defautoload(sf!*eval,specfn,expr,2);
+++ sf!*eval compiled, 8 + 16 bytes
sf*eval

flag('(do!*gamma do!*pochhammer do!*polygamma polygamma_aux do!*trigamma!*halves
       do!*zeta do!*zeta!*pos!*intcalc ibeta!:eval igamma!:eval),'opfn);nil
defautoload(do!*gamma,(specfn sfgamma));
+++ do!*gamma compiled, 8 + 16 bytes
do*gamma
defautoload(do!*pochhammer,(specfn sfgamma),expr,2);
+++ do!*pochhammer compiled, 8 + 16 bytes
do*pochhammer
defautoload(polygamma_aux,(specfn sfgamma),expr,2);
+++ polygamma_aux compiled, 8 + 16 bytes
polygamma_aux
defautoload(rdpsi!*,(specfn sfgamma));
+++ rdpsi!* compiled, 8 + 16 bytes
rdpsi*
defautoload(crpsi!*,(specfn sfgamma));
+++ crpsi!* compiled, 8 + 16 bytes
crpsi*
defautoload(do!*polygamma,(specfn sfgamma),expr,2);
+++ do!*polygamma compiled, 8 + 16 bytes
do*polygamma
defautoload(do!*trigamma!*halves,(specfn sfgamma));
+++ do!*trigamma!*halves compiled, 8 + 16 bytes
do*trigamma*halves
defautoload(do!*zeta,(specfn sfgamma));
+++ do!*zeta compiled, 8 + 16 bytes
do*zeta
defautoload(do!*zeta!*pos!*intcalc,(specfn sfgamma));
+++ do!*zeta!*pos!*intcalc compiled, 8 + 16 bytes
do*zeta*pos*intcalc
defautoload(igamma!:eval,(specfn sfgamma),expr,2);
+++ igamma!:eval compiled, 8 + 16 bytes
igamma:eval
defautoload(ibeta!:eval,(specfn sfgamma),expr,3);
+++ ibeta!:eval compiled, 10 + 16 bytes
ibeta:eval

flag('(solidharmonicy sphericalharmonicy),'opfn);nil
defautoload(solidharmonicy,specfn,expr,6);
+++ solidharmonicy compiled, 24 + 28 bytes
solidharmonicy
defautoload(sphericalharmonicy,specfn,expr,4);
+++ sphericalharmonicy compiled, 18 + 24 bytes
sphericalharmonicy

flag('(fibonacci fibonaccip),'opfn);nil
flag('(fibonacci),'integer);nil
defautoload(fibonacci,specfn);
+++ fibonacci compiled, 8 + 16 bytes
fibonacci
defautoload(fibonaccip,specfn,expr,2);
+++ fibonaccip compiled, 8 + 16 bytes
fibonaccip

flag('(motzkin),'opfn);nil
defautoload(motzkin,specfn);
+++ motzkin compiled, 8 + 16 bytes
motzkin

% specfn2 module entry points

defautoload_operator(hypergeometric,(specfn specfn2));(lambda (x) (
autoload_operator* (quote hypergeometric) (quote (specfn specfn2)) x))
defautoload_operator(MeijerG,(specfn specfn2));(lambda (x) (autoload_operator* (
quote meijerg) (quote (specfn specfn2)) x))

% Debug module entry points.

% if not(systemname!* eq 'ibm) then defautoload(embfn,debug,expr,3);


% Specfn entry points.

defautoload_operator(lambert_w,(specfn specbess));(lambda (x) (
autoload_operator* (quote lambert_w) (quote (specfn specbess)) x))

% Pgauss entry points

defautoload(pg_gauss!-sym, pgauss, expr, 2);
+++ pg_gauss!-sym compiled, 8 + 16 bytes
pg_gauss-sym

% Rltools entry points

symbolic operator meminfo;nil
defautoload(meminfo, rltools, expr, 0);
+++ meminfo compiled, 7 + 16 bytes
meminfo

defautoload(systo_datestamp, rltools, expr, 0);
+++ systo_datestamp compiled, 7 + 16 bytes
systo_datestamp
defautoload(systo_get!-resource!-directory, rltools, expr, 0);
+++ systo_get!-resource!-directory compiled, 7 + 16 bytes
systo_get-resource-directory
defautoload(systo_trunk, rltools, expr, 0);
+++ systo_trunk compiled, 7 + 16 bytes
systo_trunk

defautoload(ioto_cplu, rltools, expr, 2);
+++ ioto_cplu compiled, 8 + 16 bytes
ioto_cplu
defautoload(ioto_cterpri, rltools, expr, 0);
+++ ioto_cterpri compiled, 7 + 16 bytes
ioto_cterpri
defautoload(ioto_form2str, rltools, expr, 1);
+++ ioto_form2str compiled, 8 + 16 bytes
ioto_form2str
defautoload(ioto_prin2, rltools, expr, 1);
+++ ioto_prin2 compiled, 8 + 16 bytes
ioto_prin2
defautoload(ioto_prin2t, rltools, expr, 1);
+++ ioto_prin2t compiled, 8 + 16 bytes
ioto_prin2t
defautoload(ioto_realtime, rltools, expr, 0);
+++ ioto_realtime compiled, 7 + 16 bytes
ioto_realtime
defautoload(ioto_smaprin, rltools, expr, 1);
+++ ioto_smaprin compiled, 8 + 16 bytes
ioto_smaprin
defautoload(ioto_sxread, rltools, expr, 1);
+++ ioto_sxread compiled, 8 + 16 bytes
ioto_sxread
defautoload(ioto_tprin2, rltools, expr, 1);
+++ ioto_tprin2 compiled, 8 + 16 bytes
ioto_tprin2
defautoload(ioto_tprin2t, rltools, expr, 1);
+++ ioto_tprin2t compiled, 8 + 16 bytes
ioto_tprin2t

defautoload(lto_0listp, rltools, expr, 1);
+++ lto_0listp compiled, 8 + 16 bytes
lto_0listp
defautoload(lto_upcase, rltools, expr, 1);
+++ lto_upcase compiled, 8 + 16 bytes
lto_upcase
defautoload(lto_alinsert, rltools, expr, 3);
+++ lto_alinsert compiled, 10 + 16 bytes
lto_alinsert
defautoload(lto_almerge, rltools, expr, 2);
+++ lto_almerge compiled, 8 + 16 bytes
lto_almerge
defautoload(lto_alphap, rltools, expr, 1);
+++ lto_alphap compiled, 8 + 16 bytes
lto_alphap
defautoload(lto_alunion, rltools, expr, 1);
+++ lto_alunion compiled, 8 + 16 bytes
lto_alunion
defautoload(lto_appendn, rltools, expr, 1);
+++ lto_appendn compiled, 8 + 16 bytes
lto_appendn
defautoload(lto_apply2nthip, rltools, expr, 4);
+++ lto_apply2nthip compiled, 18 + 24 bytes
lto_apply2nthip
defautoload(lto_at2str, rltools, expr, 1);
+++ lto_at2str compiled, 8 + 16 bytes
lto_at2str
defautoload(lto_cartprod, rltools, expr, 1);
+++ lto_cartprod compiled, 8 + 16 bytes
lto_cartprod
defautoload(lto_cassoc, rltools, expr, 2);
+++ lto_cassoc compiled, 8 + 16 bytes
lto_cassoc
defautoload(lto_catsoc, rltools, expr, 2);
+++ lto_catsoc compiled, 8 + 16 bytes
lto_catsoc
defautoload(lto_delnthip, rltools, expr, 2);
+++ lto_delnthip compiled, 8 + 16 bytes
lto_delnthip
defautoload(lto_delq, rltools, expr, 2);
+++ lto_delq compiled, 8 + 16 bytes
lto_delq
defautoload(lto_delqip, rltools, expr, 2);
+++ lto_delqip compiled, 8 + 16 bytes
lto_delqip
defautoload(lto_downcase, rltools, expr, 1);
+++ lto_downcase compiled, 8 + 16 bytes
lto_downcase
defautoload(lto_drop, rltools, expr, 2);
+++ lto_drop compiled, 8 + 16 bytes
lto_drop
defautoload(lto_eatsoc, rltools, expr, 3);
+++ lto_eatsoc compiled, 10 + 16 bytes
lto_eatsoc
defautoload(lto_fastgensym, rltools, expr, 0);
+++ lto_fastgensym compiled, 7 + 16 bytes
lto_fastgensym
defautoload(lto_hinsert, rltools, expr, 3);
+++ lto_hinsert compiled, 10 + 16 bytes
lto_hinsert
defautoload(lto_hmember, rltools, expr, 3);
+++ lto_hmember compiled, 10 + 16 bytes
lto_hmember
defautoload(lto_idconcat, rltools, expr, 1);
+++ lto_idconcat compiled, 8 + 16 bytes
lto_idconcat
defautoload(lto_idconcat2, rltools, expr, 2);
+++ lto_idconcat2 compiled, 8 + 16 bytes
lto_idconcat2
defautoload(lto_init, rltools, expr, 1);
+++ lto_init compiled, 8 + 16 bytes
lto_init
defautoload(lto_insert, rltools, expr, 2);
+++ lto_insert compiled, 8 + 16 bytes
lto_insert
defautoload(lto_insertq, rltools, expr, 2);
+++ lto_insertq compiled, 8 + 16 bytes
lto_insertq
defautoload(lto_last, rltools, expr, 1);
+++ lto_last compiled, 8 + 16 bytes
lto_last
defautoload(lto_lengthp, rltools, expr, 3);
+++ lto_lengthp compiled, 10 + 16 bytes
lto_lengthp
defautoload(lto_list2set, rltools, expr, 1);
+++ lto_list2set compiled, 8 + 16 bytes
lto_list2set
defautoload(lto_list2vector, rltools, expr, 1);
+++ lto_list2vector compiled, 8 + 16 bytes
lto_list2vector
defautoload(lto_lpvarl, rltools, expr, 1);
+++ lto_lpvarl compiled, 8 + 16 bytes
lto_lpvarl
defautoload(lto_max, rltools, expr, 1);
+++ lto_max compiled, 8 + 16 bytes
lto_max
defautoload(lto_maxkl, rltools, expr, 1);
+++ lto_maxkl compiled, 8 + 16 bytes
lto_maxkl
defautoload(lto_mergesort, rltools, expr, 2);
+++ lto_mergesort compiled, 8 + 16 bytes
lto_mergesort
defautoload(lto_min, rltools, expr, 1);
+++ lto_min compiled, 8 + 16 bytes
lto_min
defautoload(lto_nconcn, rltools, expr, 1);
+++ lto_nconcn compiled, 8 + 16 bytes
lto_nconcn
defautoload(lto_partition, rltools, expr, 2);
+++ lto_partition compiled, 8 + 16 bytes
lto_partition
defautoload(lto_powerset, rltools, expr, 1);
+++ lto_powerset compiled, 8 + 16 bytes
lto_powerset
defautoload(lto_remove, rltools, expr, 2);
+++ lto_remove compiled, 8 + 16 bytes
lto_remove
defautoload(lto_rmpos, rltools, expr, 2);
+++ lto_rmpos compiled, 8 + 16 bytes
lto_rmpos
defautoload(lto_sconcat, rltools, expr, 1);
+++ lto_sconcat compiled, 8 + 16 bytes
lto_sconcat
defautoload(lto_sconcat2, rltools, expr, 2);
+++ lto_sconcat2 compiled, 8 + 16 bytes
lto_sconcat2
defautoload(lto_setequalq, rltools, expr, 2);
+++ lto_setequalq compiled, 8 + 16 bytes
lto_setequalq
defautoload(lto_setminus, rltools, expr, 2);
+++ lto_setminus compiled, 8 + 16 bytes
lto_setminus
defautoload(lto_sgnchg, rltools, expr, 1);
+++ lto_sgnchg compiled, 8 + 16 bytes
lto_sgnchg
defautoload(lto_string2id, rltools, expr, 1);
+++ lto_string2id compiled, 8 + 16 bytes
lto_string2id
defautoload(lto_stringdescriptionlist, rltools, expr, 5);
+++ lto_stringdescriptionlist compiled, 18 + 24 bytes
lto_stringdescriptionlist
defautoload(lto_stringparagraph, rltools, expr, 3);
+++ lto_stringparagraph compiled, 10 + 16 bytes
lto_stringparagraph
defautoload(lto_stringsplit, rltools, expr, 2);
+++ lto_stringsplit compiled, 8 + 16 bytes
lto_stringsplit
defautoload(lto_sublistp, rltools, expr, 2);
+++ lto_sublistp compiled, 8 + 16 bytes
lto_sublistp
defautoload(lto_subset, rltools, expr, 2);
+++ lto_subset compiled, 8 + 16 bytes
lto_subset
defautoload(lto_subsetq, rltools, expr, 2);
+++ lto_subsetq compiled, 8 + 16 bytes
lto_subsetq
defautoload(lto_unionn, rltools, expr, 1);
+++ lto_unionn compiled, 8 + 16 bytes
lto_unionn
defautoload(lto_zip, rltools, expr, 3);
+++ lto_zip compiled, 10 + 16 bytes
lto_zip

defautoload(sfto_allcoeffs, rltools, expr, 2);
+++ sfto_allcoeffs compiled, 8 + 16 bytes
sfto_allcoeffs
defautoload(sfto_avgq, rltools, expr, 2);
+++ sfto_avgq compiled, 8 + 16 bytes
sfto_avgq
defautoload(sfto_dcontentf, rltools, expr, 1);
+++ sfto_dcontentf compiled, 8 + 16 bytes
sfto_dcontentf
defautoload(sfto_decdegf, rltools, expr, 3);
+++ sfto_decdegf compiled, 10 + 16 bytes
sfto_decdegf
defautoload(sfto_dgcdf, rltools, expr, 2);
+++ sfto_dgcdf compiled, 8 + 16 bytes
sfto_dgcdf
defautoload(sfto_dprpartf, rltools, expr, 1);
+++ sfto_dprpartf compiled, 8 + 16 bytes
sfto_dprpartf
defautoload(sfto_dprpartksf, rltools, expr, 1);
+++ sfto_dprpartksf compiled, 8 + 16 bytes
sfto_dprpartksf
defautoload(sfto_exteucd, rltools, expr, 2);
+++ sfto_exteucd compiled, 8 + 16 bytes
sfto_exteucd
defautoload(sfto_fctrf, rltools, expr, 1);
+++ sfto_fctrf compiled, 8 + 16 bytes
sfto_fctrf
defautoload(sfto_floatsub, rltools, expr, 2);
+++ sfto_floatsub compiled, 8 + 16 bytes
sfto_floatsub
defautoload(sfto_fsub, rltools, expr, 2);
+++ sfto_fsub compiled, 8 + 16 bytes
sfto_fsub
defautoload(sfto_fsub1, rltools, expr, 2);
+++ sfto_fsub1 compiled, 8 + 16 bytes
sfto_fsub1
defautoload(sfto_gcdf!*, rltools, expr, 2);
+++ sfto_gcdf!* compiled, 8 + 16 bytes
sfto_gcdf*
defautoload(sfto_greaterq, rltools, expr, 2);
+++ sfto_greaterq compiled, 8 + 16 bytes
sfto_greaterq
defautoload(sfto_idvarf, rltools, expr, 1);
+++ sfto_idvarf compiled, 8 + 16 bytes
sfto_idvarf
defautoload(sfto_int2sf, rltools, expr, 1);
+++ sfto_int2sf compiled, 8 + 16 bytes
sfto_int2sf
defautoload(sfto_kernelp, rltools, expr, 1);
+++ sfto_kernelp compiled, 8 + 16 bytes
sfto_kernelp
defautoload(sfto_kmemberf, rltools, expr, 2);
+++ sfto_kmemberf compiled, 8 + 16 bytes
sfto_kmemberf
defautoload(sfto_lcmn, rltools, expr, 2);
+++ sfto_lcmn compiled, 8 + 16 bytes
sfto_lcmn
defautoload(sfto_lcx, rltools, expr, 1);
+++ sfto_lcx compiled, 8 + 16 bytes
sfto_lcx
defautoload(sfto_lessq, rltools, expr, 2);
+++ sfto_lessq compiled, 8 + 16 bytes
sfto_lessq
defautoload(sfto_linwpp, rltools, expr, 2);
+++ sfto_linwpp compiled, 8 + 16 bytes
sfto_linwpp
defautoload(sfto_lmq, rltools, expr, 1);
+++ sfto_lmq compiled, 8 + 16 bytes
sfto_lmq
defautoload(sfto_lmultf, rltools, expr, 1);
+++ sfto_lmultf compiled, 8 + 16 bytes
sfto_lmultf
defautoload(sfto_lreorder, rltools, expr, 2);
+++ sfto_lreorder compiled, 8 + 16 bytes
sfto_lreorder
defautoload(sfto_mkpowq, rltools, expr, 2);
+++ sfto_mkpowq compiled, 8 + 16 bytes
sfto_mkpowq
defautoload(sfto_monfp, rltools, expr, 1);
+++ sfto_monfp compiled, 8 + 16 bytes
sfto_monfp
defautoload(sfto_mvartest, rltools, expr, 2);
+++ sfto_mvartest compiled, 8 + 16 bytes
sfto_mvartest
defautoload(sfto_mvarx, rltools, expr, 1);
+++ sfto_mvarx compiled, 8 + 16 bytes
sfto_mvarx
defautoload(sfto_pdecf, rltools, expr, 1);
+++ sfto_pdecf compiled, 8 + 16 bytes
sfto_pdecf
defautoload(sfto_qsub, rltools, expr, 2);
+++ sfto_qsub compiled, 8 + 16 bytes
sfto_qsub
defautoload(sfto_qsub1, rltools, expr, 2);
+++ sfto_qsub1 compiled, 8 + 16 bytes
sfto_qsub1
defautoload(sfto_qsubhor, rltools, expr, 3);
+++ sfto_qsubhor compiled, 10 + 16 bytes
sfto_qsubhor
defautoload(sfto_qsubhor1, rltools, expr, 3);
+++ sfto_qsubhor1 compiled, 10 + 16 bytes
sfto_qsubhor1
defautoload(sfto_redx, rltools, expr, 1);
+++ sfto_redx compiled, 8 + 16 bytes
sfto_redx
defautoload(sfto_renamealf, rltools, expr, 2);
+++ sfto_renamealf compiled, 8 + 16 bytes
sfto_renamealf
defautoload(sfto_renamef, rltools, expr, 3);
+++ sfto_renamef compiled, 10 + 16 bytes
sfto_renamef
defautoload(sfto_reorder, rltools, expr, 2);
+++ sfto_reorder compiled, 8 + 16 bytes
sfto_reorder
defautoload(sfto_resf, rltools, expr, 3);
+++ sfto_resf compiled, 10 + 16 bytes
sfto_resf
defautoload(sfto_sf2int, rltools, expr, 1);
+++ sfto_sf2int compiled, 8 + 16 bytes
sfto_sf2int
defautoload(sfto_sf2monl, rltools, expr, 1);
+++ sfto_sf2monl compiled, 8 + 16 bytes
sfto_sf2monl
defautoload(sfto_sf2monlip, rltools, expr, 1);
+++ sfto_sf2monlip compiled, 8 + 16 bytes
sfto_sf2monlip
defautoload(sfto_sqfdecf, rltools, expr, 1);
+++ sfto_sqfdecf compiled, 8 + 16 bytes
sfto_sqfdecf
defautoload(sfto_sqfpartf, rltools, expr, 1);
+++ sfto_sqfpartf compiled, 8 + 16 bytes
sfto_sqfpartf
defautoload(sfto_sqfpartz, rltools, expr, 1);
+++ sfto_sqfpartz compiled, 8 + 16 bytes
sfto_sqfpartz
defautoload(sfto_sqrtf, rltools, expr, 1);
+++ sfto_sqrtf compiled, 8 + 16 bytes
sfto_sqrtf
defautoload(sfto_truncq, rltools, expr, 2);
+++ sfto_truncq compiled, 8 + 16 bytes
sfto_truncq
defautoload(sfto_tsqsumf, rltools, expr, 1);
+++ sfto_tsqsumf compiled, 8 + 16 bytes
sfto_tsqsumf
defautoload(sfto_ucontentf, rltools, expr, 1);
+++ sfto_ucontentf compiled, 8 + 16 bytes
sfto_ucontentf
defautoload(sfto_varisnump, rltools, expr, 1);
+++ sfto_varisnump compiled, 8 + 16 bytes
sfto_varisnump
defautoload(sfto_vardeg, rltools, expr, 2);
+++ sfto_vardeg compiled, 8 + 16 bytes
sfto_vardeg
defautoload(sfto_varf, rltools, expr, 1);
+++ sfto_varf compiled, 8 + 16 bytes
sfto_varf
defautoload(sfto_varp, rltools, expr, 1);
+++ sfto_varp compiled, 8 + 16 bytes
sfto_varp
defautoload(sfto_zdeqn, rltools, expr, 2);
+++ sfto_zdeqn compiled, 8 + 16 bytes
sfto_zdeqn

symbolic operator fastresultant;nil
defautoload(fastresultant, rltools, expr, 3);
+++ fastresultant compiled, 10 + 16 bytes
fastresultant

% Rlsupport entry points

defautoload(revision, rlsupport, expr, 2);
+++ revision compiled, 8 + 16 bytes
revision

defautoload(copyright, rlsupport, expr, 2);
+++ copyright compiled, 8 + 16 bytes
copyright

defautoload(rl_provideService, rlsupport, expr, 2);
+++ rl_provideservice compiled, 8 + 16 bytes
rl_provideservice

put('rl_type, 'stat, 'rl_typeStat);rl_typestat
defautoload(rl_typeStat, rlsupport, expr, 0);
+++ rl_typestat compiled, 7 + 16 bytes
rl_typestat

put('rl_builtin, 'stat, 'rl_builtinStat);rl_builtinstat
defautoload(rl_builtinStat, rlsupport, expr, 0);
+++ rl_builtinstat compiled, 7 + 16 bytes
rl_builtinstat

put('rl_service, 'stat, 'rl_serviceStat);rl_servicestat
defautoload(rl_serviceStat, rlsupport, expr, 0);
+++ rl_servicestat compiled, 7 + 16 bytes
rl_servicestat

put('rl_blackBox, 'formfn, 'rl_formBlackBox);rl_formblackbox
defautoload(rl_formBlackBox, rlsupport, expr, 3);
+++ rl_formblackbox compiled, 10 + 16 bytes
rl_formblackbox

defautoload(rl_servicewrapper, rlsupport, expr, 8);
+++ rl_servicewrapper compiled, 29 + 28 bytes
rl_servicewrapper

defautoload(rl_exception, rlsupport, expr, 1);
+++ rl_exception compiled, 8 + 16 bytes
rl_exception

defautoload(rl_exceptionp, rlsupport, expr, 1);
+++ rl_exceptionp compiled, 8 + 16 bytes
rl_exceptionp

defautoload(rl_exc, rlsupport, expr, 1);
+++ rl_exc compiled, 8 + 16 bytes
rl_exc

defautoload(rl_excp, rlsupport, expr, 1);
+++ rl_excp compiled, 8 + 16 bytes
rl_excp

% Redlog entry points

put('rlset, 'psopfn, 'rl_set!$);rl_set$
defautoload(rl_set!$, redlog, expr, 1);
+++ rl_set!$ compiled, 8 + 16 bytes
rl_set$

defautoload(rl_set, redlog, expr, 1);
+++ rl_set compiled, 8 + 16 bytes
rl_set

defautoload(rl_copyc, redlog, expr, 2);
+++ rl_copyc compiled, 8 + 16 bytes
rl_copyc

% Qhull e
+++ Garbage collection 3 (internal cons) after 28.55+0.28 seconds
At gc end about 24.0 Mbytes of 112.0 (21.4%) of heap is in use
ntry point

symbolic operator qhull;nil
defautoload(qhull, qhull, expr, 1);
+++ qhull compiled, 8 + 16 bytes
qhull

defautoload(qhull_qhull, qhull, expr, 1);
+++ qhull_qhull compiled, 8 + 16 bytes
qhull_qhull

% Gurobi entry points

defautoload(gurobi_newmodel, gurobi, expr, 2);
+++ gurobi_newmodel compiled, 8 + 16 bytes
gurobi_newmodel

% Crack, Applysym & Liepde

defautoload(backup_reduce_flags, crack, expr, 0);
+++ backup_reduce_flags compiled, 7 + 16 bytes
backup_reduce_flags
symbolic operator setcrackflags;nil
defautoload(setcrackflags, crack, expr, 0);
+++ setcrackflags compiled, 7 + 16 bytes
setcrackflags
defautoload(liepde, liepde, expr, 4);
+++ liepde compiled, 18 + 24 bytes
liepde
defautoload(einfachst, applysym, expr, 2);
+++ einfachst compiled, 8 + 16 bytes
einfachst

% Assert

fluid '(!*assert assert_functionl!*);nil

switch assert;nil

put('assert, 'simpfg, '((t (assert_onoff)) (nil (assert_onoff))));((t (
assert_onoff)) (nil (assert_onoff)))
defautoload(assert_onoff, assert, expr, 0);
+++ assert_onoff compiled, 7 + 16 bytes
assert_onoff

defautoload(assert_declarestat, assert, expr, 0);
+++ assert_declarestat compiled, 7 + 16 bytes
assert_declarestat
put('declare, 'stat, 'assert_declarestat);assert_declarestat

defautoload(assert_structstat, assert, expr, 0);
+++ assert_structstat compiled, 7 + 16 bytes
assert_structstat
put('struct,'stat,'assert_structstat);assert_structstat

defautoload(assert_procstat, assert, expr, 0);
+++ assert_procstat compiled, 7 + 16 bytes
assert_procstat
put('asserted, 'stat, 'assert_procstat);assert_procstat

defautoload(assert_install, assert, expr, 1);
+++ assert_install compiled, 8 + 16 bytes
assert_install
put('assert_install, 'stat, 'rlis);rlis

defautoload(assert_uninstall, assert, expr, 1);
+++ assert_uninstall compiled, 8 + 16 bytes
assert_uninstall
put('assert_uninstall, 'stat, 'rlis);rlis

operator assert_install_all;nil
defautoload(assert_install_all, assert, expr, 0);
+++ assert_install_all compiled, 7 + 16 bytes
assert_install_all

operator assert_uninstall_all;nil
defautoload(assert_uninstall_all, assert, expr, 0);
+++ assert_uninstall_all compiled, 7 + 16 bytes
assert_uninstall_all

% LALR

defautoload(lex_cleanup, lalr, expr, 0);
+++ lex_cleanup compiled, 7 + 16 bytes
lex_cleanup
defautoload(lalr_construct_parser, lalr, expr, 2);
+++ lalr_construct_parser compiled, 8 + 16 bytes
lalr_construct_parser
defautoload(yyparse, lalr, expr, 1);
+++ yyparse compiled, 8 + 16 bytes
yyparse

% Ranum

switch ranum;nil
put('ranum,'simpfg,'((t (load!-package 'ranum) (setdmode (quote ranum) t))));((t
(load-package (quote ranum)) (setdmode (quote ranum) t)))

defautoload(ra_x, ranum, expr, 0);
+++ ra_x compiled, 7 + 16 bytes
ra_x
defautoload(ra_y, ranum, expr, 0);
+++ ra_y compiled, 7 + 16 bytes
ra_y

% Smt
operator smt;nil
defautoload(smt, smt, expr, 0);
+++ smt compiled, 7 + 16 bytes
smt

operator smt_mainloop;nil
defautoload(smt_mainloop, smt, expr, 0);
+++ smt_mainloop compiled, 7 + 16 bytes
smt_mainloop

% mrvlimit
symbolic operator mrv_limit;nil
defautoload(mrv_limit, mrvlimit, expr, 3);
+++ mrv_limit compiled, 10 + 16 bytes
mrv_limit

endmodule;nil

end;nil
nil


(load!-package!-sources 'remake 'support)module remake;nil % Update the fasl loading version and cross-reference of
               % a given file.

% Authors: Martin L. Griss and Anthony C. Hearn.
% Modified by ACN for the Sourceforge version...

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the relevant copyright
%      notice, this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR
% CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%


fluid '(!*argnochk
        !*break
        !*cref
        !*crefchk
        !*faslp
        !*forcecompile
        !*int
        !*loadall
        !*usermode
        !*writingfaslfile
        lispsystem!*);nil

global '(nolist!* loaded!-modules!*);nil

symbolic procedure psl!-file!-write!-date u;
   % Returns write date of file u as an integer.
   (if null x then rederr list("file not found:",u)
    else cddr assoc('writetime,x))
   where x = filestatus(u,nil);
+++ psl!-file!-write!-date compiled, 17 + 24 bytes
psl-file-write-date

symbolic procedure olderfaslp(u,v);
   if 'psl memq lispsystem!*
     then null filep u
        or psl!-file!-write!-date u < psl!-file!-write!-date v
    else if null filedate v then rederr list("Missing file",v)
    else null modulep u or datelessp(modulep u,filedate v);
+++ olderfaslp compiled, 53 + 48 bytes
olderfaslp

% Code for updating cross reference information.

nolist!* := append('(module endmodule),nolist!*);(module endmodule)

% +++++ The cross-referencing capability probably no longer works.

symbolic procedure update!-cref x;
   % Updates cross-reference for x (module . path).
   begin scalar y,z;
      y := concat2("$rcref/",concat2(mkfil car x,".crf"));
      z := module2!-to!-file(car x,get(cdr x,'path));
      if olderfaslp(y,z) or !*forcecompile
        then <<terpri();
               terpri();
               if errorp errorset!*(list('upd!-cref1,mkquote car x,
                                                   mkquote z,mkquote y),
                                  t)
                 then lprie list("Error during cref of",x)>>
%                then errorprintf("***** Error during cref of %w%n",x)>>
   end;
+++ update!-cref compiled, 67 + 76 bytes
update-cref

symbolic procedure upd!-cref1(u,v,w);
   begin scalar !*break,!*cref,!*int,!*usermode,ochan,oldochan,oldll;
      lprim list("Cross referencing",u,"...");
%     prin2t bldmsg("*** Cross referencing %w ...",u);
      ochan := open(w,'output);
      oldochan := wrs ochan;
      oldll := linelength 75;
      crefon();   % this is entry point to cref routines
      !*cref := t;
      infile v;
      !*cref := nil;
      crefoff();
      close ochan;
      wrs oldochan;
      linelength oldll
   end;
+++ upd!-cref1 compiled, 63 + 68 bytes
upd-cref1


% Support for packages directory.

symbolic procedure package!-remake x;
   (if y then package!-remake2(x,y) else package!-remake2(x,x))
   where y=get(x,'folder);
+++ package!-remake redefined
+++ package!-remake compiled, 13 + 16 bytes
package-remake

fluid '(new_inline_definitions);nil

new_inline_definitions := nil;nil

% If anybody wanted to support true parallel recompilation of Reduce
% packages than in addition to any other adjustments it would be
% important to make the following procedures atomic.

% Here I indicate where the file listing inline-definitions will live...
% Note that it is in different places for different flavours of Lisp. For
% CSL it is in the generated-c directory because several different variant
% builds may wish to share it.

symbolic procedure inline_defs_file();
% The PSL bootstrap build needs the "!" here
!#if (memq 'vsl lispsystem!*)
   "inline-defs.dat";
!#elif (memq 'csl lispsystem!*)
   "$reduce/cslbuild/generated-c/inline-defs.dat";
+++ inline_defs_file compiled, 2 + 12 bytes
inline_defs_file
!#else
   "$fasl/inline-defs.dat";
!#endif

symbolic procedure load_saved_inlines();
  begin
    scalar ff, u, v;
%
% There is another bit of fun here. I would like to be able to call
% module!-rebuild at any time, and that means that the current directory
% is uncertain when that happens. So with CSL I arrange that I always keep
% my "inline-defs.dat" file in the directory where generated C lives.
% For PSL I put things where fasl files go.
%
    ff := inline_defs_file();
    if not filep ff then return nil;
    ff := open(ff, 'input);
    if null ff then return nil;
    u := rds ff;
    v := read();
    if atom v then v := nil; % E.g. if v = !$eof!$
    rds u;
    close ff;
    for each a in v do put(car a, 'inline, cdr a);
    return nil
  end;
+++ load_saved_inlines compiled, 53 + 32 bytes
load_saved_inlines

% There is an ISSUE here. If a version of the souce code introduced an
% inline definition for a function (say FFF) then that definition gets lifted
% out and saved in inline-defs.dat. If the inline definition for FFF is
% changed then the new definition will eventually end up in inline-defs.dat.
% However if the inline definition is removed from the source files a version
% can persist in inline-defs.dat with no mechanical scheme to get rid of it.
% At present my stance is that anybody who changes what functions are tagged
% inline has a responsibility to do a "make clean" and in due course I will
% cause that to remove the cached definitions...

symbolic procedure save_inlines();
  begin
    scalar fname, ff, u, v, w, changed;
% If there are no new inline definition at all from this compilation or
% if new ones match what was already present then I will not want to update
% the file where definitions are saved. Then I can use a dependency on it
% in a Makefile to help me ensure I recompile enough times to get to a fully
% stable state.
    if null new_inline_definitions then <<
      lprim "No new inline definitions here";
      return nil>>;
    fname := inline_defs_file();
    if filep fname then <<
      ff := open(fname, 'input);
      if null ff then return nil; % Failed! Note filep had said it was there.
      u := rds ff;
      v := read();
      if atom v then v := nil;
      rds u;
      close ff >>
    else v := nil; % if "inline-defs.dat" does not exist at all treat it
                   % as if empty.
% Ok I have now read the current set of inline definitions. I had read it once
% at the start of rebuilding the current package, but I read it again
% here in case anybody has updated it since I started to rebuild this package.
    changed := nil;
    for each a in new_inline_definitions do <<
      w := assoc(car a, v);
      if not w then <<
        if posn() neq 0 then terpri();
        princ "+++ new inline definition for ";
        prin1 car a >>;
      if w and not (w = a) then <<
        if posn() neq 0 then terpri();
        princ "+++ inline definition for ";
        prin1 car a;
        printc " differs from previous version - please recompile everything";
        v := delasc(car a, v);
        w := nil >>; % Setting w to nil here discards the previous version
      if not w then << % If there was no previous version then I need to record
        v := a . v;
        changed := t >> >>;
    if changed then <<
      lprim "Need to rewrite inline-defs.dat file";
      ff := open(fname, 'output);
      if null ff then return nil; % Failed!
      u := wrs ff;
      prin2 "(";
      terpri();
      for each x in v do << print x; terpri() >>;
      prin2 ")";
      terpri();
      wrs u;
      close ff >>;
    return nil
  end;
+++ save_inlines compiled, 179 + 84 bytes
save_inlines

symbolic procedure package!-remake2(u,v);
   begin scalar y;
%     if !*crefchk then update!-cref2(u . v);
      load_saved_inlines();
      new_inline_definitions := nil;
      update!-fasl2(u . v);
      evload list u;
      loaded!-modules!* := union(loaded!-modules!*, list u);
      y := get(u,'package);
      if y then y := cdr y;
      for each j in y do
         <<update!-fasl2(j . v);
%          if !*crefchk then update!-cref2(j . v)>>
         >>;
      save_inlines();
   end;
+++ package!-remake2 compiled, 50 + 40 bytes
package-remake2

symbolic procedure update!-fasl2 x;
   begin scalar y,z;
      if 'psl memq lispsystem!*
        then y := concat2("$fasl/", concat2(mkfil car x, ".b"))
       else y := car x;
      z := module2!-to!-file(car x,cdr x);
      if olderfaslp(y,z) or !*forcecompile
        then <<terpri();
               terpri();
               if errorp errorset!*(list('upd!-fasl1,mkquote car x,
                                                   mkquote z,
                                                   mkquote cdr x),
                                  t)
                 then <<if !*writingfaslfile then lispeval '(faslend);
                        lprie list("Error during mkfasl of",x)>>>>
   end;
+++ update!-fasl2 compiled, 81 + 92 bytes
update-fasl2

symbolic procedure upd!-fasl1(u,v,w);
   % We rebind *fastfor here because it's the only case of "compiletime"
   % at the moment (!).
   begin scalar !*fastfor,!*lower,!*usermode,!*quiet_faslout,!*break,x;
      !*faslp := t;
      !*quiet_faslout := t;
      if not('psl memq lispsystem!*) then !*lower := t;
      if !*loadall and w neq u then <<
         evload list w;
         loaded!-modules!* := union(loaded!-modules!*, list w) >>;
      if x := get(u,'compiletime)
        then <<prin2 "*** Compile time: "; prin2t x; lispeval x>>;
      u := mkfil u;
      lprim list("Compiling",u,"...");
%     prin2t bldmsg("*** Compiling %w ...",u);
      terpri();
      if 'psl memq lispsystem!*
        then lispeval list('faslout, concat2("$fasl/",u))
       else lispeval list('faslout,u);
      infile v;
      lispeval '(faslend)
   end;
+++ upd!-fasl1 compiled, 124 + 116 bytes
upd-fasl1

symbolic procedure module2!-to!-file(u,v);
   % Converts the module u in package directory v to a fully rooted file
   % name.
   if memq('vsl, lispsystem!*) then
     concat2("../packages/",concat2(mkfil v,
            concat2("/",concat2(mkfil u,".red"))))
   else
     concat2("$reduce/packages/",concat2(mkfil v,
            concat2("/",concat2(mkfil u,".red"))));
+++ module2!-to!-file redefined
+++ module2!-to!-file compiled, 50 + 40 bytes
module2-to-file

endmodule;nil

end;nil
nil


(setq !*comp nil)
nil


(begin)

symbolic;

nil


!#if (and (or (boundp 'force_c_code) (not (memq 'embedded lispsystem!*)))
          (not !*savedef))

faslout 'user;

FASLOUT (user): IN files;  or type in expressions
When all done, execute FASLEND;


%
% The "user" module is only useful when building a full system, since
% in the bootstrap the files u01.lsp to u60.lsp will probably not exist
% and it is CERTAIN that they are not useful.
%

if modulep 'cslcompat then load!-module 'cslcompat;

!#if (not (memq 'jlisp lispsystem!*))
% Note that Jlisp will use a different scheme to get the literal-vectors
% of translated functions installed.

symbolic procedure c!:install(name, env, c!-version, !&optional, c1);
  begin
    scalar v, n;
    if c1 then return check!-c!-code(name, env, c!-version, c1);
    put(name, 'c!-version, c!-version);
    if null env then return name;
    v := mkvect sub1 length env;
    n := 0;
    while env do <<
      putv(v, n, car env);
      n := n + 1;
      env := cdr env >>;
% I only instate the environment if there is nothing useful there at
% present. This is a rather dubious test!
    if symbol!-env name = nil or
       symbol!-env name = name then symbol!-set!-env(name, v);
    put(name, 'funarg, v);
    return name;
  end;
*** local variable &optional in procedure c:install not used 
+++ c!:install compiled, 75 + 28 bytes




for each name in '(
   "u01.lsp"   "u02.lsp"   "u03.lsp"   "u04.lsp"   "u05.lsp"
   "u06.lsp"   "u07.lsp"   "u08.lsp"   "u09.lsp"   "u10.lsp"
   "u11.lsp"   "u12.lsp"   "u13.lsp"   "u14.lsp"   "u15.lsp"
   "u16.lsp"   "u17.lsp"   "u18.lsp"   "u19.lsp"   "u20.lsp"
   "u21.lsp"   "u22.lsp"   "u23.lsp"   "u24.lsp"   "u25.lsp"
   "u26.lsp"   "u27.lsp"   "u28.lsp"   "u29.lsp"   "u30.lsp"
   "u31.lsp"   "u32.lsp"   "u33.lsp"   "u34.lsp"   "u35.lsp"
   "u36.lsp"   "u37.lsp"   "u38.lsp"   "u39.lsp"   "u40.lsp"
   "u41.lsp"   "u42.lsp"   "u43.lsp"   "u44.lsp"   "u45.lsp"
   "u46.lsp"   "u47.lsp"   "u48.lsp"   "u49.lsp"   "u50.lsp"
   "u51.lsp"   "u52.lsp"   "u53.lsp"   "u54.lsp"   "u55.lsp"
   "u56.lsp"   "u57.lsp"   "u58.lsp"   "u59.lsp"   "u60.lsp") do <<
   if memq('embedded, lispsystem!*) or
      not memq('generic, lispsystem!*) then
      name := compress('!" .
                 append(explodec "$reduce/cslbuild/generated-c/",
                        cdr explode name));
   rdf name >>;

!#endif  % jlisp

if modulep 'smacros then load!-module 'smacros;

faslend;Completed FASL files for user

nil

!#endif  % embedded

faslout 'remake;

FASLOUT (remake): IN files;  or type in expressions
When all done, execute FASLEND;


!#if (and (or (boundp 'force_c_code) (not (memq 'embedded lispsystem!*)))
          (not !*savedef))

load!-module "user";

!#endif % embedded

in "$reduce/packages/support/remake.red"$
+++ psl!-file!-write!-date compiled, 17 + 24 bytes
+++ olderfaslp compiled, 53 + 48 bytes
+++ update!-cref compiled, 67 + 76 bytes
+++ upd!-cref1 compiled, 63 + 68 bytes
+++ package!-remake compiled, 13 + 16 bytes
+++ inline_defs_file compiled, 2 + 12 bytes
+++ load_saved_inlines compiled, 53 + 32 bytes
+++ save_inlines compiled, 179 + 84 bytes
+++ package!-remake2 compiled, 50 + 40 bytes
+++ update!-fasl2 compiled, 81 + 92 bytes
+++ upd!-fasl1 compiled, 124 + 116 bytes
+++ module2!-to!-file compiled, 50 + 40 bytes


global '(reduce_base_modules reduce_extra_modules
         reduce_test_cases reduce_regression_tests
         !*reduce!-packages!*);

symbolic procedure get_configuration_data();
% Read data from a configuration file that lists the modules that must
% be processed.  NOTE that this and the next few funtions will ONLY
% work properly if REDUCE had been started up with the correct
% working directory. This is (just about) acceptable because these are
% system maintainance functions rather than generally flexible things
% for arbitrary use.
  begin
    scalar i, w, e, r, r1;
% Configuration information is held in a file called something like
% "package.map".
    if boundp 'minireduce and symbol!-value 'minireduce then
         i := "package.map"
    else i := "$reduce/packages/package.map";
    i := open(i, 'input);
    i := rds i;
    e := !*echo;
    !*echo := nil;
    w := read();
    !*echo := e;
    i := rds i;
    close i;
    reduce_base_modules :=
      for each x in w conc
         if member('core, cddr x) and
            member('csl, cddr x) then list car x else nil;
    reduce_extra_modules :=
      for each x in w conc
         if not member('core, cddr x) and
            member('csl, cddr x) then list car x else nil;
    reduce_test_cases :=
      for each x in w conc
         if member('test, cddr x) and
            member('csl, cddr x) then list car x else nil;
% Any file with a name *.tst in the regressions directory will be
% considered to be a test case in addition to ones explicitly shown
% in package.map.
    reduce_regression_tests := nil;
% The embedded build may not support the list!-directory function and so
% I arrange that if it fails I just omit being aware of the regression
% test scripts. Soon the embedded system (built ising C++17) will in fact
% support this!
    r := errorset(list('list!-directory, "$reduce/packages/regressions"),
                  nil, nil);
    if atom r then r :=nil else r := car r;
    for each f in r do <<
      r1 := reverse explodec f;
      if eqcar(r1, 't) and
         eqcar(cdr r1, 's) and
         eqcar(cddr r1, 't) and
         eqcar(cdddr r1, '!.) then <<
            r1 := intern list!-to!-string reverse cddddr r1;
            put(r1, 'folder, "regressions");
            reduce_regression_tests :=
               r1 . reduce_regression_tests >> >>;
% I will run the "alg" test twice! This is for the benefit of Java where the
% first time will be seriously slowed down by the need to JIT almost
% everything.
    reduce_test_cases := 'alg . append(reduce_test_cases, reduce_regression_tests);
    for each x in w do
       if member('csl, cddr x) then put(car x, 'folder, cadr x);
%   princ "reduce_base_modules: "; print reduce_base_modules;
%   princ "reduce_extra_modules: "; print reduce_extra_modules;
%   princ "reduce_test_cases: "; print reduce_test_cases;
%   princ "reduce_regression_tests: "; print reduce_regression_tests;
    !*reduce!-packages!* := append(reduce_base_modules, reduce_extra_modules);
    return;
  end;
+++ get_configuration_data compiled, 420 + 108 bytes


symbolic procedure build_reduce_modules names;
  begin
    scalar w;
    if boundp 'interpreted and interpreted then !*nocompile := t;
    !*comp := null !*nocompile;

!#if !*savedef
    !*savedef := t;
!#else
    !*savedef := nil;
!#endif
!#if !*noinlines
    !*noinlines := t;
!#else
    !*noinlines := nil;
!#endif
    make!-special '!*native_code;
    !*native_code := nil;
    get_configuration_data();
    if !*backtrace then !*echo := t;  % To help with debugging...
    w := explodec car names;
    if !*savedef then w := append(explodec "[Bootstrap] ", w);
    window!-heading list!-to!-string w;
!#if !*savedef
% When building the bootstrap version I want to record what switches
% get declared...
    if not getd 'original!-switch then <<
       w := getd 'switch;
       putd('original!-switch, car w, cdr w);
       putd('switch, 'expr,
          '(lambda (x)
              (dolist (y x) (princ "+++ Declaring a switch: ") (print y))
              (original!-switch x))) >>;
!#endif
    package!-remake car names;
    if null (names := cdr names) then <<
        printc "Recompilation complete";
        window!-heading  "Recompilation complete" >>;
!#if (or !*savedef
         (and (not (boundp 'force_c_code)) (memq 'embedded lispsystem!*)))
    if null names then restart!-csl 'begin
    else restart!-csl('(remake build_reduce_modules), names)
!#else
    if null names then restart!-csl '(user begin)
    else restart!-csl('(remake build_reduce_modules), names)
!#endif
  end;
*** nonlocal use of undeclared variable interpreted in procedure 
build_reduce_modules 
+++ interpreted declared fluid
+++ build_reduce_modules compiled, 80 + 80 bytes


fluid '(cpulimit conslimit testdirectory);

symbolic procedure test_a_package names;
  begin
    scalar packge, logname, logtmp, logfile;
    scalar quitfn, oll, rr, !*redefmsg, !*redeflg!*, walltime, w;
    if not boundp 'cpulimit or
       not fixp (cpulimit := compress explodec cpulimit) or
       cpulimit < 1 then
       cpulimit := if memq('jlisp, lispsystem!*) then 6000 else 360;
    if not boundp 'conslimit or
       not fixp (conslimit := compress explodec conslimit) or
       conslimit < 1 then
       conslimit := 2000;
    princ "TESTING: "; printc car names;
    window!-heading list!-to!-string append(explodec "[Testing] ",
                                            explodec car names);
    !*backtrace := nil;
    !*errcont := t;
    !*extraecho := t;    % Ensure standard environment for the test...
    !*int := nil;        % ... so that results are predictable.
    packge := car names;
    verbos nil;
% Normally logs from testing go in testlogs/name.rlg, however you may
% may sometimes want to put them somewhere else. If you do then launch reduce
% along the lines
%    reduce -D@log="mylogs" ...
% and ensure that <top>/mylogs exists.
    if boundp '!@log and stringp symbol!-value '!@log then
        logname := symbol!-value '!@log
    else logname := "testlogs";
    logname := concat(logname, "/");
    logtmp  := concat(logname, concat(car names, ".tmp"));
    logname := concat(logname, concat(car names,".rlg"));
    logfile := open(logtmp, 'output);
    get_configuration_data();
% Any messages generated while loading the package do NOT appear in the log
    if not memq(packge, reduce_regression_tests) then load!-package packge;
    begin
       scalar !*terminal!-io!*, !*standard!-output!*, !*error!-output!*,
              !*trace!-output!*, !*debug!-io!*, !*query!-io!*, !*errcont,
              outputhandler!*;
       !*terminal!-io!* := !*standard!-output!* := !*error!-output!* := logfile;
       !*trace!-output!* := !*debug!-io!* := !*query!-io!* := logfile;
       oll := linelength 80;
%      princ date(); princ " run on "; printc cdr assoc('name, lispsystem!*);
       if get(packge,'folder) then packge := get(packge,'folder);
       testdirectory := concat("$reduce/packages/", packge);
       packge := concat("$reduce/packages/",
                   concat(packge,
                     concat("/",
                       concat(car names,".tst"))));
       quitfn := getd 'quit;
% At least at one stage at least one test file ends in "quit;" rather than
% "end;" and the normal effect would be that this leads it to cancel
% all execution instantly. To avoid that I will undefine the function
% "quit", but restore it after the test. I reset !*redefmsg to avoid getting
% messages about this. I redefined quit to something (specifically "posn")
% that does not need an argument and that is "harmless".
       remd 'quit;
       putd('quit, 'expr, 'posn);
       !*mode := 'algebraic;
       !*extraecho := t;    % Ensure standard environment for the test...
       !*int := nil;        % ... so that results are predictable.
       !*errcont := t;
% resource!-limit is a special feature in CSL so that potentially wild
% code can be run with it being stopped harshly if it gets stuck.
% The first argument is an expression to evaluate. The next 4 are
%    a time limit, in seconds
%    a "cons" limit, in megaconses
%    a limit on the number of thousands of I/O bytes that can be
%            performed, with both reading and printing counted
%    a limit on the number of Lisp-level errors that can be raised.
%            note that that can be large if errorset is used to trap them.
%
% If a limit is specified as a negative value (typically -1) then that
% resource is not applied.
% The first 3 limits are applied in an APPROXIMATE way, and the first
% is seriously sensitive the the speed of the computer you are running
% on, so should be used with real care. At the end the return value
% is atomic if a limit expired, otherwise ncons of the regular value.
% A global variable *resources* should end up a list of 4 values
% showing the usage in each category.

% The settings here are intended to be fairly conservative...
%  Time:   On an Intel Q6600 CPU the longest test runs in under 20 seconds,
%          so allowing 3 minutes gives almost a factor of 10 slack. If
%          many people are running slow(ish) machines still I can increase
%          the limit.
%  Space:  The amount of space used ought to be pretty independent of
%          the computer used. Measuring on 32 and 64-bit systems will
%          give minor differences. But the limit given here seems to allow
%          all the current tests to run with a factor of 2 headroom
%          in case the test-scripts are updated.
%  IO:     The "crack" package has code in it that checkpoints its state
%          to disc periodically, and tests that activate that use amazingly
%          more IO than the others. The limit at 10 Mbytes suits the
%          relevant current tests. If a broken package leads to a test
%          script looping this then means that the resulting log file is no
%          larger than (about) 10 Mbytes, which is ugly but managable.
%  Errors: Some REDUCE packages make extensive use of errorset and
%          predictable use of "error" (for lack of use of catch and throw,
%          usually). So I do not constrain errors here. But if things were
%          ever such that no errors were expected I could enforce that
%          condition here.
       walltime := timeofday();
       eval '(resettime1);
       rr := resource!-limit(list('in_list1, mkquote packge, t),
                             cpulimit, % CPU time per test
                             conslimit,  % megaconses
                             10000,% allow ten megabytes of I/O
                             -1);  % Do not limit Lisp-level errors at all
       erfg!* := nil;
       terpri();
       princ "Tested on ";
       princ cdr assoc('platform, lispsystem!*);
       princ " CSL";
       eval '(showtime1 nil);
       w := timeofday();
       walltime := (car w - car walltime) . (cdr w - cdr walltime);
       w := cdr walltime;
       walltime := car walltime;
       if w < 0 then << walltime := walltime - 1; w := w + 1000000 >>;
       princ "real	";
       princ (walltime/60);
       princ "m";
       princ remainder(walltime, 60);
       princ ".";
% This illustrates that I need a proper general formatted print mechanism!
       w := (w + 500)/1000;
       if w < 10 then princ "00"
       else if w < 100 then princ "0";
       princ w;
       printc "s";
       erfg!* := nil;
       putd('quit, car quitfn, cdr quitfn);
       if atom rr then printc "+++++ Error: Resource limit exceeded";
       linelength oll
    end;
    close logfile;
    delete!-file logname;
    rename!-file(logtmp, logname);
    names := cdr names;
    if null names then <<
        printc "Testing complete";
        window!-heading "Testing complete";
        restart!-csl t >>
    else restart!-csl('(remake test_a_package), names)
  end;
+++ test_a_package compiled, 573 + 336 bytes


symbolic procedure profile_compare_fn(p, q);
  begin
    scalar a, b;
    a := (float caddr p/float cadr p);
    b := (float caddr q/float cadr q);
    if a < b then return t
    else if a > b then return nil
    else return ordp(p, q)   % Use alpha ordering on function
                             % if counts match exactly.
  end;
+++ profile_compare_fn compiled, 41 + 16 bytes


%
% This function runs a test file and sorts out what the top 350
% functions in it. It appends their names to "profile.dat".
%

symbolic procedure profile_a_package names;
  begin
    scalar packge, oll, w, w1, w2, quitfn, !*errcont, rr;
    if not boundp 'cpulimit or
       not fixp (cpulimit := compress explodec cpulimit) or
       cpulimit < 1 then
       cpulimit := if memq('jlisp, lispsystem!*) then 5000 else 180;
    if not boundp 'conslimit or
       not fixp (conslimit := compress explodec conslimit) or
       conslimit < 1 then
       conslimit := 2000;
    princ "PROFILING: "; print car names;
    !*backtrace := nil;
    !*errcont := t;
    !*int := nil;
    packge := car names;
    verbos nil;
    get_configuration_data();
    if not memq(packge, reduce_regression_tests) then <<
       load!-package packge;
       if get(packge,'folder) then packge := get(packge,'folder);
       testdirectory := concat("$reduce/packages/", packge);
       packge := concat("$reduce/packages/",
                   concat(packge,
                     concat("/",
                       concat(car names,".tst"))));
       oll := linelength 80;
       !*mode := 'algebraic;
       window!-heading list!-to!-string append(explodec "[Profile] ",
                                               explodec car names);
       quitfn := getd 'quit;
       remd 'quit;
       putd('quit, 'expr, 'posn);
       mapstore 4;  % reset counts;
       !*errcont := t;
% I try hard to arrange that even if the test fails I can continue and that
% input & output file selection is not messed up for me.
       w := wrs nil;   w1 := rds nil;
       wrs w;          rds w1;
       rr := resource!-limit(list('errorset,
                                  mkquote list('in_list1, mkquote packge, t),
                                  nil, nil),
                             cpulimit,
                             conslimit,
                             10000,% allow ten megabytes of I/O
                             -1);  % Do not limit Lisp-level errors at all
       wrs w;          rds w1;
       erfg!* := nil;
       terpri();
       putd('quit, car quitfn, cdr quitfn);
       w := sort(mapstore 2, function profile_compare_fn);
       begin
          scalar oo;
          oo := wrs open("buildlogs/flaguse.log", 'append);
          bytecounts t;
          close wrs oo;
       end;
       load!-source(); % Need source versions of all code here
       w1 := nil;
       while w do <<
           w2 := get(caar w, '!*savedef);
           if eqcar(w2, 'lambda) then w1 := (caar w . md60 (caar w . cdr w2) .
                                             cadar w . caddar w) . w1;
           w := cdr w >>;
       w := w1;
       % I collect the top 350 functions as used by each test, not because all
       % that many will be wanted but because I might as well record plenty
       % of information here and discard unwanted parts later on.
       for i := 1:349 do if w1 then w1 := cdr w1;
       if w1 then rplacd(w1, nil);
       % princ "MODULE "; prin car names; princ " suggests ";
       % print for each z in w collect car z;
       w1 := open("profile.dat", 'append);
       w1 := wrs w1;
       linelength 80;
       if atom rr then printc "% +++++ Error: Resource limit exceeded";
       princ "% @@@@@ Resources used: "; print !*resources!*;
       princ "("; prin car names; terpri();
       for each n in w do <<
           princ "  ("; prin car n; princ " ";
           if posn() > 30 then << terpri(); ttab 30 >>;
           prin cadr n;
           % I also display the counts just to help me debug & for interest.
           princ " "; prin caddr n; princ " "; princ cdddr n;
           printc ")" >>;
       printc "  )";
       terpri();
       close wrs w1;
       linelength oll >>;
    names := cdr names;
    if null names then <<
        w1 := open("buildlogs/flaguse.log", 'input);
        w1 := rds w1;
        w := nil;
        while (w2 := read()) neq !$eof!$ do
            w := sort(w2, 'orderp) . w;
        close rds w1;
        rr := '((symbol!-make!-fastget 'lose 1)
                (symbol!-make!-fastget 'noncom 0));
        flag('(lose noncom), 'processed);
        oll := 2;
        while w do <<
           w1 := nil;
           for each x in w do <<
               if x and
                  not flagp(cadar x, 'processed) and
                  oll < 63 then <<
                   rr :=
                       list('symbol!-make!-fastget, mkquote cadar x, oll) . rr;
                   flag(list cadar x, 'processed);
                   oll := oll + 1 >>;
               if cdr x then w1 := cdr x . w1 >>;
           w := reverse w1 >>;
        w := open("buildlogs/fastgets.lsp", 'output);
        w := wrs w;
        printc "% fastgets.lsp generated by profiling";
        terpri();
        prettyprint ('progn . reverse rr);
        terpri();
        printc "% end of fastgets.lsp";
        close wrs w;
        printc "Profiling complete";
        window!-heading "Profiling complete";
        restart!-csl t >>
    else restart!-csl('(remake profile_a_package), names)
  end;
+++ profile_a_package not compiled (C++ version available)


symbolic procedure trim_prefix(a, b);
  begin
    while a and b and car a = car b do <<
      a := cdr a;
      b := cdr b >>;
    if null a then return b
    else return nil
  end;
+++ trim_prefix compiled, 19 + 8 bytes


fluid '(time_info);

symbolic procedure read_file f1;
  begin
% I take the view that I can afford to read the whole of a file into
% memory at the start of processing. This makes life easier for me
% and the REDUCE log files are small compared with current main memory sizes.
    scalar r, w, w1, n, x;
    scalar p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13;
% To make comparisons between my CSL logs and some of the "reference
% logs", which are created using a different script, I will discard
% lines that match certain patterns!  Note that if the reference logs change
% the particular tests I perform here could become out of date! Also if any
% legitimate test output happened to match one of the following strings
% I would lose out slightly.
    p1 := explodec "Time: ";
    p2 := explodec "user	";
    p3 := explodec "sys	";
    p4 := explodec "time to formulate conditions:";
    p5 := explodec "CRACK needed :";
    p6 := explodec "time for initializations:";
    p7 := explodec "Tested on ";
    p8 := explodec "Total time taken:";
    p9 := explodec "*** turned off switch";
    p10 := explodec "+++ levelt compiled";
    p11 := explodec "Request to set constant bitsperword";
    p12 := explodec "*** (levelt): base";
    p13 := explodec "max_gc_int :";
    r := nil;
    n := 0;
    while not ((w := readline f1) = !$eof!$) do <<
       w1 := explodec w;
       if trim_prefix(p1, w1)
          or trim_prefix(p2, w1)
          or trim_prefix(p3, w1)
          or trim_prefix(p4, w1)
          or trim_prefix(p5, w1)
          or trim_prefix(p6, w1)
          or trim_prefix(p7, w1)
          or trim_prefix(p8, w1)
          or trim_prefix(p9, w1)
          or trim_prefix(p10, w1)
          or trim_prefix(p11, w1)
          or trim_prefix(p12, w1)
          or trim_prefix(p13, w1)
          then n := n + 1
       else r := ((n := n + 1) . w) . r >>;
    w := r;
% The text scanned for here is expected to match that generated by the
% test script. I locate the last match in a file, extract the numbers
% and eventually write them to testlogs/times.log
    n := explodec "Time (counter 1):";
    while w and null (x := trim_prefix(n, explodec cdar w)) do w := cdr w;
    if null w then <<
       time_info := nil;
       return reversip r >>;
% Remove time info from lines
    w := cdr w;
    if (trim_prefix(explodec "Tested on ", explodec cdar w)) then w := cdr w;
    r := w;
    while eqcar(x, '! ) do x := cdr x;
    w := n := nil;
    while digit car x do << w := car x . w; x := cdr x >>;
    while eqcar(x, '! ) do x := cdr x;
    if x := trim_prefix(explodec "ms  plus GC time:", x) then <<
        while eqcar(x, '! ) do x := cdr x;
        while digit car x do << n := car x . n; x := cdr x >> >>;
    if null w then w := '(!0);
    if null n then n := '(!0);
    time_info := compress reverse w . compress reverse n;
    return reversip r;
  end;
+++ read_file compiled, 326 + 96 bytes


fluid '(!*insist_on_exact_match);

!*insist_on_exact_match := t;

symbolic procedure roughly_equal(a, b);
  begin
% a and b are strings repesenting lines of text. I want to test if they
% match subject to some floating point slop.
    scalar wa, wb, adot, bdot;
    if a = b then return t;
    a := explodec a;
    b := explodec b;
    if !*insist_on_exact_match then return (a = b);
top:
% First deal with end of line matters.
    if null a and null b then return t
    else if null a or null b then return nil;
% next split off any bits of a and b up to a digit
    wa := wb := nil;
    while a and not digit car a do <<
       wa := car a . wa;
       a := cdr a >>;
    while b and not digit car b do <<
       wb := car b . wb;
       b := cdr b >>;
    if not (wa = wb) then return nil;
% now both a and b start with digits. I will seek a chunk of the
% form nnn.mmmE+xxx where E<sign>xxx is optional...
% Note that any leading sign on the float has been checked already!
    wa := wb := nil;
    adot := bdot := nil;
    while a and digit car a do <<
       wa := car a . wa;
       a := cdr a >>;
    if eqcar(a, '!.) then <<
       adot := t;
       wa := car a . wa;
       a := cdr a >>;
    while a and digit car a do <<
       wa := car a . wa;
       a := cdr a >>;
    if eqcar(a, '!e) or eqcar(a, '!E) then <<
       adot := t;
       wa := car a . wa;
       a := cdr a;
       if eqcar(a, '!+) or eqcar(a, '!-) then <<
          wa := car a . wa;
          a := cdr a >>;
       while a and digit car a do <<
          wa := car a . wa;
          a := cdr a >> >>;
% Now all the same to grab a float from b
    while b and digit car b do <<
       wb := car b . wb;
       b := cdr b >>;
    if eqcar(b, '!.) then <<
       bdot := t;
       wb := car b . wb;
       b := cdr b >>;
    while b and digit car b do <<
       wb := car b . wb;
       b := cdr b >>;
    if eqcar(b, '!e) or eqcar(b, '!E) then <<
       bdot := t;
       wb := car b . wb;
       b := cdr b;
       if eqcar(b, '!+) or eqcar(b, '!-) then <<
          wb := car b . wb;
          b := cdr b >>;
       while b and digit car b do <<
          wb := car b . wb;
          b := cdr b >> >>;
% Now one possibility is that I had an integer not a float,
% and in that case I want an exact match
    if not adot or not bdot then <<
       if wa = wb then goto top
       else return nil >>;
    if wa = wb then goto top;   % textual match on floating point values
    wa := compress reversip wa;
    wb := compress reversip wb;
    if fixp wa then wa := float wa;
    if fixp wb then wb := float wb;
    if not (floatp wa and floatp wb) then return nil; % messed up somehow!
    if wa = wb then goto top;
% now the crucial approximate floating point test - note that both numbers
% are positive, but that they may be extreme in range.
% As a cop-out I am going to insist that if values are either very very big
% or very very small that they match as text.
    if wa > 1.0e100 or wb > 1.0e100 then return nil;
    if wa < 1.0e-100 or wb < 1.0e-100 then return nil;
    wa := (wa - wb)/(wa + wb);
    if wa < 0 then wa := -wa;
    if wa > 0.0001 then return nil; % pretty crude!
    goto top
  end;
+++ roughly_equal compiled, 361 + 48 bytes


symbolic procedure in_sync(d1, n1, d2, n2);
  begin
    for i := 1:n1 do if d1 then <<  % skip n1 lines from d1
       d1 := cdr d1 >>;
    for i := 1:n2 do if d2 then <<  % skip n2 lines from d2
       d2 := cdr d2 >>;
% If one is ended but the other is not then we do not have a match. If
% both are ended we do have one.
    if null d1 then return null d2
    else if null d2 then return nil;
% Here I insist on 3 lines that agree before I count a match as
% having been re-established.
    if not roughly_equal(cdar d1, cdar d2) then return nil;
    d1 := cdr d1; d2 := cdr d2;
    if null d1 then return null d2
    else if null d2 then return nil;
    if not roughly_equal(cdar d1, cdar d2) then return nil;
    d1 := cdr d1; d2 := cdr d2;
    if null d1 then return null d2
    else if null d2 then return nil;
    if not roughly_equal(cdar d1, cdar d2) then return nil;
    d1 := cdr d1; d2 := cdr d2;
    if null d1 then return null d2
    else if null d2 then return nil
    else return t
  end;
+++ in_sync compiled, 112 + 20 bytes


fluid '(time_data time_ratio gc_time_ratio log_count);

symbolic procedure prinright(x, w);
  begin
    scalar xx, xl;
    xx := explodec x;
    xl := length xx;
    while w > xl do << princ " "; xl := xl + 1 >>;
    princ x;
  end;
+++ prinright compiled, 24 + 12 bytes


fluid '(files_with_differences);

symbolic procedure file_compare(f1, f2, name);
  begin
    scalar i, j, d1, d2, t1, gt1, t2, gt2, time_info, fdiffer;
    d1 := read_file f1;
    if null time_info then t1 := gt1 := 0
    else << t1 := car time_info; gt1 := cdr time_info >>;
    d2 := read_file f2;
    if null time_info then t2 := gt2 := 0
    else << t2 := car time_info; gt2 := cdr time_info >>;
    i := wrs time_data;
    j := set!-print!-precision 3;
    prin name;
    ttab 17;
    if zerop t1 then princ "     ---"
    else << prinright(t1, 8);
% Tag the time with an asterisk if it will not participate in the
% eventual overall timing report.
            if t1<=200 then princ "*";
            ttab 30; prinright(gt1, 8) >>;
    ttab 40;
    if zerop t2 then princ "     ---"
    else << prinright(t2, 9);
            if t2<=200 then princ "*";
            ttab 50; prinright(gt2, 8) >>;
    ttab 60;
    if zerop t1 or zerop t2 then princ "     ***       ***"
    else begin
       scalar r1, gr1, w;
       r1 := float t1 / float t2;
       gr1 := float (t1+gt1)/float (t2+gt2);
% I will only use tests where the time taken was over 200ms in my eventual
% composite summary of timings, since measurement accuracy can leave the
% really short tests pretty meaningless.
       if t1 > 200 and t2 > 200 then <<
% But I will go further than that and give less weight to any test whose time
% is under 1 second, so that the cut-off is gradual rather than abrupt.
          w := min(t1, t2);
% This means that if w (the smaller time) = 200 then then
% the test does not contribute to the average, while if w>=1000
% it contributes fully.
          if w < 1000.0 then w := (w - 200.0)/800.0
          else w := 1.0;
          time_ratio := time_ratio * expt(r1, w);
          gc_time_ratio := gc_time_ratio * expt(gr1, w);
          log_count := log_count + w >>;
       princ r1;
       ttab 70;
       princ gr1;
       end;
    terpri();
    set!-print!-precision j;
    wrs i;
% The next segment of code is a version of "diff" to report ways in which
% reference and recent log files match or diverge.
% I can not see a neat way to get a "structured" control structure
% here easily.  Ah well, drop back to GOTO statements!
top:
    if null d1 then <<      % end of one file
       if d2 then terpri();
       i := 0;
       while d2 and i < 20 do <<
          fdiffer := t;
          princ "REF "; princ caar d2; princ ":"; ttab 10; printc cdar d2;
          d2 := cdr d2;
          i := i + 1 >>;
       if d2 then printc "...";
       if fdiffer then files_with_differences := name . files_with_differences;
       return >>;
    if null d2 then <<      % end of other file
       i := 0;
       while d1 and i < 20 do <<
          fdiffer := t;
          princ "NEW "; princ caar d1; princ ":"; ttab 10; printc cdar d1;
          d1 := cdr d1;
          i := i + 1 >>;
       if d1 then printc "...";
       if fdiffer then files_with_differences := name . files_with_differences;
       return >>;
% The test "roughly_equal" compares allowing some tolerance on floating
% point values. This is because REDUCE uses platform libraries for
% floating point elementary functions and printing, so small differences
% are expected. This is perhaps uncomfortable, but is part of reality, and
% the test here makes comparison output much more useful in that the
% differences shown up are better limited towards "real" ones.
    if roughly_equal(cdar d1, cdar d2) then <<
       d1 := cdr d1;
       d2 := cdr d2;
       go to top >>;
% I will first see if there are just a few blank lines inserted into
% one or other file. This special case is addressed here because it
% appears more common a possibility than I had expected.
    if cdar d1 = "" and cdr d1 and roughly_equal(cdadr d1, cdar d2) then <<
       fdiffer := t;
       princ "NEW "; princ caar d1; princ ":"; ttab 10; printc cdar d1;
       d1 := cdr d1;
       go to top >>
    else if cdar d1 = "" and cdr d1 and cdadr d1 = "" and cddr d1 and
       roughly_equal(cdaddr d1, cdar d2) then <<
       fdiffer := t;
       princ "NEW "; princ caar d1; princ ":"; ttab 10; printc cdar d1;
       d1 := cdr d1;
       princ "NEW "; princ caar d1; princ ":"; ttab 10; printc cdar d1;
       d1 := cdr d1;
       go to top >>
    else if cdar d2 = "" and cdr d2 and
       roughly_equal(cdadr d2, cdar d1) then <<
       fdiffer := t;
       princ "REF "; princ caar d2; princ ":"; ttab 10; printc cdar d2;
       d2 := cdr d2;
       go to top >>
    else if cdar d2 = "" and cdr d2 and cdadr d2 = "" and cddr d2 and
       roughly_equal(cdaddr d2, cdar d1) then <<
       fdiffer := t;
       princ "REF "; princ caar d2; princ ":"; ttab 10; printc cdar d2;
       d2 := cdr d2;
       princ "REF "; princ caar d2; princ ":"; ttab 10; printc cdar d2;
       d2 := cdr d2;
       go to top >>;
    i := 1;
seek_rematch:
    j := 0;
inner:
    if in_sync(d1, i, d2, j) then <<
       terpri();
       for k := 1:i do <<
          if not trim_prefix(explodec "Time (counter 1)", explodec cdar d1) and
             not trim_prefix(explodec "real	", explodec cdar d1) then
             fdiffer := t;
          princ "NEW "; princ caar d1; princ ":"; ttab 10; printc cdar d1;
          d1 := cdr d1 >>;
       for k := 1:j do <<
          if not trim_prefix(explodec "Time (counter 1)", explodec cdar d2) and
             not trim_prefix(explodec "real	", explodec cdar d2) then
             fdiffer := t;
          princ "REF "; princ caar d2; princ ":"; ttab 10; printc cdar d2;
          d2 := cdr d2 >>;
       if null d1 then <<
          if fdiffer then files_with_differences := name . files_with_differences;
          return >>
       else go to top >>;
    j := j + 1;
    i := i - 1;
    if i >= 0 then go to inner;
    i := j;
% I am prepared to seek 80 lines ahead on each side before I give up.
% The number 80 is pretty much arbitrary.
    if i < 80 then goto seek_rematch;
    terpri();
    i := 0;
    while d2 and i < 20 do <<
       fdiffer := t;
       princ "REF "; princ caar d2; princ ":"; ttab 10; printc cdar d2;
       d2 := cdr d2;
       i := i+1 >>;
    if d2 then printc "...";
    i := 0;
    while d1 and i < 20 do <<
       fdiffer := t;
       princ "NEW "; princ caar d1; princ ":"; ttab 10; printc cdar d1;
       d1 := cdr d1;
       i := i+1 >>;
    if d1 then printc "...";
    printc "Comparison failed.";
    if fdiffer then files_with_differences := name . files_with_differences;
  end;
+++ file_compare compiled, 984 + 188 bytes


fluid '(which_module);

symbolic procedure check_a_package;
  begin
    scalar oll, names, p1, logname, mylogname, mylog, reflogname, reflog,
           time_data, time_ratio, gc_time_ratio, log_count,
           files_with_differences;
    get_configuration_data();
    if boundp 'which_module and symbol!-value 'which_module and
       not (symbol!-value 'which_module = "") then <<
       names := compress explodec symbol!-value 'which_module;
       if member(names, reduce_test_cases) then names := list names
       else error(0, list("unknown module to check", which_module)) >>
    else names := reduce_test_cases;
% I write a summary of timing information into csllogs/times.log
    time_data := open("testlogs/times.log", 'output);
    p1 := wrs time_data;
    princ "MODULE";
    ttab 21; princ "Local";     ttab 32; princ "(GC)";
    ttab 40; princ "Reference"; ttab 52; princ "(GC)";
    ttab 55; princ "Ratio";     ttab 65; printc "inc GC";
    wrs p1;
    terpri();
    oll := linelength 100;
    printc "=== Comparison results ===";
    time_ratio := gc_time_ratio := 1.0; log_count := 0.0;
    for each packge in names do <<
       terpri();
       princ "CHECKING: "; print packge;
       if boundp '!@log and stringp symbol!-value '!@log then
           logname := symbol!-value '!@log
       else logname := "testlogs";
       mylogname := concat(logname, concat("/", concat(packge, ".rlg")));
       if get(packge,'folder) then p1 := get(packge,'folder)
       else p1 := packge;
       reflogname := concat("$reduce/packages/",
                       concat(p1,
                         concat("/",
                           concat(packge,".rlg"))));
       mylog := errorset(list('open, mkquote mylogname, ''input), nil, nil);
       reflog := errorset(list('open, mkquote reflogname, ''input), nil, nil);
       if errorp mylog then <<
          if not errorp reflog then close car reflog;
          princ "No current log in "; print mylogname >>
       else if errorp reflog then <<
          close car mylog;
          princ "No reference log in "; print reflogname >>
       else <<
          princ "LOGS: "; princ mylogname; princ " "; printc reflogname;
          mylog := car mylog; reflog := car reflog;
          file_compare(mylog, reflog, packge);
          close mylog;
          close reflog >> >>;
     time_data := wrs time_data;
     if not zerop log_count then <<
        time_ratio := expt(time_ratio, 1.0/log_count);
        gc_time_ratio := expt(gc_time_ratio, 1.0/log_count);
        terpri();
        p1 := set!-print!-precision 3;
        princ "Over "; prin log_count; princ " tests the speed ratio was ";
        print time_ratio;
        princ "    (or ";
        prin gc_time_ratio;
        printc " is garbage collection costs are included)";
        set!-print!-precision p1 >>;
     close wrs time_data;
     linelength oll;
     if null files_with_differences then <<
        terpri(); terpri();
        printc "+++++++++++++++++++++++++++";
        printc "+++ All log files match +++";
        printc "+++++++++++++++++++++++++++";
        terpri() >>
     else <<
        terpri(); terpri();
        printc "+++++++++++++++++++++++++++++++";
        printc "+++ The following logs differ:";
        for each x in reverse files_with_differences do <<
           ttab 4; print x >>;
        printc "+++++++++++++++++++++++++++++++";
        terpri() >>;
  end;
+++ check_a_package compiled, 548 + 244 bytes



faslend;Completed FASL files for remake

nil


load!-module 'remake;

Reading "$reduce/cslbuild/generated-c/u01.lsp"

% u01.lsp           Machine generated Lisp

(c!:install "u01" 155351 4382164 1390646)
nil


(c!:install 'mchkopt '(mchkopt mchkopt1) 17870479248354630069)
mchkopt


(c!:install 'smember '(smember) 13191502175548781548)
smember


(c!:install '!*n2f '(!*n2f) 10289146006010272445)
!*n2f


(c!:install 'setdiff '(setdiff) 10882386784744671254)
setdiff


(c!:install 'nth '(nth pnth) 13103979795264948375)
nth


(c!:install 'terminalp '(terminalp !*int ifl!*) 14405872713976495584)
terminalp


(c!:install 'multf '(multf !*physop!-loaded physop!-multf poly!-multf) 
494727110790351985)
multf


(c!:install 'monomgetvariabledegree '(monomgetvariabledegree) 
8023262334649356999)
monomgetvariabledegree


(c!:install 'quotelist '(quotelist list) 1574403703834970305)
quotelist


(c!:install 'num!-exponents '(num!-exponents) 15463308288451653383)
num!-exponents


(c!:install 'simpcar '(simpcar simp) 3553785855597976598)
simpcar


(c!:install 'wuconstantp '(wuconstantp wuvarlist!*) 12941656753920697454
)
wuconstantp


(c!:install 'mkcopy '(mkcopy nreverse) 7183001257258168070)
mkcopy


(c!:install 'revpr '(revpr) 3648246328003253418)
revpr


(c!:install 'talp_getl '(talp_getl talp_lang!*) 10605522302596989277)
talp_getl


(c!:install 'kernels '(kernels kernels1) 10365596704375016327)
kernels


(c!:install 'qqe_rqopp '(qqe_rqopp (qequal qneq)) 9487265644821376008)
qqe_rqopp


(c!:install 'powers '(powers powers0) 12547666331220240574)
powers


(c!:install 'lto_hashid '(lto_hashid string2list) 12756331278654427960)
lto_hashid


(c!:install 'noncomfp '(noncomfp !*ncmp noncomfp1) 11957482738418472085)
noncomfp


(c!:install 'ioto_prtb '(ioto_prtb) 6884062130396396443)
ioto_prtb


(c!:install 'delall '(delall) 1756895226056909811)
delall


(c!:install 'ordop '(ordop !*physop!-loaded kord!* physop!-ordop ordp) 
3890858479330319784)
ordop


(c!:install 'ps!:getv '(ps!:getv !:ps!: tps "PS:GETV: not a ps" eval
rerror) 16942942242138714985)
ps!:getv


(c!:install 'prepf '(prepf prepf1a replus1) 9856160862572892849)
prepf


(c!:install 'c!:ordxp '(c!:ordxp) 2602976016472606765)
c!:ordxp


(c!:install 'zero2nil '(zero2nil !:zerop) 10633115001215793252)
zero2nil


(c!:install 'mval '(mval) 11011388250209885205)
mval


(c!:install 'reval '(reval reval1) 607148151428708743)
reval


(c!:install 'evcomp '(evcomp dipsortevcomp!* apply) 11458319438815987135
)
evcomp


(c!:install 'evmatrixcomp2 '(evmatrixcomp2 iequal evmatrixcomp3) 
17134931270508499986)
evmatrixcomp2


(c!:install 'xval '(xval wedgefax) 4982697926302997625)
xval


(c!:install 'times!: '(times!: !:rd!:) 13918419094490476156)
times!:


(c!:install 'mkvar '(mkvar) 11824711320760967426)
mkvar


(c!:install 'physopp '(physopp physop) 14198226529859723595)
physopp


(c!:install 'memq_edgelist '(memq_edgelist) 16418766517129154613)
memq_edgelist


(c!:install 'mo_comp '(mo_comp) 7822316642505852903)
mo_comp


(c!:install 'c_zero '(c_zero) 1032248116684792182)
c_zero


(c!:install 'sieve_pv0 '(sieve_pv0 reduce_pv0) 13154362390419875934)
sieve_pv0


(c!:install 'listp '(listp) 12303291008233215571)
listp


(c!:install 'modzerop!: '(modzerop!:) 5977998997490276172)
modzerop!:


(c!:install 'getrtypeor '(getrtypeor getrtype) 6980262008830534162)
getrtypeor


(c!:install 'lalr_productions '(lalr_productions lalr_produces) 
3298372555673516867)
lalr_productions


(c!:install 'random_new_seed '(random_new_seed "positive integer"
randommodulus!* unidev_vec!* unidev_next!* unidev_nextp!* typerr) 
5608916306279639031)
random_new_seed


(c!:install 'monomcompare '(monomcompare fluidbibasismonomialorder lex
deglex monomcomparelex monomcomparedeglex monomcomparedegrevlex) 
11668802883052497314)
monomcompare


(c!:install 'makelist '(makelist list) 15515310845748409871)
makelist


(c!:install 'quotf '(quotf !*exp quotf1) 10208944217213743985)
quotf


(c!:install 'mchk!* '(mchk!* !*mcd mchk sfp prepf) 15002136098479593556)
mchk!*


(c!:install 'get!+mat!+entry '(get!+mat!+entry nth) 6094923771698919845)
get!+mat!+entry


(c!:install 'talp_getextl '(talp_getextl talp_extlang!*) 
12538925215258623962)
talp_getextl


(c!:install 'ibalp_clmember '(ibalp_clmember ibalp_cequal) 
12615747429273137966)
ibalp_clmember


(c!:install 'aex_ex '(aex_ex nth) 6874894332184563799)
aex_ex


(c!:install 'argsofopr '(argsofopr) 14485097781522944211)
argsofopr


(c!:install 'find2 '(find2 (stop)) 3919817123441467574)
find2


(c!:install 'noncomp '(noncomp !*ncmp noncomp1) 7281023392677228180)
noncomp


(c!:install 'ps!:order '(ps!:order !:ps!: ps!:getv) 10995295834433152897
)
ps!:order


(c!:install 'prepf1a '(prepf1a prepf1a_reversed) 17523181497977731895)
prepf1a


(c!:install 'pm!:free '(pm!:free unbound binding) 6755412176488262089)
pm!:free


(c!:install 'vbcsize '(vbcsize) 10149681502585176508)
vbcsize


(c!:install 'pnth '(pnth alg "Index out of range" rerror) 
9023406246188284074)
pnth


(c!:install 'wedgefax '(wedgefax wedge) 9774641278439376054)
wedgefax


(c!:install 'convprec '(convprec round!* convchk) 4406448051485643347)
convprec


(c!:install '!*physopp '(!*physopp) 17193575244302011073)
!*physopp


(c!:install 'wideid2list '(wideid2list id2string widestring2list) 
14899334837554163239)
wideid2list


(c!:install 'termsf '(termsf) 5142070612029737275)
termsf


(c!:install 'mkspm '(mkspm subfg!* asymplis!* sub2chk to) 
12924718737372251795)
mkspm


(c!:install 'dssoc '(dssoc) 9943343782137733392)
dssoc


(c!:install 'noncomlistp '(noncomlistp noncomp1) 11410168196383151040)
noncomlistp


(c!:install 'rnzerop!: '(rnzerop!:) 16731020569996446694)
rnzerop!:


(c!:install 'mksp '(mksp fkern getpower) 5150597736874327244)
mksp


(c!:install 'aeval '(aeval reval1) 7849631381568206072)
aeval


(c!:install 'lalr_first '(lalr_first union) 16041187756973293382)
lalr_first


(c!:install 'addcomment '(addcomment cursym!*) 1372804578070059914)
addcomment


(c!:install 'arrayp '(arrayp array) 7480162614326499458)
arrayp


(c!:install 'cl_cflip '(cl_cflip cl_flip) 11247492121595187556)
cl_cflip


(c!:install 'subs3f '(subs3f !*match subs3f1) 5708552445967467259)
subs3f


(c!:install 'kernlp '(kernlp) 4776685139720076559)
kernlp


(c!:install 'talp_invp '(talp_invp talp_op talp_getl talp_getextl) 
18265295900233247614)
talp_invp


(c!:install 'qqe_rbopp '(qqe_rbopp (equal neq lessp leq geq greaterp)) 
4174886615890578722)
qqe_rbopp


(c!:install 'sub2chk '(sub2chk subfg!* powlis!* (expt sqrt) !*sub2) 
13289057268120537615)
sub2chk


(c!:install 'butes '(butes !  !$) 12675838350938118425)
butes


(c!:install 'ps!:last!-term '(ps!:last!-term !:ps!: ps!:max!-order
ps!:getv) 9653922917099831857)
ps!:last!-term


(c!:install 'exchk '(exchk exchk1) 11606904193205051154)
exchk


(c!:install 'expchk '(expchk !*exp offexpchk) 9915809864728027311)
expchk


(c!:install 'dm!-abs '(dm!-abs !:minusp dm!-minus) 5836926462620992597)
dm!-abs


(c!:install 'binding '(binding) 4680970127765444998)
binding


(c!:install 'evlexcomp '(evlexcomp (0) iequal) 15296642623206294172)
evlexcomp


(c!:install 'sc_getmat '(sc_getmat) 58534311512400522)
sc_getmat


(c!:install 'getrtypecar '(getrtypecar getrtype) 15058805869473325106)
getrtypecar


(c!:install 'isanindex '(isanindex physopindices!* physopvarind!*
frlis!* frasc!* revassoc) 12508025661076306506)
isanindex


(c!:install 'poly!-multf '(poly!-multf !*exp ncmp!* wtl!* !*!*processed
plus !*asymp!* !*mcd multd mkprod noncomfp noncomp poly!-multfnc reval
to mkspm addf ordop) 6319512014551894727)
poly!-multf


(c!:install 'mo_divides!? '(mo_divides!? mo!=modiv1) 
17637252768363875233)
mo_divides!?


(c!:install 'dlesslex '(dlesslex) 11955018107554220526)
dlesslex


(c!:install 'hasonevector '(hasonevector vecp) 12564010309464711379)
hasonevector


(c!:install 'reduce_pv0 '(reduce_pv0 pv_den lcm pv_multc pv_add) 
5153456908751287689)
reduce_pv0


(c!:install 'modonep!: '(modonep!:) 5158574548373630293)
modonep!:


(c!:install 'remainder!-in!-vector '(remainder!-in!-vector
"Attempt to divide by zero" errorf) 4351866787004292850)
remainder!-in!-vector


(c!:install 'smemql '(smemql nreverse) 4082635428198047081)
smemql


(c!:install 'lalr_add_lookahead '(lalr_add_lookahead) 
13974897791435704310)
lalr_add_lookahead


(c!:install 'setkorder '(setkorder kord!* alglist!*) 1274397398323497919
)
setkorder


(c!:install 'mtchp1 '(mtchp1 frlis!* !*mcd mchk!* powmtch mapcons) 
8040862986504420322)
mtchp1


(c!:install 'get!+row!+nr '(get!+row!+nr) 619237314739600394)
get!+row!+nr


(c!:install 'rl_negateat '(rl_negateat rl_negateat!* apply) 
284003718963730135)
rl_negateat


(c!:install 'kernels1 '(kernels1) 11809629817331374048)
kernels1


(c!:install 'lpri '(lpri " ") 354308775184825461)
lpri


(c!:install 'addd '(addd nreverse adddm) 3070103899685532212)
addd


(c!:install 'compress!* '(compress!* !/ !- !; !. !!) 
11549636611627544158)
compress!*


(c!:install 'noncomfp1 '(noncomfp1 noncomp) 10476302401066043959)
noncomfp1


(c!:install 'ldepends '(ldepends depends) 11339890901733305229)
ldepends


(c!:install 'numlis '(numlis) 15211646017088965144)
numlis


(c!:install '!:minusp '(!:minusp) 3782016383522340347)
!:minusp


(c!:install 'evzero!? '(evzero!?) 4595356540037025948)
evzero!?


(c!:install 'factorordp '(factorordp worderp) 18023367160266015232)
factorordp


(c!:install 'degr '(degr) 4574746505718608755)
degr


(c!:install 'mkround '(mkround !:rd!:) 16376423073134403457)
mkround


(c!:install 'collectindices '(collectindices collectindices_reversed) 
13350879772651161584)
collectindices


(c!:install 'union_edge '(union_edge memq_edgelist) 18402163738355741286
)
union_edge


(c!:install 'ring_ecart '(ring_ecart nth) 9144020264867069358)
ring_ecart


(c!:install 'mtp '(mtp frlis!*) 16156939807690480451)
mtp


(c!:install 'reduce_pv '(reduce_pv reduce_pv0) 7786781876430233123)
reduce_pv


(c!:install 'rnequiv '(rnequiv) 13456506203434818050)
rnequiv


(c!:install 'general!-modular!-times '(general!-modular!-times
current!-modulus) 12723973456730574931)
general!-modular!-times


(c!:install 'multd '(multd nreverse multdm) 9364600233547318720)
multd


(c!:install 'lalr_lr0_move_dot '(lalr_lr0_move_dot !.) 
8933058430108074818)
lalr_lr0_move_dot


(c!:install 'aex_ctx '(aex_ctx nth) 17701972192989521900)
aex_ctx


(c!:install 'prin2x '(prin2x outl!*) 8707702100765069327)
prin2x


(c!:install 'minusf '(minusf) 458362134412293575)
minusf


(c!:install 'reorder '(reorder rmultpf raddf) 12871853738173991382)
reorder


(c!:install 'aconc!* '(aconc!*) 12129366969500193987)
aconc!*



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u01.lsp"

Reading "$reduce/cslbuild/generated-c/u02.lsp"

% u02.lsp           Machine generated Lisp

(c!:install "u02" 169761 5971315 9509929)
nil


(c!:install 'mchk '(mchk !*sq frlis!* minus difference plus prepsqxx
mchkopt mcharg mchkminus) 148810512295251760)
mchk


(c!:install 'quotsq '(quotsq invsq multsq) 16017804956025636103)
quotsq


(c!:install 'tayexp!-greaterp '(tayexp!-greaterp tayexp!-lessp) 
1123168781243193893)
tayexp!-greaterp


(c!:install '!*d2q '(!*d2q !:zerop) 2942878362772793713)
!*d2q


(c!:install 'talp_simplt '(talp_simplt talp_simplt1) 
17444896794875062292)
talp_simplt


(c!:install 'qqe_qoptailp '(qqe_qoptailp (rtail ltail)) 
17434519072488697490)
qqe_qoptailp


(c!:install 'multdm '(multdm dmode!* times dcombine) 6516973467835205199
)
multdm


(c!:install '!*q2a '(!*q2a !*nosq !*q2a1) 11555987202239149450)
!*q2a


(c!:install '!:onep '(!:onep) 4011829079803763631)
!:onep


(c!:install 'buchvevdivides!? '(buchvevdivides!? gmodule!* vevmtest!?
gevcompatible1) 11196724188458402298)
buchvevdivides!?


(c!:install 'vevmtest!? '(vevmtest!? vevzero!?1) 11706374004685961547)
vevmtest!?


(c!:install 'sublistp '(sublistp) 3169363773062908815)
sublistp


(c!:install 'csl_normbf '(csl_normbf (!:rd!: 0 . 0) !:rd!: lsd lshift) 
13915775592432571512)
csl_normbf


(c!:install 'round!* '(round!*) 15435073396947745909)
round!*


(c!:install 'collectindices_reversed '(collectindices_reversed isanindex
) 15344220528776217650)
collectindices_reversed


(c!:install 'reval_without_mod '(reval_without_mod dmode!* !:mod!: reval
) 11636295117530310728)
reval_without_mod


(c!:install 'mo!=sprod '(mo!=sprod) 9344181336102125413)
mo!=sprod


(c!:install 'pappl '(pappl unpkp) 8550675407748926371)
pappl


(c!:install '!*i2mod '(!*i2mod general!-modular!-number !*modular2f) 
15015861616903927392)
!*i2mod


(c!:install 'general!-modular!-plus '(general!-modular!-plus
current!-modulus) 8526843358129128471)
general!-modular!-plus


(c!:install '!*d2n '(!*d2n) 3633340374767821611)
!*d2n


(c!:install 'delcp '(delcp) 9134181419118630333)
delcp


(c!:install 'getpower '(getpower expt !*sub2) 5825647195735019199)
getpower


(c!:install 'sort '(sort stable!-sortip) 17468245960117337925)
sort


(c!:install 'finde '(finde) 15015524044270863670)
finde


(c!:install 'sfp '(sfp) 5333901289349618817)
sfp


(c!:install 'tayexp!-lessp '(tayexp!-lessp tayexp!-difference !:minusp) 
2420807945700247452)
tayexp!-lessp


(c!:install 'get!+vec!+entry '(get!+vec!+entry nth) 13540592547955936973
)
get!+vec!+entry


(c!:install 'rl_simplat1 '(rl_simplat1 rl_simplat1!* apply) 
1119653501954174848)
rl_simplat1


(c!:install 'mri_floorkernelp '(mri_floorkernelp kernels mri_floorp) 
12260307348955726856)
mri_floorkernelp


(c!:install 'get_token '(get_token ch !> !$) 9412163165595484911)
get_token


(c!:install 'xsimp '(xsimp simp!* expchk) 3255895205295822210)
xsimp


(c!:install 'prepsqxx '(prepsqxx prepsqx negnumberchk) 
331390757553135339)
prepsqxx


(c!:install 'aeval!* '(aeval!* alglist!* reval1) 7399874288010001339)
aeval!*


(c!:install 'adddm '(adddm dmode!* plus !*n2f int!-equiv!-chk dcombine) 
15272508536123350498)
adddm


(c!:install 'cali_bc_prod '(cali_bc_prod multf bc!=simp) 
10442551923468604639)
cali_bc_prod


(c!:install 'sieve_pv '(sieve_pv sieve_pv0) 8777934566637263854)
sieve_pv


(c!:install 'lalr_closure '(lalr_closure !. lalr_productions lalr_first
lalr_item_with_rule setdiff lalr_add_lookahead) 11861106866886183000)
lalr_closure


(c!:install 'list2wideid '(list2wideid list2widestring) 
3523675516333595609)
list2wideid


(c!:install 'rl_varlat '(rl_varlat rl_varlat!* apply) 
5027893105409685837)
rl_varlat


(c!:install 'monomclone '(monomclone) 14855044415434424746)
monomclone


(c!:install 'comfac!-to!-poly '(comfac!-to!-poly) 4709435520467114160)
comfac!-to!-poly


(c!:install 'mtchk '(mtchk noncomp mtchp1 lispeval nocp) 
8584926739393883147)
mtchk


(c!:install 'exptchksq '(exptchksq !*combineexpt exptchk invsq multsq) 
6994235192515332434)
exptchksq


(c!:install 'talp_varlt '(talp_varlt talp_varlt1) 5444361619200117433)
talp_varlt


(c!:install 'lprim '(lprim !*msg "***" lpriw) 7798764165975688666)
lprim


(c!:install 'notstring '(notstring !  !" delall) 2964729193865468950)
notstring


(c!:install 'c!:ordexn '(c!:ordexn c!:ordxp) 4047906876943858375)
c!:ordexn


(c!:install 'constp '(constp domainlist!*) 4795165005821108387)
constp


(c!:install 'bczero!? '(bczero!? !*grmod!*) 5570695932568861154)
bczero!?


(c!:install 'multpfsq '(multpfsq nreverse multsq) 5143380340612129390)
multpfsq


(c!:install 'negnumberchk '(negnumberchk minus) 17451271898430660305)
negnumberchk


(c!:install 'opmtch!* '(opmtch!* subfg!* opmtch) 4529636177027904564)
opmtch!*


(c!:install 'sinitl '(sinitl eval) 1398428616857584375)
sinitl


(c!:install 'smemqlp '(smemqlp quote) 8501739837946035427)
smemqlp


(c!:install 'angles!-equal '(angles!-equal) 16566385185896185115)
angles!-equal


(c!:install 'pappl0 '(pappl0 unpkp pappl pkp) 16766546389216365062)
pappl0


(c!:install 'rnonep!: '(rnonep!:) 10970430191720549988)
rnonep!:


(c!:install 'multiply!-by!-constant!-mod!-p '(
multiply!-by!-constant!-mod!-p !*n2f) 6160203573024828849)
multiply!-by!-constant!-mod!-p


(c!:install 'lalr_prin_symbol '(lalr_prin_symbol "$" terminal_codes
cdrassoc explode2uc) 11673478962445058462)
lalr_prin_symbol


(c!:install 'aex_mk '(aex_mk aex) 14887199082447899676)
aex_mk


(c!:install 'monomisdivisibleby '(monomisdivisibleby) 
14863886936527861088)
monomisdivisibleby


(c!:install 'setcdr '(setcdr) 14832354553454505069)
setcdr


(c!:install 'powers0 '(powers0 repasc) 6537133265482714906)
powers0


(c!:install 'remove!-free!-vars!-l '(remove!-free!-vars!-l !*sq prepsq!*
remove!-free!-vars) 109993854797769662)
remove!-free!-vars!-l


(c!:install 'get!+vec!+dim '(get!+vec!+dim) 9629896398144938975)
get!+vec!+dim


(c!:install 'rl_ordatp '(rl_ordatp rl_ordatp!* apply) 
2629721809518774616)
rl_ordatp


(c!:install 'qqe_qopaddp '(qqe_qopaddp (ladd radd)) 11458331942659716410
)
qqe_qopaddp


(c!:install 'attributes '(attributes !  (!$) atts) 2379865991065383663)
attributes


(c!:install 'fast!-row!-dim '(fast!-row!-dim) 9304921290682235866)
fast!-row!-dim


(c!:install 'evmatrixcomp1 '(evmatrixcomp1 evmatrixcomp2 iequal) 
1762009739234747312)
evmatrixcomp1


(c!:install 'i2rd!* '(i2rd!* chkint!* mkround) 5437373606316795850)
i2rd!*


(c!:install 'getphystype!*sq '(getphystype!*sq getphystypesf) 
6440093314568178873)
getphystype!*sq


(c!:install 'union_edges '(union_edges union_edge) 16071474792195485152)
union_edges


(c!:install 'mo!=modiv1 '(mo!=modiv1) 10533875034678584595)
mo!=modiv1


(c!:install 'unpkp '(unpkp !0 diglist!*) 1739572093140679399)
unpkp


(c!:install 'modtimes!: '(modtimes!: general!-modular!-times !*modular2f
) 18159281788179474687)
modtimes!:


(c!:install 'times!-in!-vector '(times!-in!-vector) 4779664854939156595)
times!-in!-vector


(c!:install 'gcdfd '(gcdfd dmode!* gcdfd1) 9690821169017690901)
gcdfd


(c!:install 'cdrassoc '(cdrassoc "ASSOC trouble: " " " "assoc trouble"
rederr) 1475441646810113968)
cdrassoc


(c!:install 'cl_atmlc '(cl_atmlc) 17505962978350274030)
cl_atmlc


(c!:install 'delallasc '(delallasc nreverse) 12463333164811695390)
delallasc


(c!:install 'rank '(rank !*mcd degr) 13785758358482167955)
rank


(c!:install 'sizchk '(sizchk nreverse) 12235146735279254117)
sizchk


(c!:install 'rl_smcpknowl '(rl_smcpknowl rl_smcpknowl!* apply) 
16284918986271660351)
rl_smcpknowl


(c!:install 'qqe_qopheadp '(qqe_qopheadp (lhead rhead)) 
15180717920636906257)
qqe_qopheadp


(c!:install 'lto_hashequalq '(lto_hashequalq lto_hashid iequal) 
9738948250641085975)
lto_hashequalq


(c!:install 'get_content '(get_content ch !< !$eof!$ !  !" !$
list2string delall) 9268416252380254427)
get_content


(c!:install 'ps!:evaluate '(ps!:evaluate ps ps!:get!-term ps!:last!-term
ps!:evaluate!-next) 10007725786071766620)
ps!:evaluate


(c!:install '!:zerop '(!:zerop) 2700266875788551690)
!:zerop


(c!:install 'initcomb '(initcomb) 12815586964691946178)
initcomb


(c!:install 'bcprod '(bcprod !*grmod!* times bcfi bcint2op multsq
bccheckz) 5527952162054297686)
bcprod



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u02.lsp"

Reading "$reduce/cslbuild/generated-c/u03.lsp"

% u03.lsp           Machine generated Lisp

(c!:install "u03" 31472 3075116 3574010)
nil


(c!:install 'rd!:zerop '(rd!:zerop) 17709990252071441276)
rd!:zerop


(c!:install 'ordpp '(ordpp kord!* ordpa) 12822298693234152376)
ordpp


(c!:install 'monordp '(monordp wedge xorder) 12478659793155962360)
monordp


(c!:install '!*physopp!* '(!*physopp!* physopp!* getphystype) 
948670675597052586)
!*physopp!*


(c!:install 'cdiv '(cdiv resimp) 11683222651518251092)
cdiv


(c!:install 'pv_multc '(pv_multc) 9879545177389591922)
pv_multc


(c!:install 'upbve '(upbve) 1327966133220664679)
upbve


(c!:install 'striptag '(striptag) 17326995988230344292)
striptag


(c!:install 'lalr_compute_lr0_goto '(lalr_compute_lr0_goto
lalr_lr0_move_dot lalr_lr0_closure) 2461723306240185358)
lalr_compute_lr0_goto


(c!:install 'monomcomparedegrevlex '(monomcomparedegrevlex) 
5379678862617958039)
monomcomparedegrevlex


(c!:install 'lt!* '(lt!* !*mcd degr) 7232897656725575641)
lt!*


(c!:install 'subs2f '(subs2f simpcount!* simplimit!* poly
"Simplification recursion too deep" !*sub2 powlis1!* !*resubs rerror
subs2f1 subs2q) 10051676709538020572)
subs2f


(c!:install 'talp_simpat '(talp_simpat talp_arg2l talp_arg2r talp_tordp
talp_op talp_mk2) 3469360596094058181)
talp_simpat


(c!:install 'kernord!-sort '(kernord!-sort maxdeg delallasc) 
4668489427632091701)
kernord!-sort


(c!:install 'printout '(printout !*web indent " " !:rd!: !:rn!: ma_print
) 17135296235608100067)
printout


(c!:install 'mgenp '(mgenp mgen) 14519754117186260097)
mgenp


(c!:install 'evcompless!? '(evcompless!? evcomp) 656781853352752310)
evcompless!?


(c!:install 'evmatrixcomp '(evmatrixcomp vdpmatrix!* evmatrixcomp1) 
16587571580785743131)
evmatrixcomp


(c!:install 'wedgepf2 '(wedgepf2 wedget2 addpf) 12770300117273750368)
wedgepf2


(c!:install 'pprin2 '(pprin2 !*pprinbuf!* !*posn!*) 2238797775385437809)
pprin2


(c!:install '!*collectphysops_reversed '(!*collectphysops_reversed
physopp) 158985461405150257)
!*collectphysops_reversed


(c!:install 'constimes '(constimes cstimes) 7039731577920185829)
constimes


(c!:install 'errorp '(errorp) 8490585414243727613)
errorp


(c!:install 'timesip '(timesip times i) 450242453837008834)
timesip


(c!:install 'fs!:timestermterm '(fs!:timestermterm (1 . 2) sin cos
multsq negsq make!-term fs!:plus) 15534087645662146267)
fs!:timestermterm


(c!:install 'mo_vdivides!? '(mo_vdivides!? mo_comp mo_divides!?) 
4801467432489937362)
mo_vdivides!?


(c!:install 'dless '(dless ordering lex glex grev dlesslex) 
13675625109103645543)
dless


(c!:install 'pkp '(pkp !*ppacked diglist!* !0 dssoc) 3262876245839786418
)
pkp


(c!:install '!*i2rn '(!*i2rn !:rn!:) 8350483260431827809)
!*i2rn


(c!:install 'gcdfd1 '(gcdfd1 gcddd) 7828869281505561653)
gcdfd1


(c!:install 'lalr_propagate_lookaheads '(lalr_propagate_lookaheads
lalr_add_lookahead) 11371262137067644413)
lalr_propagate_lookaheads


(c!:install 'add2calls '(add2calls cinthis nolist xseen!* calls!*) 
5257137815112412235)
add2calls


(c!:install 'getrtype2 '(getrtype2 !3vector matmapfn matrix vecp
getrtype) 15939234473122355531)
getrtype2


(c!:install 'maxdeg '(maxdeg) 15858359606410142356)
maxdeg


(c!:install 'symbollessp '(symbollessp wukord!* wuorderp) 
6195008246583528310)
symbollessp


(c!:install 'multsq '(multsq multf gcdf quotf!-fail canonsq) 
12731693028284618669)
multsq


(c!:install 'rl_smupdknowl '(rl_smupdknowl rl_smupdknowl!* apply) 
13044180732527790587)
rl_smupdknowl


(c!:install 'ibalp_varlt '(ibalp_varlt ibalp_varlt1) 
11883918343511078755)
ibalp_varlt


(c!:install 'get!-print!-name '(get!-print!-name) 12554519722649643614)
get!-print!-name


(c!:install 'bftrim!: '(bftrim!: !:bprec!: round!:mt normbf) 
4135539689745124938)
bftrim!:


(c!:install 'on1 '(on1 onoff) 15736753824152232296)
on1


(c!:install 'bcint2op '(bcint2op dmode!* times plus) 4308300868984228201
)
bcint2op


(c!:install 'atomf '(atomf) 6612718896541201503)
atomf


(c!:install 'negsq '(negsq negf) 254780190327480257)
negsq


(c!:install 'hasonephysop '(hasonephysop physopp!*) 2192203047103297718)
hasonephysop


(c!:install 'arraychk '(arraychk array) 14768056252572375151)
arraychk


(c!:install 'fs!:angle!-order '(fs!:angle!-order sin) 
4968391117210088667)
fs!:angle!-order


(c!:install 'cali_trace '(cali_trace cali) 7527151419452896228)
cali_trace


(c!:install 'pcmult '(pcmult cprod) 1325726446480199114)
pcmult


(c!:install 'pv_renorm '(pv_renorm pv_neg gcdf!*) 2913080176010837600)
pv_renorm


(c!:install 'plus!-mod!-p '(plus!-mod!-p !*n2f ordop) 
11495117821214418486)
plus!-mod!-p


(c!:install 'split_form '(split_form split_f) 17958201723664562249)
split_form


(c!:install 'lalr_goto '(lalr_goto goto_table gethash) 
11789687400657200353)
lalr_goto


(c!:install 'toknump '(toknump !:dn!: !:int!:) 10408367941981424399)
toknump


(c!:install 'getrtype '(getrtype (scalar generic) physop sub
yetunknowntype getrtype1 eval physopp!* getrtype2) 17463766755553874190)
getrtype


(c!:install 'rmultpf '(rmultpf prepf simp!* !*q2f) 1878017964621528160)
rmultpf


(c!:install 'mtchp '(mtchp mtchp1 lispeval simp exptsq to multsq) 
15770205112570652726)
mtchp


(c!:install 'nocp '(nocp noncomp) 14841654342875670650)
nocp


(c!:install 'subs2q '(subs2q subs2f quotsq) 7705154240234812399)
subs2q


(c!:install 'qqe_nytidp '(qqe_nytidp) 1483882309597552990)
qqe_nytidp


(c!:install 'subs2!* '(subs2!* !*sub2 subs2) 8913029558719780175)
subs2!*


(c!:install 'off1 '(off1 onoff) 3726041070032633484)
off1


(c!:install 'prepsq '(prepsq prepf sqform) 7967683921450212310)
prepsq


(c!:install 'evsum '(evsum) 11202217146848191637)
evsum


(c!:install 'rd!:minusp '(rd!:minusp minusp!:) 6192968839908774165)
rd!:minusp


(c!:install 'reordop '(reordop !*ncmp reordablep ordop noncomp1) 
2895570421945065422)
reordop


(c!:install 'errorset!* '(errorset!* !*backtrace errorset) 
17780892343249883991)
errorset!*


(c!:install 'fs!:timesterm '(fs!:timesterm fs!:timestermterm fs!:plus) 
4213227144414903097)
fs!:timesterm


(c!:install '!:minus '(!:minus minus times dcombine) 
13211720288274851664)
!:minus


(c!:install 'rev '(rev) 18392574721571992098)
rev


(c!:install '!*!*s2a '(!*!*s2a) 14753551702131982369)
!*!*s2a


(c!:install 'lnc '(lnc) 9828819496956821615)
lnc


(c!:install 'stable!-sortip '(stable!-sortip) 349688021140228034)
stable!-sortip


(c!:install 'qqe_btidp '(qqe_btidp bt) 1084299208955020670)
qqe_btidp



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u03.lsp"

Reading "$reduce/cslbuild/generated-c/u04.lsp"

% u04.lsp           Machine generated Lisp

(c!:install "u04" 127950 6638866 7359898)
nil


(c!:install 'lex '(lex safe_atts char atts ch !$eof!$ space !< count
list2string get_token get_content notstring butes isvalid attributes) 
6774383505700854689)
lex


(c!:install 'ps!:get!-term '(ps!:get!-term !:ps!: ps!:order
ps!:last!-term ps!:getv) 10856925109236479609)
ps!:get!-term


(c!:install '!*q2a1 '(!*q2a1 mk!*sq prepsqxx) 927688556363511767)
!*q2a1


(c!:install 'replus1 '(replus1 plus) 3501446451937526220)
replus1


(c!:install 'peel '(peel (liedf innerprod) quotient worderp) 
1474301296103034713)
peel


(c!:install 'quotfm '(quotfm !*mcd quotf) 1152006984286044194)
quotfm


(c!:install 'idlistp '(idlistp) 14853692317672070322)
idlistp


(c!:install 'formlis '(formlis form1 reversip!*) 761340711108558520)
formlis


(c!:install 'bas_rep '(bas_rep nth) 5301928451121572698)
bas_rep


(c!:install 'pv_sort2 '(pv_sort2 pv_sort2a) 12843234465109260842)
pv_sort2


(c!:install 'ofsf_posdefp '(ofsf_posdefp !*rlpos ofsf_posdefp!-pos
sfto_tsqsumf) 3541930251710259147)
ofsf_posdefp


(c!:install 'quotf!-fail '(quotf!-fail !*rounded !*roundall poly
"UNEXPECTED DIVISION FAILURE" quotf rerror) 12538164146904265902)
quotf!-fail


(c!:install 'free!-powerp '(free!-powerp) 14743946471998162386)
free!-powerp


(c!:install 'invsq '(invsq poly "Zero divisor" !*rationalize rerror
revpr gcdchk canonsq) 5653382361166941628)
invsq


(c!:install 'kernord '(kernord kernord!-split kernord!-sort) 
15540519272858472938)
kernord


(c!:install 'negf '(negf dmode!* nreverse !:minus) 18425682831999215169)
negf


(c!:install 'mkwedge '(mkwedge) 6371839370084388030)
mkwedge


(c!:install 'scprint '(scprint !*utf8 posn!* utf8_scprint) 
12093415061379873120)
scprint


(c!:install 'qassoc '(qassoc) 11801307530585957207)
qassoc


(c!:install 'nonzero!-length '(nonzero!-length) 13279789547682091641)
nonzero!-length


(c!:install 'mo_ecart '(mo_ecart cali!=degrees cali!=basering mo_comp
mo_sum ring_ecart mo!=sprod) 3017722440507251153)
mo_ecart


(c!:install 'add_prin_char '(add_prin_char !*nat !*unicode_in_off_nat
posn!* ycoord!* pline!*) 9500969400492242253)
add_prin_char


(c!:install 'pv_sort '(pv_sort pv_sort1) 12067222525334524779)
pv_sort


(c!:install 'general!-modular!-number '(general!-modular!-number
current!-modulus) 15968753272500439570)
general!-modular!-number


(c!:install 'bfzerop!: '(bfzerop!:) 4144869744488506707)
bfzerop!:


(c!:install 'flatten!-sorted!-tree '(flatten!-sorted!-tree) 
15115184242697306585)
flatten!-sorted!-tree


(c!:install 'ordopcar '(ordopcar ordop) 15013377272736434367)
ordopcar


(c!:install 'checkargcount '(checkargcount name naryargs curfun!* hasarg
instdof) 11779892391777123742)
checkargcount


(c!:install 'treesizep1 '(treesizep1) 4179991401639837357)
treesizep1


(c!:install 'listeval '(listeval simpcount!* simplimit!*
"Simplification recursion too deep" rederr eval reval1) 
2250432181165746339)
listeval


(c!:install 'get!+col!+nr '(get!+col!+nr) 2016147149417159660)
get!+col!+nr


(c!:install 'cl_simplat '(cl_simplat !*rlidentify cl_identifyat
rl_simplat1 cl_apply2ats) 13024413398561650547)
cl_simplat


(c!:install 'fac!-merge '(fac!-merge multf) 9464410801670856120)
fac!-merge


(c!:install 'retimes '(retimes !*bool times minus retimes1) 
10466653925941673875)
retimes


(c!:install 'vevcompless!? '(vevcompless!? evcomp) 2298241748517527985)
vevcompless!?


(c!:install 'ordad '(ordad ordp) 5232203268885888725)
ordad


(c!:install 'round!:last '(round!:last !:rd!: lshift) 
11771289043284577007)
round!:last


(c!:install 'update!-pline '(update!-pline) 8413433348725287400)
update!-pline


(c!:install 'fprin2 '(fprin2 !*lower !*fortupper prin2!-upcase
prin2!-downcase) 11224564587785184818)
fprin2


(c!:install 'tensopp '(tensopp tensor isanindex) 15497026400427711128)
tensopp


(c!:install 'widestring2list '(widestring2list
"Improper byte in utf-8 string" string2list land moan!-if!-truncated
lshift error) 5728454958190311291)
widestring2list


(c!:install 'mo!=sum '(mo!=sum) 9378274341461733991)
mo!=sum


(c!:install 'lcm '(lcm gcdf quotf!-fail multf) 2991433227697465912)
lcm


(c!:install 'arzerop!: '(arzerop!:) 5710966682414274736)
arzerop!:


(c!:install 'simpexpon '(simpexpon simp!* simpexpon1) 
16107270373750224130)
simpexpon


(c!:install 'lalr_lr0_closure '(lalr_lr0_closure !. lalr_productions
union) 13122931596552059001)
lalr_lr0_closure


(c!:install 'rat_sgn '(rat_sgn rat_numrn sgn) 1641969354060249299)
rat_sgn


(c!:install 'anform '(anform !*globals locls!* glb2rf globs!* anform1) 
2819029936396861794)
anform


(c!:install 'praddf '(praddf addf) 17932848155221706316)
praddf


(c!:install 'tayexp!-plus2 '(tayexp!-plus2 !*i2rn rnplus!:) 
17543982543919753841)
tayexp!-plus2


(c!:install 'tmsf!* '(tmsf!* tmsf) 17129046060010787571)
tmsf!*


(c!:install 'cl_smrmknowl '(cl_smrmknowl) 9448754117248704526)
cl_smrmknowl


(c!:install 'isvalid '(isvalid functions!* !/ char compress!*) 
17957404616594273213)
isvalid


(c!:install 'revlis '(revlis reval) 12784786891327265868)
revlis


(c!:install 'rmsubs '(rmsubs !*sqvar!* alglist!*) 15196636406925854400)
rmsubs


(c!:install 'getroad '(getroad qassoc) 3298571974922732838)
getroad


(c!:install 'expdrmacro '(expdrmacro noexpand !*cref expand !*force
getrmacro) 18039924872036670149)
expdrmacro


(c!:install 'mo!=degcomp '(mo!=degcomp) 8626677450942799514)
mo!=degcomp


(c!:install 'dquot '(dquot) 3560671920954253512)
dquot


(c!:install 'insert_pv '(insert_pv sieve_pv pv_renorm insert_pv1) 
3928730491069730406)
insert_pv


(c!:install 'noncomp1 '(noncomp1 !*sq taylor!* mat noncomfp noncomlistp)
 16592810344229548862)
noncomp1


(c!:install 'rntimes!: '(rntimes!: mkrn) 16843820830970689749)
rntimes!:


(c!:install 'noncomdel '(noncomdel noncomp!* noncomdel1) 
9512117499868604191)
noncomdel


(c!:install 'frvarsof '(frvarsof frlis!*) 4938463613637485786)
frvarsof


(c!:install 'orderactions '(orderactions shift ordp) 9345515028130377688
)
orderactions


(c!:install 'ofsf_clnegrel '(ofsf_clnegrel ofsf_lnegrel) 
10718404464395059854)
ofsf_clnegrel


(c!:install 'quotf1 '(quotf1 !*mcd quotfd rank lt!* to negf multf addf
aconc!* rnconc ordop quotk) 8745973449872565457)
quotf1


(c!:install 'remove!-free!-vars '(remove!-free!-vars !~ !*!*noremove!*!*
frasc!* "free variable" frlis!* typerr get!-free!-form union
remove!-free!-vars!-l) 6786054341651147999)
remove!-free!-vars


(c!:install 'tayexp!-minusp '(tayexp!-minusp rnminusp!:) 
11440009276948992143)
tayexp!-minusp


(c!:install 'subs2 '(subs2 subfg!* !*sub2 powlis1!* slash !*match !*exp
subs2q exptchksq resimp subs3q subs4q) 9661079352785559604)
subs2


(c!:install 'mri_floorp '(mri_floorp floor) 15639793372292956144)
mri_floorp


(c!:install 'xxsort '(xxsort lambda_qrvi5bym67r22 sort) 
3188861117163028558)
xxsort


(c!:install 'lambda_qrvi5bym67r22 '(lambda_qrvi5bym67r22 termorder) 
16174915286514799361)
lambda_qrvi5bym67r22



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u04.lsp"

Reading "$reduce/cslbuild/generated-c/u05.lsp"

% u05.lsp           Machine generated Lisp

(c!:install "u05" 59962 9967390 5314157)
nil


(c!:install 'ibalp_cequal '(ibalp_cequal lto_setequalq) 
7258514506553550344)
ibalp_cequal


(c!:install 'vdp_poly '(vdp_poly) 1621136418650712159)
vdp_poly


(c!:install 'ev_comp '(ev_comp dip_sortevcomp!* apply) 
6308362367969480729)
ev_comp


(c!:install 'fullcopy '(fullcopy nreverse) 15320005618721388603)
fullcopy


(c!:install 'dm!-times '(dm!-times zero2nil !:times) 
10142955220570690041)
dm!-times


(c!:install 'getrtype1 '(getrtype1 !3vector) 17623002873539832421)
getrtype1


(c!:install 'vevtdeg '(vevtdeg) 390444595040601212)
vevtdeg


(c!:install 'safe!-fp!-minus '(safe!-fp!-minus !*nonegzerominus 0.0) 
5053334932847537604)
safe!-fp!-minus


(c!:install 'prin2!-downcase '(prin2!-downcase red!-char!-downcase) 
2999629200536730834)
prin2!-downcase


(c!:install 'readch1 '(readch1 peekchar!* !$eof!$ !*psl !*raise !*lower
!$eol!$ curline!* crbuf1!* crbuf!* !# !; unicode_character
named!-character!* u !U x !X hexdigit red!-char!-downcase char!-downcase
char!-upcase terminalp id2string string!-length list2string int2wideid) 
7903236607841033996)
readch1


(c!:install 'fs!:plus '(fs!:plus angles!-equal addsq fs!:angle!-order) 
13903516929866200135)
fs!:plus


(c!:install 'mo!=shorten '(mo!=shorten) 12559554740446522352)
mo!=shorten


(c!:install 'prin2!* '(prin2!* !*utf8 outputhandler!* overflowed!*
overflowed !*fort !*nat pi !.pi infinity !*rounded posn!* spare!*
testing!-width!* utf8_prin2!* fprin2!* symbol widelengthc i2rd!*
rd!:prin terpri!* add_prin_char prin2lint) 1841416926161410357)
prin2!*


(c!:install 'insert_pv1 '(insert_pv1 reduce_pv pv_renorm) 
13461779201674913131)
insert_pv1


(c!:install 'noncomp!* '(noncomp!* expt noncomp) 11520600477447941211)
noncomp!*


(c!:install 'mkgi '(mkgi !:gi!:) 5211409146390769880)
mkgi


(c!:install 'polynomclone '(polynomclone monomclone) 
16945265351910705256)
polynomclone


(c!:install 'gcdf '(gcdf !*exp !*rounded !*mcd !*ezgcd dmode!*
!*combineexpt free!-powerp gcdf1 ezgcdf minusf negf) 940727046805833939)
gcdf


(c!:install 'reordsq '(reordsq reorder) 6551028279869735544)
reordsq


(c!:install 'addsq '(addsq !*exp !*lcm !*gcd addf mkprod gcdf!* gcdf
quotf!-fail canonsq multf) 3539849522071400094)
addsq


(c!:install 'ckrn1 '(ckrn1 gck2 noncomp) 7007800398806749316)
ckrn1


(c!:install 'talp_negateat '(talp_negateat equal neq talp_op talp_arg2l
talp_arg2r talp_mk2) 6845920600026038126)
talp_negateat


(c!:install 'sort!-factors '(sort!-factors orderfactors sort) 
15458406081081601622)
sort!-factors


(c!:install 'mathml_list2string '(mathml_list2string) 
18208425034285005617)
mathml_list2string


(c!:install 'findrow '(findrow sparsemat) 7693175182874322505)
findrow


(c!:install 'groebsearchinlist '(groebsearchinlist buchvevdivides!?) 
8824115933558065593)
groebsearchinlist


(c!:install 'find_item '(find_item) 11091868128839770907)
find_item


(c!:install 'prin2la '(prin2la ncharspr!* laline!* chundexp) 
16636695083161034415)
prin2la


(c!:install 'command1 '(command1 cursym!* key!* scan setcloc!* xread1) 
15384879614138737363)
command1


(c!:install 'getel1 '(getel1 "array index" rlisp "Array out of bounds"
typerr rerror) 14149257150581464448)
getel1


(c!:install 'prepsqx '(prepsqx !*intstr prepsq!* prepsq) 
2057516612996716158)
prepsqx


(c!:install 'mo_sum '(mo_sum mo!=sum mo!=shorten mo!=deglist) 
11690513269509191580)
mo_sum


(c!:install 'resimp '(resimp varstack!* resimp1) 245030305365798647)
resimp


(c!:install 'pv_add '(pv_add) 13132997057459499096)
pv_add


(c!:install 'sgn '(sgn) 1074806718032526601)
sgn


(c!:install 'xcomment '(xcomment comment aconc) 312308063884810300)
xcomment


(c!:install 'absf '(absf minusf negf) 9890379060160977735)
absf


(c!:install 'talp_mkinv '(talp_mkinv) 9881918859696743090)
talp_mkinv


(c!:install 'rl_prepat '(rl_prepat rl_prepat!* apply) 
7678146107771699444)
rl_prepat


(c!:install 'ev_tdeg '(ev_tdeg) 2776263759101515019)
ev_tdeg


(c!:install 'listsum '(listsum) 4359773221243097064)
listsum


(c!:install 'indent!* '(indent!* indent ind) 15041536051208217428)
indent!*


(c!:install 'multi_isarb_int '(multi_isarb_int isarb_int) 
13178152468178755731)
multi_isarb_int


(c!:install 'c!:ordexp '(c!:ordexp c!:ordxp) 16045650534029472007)
c!:ordexp


(c!:install 'int!-equiv!-chk '(int!-equiv!-chk !*noequiv) 
3177926317644332068)
int!-equiv!-chk


(c!:install '!*collectphysops '(!*collectphysops
!*collectphysops_reversed) 16819877731731729102)
!*collectphysops


(c!:install 'dp_term '(dp_term) 1030431448728476156)
dp_term


(c!:install 'pv_sort1 '(pv_sort1 pv_sort2) 18324050516951395998)
pv_sort1


(c!:install 'modplus!: '(modplus!: general!-modular!-plus !*modular2f) 
10334211820605972842)
modplus!:


(c!:install 'ofsf_vareqnp '(ofsf_vareqnp sfto_varisnump) 
609914299391789314)
ofsf_vareqnp


(c!:install 'polynomadd '(polynomadd monomcompare) 2116639427254958855)
polynomadd


(c!:install 'rl_smmkatl '(rl_smmkatl rl_smmkatl!* apply) 
4189128276617618692)
rl_smmkatl


(c!:install 'setcar '(setcar) 8503541034644394161)
setcar


(c!:install 'multi_isarb_compl '(multi_isarb_compl isarb_compl) 
5408831469196759241)
multi_isarb_compl


(c!:install 'minus!: '(minus!: !:rd!:) 10147849189749433953)
minus!:


(c!:install 'depends '(depends frlis!* depl!* domain!-depends!-fn tensor
ldepends) 4176191591124326081)
depends


(c!:install 'dm!-difference '(dm!-difference zero2nil !:difference) 
15526280912238833915)
dm!-difference


(c!:install 'rd!:onep '(rd!:onep 1.0 !!fleps1 bfone!* bftrim!: equal!:) 
10840846068437734264)
rd!:onep


(c!:install 'simpminus '(simpminus minus carx simp negsq) 
5896211553045019281)
simpminus


(c!:install 'xdiv '(xdiv sublistp listdiff) 5481178236408994693)
xdiv


(c!:install 'getrmacro '(getrmacro macro inline smacro getd) 
14258017769871059051)
getrmacro


(c!:install 'mo_compare '(mo_compare cali!=basering revlex mo!=degcomp
ring_tag mo!=revlexcomp mo!=lexcomp) 1248999113790946364)
mo_compare


(c!:install 'vecp '(vecp !3vector vectorfn varithop vectormapping
isvectorindex hasonevector) 2250899134802842041)
vecp


(c!:install 'pv_applp '(pv_applp pappl0 pv_sort) 7635752925502425505)
pv_applp


(c!:install 'aronep!: '(aronep!:) 6005702156452897888)
aronep!:


(c!:install 'mod!# '(mod!# current!-modulus) 15684098227533559362)
mod!#


(c!:install 'gen!-mult!-by!-const!-mod!-p '(gen!-mult!-by!-const!-mod!-p
general!-modular!-times !*n2f) 13583715677638801333)
gen!-mult!-by!-const!-mod!-p


(c!:install 'copy!-vector '(copy!-vector) 18040727933833995838)
copy!-vector


(c!:install 'aconc '(aconc) 4286747449048000529)
aconc



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u05.lsp"

Reading "$reduce/cslbuild/generated-c/u06.lsp"

% u06.lsp           Machine generated Lisp

(c!:install "u06" 147316 9258670 4977558)
nil


(c!:install 'lalr_print_collection '(lalr_print_collection
"=== LALR ITEMSET COLLECTION ===" itemset_collection "Itemset " ordp " "
" ->" " [" "]" "/" symbols "GOTO(" ") = " sort lalr_prin_symbol
lalr_goto) 2909634294833788172)
lalr_print_collection


(c!:install 'convertmode '(convertmode form1 convertmode1) 
1419734818002222436)
convertmode


(c!:install 'subs3q '(subs3q mchfg!* subs3f quotsq) 3545428769602154647)
subs3q


(c!:install 'talp_smwcpknowl '(talp_smwcpknowl !*rlsusi cl_susicpknowl
cl_smcpknowl) 13028224229960715909)
talp_smwcpknowl


(c!:install 'qqe_qtidp '(qqe_qtidp qt) 4509446187774578496)
qqe_qtidp


(c!:install 'algid '(algid) 3742255102945651473)
algid


(c!:install 'emtch '(emtch opmtch) 9395393102454316218)
emtch


(c!:install 'pnthxzz '(pnthxzz) 4749855178029359567)
pnthxzz


(c!:install 'csl_timbf '(csl_timbf (!:rd!: 0 . 0) !:bprec!: !:rd!: inorm
) 18165318944716659070)
csl_timbf


(c!:install 'putpline '(putpline posn!* spare!* orig!* ycoord!* pline!*
ymin!* ymax!* terpri!* update!-pline min max) 9984476619971481198)
putpline


(c!:install '!:times '(!:times times dcombine) 7317178501310073043)
!:times


(c!:install 'mkrn '(mkrn !:rn!:) 8615064137746325980)
mkrn


(c!:install 'gperm1 '(gperm1 rev) 5120862869177590181)
gperm1


(c!:install 'evaluate!-in!-order '(evaluate!-in!-order !*d2n
horner!-rule) 9840903884908678569)
evaluate!-in!-order


(c!:install 'delete_from_alglist '(delete_from_alglist remhash) 
16769384104373499423)
delete_from_alglist


(c!:install 'gcdf!* '(gcdf!* !*gcd gcdf) 4435744738542786350)
gcdf!*


(c!:install 'prin2t '(prin2t) 5370635860544999099)
prin2t


(c!:install 'reval1 '(reval1 !*revalp varstack!* dmode!* subfg!* evfn
structfn !*sq !*resimp cleanupfn alg "Missing evaluation for type" list
aggregatefn matrixmap matmapfn boolean !*listargs listargp reval2
recursiveerror apply errpri2 prepsqxx rmmbreval opfneval arrayp getelv
getrtype rerror) 7659408201389900324)
reval1


(c!:install 'sfto_dcontentf1 '(sfto_dcontentf1 absf sfto_gcdf) 
10251860885825888217)
sfto_dcontentf1


(c!:install 'sqchk '(sqchk prepf) 15584170906883106856)
sqchk


(c!:install 'removev '(removev "Vertex" "is absent." cerror) 
11755252615704088808)
removev


(c!:install 'talp_simplat1 '(talp_simplat1 true false talp_simpat
talp_op talp_arg2l talp_arg2r talp_simplat2) 4143642023805816654)
talp_simplat1


(c!:install 'ibalp_varlat '(ibalp_varlat ibalp_arg2l ibalp_varlt
ibalp_arg2r union) 3082100373558802606)
ibalp_varlat


(c!:install 'quotfd '(quotfd dmode!* divd quotdd quotk) 
12457232032859727359)
quotfd


(c!:install 'mathml '(mathml lex sub_math) 2254284459118856999)
mathml


(c!:install 'sortcolelem '(sortcolelem) 2821064227035305453)
sortcolelem


(c!:install 'prepf1a_reversed '(prepf1a_reversed plus difference minus
k!* prepd exchk retimes) 3920782612352183888)
prepf1a_reversed


(c!:install 'comm_kernels '(comm_kernels comm_kernels1) 
1085729417501072384)
comm_kernels


(c!:install 'fast!-column!-dim '(fast!-column!-dim) 6536696017703085317)
fast!-column!-dim


(c!:install 'evtdeg '(evtdeg) 11402388914802951445)
evtdeg


(c!:install 'mknwedge '(mknwedge wedge) 9273441016196573903)
mknwedge


(c!:install '!:plus '(!:plus plus dcombine) 14295972896338778478)
!:plus


(c!:install 'getelv '(getelv reval_without_mod getel) 
16897334088165199342)
getelv


(c!:install 'dp!=ecart '(dp!=ecart dp_lmon mo_ecart) 1513483039109638609
)
dp!=ecart


(c!:install 'tsym4 '(tsym4 pv_applp sieve_pv pv_renorm insert_pv) 
11594712105546691380)
tsym4


(c!:install 'set_svf '(set_svf setk) 15603250658461753273)
set_svf


(c!:install 'gcddd '(gcddd gcd fieldp dcombine) 6392150503747631200)
gcddd


(c!:install 'anform1 '(anform1 dclglb glb2rf globs!* locls!* noanl anlfn
anforml add2calls checkargcount) 11765923365426148039)
anform1


(c!:install 'freeofl '(freeofl freeof) 1695728625742780640)
freeofl


(c!:install 'mri_type '(mri_type) 14400215089325008231)
mri_type


(c!:install 'pasf_dec '(pasf_dec negf addf) 13159550184310097093)
pasf_dec


(c!:install 'cgp_evlmon '(cgp_evlmon cgp_rp dip_evlmon) 
11503118130341470008)
cgp_evlmon


(c!:install 'times!-mod!-p '(times!-mod!-p
multiply!-by!-constant!-mod!-p times!-term!-mod!-p plus!-mod!-p ordop) 
11674828902396525929)
times!-mod!-p


(c!:install 'omobj '(omobj char omfuncs!* compress!* apply) 
552316010938588333)
omobj


(c!:install 'sqform '(sqform quotient) 12561050226564334981)
sqform


(c!:install 'mk!*sq '(mk!*sq list !*sq !*resubs !*sqvar!* expchk kernp) 
6963996289700059966)
mk!*sq


(c!:install 'subscriptedvarp '(subscriptedvarp subscripted symtabget) 
10047303296984028393)
subscriptedvarp


(c!:install 'exptchk '(exptchk comm_kernels exptchk0) 
7218657526841631203)
exptchk


(c!:install 'order!: '(order!: msd) 2743596083191641400)
order!:


(c!:install 'areallindices '(areallindices isanindex) 299020035761465616
)
areallindices


(c!:install '!*ssave '(!*ssave !*uncached alglist!* !*sub2
alglist_count!* alglist_limit!* 2.0 simpcount!* mkhash puthash) 
17682649696344827703)
!*ssave


(c!:install 'red!-weight '(red!-weight nonzero!-length red!-weight1) 
4249037292437646850)
red!-weight


(c!:install 'dp_diff '(dp_diff dp_neg dp_sum) 12366907914249003617)
dp_diff


(c!:install 'resimp1 '(resimp1 !*sub2 subf1 quotsq) 16917756133474648583
)
resimp1


(c!:install 'pv_sort2a '(pv_sort2a) 13353353018645474506)
pv_sort2a


(c!:install 'starts!-with '(starts!-with !\ !/) 7337007207677606629)
starts!-with


(c!:install 'sfto_davp '(sfto_davp) 17491099964523223853)
sfto_davp


(c!:install 'talp_varlt1 '(talp_varlt1 talp_getl lto_insert talp_argl
union) 17322878992346705249)
talp_varlt1


(c!:install 'mri_simplfloor '(mri_simplfloor mri_floorkernelp
mri_simplfloor1) 16657927298066891305)
mri_simplfloor


(c!:install 'qqe_prepat '(qqe_prepat) 18399950725634295861)
qqe_prepat


(c!:install 'eolcheck '(eolcheck !*eoldelimp nxtsym!* !$eol!$ cursym!*
end !; token) 279026188828444361)
eolcheck


(c!:install 'mcharg1 '(mcharg1 matchlength!* mchcomb mkbin mchsarg mtp
pair mcharg2) 7180069116472231263)
mcharg1


(c!:install 'boundindp '(boundindp) 7981918625673461700)
boundindp


(c!:install 'chundexp '(chundexp !_ !\) 8745084979690390780)
chundexp


(c!:install 'red!-char!-downcase '(red!-char!-downcase charassoc!*) 
11739339504623139397)
red!-char!-downcase


(c!:install 'physopp!* '(physopp!* physopfn physoparith physopmapping
physopp hasonephysop) 4688643543797558505)
physopp!*


(c!:install 'macrochk '(macrochk symbolic macrofn expdrmacro) 
6624621222934061550)
macrochk


(c!:install 'getel '(getel dimension rlisp "Incorrect array reference"
rerror getel1) 10029705835642610942)
getel


(c!:install 'mo!=lexcomp '(mo!=lexcomp (0)) 12857211769790526072)
mo!=lexcomp


(c!:install 'gperm '(gperm gperm0 pkp) 6978857666060417365)
gperm


(c!:install 'copy '(copy nreverse) 11644407946646413746)
copy


(c!:install '!*modular2f '(!*modular2f !*balanced_mod current!-modulus
!:mod!:) 17480095946135970011)
!*modular2f


(c!:install 'general!-modular!-quotient '(general!-modular!-quotient
general!-modular!-reciprocal general!-modular!-times) 
10028416593412426364)
general!-modular!-quotient


(c!:install 'minus!-mod!-p '(minus!-mod!-p nreverse) 
13865097314770874216)
minus!-mod!-p



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u06.lsp"

Reading "$reduce/cslbuild/generated-c/u07.lsp"

% u07.lsp           Machine generated Lisp

(c!:install "u07" 19092 3978830 9998442)
nil


(c!:install 'clear!-column '(clear!-column null!-space!-basis) 
2174171855257234860)
clear!-column


(c!:install 'lalr_add_goto '(lalr_add_goto goto_table gethash puthash) 
17729286800343653061)
lalr_add_goto


(c!:install 'wulessp '(wulessp wuconstantp symbollessp) 
799452387677490987)
wulessp


(c!:install 'talp_smwupdknowl '(talp_smwupdknowl !*rlsusi cl_smupdknowl
talp_smupdknowl) 11365454144261299625)
talp_smwupdknowl


(c!:install 'mri_0mk2 '(mri_0mk2) 16051666004088395260)
mri_0mk2


(c!:install 'rl_simpat '(rl_simpat rl_simpat!* apply) 
14907637319273239108)
rl_simpat


(c!:install 'ibalp_varlt1 '(ibalp_varlt1 lto_insertq ibalp_argn) 
15073405374690958584)
ibalp_varlt1


(c!:install 'ev_invlexcomp '(ev_invlexcomp iequal) 301871774651962531)
ev_invlexcomp


(c!:install 'powers2 '(powers2 powers4) 18389454131571423670)
powers2


(c!:install 'find '(find != !" !$ (stop) !/ (d e f i n i t i o n u r l)
!  find2 delall compress!*) 16338933635983901873)
find


(c!:install 'simp!* '(simp!* !*asymp!* !*sq !*resimp mul!* !*sub2
!*nospurp (isimpq) !*combinelogs dmode!* !:gi!: !*norationalgi
!*rationalize simp union subs2 clogsq!* girationalize!: rationalizesq
rationalizei gcdchk) 14819034963591409791)
simp!*


(c!:install 'downwght '(downwght delhisto downwght1 inshisto) 
16079583727061489875)
downwght


(c!:install 'freexp '(freexp pm!:free) 2227958442769940130)
freexp


(c!:install 'termordp '(termordp wedgefax monordp) 217193576870404836)
termordp


(c!:install 'gizerop!: '(gizerop!:) 15668976833653917251)
gizerop!:


(c!:install 'repeatsp '(repeatsp) 8005844584162456289)
repeatsp


(c!:install 'bc!=simp '(bc!=simp cali
"recursion depth of bc!=simp too high" qremf multf addf rederr) 
15256469392559574114)
bc!=simp


(c!:install 'gperm2 '(gperm2 rev gperm1) 18064284019234804902)
gperm2


(c!:install 'exptmod!: '(exptmod!: general!-modular!-expt !*modular2f) 
15369828140386100024)
exptmod!:


(c!:install 'convprec!* '(convprec!* !:rd!: convchk) 1859208267860746683
)
convprec!*


(c!:install 'rat_numrn '(rat_numrn) 10709366573743677142)
rat_numrn


(c!:install 'freeof '(freeof depl!* smember) 3637959333020234962)
freeof


(c!:install 'gcdf1 '(gcdf1 !*anygcd !*gcd dmode!* (!:rd!: !:cr!:)
"gcdf failed" gcdfd num!-exponents quotf1 gcdf2 noncomfp prepf errach) 
418753600749232228)
gcdf1


(c!:install 'talp_smupdknowl '(talp_smupdknowl false break
talp_smupdknowl1) 2521773602485433729)
talp_smupdknowl


(c!:install 'qqe_id!-nyt!-branchb '(qqe_id!-nyt!-branchb qqe_btidp
qqe_nytidp qqe_qopaddp qqe_qoptailp) 13310094407739766078)
qqe_id!-nyt!-branchb


(c!:install 'pasf_deci '(pasf_deci pasf_dec) 7606875779504539690)
pasf_deci


(c!:install 'ibalp_litlp '(ibalp_litlp ibalp_litp) 8695577270835652998)
ibalp_litlp


(c!:install 'mintype '(mintype) 7023828771997735570)
mintype


(c!:install 'prepd '(prepd minus prepfn !:minus prepd1) 
16549409407206613223)
prepd


(c!:install 'quotematrix '(quotematrix matrix) 9634185097357256809)
quotematrix


(c!:install 'deg!*farg '(deg!*farg deg!*form addf) 11582492540121933055)
deg!*farg


(c!:install 'make!-set '(make!-set set!-ordp sort makelist) 
17863511358970148213)
make!-set


(c!:install 'optype '(optype !*optype!*) 3778890871487542886)
optype


(c!:install 'setcloc!* '(setcloc!* ifl!* curline!* cloc!*) 
3259902650283198162)
setcloc!*


(c!:install 'red_divtestbe '(red_divtestbe bas_dpecart bas_dpoly dp_lmon
mo_vdivides!?) 8745092154154609337)
red_divtestbe


(c!:install 'pappl_pv '(pappl_pv pappl0 pv_sort) 12865351114010935612)
pappl_pv


(c!:install '!*i2ar '(!*i2ar !:ar!:) 10560348635455940300)
!*i2ar


(c!:install 'general!-modular!-minus '(general!-modular!-minus
current!-modulus) 7446043339403337171)
general!-modular!-minus


(c!:install 'lalr_analyze_lookaheads '(lalr_analyze_lookaheads
itemset_collection (-1) !. lalr_closure lalr_goto lalr_lr0_move_dot
lalr_item_with_rule lalr_add_lookahead) 2902620670388623196)
lalr_analyze_lookaheads


(c!:install 'powers1 '(powers1 powers3 powers2) 7558645644074747293)
powers1


(c!:install 'cl_atfp '(cl_atfp true false or and not impl repl equiv ex
all bex ball) 16317418177497158700)
cl_atfp


(c!:install 'quotk '(quotk quotf1) 7655743017610255852)
quotk


(c!:install 'multi_elem '(multi_elem expression) 15754855898525001441)
multi_elem


(c!:install 'letmtr3 '(letmtr3 sparsemat matrix "Matrix" "not set" hold
cx rerror revlis numlis errpri2 sortcolelem) 14473509980124684464)
letmtr3


(c!:install 'nextarg '(nextarg symm s!-nextarg o!-nextarg) 
16482704159804204717)
nextarg


(c!:install 'diplength '(diplength) 14871242854063033043)
diplength


(c!:install 'divide!: '(divide!: !:rd!: msd conv!:mt round!:mt) 
822680077161613832)
divide!:


(c!:install 'list2widestring '(list2widestring ""
"Invalid item in arg to list2widestring"
"Negative integer in list2widestring"
"Integer too large in list2widestring" widestring2list rederr error
allocate!-string string!-store lshift land string!-store2 string!-store3
string!-store4) 4879502497584558050)
list2widestring


(c!:install 'groeb!=testa '(groeb!=testa nth mo_divides!?) 
4982525962249251425)
groeb!=testa


(c!:install 'dv_skelhead '(dv_skelhead dv_cambhead) 17417041200199632033
)
dv_skelhead


(c!:install 'rnplus!: '(rnplus!: mkrn) 1535836573879756582)
rnplus!:


(c!:install 'lalr_remove_duplicates '(lalr_remove_duplicates) 
13596569393979284913)
lalr_remove_duplicates


(c!:install 'sfto_gcdf '(sfto_gcdf !*rldavgcd !*ezgcd gcdf sfto_davp
ezgcdf) 16666557222424495593)
sfto_gcdf


(c!:install 'totallessp '(totallessp less totalcompare) 
2780895902761703900)
totallessp


(c!:install 'talp_tcfrp '(talp_tcfrp talp_invp) 1030780893080362627)
talp_tcfrp


(c!:install 'pasf_susitf '(pasf_susitf) 13004730534395993431)
pasf_susitf


(c!:install 'times!-term!-mod!-p '(times!-term!-mod!-p
multiply!-by!-constant!-mod!-p mksp times!-mod!-p ordop) 
12134610716879626746)
times!-term!-mod!-p


(c!:install 'omobjs '(omobjs char (!/ o m a) omobj lex) 
13807968452401441856)
omobjs


(c!:install 'bound '(bound unbound binding) 13956817632156004274)
bound


(c!:install 'freeindexchk '(freeindexchk indxl!*
form!-with!-free!-indices indxchk) 11921768991783730918)
freeindexchk


(c!:install 'worderp '(worderp kord!* indexvarordp ordop peel) 
6886687244145475157)
worderp


(c!:install 'vecopp '(vecopp vector isanindex) 3613955425733007325)
vecopp


(c!:install 'sroad '(sroad nreverse) 3816325071880864422)
sroad


(c!:install 'simpplus '(simpplus ckpreci!# simpcar addsq) 
13307383627601434855)
simpplus


(c!:install 'mv!-pow!-mv!-term!-!+ '(mv!-pow!-mv!-term!-!+ mv!-pow!-!+) 
10270817876720591082)
mv!-pow!-mv!-term!-!+


(c!:install 'dp_ecart '(dp_ecart dp!=ecart dp_lmon mo_ecart) 
6091531937966727815)
dp_ecart


(c!:install 'adddummy1a '(adddummy1a pappl_pv insert_pv) 
17246486385526803890)
adddummy1a



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u07.lsp"

Reading "$reduce/cslbuild/generated-c/u08.lsp"

% u08.lsp           Machine generated Lisp

(c!:install "u08" 11333 5477096 8454293)
nil


(c!:install 'general!-plus!-mod!-p '(general!-plus!-mod!-p nreverse
general!-modular!-plus !*n2f ordop) 15694382996916044951)
general!-plus!-mod!-p


(c!:install 'get_first_kernel '(get_first_kernel gfk) 
15648336848191114505)
get_first_kernel


(c!:install 'lalr_precedence '(lalr_precedence precedence_table) 
5285271617135623330)
lalr_precedence


(c!:install 'diff '(diff multf diffp1 addf) 2605274499258555896)
diff


(c!:install 'talp_varlat '(talp_varlat talp_arg2l talp_varlt talp_arg2r
union) 16180238194531187409)
talp_varlat


(c!:install 'rl_gettype '(rl_gettype) 1792825115883707683)
rl_gettype


(c!:install 'quotfail!-mod!-p '(quotfail!-mod!-p exact!-quotient!-flag
"Quotient not exact (mod p)" quotient!-mod!-p errorf) 
1317977702197480167)
quotfail!-mod!-p


(c!:install 'retattributes '(retattributes find) 17993207373981413162)
retattributes


(c!:install 'round!:mt '(round!:mt !:rd!: msd round!:last ashift
bflerrmsg) 5455266803712742649)
round!:mt


(c!:install 'eofcheck '(eofcheck program!* !$eof!$ ttype!* eof!*) 
12693317518809967104)
eofcheck


(c!:install 'divd '(divd poly "0/0 formed" "Zero divisor" rerror
nreverse divdm) 14596174159620176409)
divd


(c!:install 'dp_times_bc '(dp_times_bc cali_bc_prod) 7292056026877438446
)
dp_times_bc


(c!:install 'pdmult '(pdmult pair) 1769095089218186773)
pdmult


(c!:install 'mcharg2 '(mcharg2 mchk updtemplate msappend lastpair) 
8310717807567935274)
mcharg2


(c!:install 'cancel '(cancel !*mcd multsq mk!*sq simpexpt) 
2615146117212680732)
cancel


(c!:install 'canonsq '(canonsq asymplis!* difference dmode!* unitsfn
gcdf quotf!-fail lnc negf fieldconv) 1341355762807092992)
canonsq


(c!:install 'rassoc '(rassoc) 4874041693837250365)
rassoc


(c!:install 'anforml '(anforml !*globals locls!* glb2rf globs!* anform) 
14423759540013469578)
anforml


(c!:install 'cdarx '(cdarx cdar carx) 3213420843911737010)
cdarx


(c!:install 'talp_atfp '(talp_atfp (neq equal) talp_op) 
11744740902497746626)
talp_atfp


(c!:install 'ibalp_simpat '(ibalp_simpat ibalp_simpterm ibalp_mk2) 
12585734351966318121)
ibalp_simpat


(c!:install 'checktag '(checktag char "Problem" "problem" errorml) 
11657895875962433019)
checktag


(c!:install 'subs2f1 '(subs2f1 powlis!* expt quotient alglist!* dmode!*
powlis1!* !*structure !*exp times !*d2q degr subs2p simp exptsq cancel
raddsq multsq mtchp addsq mkprod mksq simpexpt) 127942258716955345)
subs2f1


(c!:install 'bcsum '(bcsum !*grmod!* plus2 bcfi bcint2op addsq bccheckz)
 8246123458018695289)
bcsum


(c!:install 'vevmaptozero1 '(vevmaptozero1) 5413646659924096645)
vevmaptozero1


(c!:install 'deg!*form '(deg!*form wedge d hodge dimex!* partdf liedf
innerprod (plus minus difference quotient) times !*sq deg!*farg addd
negf addf simp!* prepsq) 5903215969894583510)
deg!*form


(c!:install 'physopsim!* '(physopsim!* !:dn!: simp prepsq !*physopp!*
physopsm!*) 9272985490652343806)
physopsim!*


(c!:install 'rread '(rread " '" prin2x rread1) 11718658437400776781)
rread


(c!:install 'reval2 '(reval2 !*combineexpt dmode!* !*mcd simp!* !*q2a1) 
14942434520619058194)
reval2


(c!:install 'red!-weight1 '(red!-weight1) 18193212404213536799)
red!-weight1


(c!:install 'bas_make1 '(bas_make1 dp_ecart) 8684791487173625242)
bas_make1


(c!:install 'hevenp '(hevenp) 18344645686636477175)
hevenp


(c!:install 'yyreadch '(yyreadch lex_peek_char lex_char !$eol!$
which_line !$eof!$ last64p last64) 9000167786505618202)
yyreadch


(c!:install 'talp_candp '(talp_candp true talp_arg2l talp_arg2r
talp_invp talp_invarg) 14705223956677754842)
talp_candp


(c!:install 'ibalp_litp '(ibalp_litp not ibalp_atomp) 
14968165359185496103)
ibalp_litp


(c!:install 'rationalizei '(rationalizei i kord!* (i . 1) reordsq to
negf multf addf) 14087879749653327036)
rationalizei


(c!:install 'genp '(genp gen mgenp) 15549188022134307524)
genp


(c!:install 'xdegreemon '(xdegreemon xdegreelist!* mknwedge xdegree) 
11940686756163340154)
xdegreemon


(c!:install 'evaluate0 '(evaluate0 evaluate!-horner evaluate1) 
13985323310385376309)
evaluate0


(c!:install 'domain!*p '(domain!*p domainlist!*) 2444284547095513599)
domain!*p


(c!:install 'rnquotient!: '(rnquotient!: mkrn) 12337815946570309451)
rnquotient!:


(c!:install 'gintequiv!: '(gintequiv!:) 170157521522791609)
gintequiv!:


(c!:install 'procstat '(procstat procstat1) 2761016754500269744)
procstat


(c!:install '!*sqprint '(!*sqprint sqprint) 14862046607707741929)
!*sqprint


(c!:install 'mcharg '(mcharg minus slash reform!-minus mcharg1
reform!-minus2 lastpair) 4756747130301868943)
mcharg


(c!:install 'tayexp!-min2 '(tayexp!-min2 tayexp!-lessp) 
450066141476525100)
tayexp!-min2


(c!:install 'talp_smupdknowl1 '(talp_smupdknowl1 or false rl_negateat
talp_chkknowl) 18164921448930879520)
talp_smupdknowl1


(c!:install 'ibalp_atomp '(ibalp_atomp true false equal ibalp_arg2l
ibalp_arg2r) 17773256308332994895)
ibalp_atomp


(c!:install 'isarb_int '(isarb_int arbint found_int multi_isarb_int) 
8903692645515055984)
isarb_int


(c!:install 'retimes1 '(retimes1 !*bool minus times nreverse) 
17736752905380124428)
retimes1


(c!:install 'vdpsave '(vdpsave) 15921798368784988889)
vdpsave


(c!:install 'gsetsugar '(gsetsugar !*gsugar sugar vdptdeg vdpputprop) 
5956100697013325100)
gsetsugar


(c!:install 'add2inputbuf '(add2inputbuf !*nosave!* statcounter
inputbuflis!* terminalp) 3273988650128620738)
add2inputbuf


(c!:install 'simpdiff '(simpdiff ckpreci!# simpcar simpminus addsq) 
8946894650303966450)
simpdiff


(c!:install 'mv!-pow!-minusp '(mv!-pow!-minusp) 6164394581063889849)
mv!-pow!-minusp


(c!:install 'mo!=deglist '(mo!=deglist cali!=basering cali!=degrees
ring_degrees mo!=sprod mo!=sum) 15139313571954972261)
mo!=deglist


(c!:install 'psum '(psum dless csum c_zero) 15539650795427356691)
psum


(c!:install 'pv_neg '(pv_neg) 14910564455100054419)
pv_neg


(c!:install 'klistt '(klistt list nreverse carx) 4034108837235650161)
klistt



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u08.lsp"

Reading "$reduce/cslbuild/generated-c/u09.lsp"

% u09.lsp           Machine generated Lisp

(c!:install "u09" 17393 87383 7123850)
nil


(c!:install 'quotdd '(quotdd quotient dcombine) 15747830918764825106)
quotdd


(c!:install 'xread '(xread !*eoldelimp cursym!* !*semicol!* scan xread1)
 11023064693632726099)
xread


(c!:install 'prepsq!*2 '(prepsq!*2 prepsq!*1 replus) 
18407660482813847948)
prepsq!*2


(c!:install 'talp_invf '(talp_invf talp_op) 9779812008113020496)
talp_invf


(c!:install 'bc_prod '(bc_prod multsq) 1177742759903326742)
bc_prod


(c!:install 'redmsg '(redmsg !*wsm !*msg ("operator" "predicate")
"Declare" "?" "declared" terminalp get!-print!-name yesp lprim) 
6641158512662921381)
redmsg


(c!:install 'multiom '(multiom objectom) 15929192743078869346)
multiom


(c!:install 'isarb_compl '(isarb_compl arbcomplex found_compl
multi_isarb_compl) 15012797369163340989)
isarb_compl


(c!:install 'rdprep1 '(rdprep1 !:bprec!: round!:mt) 18216582633526192308
)
rdprep1


(c!:install 'variables '(variables dipvars!* setcar) 
10343379667208443626)
variables


(c!:install 'layout!-formula '(layout!-formula ycoord!* ymin!* ymax!*
posn!* pline!* testing!-width!* overflowed!* orig!* inbrackets "(" ")"
prin2!* oprin maprint) 12015381067414281630)
layout!-formula


(c!:install 'noncomp2f '(noncomp2f) 14081071292129621302)
noncomp2f


(c!:install 'contrsp2 '(contrsp2) 14356978763788615465)
contrsp2


(c!:install 'token1 '(token1 crchar!* !$eof!$ !$eol!$ !*eoldelimp
tokprop !% !*savecomments!* !! !*micro!-version !*defn !" !\ ttype!* ! 
nxtsym!* !- !*minusliter minus !*raise !*lower escaped!* !_ !:
!*line!-marker curline!* !*file!-marker ifl!* "Terminal" (!\ e n d !{ r
e d u c e !}) peekchar!* (!\ b e g i n !{ r e d u c e !})
"Name with double colon in detected:" named!-character!*
"***** End-of-file in string" id2string string!-length readch1
token!-number lispapply filenderr delcp wideid2list reversip!*
list2wideid string2list lprim lpriw list2widestring) 4739059618500721391
)
token1


(c!:install 'ckpreci!# '(ckpreci!# !*complex timesip ckprec2!#) 
13289633892301930237)
ckpreci!#


(c!:install 'mo_diff '(mo_diff mo_neg mo_sum) 4737960852278499905)
mo_diff


(c!:install 'pneg '(pneg cneg) 3398941309386812445)
pneg


(c!:install 'th_match0 '(th_match0) 2982220586190952863)
th_match0


(c!:install 'general!-times!-term!-mod!-p '(general!-times!-term!-mod!-p
gen!-mult!-by!-const!-mod!-p general!-times!-mod!-p mksp ordop) 
14419219641158729975)
general!-times!-term!-mod!-p


(c!:install 'abs!: '(abs!: !:rd!:) 7892898378426028628)
abs!:


(c!:install 'gionep!: '(gionep!:) 11176582685932153680)
gionep!:


(c!:install 'cde_position2 '(cde_position2) 14901444118537836697)
cde_position2


(c!:install 'valid_as_variable '(valid_as_variable invalid_as_variable) 
6252451321075174222)
valid_as_variable


(c!:install 'talp_simplat2 '(talp_simplat2 talp_invp talp_simplatrinv
talp_simplatat talp_simplatlinv talp_simplatfn) 3139232003655203481)
talp_simplat2


(c!:install 'cl_varl2 '(cl_varl2 true false or and not impl repl equiv
ex all bex ball lto_insertq rl_varlat) 10566558371690964264)
cl_varl2


(c!:install 'ev_revgradlexcomp '(ev_revgradlexcomp iequal ev_tdeg
ev_invlexcomp) 8235021195797815324)
ev_revgradlexcomp


(c!:install 'equal!: '(equal!: normbf) 11244774644015991854)
equal!:


(c!:install 'difff '(difff domain!-diff!-fn s s_changes_parity
t_changes_parity fermionicp negf multsq diffdp diffp addsq) 
14512842943860019511)
difff


(c!:install 'symtabget '(symtabget name !*symboltable!* (!*type!*
!*params!* !*decs!*)) 5525571283205113483)
symtabget


(c!:install 'getphystype '(getphystype scalar vector tensor state
phystypefn "PHYSOP type conflict in" physopp scalopp vecopp tensopp
po!:statep collectphystype rederr2) 838306680328065380)
getphystype


(c!:install 'lispapply '(lispapply rlisp "Apply called with non-id arg"
rerror apply) 4669262363814808279)
lispapply


(c!:install 'mv!-pow!-!+ '(mv!-pow!-!+ nreverse) 10908168933389479128)
mv!-pow!-!+


(c!:install 'kernp '(kernp) 9280616224236729168)
kernp


(c!:install 'conv!:bf2i '(conv!:bf2i ashift) 6030167484524119975)
conv!:bf2i


(c!:install 'qcputx '(qcputx quote cref compile) 7237109528981265370)
qcputx


(c!:install 'rmplus '(rmplus plus) 17073056096781679049)
rmplus


(c!:install 'comfac '(comfac dmode!* lnc !:recip multd degr noncomp gcdf
) 5277967335908146726)
comfac


(c!:install 'talp_ordatp '(talp_ordatp true talp_simpat talp_arg2l
talp_tordp talp_arg2r) 16605772488172605382)
talp_ordatp


(c!:install 'searchpl '(searchpl searchtm setunion) 12905123180357682487
)
searchpl


(c!:install 'intexprnp '(intexprnp !*revalp integer intfn intexprlisp) 
14587433259339952408)
intexprnp


(c!:install 'lpriw '(lpriw ofl!* !*fort !*nat !*defn lpri) 
5536387859388148444)
lpriw


(c!:install 'testred '(testred codmat maxvar downwght1) 
4753241407180497846)
testred


(c!:install 'off_mod_reval '(off_mod_reval !*modular modular off reval
on) 12140980420647729975)
off_mod_reval


(c!:install 'simpindexvar '(simpindexvar partitindexvar !*pf2sq) 
17822470104714462053)
simpindexvar


(c!:install 'dim!<deg '(dim!<deg dimex!* deg!*farg negf addf) 
7251850768166510267)
dim!<deg


(c!:install 'opnum!* '(opnum!* opnum collectindices removeindices) 
4437767772325788303)
opnum!*


(c!:install 'mapcons '(mapcons) 18184870184519584626)
mapcons


(c!:install '!*i2gi '(!*i2gi !:gi!:) 1223087745230862844)
!*i2gi



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u09.lsp"

Reading "$reduce/cslbuild/generated-c/u10.lsp"

% u10.lsp           Machine generated Lisp

(c!:install "u10" 87015 5957201 2180113)
nil


(c!:install 'ptoken '(ptoken !) outl!* !  !( token prin2x) 
8915379530439987008)
ptoken


(c!:install 'formc '(formc !*rlisp88 modefn symbolic
"algebraic expression" "Rlisp88 form" algebraic typerr intexprnp
convertmode) 7997369177657568609)
formc


(c!:install 'wuorderp '(wuorderp wukord!* yes no) 8906965046080400780)
wuorderp


(c!:install 'freevarinexptchk '(freevarinexptchk) 4178118939591073996)
freevarinexptchk


(c!:install 'talp_smwmkatl '(talp_smwmkatl !*rlsusi cl_susimkatl
cl_smmkatl) 4396288828514490291)
talp_smwmkatl


(c!:install 'chknewnam '(chknewnam) 14053735864040956746)
chknewnam


(c!:install 'smtp '(smtp sparsemat spm matrix "Matrix" "not set"
mkempspmat rerror findrow letmtr3) 17327195793579896949)
smtp


(c!:install 'take!-realpart '(take!-realpart repartf multsq) 
9070378222395813219)
take!-realpart


(c!:install 'assert_analyze '(assert_analyze assertstatistics!*
lambda_46uwl1lq71ua2 (function !#calls !#bad! calls
!#assertion! violations) sum " " "-" sort prin2t) 4783383686943766855)
assert_analyze


(c!:install 'lambda_46uwl1lq71ua2 '(lambda_46uwl1lq71ua2 ordp) 
1813469934075966741)
lambda_46uwl1lq71ua2


(c!:install 'dp_sum '(dp_sum dp_lmon mo_compare dp_lc cali_bc_sum
cali_bc_zero!? dp_term) 13531247209958170102)
dp_sum


(c!:install '!*q2f '(!*q2f polynomial prepsq typerr) 8910299028062321553
)
!*q2f


(c!:install 'exptf1 '(exptf1 multf) 10681007596565985967)
exptf1


(c!:install 'portable_print '(portable_print portable_prin) 
231109164927082807)
portable_print


(c!:install 'polynommultiplybymonom '(polynommultiplybymonom
polynomclone polynommultiplybyvariable) 7544476021699951062)
polynommultiplybymonom


(c!:install 'wulessp!* '(wulessp!* wulessp totallessp) 
17553717216871474355)
wulessp!*


(c!:install 'matrix!+p '(matrix!+p) 14190898046507498077)
matrix!+p


(c!:install 'cl_fvarl1 '(cl_fvarl1 cl_varl1) 8522948151680983405)
cl_fvarl1


(c!:install 'lastnondomain '(lastnondomain "non-domain" errach) 
6067694052669692)
lastnondomain


(c!:install 'numeric!-content '(numeric!-content absf gcddd) 
2164575511070702558)
numeric!-content


(c!:install 'objectom '(objectom ir2mml!* apply fnom basicom) 
12657950036901911207)
objectom


(c!:install 'initbrsea '(initbrsea rowmin rowmax codmat maxvar codhisto
headhisto initwght redcodmat inshisto) 11730998601544262957)
initbrsea


(c!:install '!:difference '(!:difference difference !:minus dcombine) 
5542252668030939367)
!:difference


(c!:install 'statep!* '(statep!* state getphystype) 5416643641890959130)
statep!*


(c!:install 'take!-impart '(take!-impart impartf multsq) 
7102534019139876260)
take!-impart


(c!:install 'errorset2 '(errorset2 !*protfg errorset) 
10046103611928419598)
errorset2


(c!:install 'maprint '(maprint p!*!* physoppri minus "(" ")" failed
orig!* posn!* obrkp!* !*comma!* physopp vec!-maprin prin2!* inprint) 
15396926397083613611)
maprint


(c!:install 'dl_get '(dl_get dl_get2) 6068215078811186188)
dl_get


(c!:install 'lalr_list_of_actions '(lalr_list_of_actions !. shift !S!'
reduce (accept) lalr_goto lalr_reduction_index lalr_remove_duplicates) 
5040498890216049320)
lalr_list_of_actions


(c!:install 'aex_simpleratp '(aex_simpleratp aex_ex) 
12227076808602370977)
aex_simpleratp


(c!:install 'polynomlistfinddivisor '(polynomlistfinddivisor
monomisdivisibleby monomispommaretdivisibleby) 12254397565235369759)
polynomlistfinddivisor


(c!:install 'diffp1 '(diffp1 to multd) 14863547682706988853)
diffp1


(c!:install 'removeg '(removeg "Free edge" "in vertex" qg g3
"Invalid type of vertex" finde cerror removeg1 removeg2) 
16725121117381506512)
removeg


(c!:install 'poly!-abs '(poly!-abs poly!-minusp negf) 
10232561214688345619)
poly!-abs


(c!:install 'freeofdepl '(freeofdepl smember) 4679369376547301521)
freeofdepl


(c!:install 'talp_acfrp '(talp_acfrp talp_arg2l talp_tcfrp talp_arg2r) 
6494946179951514378)
talp_acfrp


(c!:install 'searchtm '(searchtm searchpl) 15031410852730542525)
searchtm


(c!:install 'rl_simpbop '(rl_simpbop rl_simp1) 186782563312927961)
rl_simpbop


(c!:install 'vdp_zero!? '(vdp_zero!? vdp_poly) 3453044351461631223)
vdp_zero!?


(c!:install 'spmultm2 '(spmultm2 mkempspmat empty findrow simp multsq
addsq mk!*sq letmtr3) 15010669306500582066)
spmultm2


(c!:install 'on '(on on1) 16078868938563539050)
on


(c!:install 'covposp '(covposp) 884478413950111432)
covposp


(c!:install 'contrsp '(contrsp contrsp2) 2156789623939615128)
contrsp


(c!:install 'cali_bc_fi '(cali_bc_fi) 9127641074191274606)
cali_bc_fi


(c!:install 'oprin '(oprin " " !*fort !*list obrkp!* (plus minus)
testing!-width!* overflowed!* prin2!* terpri!*) 11168596242216730671)
oprin


(c!:install 'split_ext '(split_ext ext split_form cancel) 
13164207896762615599)
split_ext


(c!:install 'aex_simplenullp '(aex_simplenullp aex_ex) 
2580805947154704858)
aex_simplenullp


(c!:install 'ofsf_ordatp '(ofsf_ordatp ordp ofsf_ordrelp) 
18168501514376577914)
ofsf_ordatp


(c!:install 'janettreefind '(janettreefind fluidbibasisjanettreerootnode
monomgetvariabledegree) 5486742964862227594)
janettreefind


(c!:install 'talp_simplt1 '(talp_simplt1 talp_invp talp_invarg talp_getl
stack_top talp_mkinv stack_pop talp_op stack_push talp_invf talp_fargl
talp_invn nth talp_fop) 15600087823852371460)
talp_simplt1


(c!:install 'mri_2pasfat '(mri_2pasfat mri_op mri_arg2l) 
10558619212887814312)
mri_2pasfat


(c!:install 'qqe_number!-of!-tails!-in!-qterm '(
qqe_number!-of!-tails!-in!-qterm (ladd radd) qqe_op qqe_arg2r qqe_arg2l)
 10999794327935236573)
qqe_number!-of!-tails!-in!-qterm


(c!:install 'ibalp_simpatom '(ibalp_simpatom used!* "nil" "Boolean term"
"number" "string" rl_gettype reval ibalp_simpterm typerr) 
16992201105121814522)
ibalp_simpatom


(c!:install 'dip_moncomp '(dip_moncomp) 1856663348448561505)
dip_moncomp


(c!:install 'omair '(omair matrix (!/ o m a) lex omobj omobjs checktag) 
17078550959365752745)
omair


(c!:install 'off '(off off1) 11885465020214804935)
off


(c!:install 'xord_lex '(xord_lex factorordp) 11579299816355622930)
xord_lex


(c!:install 'has_parents '(has_parents !?) 1621164923762247183)
has_parents



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u10.lsp"

Reading "$reduce/cslbuild/generated-c/u11.lsp"

% u11.lsp           Machine generated Lisp

(c!:install "u11" 49994 7990876 9021729)
nil


(c!:install 'form1 '(form1 ed idfn "operator" comment noform symbolic
getel vector vecfn formfn rlis !*comma!* type rlisp
"Syntax error: , invalid after" quote !*micro!-version !*defn
!*composites current!-modulus algebraic list set!-global!-mode form2
typerr lastpair arrayp intargfn getvect convertmode macrochk formrlis
blocktyperr rerror argnochk formlis intexprnp algid) 6680787676292511794
)
form1


(c!:install 'ord '(ord ordering lex plus eval) 6669722106281443466)
ord


(c!:install '!*id2num '(!*id2num pair_id_num!*) 14219724972386172061)
!*id2num


(c!:install 'sc_kern '(sc_kern g_sc_ve) 18384385763232841337)
sc_kern


(c!:install 'list_assoc '(list_assoc) 14494301727655934033)
list_assoc


(c!:install 'get_action_without_lookahead '(get_action_without_lookahead
parser_action_table) 12900232614062859550)
get_action_without_lookahead


(c!:install 'revv0 '(revv0) 9181593057275922086)
revv0


(c!:install 'rl_external '(rl_external) 12707140363234579363)
rl_external


(c!:install 'quotfx '(quotfx !*exp !*mcd quotf quotfx1) 
13124979871990313218)
quotfx


(c!:install 'ibalp_clauselp '(ibalp_clauselp ibalp_clausep) 
4432524955812383249)
ibalp_clauselp


(c!:install 'expression '(expression ir2mml!* !*sq constsml apply prepsq
operator_fn) 2391987690299582439)
expression


(c!:install 'ident '(ident op identity) 18106207035159510332)
ident


(c!:install 'vdpgetprop '(vdpgetprop vdp dipoly
"vdpgetprop given a non-vdp as 1st parameter" rerror) 
4835172904987027563)
vdpgetprop


(c!:install 'xdegree '(xdegree deg!*form) 18238910096532210186)
xdegree


(c!:install 'sfpx '(sfpx sfpx1) 13178870049014996340)
sfpx


(c!:install 'mv!-domainlist!-!- '(mv!-domainlist!-!- nreverse) 
13370949475782114239)
mv!-domainlist!-!-


(c!:install 'exptf '(exptf "exptf" !*exp errach !:expt kernlp exptf1
mksfpf) 6799958631473734497)
exptf


(c!:install 'lalr_generate_lr0_collection '(lalr_generate_lr0_collection
itemset_collection symbols lalr_lr0_initial_itemset
lalr_compute_lr0_goto lalr_add_goto) 14701506318557506624)
lalr_generate_lr0_collection


(c!:install 'convertmode1 '(convertmode1 real algebraic (integer scalar
real) convertmode typerr) 17828960826457123473)
convertmode1


(c!:install 'ofsf_posvarpat '(ofsf_posvarpat (greaterp geq) sfto_varp) 
11032796653786499669)
ofsf_posvarpat


(c!:install 'monommultiplybyvariable '(monommultiplybyvariable) 
17172159374623842453)
monommultiplybyvariable


(c!:install 'totalcompare '(totalcompare equal less greater wulessp
wuconstantp totalcompareconstants) 11251330360413400364)
totalcompare


(c!:install 'tayexp!-difference '(tayexp!-difference !*i2rn
rndifference!:) 5539778557453719521)
tayexp!-difference


(c!:install 'cl_smcpknowl '(cl_smcpknowl) 8596525473378925871)
cl_smcpknowl


(c!:install 'exchk2 '(exchk2 !*nosqrts expt (quotient 1 2) sqrt 0.5
prepsqx) 8408209472902095226)
exchk2


(c!:install 'mkuwedge '(mkuwedge wedge fkern) 15537515151797265826)
mkuwedge


(c!:install 'formop '(formop multop raddf) 18374765434994294328)
formop


(c!:install 'leftzeros '(leftzeros) 1541631738247837761)
leftzeros


(c!:install 'arintequiv!: '(arintequiv!: !:rn!:) 5145923688412295730)
arintequiv!:


(c!:install 'reduce!-mod!-p '(reduce!-mod!-p !*n2f) 1615371093659384512)
reduce!-mod!-p


(c!:install 'mconv '(mconv dmode!* dmconv0 mconv1) 11305980058139582012)
mconv


(c!:install 'lalr_lr0_itemset_to_lalr_kernel '(
lalr_lr0_itemset_to_lalr_kernel !S!' !.) 8429948008393873139)
lalr_lr0_itemset_to_lalr_kernel


(c!:install 'formclis '(formclis formc reversip!*) 12847314577098192759)
formclis


(c!:install 'preptayexp '(preptayexp rnprep!:) 11781688924428039998)
preptayexp


(c!:install 'ofsf_prepat '(ofsf_prepat prepf) 12200178279664987678)
ofsf_prepat


(c!:install 'image!-of!-power '(image!-of!-power image!-set
next!-random!-number) 17797210803896837455)
image!-of!-power


(c!:install 'addpf '(addpf nreverse addmpf addsq termordp!!) 
189716299280573791)
addpf


(c!:install 'id2bytelist '(id2bytelist id2string string2bytelist) 
11750583731547930828)
id2bytelist


(c!:install 'scan '(scan cursym!* !*semicol!* escaped!* nxtsym!* else
outl!* comment !C!O!M!M!E!N!T !Comment !*comment !% ttype!*
percent_comment !#if !#else !#elif !#endif !#eval !*backtrace
curescaped!* !#define (rread) newnam "*** " " => " !$eof!$ !'
"Invalid QUOTE" !*eoldelimp !$eol!$ !# crchar!* !*rpar!* !*comment!*
comment!* if elif endif eval define semic!* string " " token toknump
prin2x read!-comment1 rread errorset errorp filenderr rederr addcomment
read!-comment list2string) 12633109008148600643)
scan


(c!:install 'ra_budancount '(ra_budancount ra_transform ra_budan!-0!-1) 
2201881580874814603)
ra_budancount


(c!:install 'lalr_prin_nonterminal '(lalr_prin_nonterminal
nonterminal_codes cdrassoc explode2uc) 12680425989593305962)
lalr_prin_nonterminal


(c!:install 'remflagss '(remflagss) 4435156902296550872)
remflagss


(c!:install 'ordpa '(ordpa ordp) 8806040821570593621)
ordpa


(c!:install 'rl_smrmknowl '(rl_smrmknowl rl_smrmknowl!* apply) 
2293746311521066408)
rl_smrmknowl


(c!:install 'kernord!-split '(kernord!-split powers) 
14774245284254905622)
kernord!-split


(c!:install 'basicom '(basicom integerom floatom variableom) 
1834273756308251849)
basicom


(c!:install 'dfn_prop '(dfn_prop dfn dfn2 dfn3 mkid) 3602831462996363265
)
dfn_prop


(c!:install 'initwght '(initwght codmat maxvar dm!-abs !:onep) 
1049804139918570648)
initwght


(c!:install 'bcone!? '(bcone!? !*grmod!*) 11162750296414462727)
bcone!?


(c!:install 'vdplength '(vdplength diplength) 13611916425205023055)
vdplength


(c!:install 'plus!: '(plus!: !:rd!: ashift) 12247297853357438346)
plus!:


(c!:install 'getphystypesf '(getphystypesf domain!*p getphystype) 
15012319228892138193)
getphystypesf


(c!:install 'split!-road '(split!-road sroad) 3337914756389053626)
split!-road



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u11.lsp"

Reading "$reduce/cslbuild/generated-c/u12.lsp"

% u12.lsp           Machine generated Lisp

(c!:install "u12" 169557 2701747 1894550)
nil


(c!:install 'simp '(simp varstack!* dmode!* simpcount!* simplimit!* alg
"Simplification recursion too deep" !*sq !*resimp !*uncached alglist!*
!*sub2 "operator" name mat yetunknowntype "scalar" simpiden getelemfn
boolean "algebraic operator" nochange recursiveerror rerror gethash
simpatom !*ssave typerr revlis numlis nth errpri2 opfneval getrtype
simp_without_resimp reval argnochk to simp!* !*q2f lispapply opmtchrevop
lispeval redmsg mkop) 6417605007174974761)
simp


(c!:install 'red!-weight!-less!-p '(red!-weight!-less!-p) 
15527512240772958019)
red!-weight!-less!-p


(c!:install 'pv_times3 '(pv_times3 pappend) 3691900178785916296)
pv_times3


(c!:install 'raiseind!: '(raiseind!:) 8505176479277464392)
raiseind!:


(c!:install 'set!-general!-modulus '(set!-general!-modulus
current!-modulus modulus!/2) 1874468985716972133)
set!-general!-modulus


(c!:install 'ra_budan!-transform '(ra_budan!-transform x to addf exptf
multf) 8807291508851030473)
ra_budan!-transform


(c!:install 'lalr_make_compressed_action_row '(
lalr_make_compressed_action_row lalr_list_of_actions
lalr_resolve_conflicts lalr_make_compressed_action_row1) 
2852074745146579353)
lalr_make_compressed_action_row


(c!:install 'ofsf_smwcpknowl '(ofsf_smwcpknowl !*rlsusi cl_susicpknowl
ofsf_smcpknowl) 7089546550580279020)
ofsf_smwcpknowl


(c!:install 'color1 '(color1 qg g3 "Invalid structure of c0-graph."
times addsq removeg split3gv cerror) 4352621750118498595)
color1


(c!:install 'cl_simpl '(cl_simpl !*rlsism inctheo and false cl_simpl1
cl_sitheo rl_exc rl_smupdknowl) 8977132422883725116)
cl_simpl


(c!:install 'ibalp_clausep '(ibalp_clausep or ibalp_litp ibalp_litlp) 
720166200090794143)
ibalp_clausep


(c!:install 'omiir '(omiir char lex) 5366513475899983678)
omiir


(c!:install 'writepri '(writepri eval assgnpri) 14111625423404019942)
writepri


(c!:install 'argnochk '(argnochk !*argnochk variadic !*strict_argcount
"+++++ " rlisp "called with" "argument" "arguments" "instead of"
number!-of!-args argsofopr rerror lprim) 4181807411543066481)
argnochk


(c!:install 'compactfmatch2 '(compactfmatch2 !~) 224475548025507060)
compactfmatch2


(c!:install 'make!-term '(make!-term sin cos (-1 . 1) multsq) 
9078954940219746692)
make!-term


(c!:install 'listtest '(listtest) 16706901539491943115)
listtest


(c!:install 'lalr_prin_action '(lalr_prin_action " " "shift to state "
"accept" lalr_prin_reduction) 15880402724542237190)
lalr_prin_action


(c!:install 'formprogn '(formprogn progn formclis) 2107028119090928800)
formprogn


(c!:install 'processcarpartitie1 '(processcarpartitie1 processpartitie1)
 15456138832529220939)
processcarpartitie1


(c!:install 'subs3f1 '(subs3f1 !*mymatch mchfg!* !*resubs !*sub2
powlis1!* addsq !*subs3tnc subs3t subs2q subs3q) 5861254699348922205)
subs3f1


(c!:install 'get_rep_matrix_in '(get_rep_matrix_in
"error in get representation matrix" rederr) 15349649042341146497)
get_rep_matrix_in


(c!:install 'cl_fvarl '(cl_fvarl ordp cl_fvarl1 sort) 
15724032967646760359)
cl_fvarl


(c!:install 'qsort '(qsort ordop) 12064808041959192184)
qsort


(c!:install 'integerom '(integerom "<OMI> " " </OMI>" printout) 
17516490804314905868)
integerom


(c!:install 'c!:extadd '(c!:extadd addf c!:ordexp) 12741461048729794588)
c!:extadd


(c!:install 'lessp!: '(lessp!: greaterp!:) 15260863818086175057)
lessp!:


(c!:install 'condterpri '(condterpri !*output !*echo !*extraecho !*int
ifl!* !*defn !*demo) 3886476464251229633)
condterpri


(c!:install 'red_better '(red_better bas_dplen) 8582264097889148431)
red_better


(c!:install 'gperm3 '(gperm3 gperm2) 7591388445554053377)
gperm3


(c!:install 'ordn '(ordn ord2 ordad) 10332192838769180338)
ordn


(c!:install 'rnminus!: '(rnminus!: !:minus) 10114202910328867344)
rnminus!:


(c!:install 'split_f '(split_f "SPLIT_F: expression not linear w.r.t."
list multf addf get_first_kernel msgpri update_kc_list) 
1686252993858126732)
split_f


(c!:install 'rl_simp '(rl_simp rl_simp1 rl_csimpl) 1301825759816865816)
rl_simp


(c!:install 'get_group_in '(get_group_in) 7681727314505217329)
get_group_in


(c!:install 'ibalp_simpterm '(ibalp_simpterm "Boolean function"
ibalp_simpatom ibalp_boolfp reval typerr) 15506151739196029020)
ibalp_simpterm


(c!:install 'gb_buch!-ev_divides!? '(gb_buch!-ev_divides!? ev_mtest!?) 
3408037194448717213)
gb_buch!-ev_divides!?


(c!:install 'cgb_buch!-ev_divides!? '(cgb_buch!-ev_divides!? ev_mtest!?)
 9685527381017281983)
cgb_buch!-ev_divides!?


(c!:install 'naryrd '(naryrd mathml) 1312667547952411945)
naryrd


(c!:install 'sc_setmat '(sc_setmat) 16207821621747946256)
sc_setmat


(c!:install 'flatindxl '(flatindxl) 4768325691543994563)
flatindxl


(c!:install 'gfrsq '(gfrsq gfdot) 11530621920894201651)
gfrsq


(c!:install 'ncmpchk '(ncmpchk noncommuting physop!-ordop) 
14541186059863612535)
ncmpchk


(c!:install 'mv!-pow!-!- '(mv!-pow!-!- nreverse) 14925617278174881589)
mv!-pow!-!-


(c!:install 'dp!=mocompare '(dp!=mocompare mo_compare) 
15094876893358009668)
dp!=mocompare


(c!:install 'eqdummy '(eqdummy) 18076016336838887221)
eqdummy


(c!:install 'b!:ordexn '(b!:ordexn) 7748619897744485377)
b!:ordexn


(c!:install 'horner!-rule '(horner!-rule !*d2n evaluate!-in!-order) 
9012840665532260081)
horner!-rule


(c!:install 'cde_lassoc2 '(cde_lassoc2 "Error: bad alist" rederr) 
12470965637166428923)
cde_lassoc2


(c!:install 'gcdf2 '(gcdf2 asymplis!* !*anygcd !*gcd num!-exponents
kernord setkorder reorder comfac gcdf1 comfac!-to!-poly quotf1 gcdk
multf noncomp gcdfnc ordop) 10016176172079722155)
gcdf2


(c!:install 'qqe_arg!-check!-b '(qqe_arg!-check!-b qqe_id!-nyt!-branchb
qqe_qtidp qqe_nytidp qqe_btid qqe_add2rollbackids qqe_arg!-check) 
7263150955247412042)
qqe_arg!-check!-b


(c!:install 'rl_susibin '(rl_susibin rl_susibin!* apply) 
14790073274071796983)
rl_susibin


(c!:install 'aex_varl '(aex_varl aex_ex kernels) 12138312432367490705)
aex_varl


(c!:install 'omvir '(omvir name atts hex "wrong att" dec find errorml) 
16856227075493975039)
omvir


(c!:install 'spquotematrix '(spquotematrix sparse) 5925900773705317900)
spquotematrix


(c!:install 'vdpzero '(vdpzero a2vdp) 6559425673910558182)
vdpzero


(c!:install 'tokquote '(tokquote crchar!* nxtsym!* curescaped!* ttype!*
readch1 rread) 14220838049894060213)
tokquote


(c!:install 'red!-ratios1 '(red!-ratios1 red!-ratios2) 
5051240859727381882)
red!-ratios1


(c!:install 'multop '(multop kord!* k!* multf rmultpf) 
2569549041218447668)
multop


(c!:install 'red_divtest '(red_divtest bas_dpoly dp_lmon mo_vdivides!?) 
7632384483205331330)
red_divtest


(c!:install 'pdif '(pdif pneg psum) 12118561974533042045)
pdif


(c!:install 'pv_intequiv '(pv_intequiv) 5767065334788154536)
pv_intequiv


(c!:install 'crprcd '(crprcd convprec!*) 18117100781347588171)
crprcd


(c!:install 'simpexpon1 '(simpexpon1 !*numval dmode!* !:rd!: !:cr!:
alglist!*) 16238152524484848804)
simpexpon1


(c!:install 'talp_simplatrinv '(talp_simplatrinv equal talp_simplt
talp_invp talp_eqtp talp_mk2 talp_simplat2) 11822902135988021640)
talp_simplatrinv


(c!:install 'mkzl '(mkzl nreverse) 17272778361100409105)
mkzl



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u12.lsp"

Reading "$reduce/cslbuild/generated-c/u13.lsp"

% u13.lsp           Machine generated Lisp

(c!:install "u13" 146828 5652819 2386908)
nil


(c!:install 'ibalp_vequal '(ibalp_vequal) 5437926664406397851)
ibalp_vequal


(c!:install 'lesspcdr '(lesspcdr) 14122941759879918979)
lesspcdr


(c!:install 'sub_math '(sub_math char (i d e n t !/) ident (v e c t o r)
(!/ v e c t o r) "</vector>" constructors!* csymbol fn vectorrd errorml
compress!* apply) 18419925095686531214)
sub_math


(c!:install 'rd!:minus '(rd!:minus !:rd!: safe!-fp!-minus minus!:) 
1785567278384127790)
rd!:minus


(c!:install 'zeropp '(zeropp !:rd!: rd!:zerop) 13949595092336381551)
zeropp


(c!:install 'comm_kernels1 '(comm_kernels1 noncomp) 3100368076730526959)
comm_kernels1


(c!:install 'sc_null '(sc_null) 11307350938126117219)
sc_null


(c!:install 'fortranop '(fortranop !*fortranop!*) 7164010240171970054)
fortranop


(c!:install 'simptimes '(simptimes tstack!* mul!* alglist!* simpcar
multsq) 7488974973212079865)
simptimes


(c!:install 'dividef '(dividef) 7696426718935484752)
dividef


(c!:install 'noncomperm '(noncomperm failed noncomdel mapcons lastpair) 
8755064335032433944)
noncomperm


(c!:install 'lalr_most_common_reduction '(lalr_most_common_reduction
reduce accept) 14292451567014797944)
lalr_most_common_reduction


(c!:install 'undefdchk '(undefdchk defd undefns!*) 5023456470512908736)
undefdchk


(c!:install 'mk!+mat!+mult!+mat '(mk!+mat!+mult!+mat "no matrix in mult"
"matrices can not be multiplied" !*sub2 matrix!+p rederr get!+col!+nr
get!+row!+nr get!+mat!+entry multsq addsq subs2) 5423986245894603407)
mk!+mat!+mult!+mat


(c!:install 'talp_chkknowl '(talp_chkknowl neq true talp_candp
talp_arg2l talp_arg2r talp_invf talp_op talp_invp talp_invarg) 
8314572981169472499)
talp_chkknowl


(c!:install 'qqe_ofsf_prepat '(qqe_ofsf_prepat qqe_op qqe_rqopp
qqe_prepat ofsf_prepat) 1589176860606541047)
qqe_ofsf_prepat


(c!:install 'powers4 '(powers4 nreverse ordop) 1447856910578025462)
powers4


(c!:install 'unbind '(unbind binding) 12882119460731612857)
unbind


(c!:install 'listdiff '(listdiff) 14461502497108036326)
listdiff


(c!:install 'deletemult!* '(deletemult!*) 8201013927535965436)
deletemult!*


(c!:install 'aminusp!: '(aminusp!: !*modular modular aminusp!:1
"arithmetic expression" setdmode errorset2 errorp typerr) 
5331318887694205961)
aminusp!:


(c!:install 'mo_neg '(mo_neg) 3737353681207043185)
mo_neg


(c!:install 'wtchk '(wtchk k!* "weight confusion" to quotf errach) 
3502032153783501086)
wtchk


(c!:install 'put!-kvalue '(put!-kvalue !*sq kvalue sq_member smember
recursiveerror aconc) 13372840733956172816)
put!-kvalue


(c!:install 'removeg1 '(removeg1 n!*!*2!-1 "Free edge" "in vertex"
su_order "Invalid structure of c-graph" times removev multsq finde
cerror quotsq mkcopy) 7980733250654109105)
removeg1


(c!:install 'cl_varl1 '(cl_varl1 cl_varl2) 9987905465539996329)
cl_varl1


(c!:install 'qqe_ofsf_varlterm '(qqe_ofsf_varlterm qepsilon lto_insertq)
 7995573586547159696)
qqe_ofsf_varlterm


(c!:install 'rl_simp1 '(rl_simp1 rl_cid!* "select a context"
!*strict_argcount rl_simpfn simpfnname " (" ")" "predicate" simpdefault
rederr rl_simpatom argnochk apply reval ioto_form2str lto_sconcat redmsg
) 11833055585289989692)
rl_simp1


(c!:install 'wedget2 '(wedget2 multsq wedgek2 multpfsq) 
4666025021054316281)
wedget2


(c!:install 'set!-ordp '(set!-ordp ordp) 11286157267328432309)
set!-ordp


(c!:install 'map__edges '(map__edges union_edges) 9827530180937595202)
map__edges


(c!:install 'assert_dyntypep '(assert_dyntypep assert_dyntype) 
17777038173041719451)
assert_dyntypep


(c!:install 'dd '(dd ordering lex nc!* varlist!* dquot dless leftzeros
class) 129747970404352349)
dd


(c!:install 'pv_times2 '(pv_times2 pv_times3 pv_add) 
10666651998379876444)
pv_times2


(c!:install 'exptsq '(exptsq poly " 0**0 formed" !*exp "Zero divisor"
rerror mk!*sq simpexpt mksfpf kernp mksq exptf !:expt multsq multf
canonsq) 12315468031512248083)
exptsq


(c!:install 'p_princ '(p_princ bldmsg_chars!* !  !*ll!* " ") 
2900324150656089120)
p_princ


(c!:install 'gcref_mknode!-tgf '(gcref_mknode!-tgf " " prin2t) 
4018093252830256111)
gcref_mknode!-tgf


(c!:install 'quotfail1 '(quotfail1 polyzero quotf errorf) 
5553416668947438442)
quotfail1


(c!:install 'msappend '(msappend) 11032271548117645485)
msappend


(c!:install 'exceeds!-order '(exceeds!-order tayexp!-plus2 tayexp!-lessp
) 11075431926768230131)
exceeds!-order


(c!:install 'ckrn '(ckrn dmode!* (!:rd!: !:cr!:) lnc quotfd ckrn1 multf)
 8963949368468510905)
ckrn


(c!:install 'talp_rnf '(talp_rnf cl_simpl talp_rnf1) 
10476314859936877117)
talp_rnf


(c!:install 'qqe_qprefix!-var '(qqe_qprefix!-var (ltail rtail lhead
rhead) qqe_op qqe_arg2l qqe_arg2r) 15201380281209160393)
qqe_qprefix!-var



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u13.lsp"

Reading "$reduce/cslbuild/generated-c/u14.lsp"

% u14.lsp           Machine generated Lisp

(c!:install "u14" 72515 9525852 89327)
nil


(c!:install 'xread1 '(xread1 commentlist!* cursym!* !*lpar!* !*rpar!*
!*reduce4 type decstat !$eol!$ nxtsym!* !( !*eoldelimp times
curescaped!* proc "Syntax error in procedure header" struct paren
!*comma!* lambda "Improper delimiter" group "Too many right parentheses"
unary "Redundant operator" !*!*un!*!* "Missing operator"
"Please use parentheses around use of the unary operator" right (lambda
paren) not member "NOT" "infix operator" endstat go endstatfn !,
procedure "proc form" !*semicol!* !*colon!* for !*blockp nodel (
!*rsqbkt!* !*rcbkt!* !*rsqb!*) "Too few right parentheses"
"Please send hearn@rand.org your program!!" lispapply toknump chknewnam
symerr scan eolcheck remcomma xread mkvar typerr delcp procstat1
xcomment) 11814043184281624487)
xread1


(c!:install 'binomial!-coefft!-mod!-p '(binomial!-coefft!-mod!-p !*n2f
min) 18069998271637071980)
binomial!-coefft!-mod!-p


(c!:install '!*kp2f '(!*kp2f mksq) 666337834992111105)
!*kp2f


(c!:install 'revalind '(revalind alglist!* dmode!* subfg!* !0 simp
prepsq) 14428625574767194711)
revalind


(c!:install 'scalopp '(scalopp scalar vector tensor tensdimen isanindex
nth areallindices) 12955472892045792015)
scalopp


(c!:install 'lalr_reduction_index '(lalr_reduction_index
lalr_productions cdrassoc) 11756333825059727427)
lalr_reduction_index


(c!:install 'rempropss '(rempropss) 11396279580091513007)
rempropss


(c!:install 'rl_simpl '(rl_simpl rl_simpl!* apply) 12955744972546707629)
rl_simpl


(c!:install 'cl_smmkatl '(cl_smmkatl or lastpair rl_negateat) 
12227125609069066198)
cl_smmkatl


(c!:install 'ibalp_vmember '(ibalp_vmember ibalp_vequal) 
1354869335745791598)
ibalp_vmember


(c!:install 'make!-univariate!-image!-mod!-p '(
make!-univariate!-image!-mod!-p !*n2f image!-of!-power times!-mod!-p
plus!-mod!-p) 9498715387900674649)
make!-univariate!-image!-mod!-p


(c!:install 'minusp!: '(minusp!: !:rd!:) 2935256932381667861)
minusp!:


(c!:install 'isimplicit '(isimplicit implicit! ) 14035966247736076855)
isimplicit


(c!:install 'getmat '(getmat off_mod_reval unchecked_getmatelem) 
575108285554068056)
getmat


(c!:install 'groebcpcompless!? '(groebcpcompless!? !*gsugar number
vevcomp vdpgetprop vevcompless!?) 45463741637778272)
groebcpcompless!?


(c!:install 'vevdif '(vevdif backtrace dipoly
"Vevdif, difference would be < 0" vevzero!?1 getd rerror) 
3535859941191441732)
vevdif


(c!:install 'red!-ratios2 '(red!-ratios2 red!-lowest!-terms) 
3376847918635603851)
red!-ratios2


(c!:install 'cali_bc_zero!? '(cali_bc_zero!? !*hardzerotest prepf simp
bc!=simp) 4394829021658017818)
cali_bc_zero!?


(c!:install 'gperm0 '(gperm0 gperm3) 8730090614928443564)
gperm0


(c!:install 'portable_prin '(portable_prin !*ll!* p_prinl2) 
4548240548968345519)
portable_prin


(c!:install 'aex_deg '(aex_deg aex_ex sfto_vardeg) 3607510624473054238)
aex_deg


(c!:install 'ofsf_smwupdknowl '(ofsf_smwupdknowl !*rlsusi
cl_susiupdknowl ofsf_smupdknowl) 9736546518660035619)
ofsf_smwupdknowl


(c!:install 'removeg2 '(removeg2 g3 "Edge" "is absent in vertex" qg
cerror revv0 mkcopy negsq) 6511137687378053788)
removeg2


(c!:install 'pasf_susipost '(pasf_susipost) 2506054533815200357)
pasf_susipost


(c!:install 'vdp_plist '(vdp_plist) 16380982896306623454)
vdp_plist


(c!:install 'mathml2 '(mathml2 sub_math) 17551767027574496826)
mathml2


(c!:install 'setdmode1 '(setdmode1 tag dmode!* gdmode!* (rounded
complex!-rounded) realtype domainlist!* !:gi!: !* "Domain mode"
"changed to" rmsubs offmoderr !!mfefix lprim) 14607247357730800588)
setdmode1


(c!:install 'sc_minussq '(sc_minussq minusf) 10710327319336543990)
sc_minussq


(c!:install 'vevlcm '(vevlcm) 18414229144108724852)
vevlcm


(c!:install 'mksgnsq '(mksgnsq evenfree mk!*sq simpexpt) 
4016211607104099856)
mksgnsq


(c!:install 'defined_edge '(defined_edge old_edge_list new_edge_list
all_edge defined_all_edge) 17071500137057330346)
defined_edge


(c!:install 'rnconc '(rnconc !*ncmp noncomfp1 addf) 466226041312299716)
rnconc


(c!:install 'evalneq '(evalneq evalequal) 13844996325675159343)
evalneq


(c!:install 'dp_times_bcmo '(dp_times_bcmo mo_sum cali_bc_prod) 
7642691351532011130)
dp_times_bcmo


(c!:install 'ra_budan!-0!-1 '(ra_budan!-0!-1 ra_budan!-transform minusf)
 15518973105210631036)
ra_budan!-0!-1


(c!:install 'p_prin '(p_prin !_ !! bldmsg_chars!* !  !*ll!* " ") 
14632487754332920832)
p_prin


(c!:install 'ofsf_entry2at1 '(ofsf_entry2at1 and ofsf_clnegrel addsq) 
16980845921898880700)
ofsf_entry2at1


(c!:install 'polynommultiplybyvariable '(polynommultiplybyvariable
monomgetvariabledegree monommultiplybyvariable polynomadd) 
16583926328334196556)
polynommultiplybyvariable


(c!:install 'intexprlisp '(intexprlisp intexprnp) 6347235130115113606)
intexprlisp


(c!:install 'cl_sitheo '(cl_sitheo !*rlsiexpla !*rlsithok false inctheo
true cl_simplat) 15244933074264938711)
cl_sitheo


(c!:install 'qqe_ofsf_simplat1 '(qqe_ofsf_simplat1 (true false)
qqe_simplat1 qqe_op qqe_rqopp ofsf_simplat1) 4071328728144776747)
qqe_ofsf_simplat1


(c!:install 'sf2ss '(sf2ss searchpl qsort sq2sspl lx2xx) 
12717373165686143115)
sf2ss



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u14.lsp"

Reading "$reduce/cslbuild/generated-c/u15.lsp"

% u15.lsp           Machine generated Lisp

(c!:install "u15" 143239 1709677 6224182)
nil


(c!:install 'diff!-over!-k!-mod!-p '(diff!-over!-k!-mod!-p
quotfail!-mod!-p times!-mod!-p mksp) 15305212507911809722)
diff!-over!-k!-mod!-p


(c!:install 'c!:subs2multf '(c!:subs2multf !*sub2 matrix
"Sub error in glnrsolve" multf subs2 rerror) 9238164989815300843)
c!:subs2multf


(c!:install 'testredh '(testredh codmat maxvar rowdel testredzz) 
17389003401682745904)
testredh


(c!:install 'getcomb '(getcomb i comb nextcomb setdiff) 
17896886103709319914)
getcomb


(c!:install 'bc2a '(bc2a !*grmod!* prepsq) 12731770465936355733)
bc2a


(c!:install 'lid '(lid) 17189129716112135001)
lid


(c!:install 'list!+list '(list!+list nreverse !:plus) 
3588448022400956151)
list!+list


(c!:install 'physop!-multf '(physop!-multf !*exp ncmp!* wtl!*
!*!*processed !*contract2 !*asymp!* !*mcd multd mkprod noncomp2f
physop!-multfnc physop!-ordop physopp mkspm addf) 16688548001939892138)
physop!-multf


(c!:install 'form '(form always_nform !*rlisp88 !*vars!* !*mode symbolic
modefn "algebraic expression" "Rlisp88 form" n_form form1 typerr) 
892566736032357707)
form


(c!:install 'lengthcdr '(lengthcdr) 6543389359225820768)
lengthcdr


(c!:install 'mo_neworder '(mo_neworder mo!=shorten mo!=deglist) 
3498630001384855489)
mo_neworder


(c!:install 'dl_get2 '(dl_get2 di_insert) 14233851812246089122)
dl_get2


(c!:install 'general!-times!-mod!-p '(general!-times!-mod!-p
gen!-mult!-by!-const!-mod!-p general!-times!-term!-mod!-p
general!-plus!-mod!-p ordop) 17334083889051163507)
general!-times!-mod!-p


(c!:install 'efface1 '(efface1) 12879838724924137848)
efface1


(c!:install 'rsubla '(rsubla rassoc) 16645073108331555335)
rsubla


(c!:install 'cl_smsimpl!-junct '(cl_smsimpl!-junct !*rlsism false and
cl_gand!-col rl_smcpknowl cl_cflip cl_atfp cl_simplat rl_smupdknowl
cl_smsimpl!-junct1) 11682729181179643947)
cl_smsimpl!-junct


(c!:install 'sq2sspl '(sq2sspl sq2sstm) 9696884435459883490)
sq2sspl


(c!:install 'sq2sscfpl '(sq2sscfpl mkzl sq2sstm) 7910318926466258719)
sq2sscfpl


(c!:install 'horner!-rule!-mod!-p '(horner!-rule!-mod!-p expt!-mod!-p
times!-mod!-p plus!-mod!-p) 17881801528335960065)
horner!-rule!-mod!-p


(c!:install 'downwght1 '(downwght1 codmat maxvar dm!-abs !:onep) 
15360006528447657581)
downwght1


(c!:install 'newenv '(newenv unbound bind) 7633756221636202719)
newenv


(c!:install 'arg2of2 '(arg2of2) 4375772679821807059)
arg2of2


(c!:install 'evenfree '(evenfree qremd absf addf) 18154060703490971120)
evenfree


(c!:install 'fortranprecedence '(fortranprecedence !*fortranprecedence!*
) 11537112185118381901)
fortranprecedence


(c!:install 'assert_typesyntaxp '(assert_typesyntaxp !*assert
assert_dyntypep) 17209299985469235662)
assert_typesyntaxp


(c!:install 'mo!=revlexcomp '(mo!=revlexcomp mo!=degcomp) 
2383043388671786395)
mo!=revlexcomp


(c!:install 'artimes!: '(artimes!: dmode!* !*exp !:ar!: multf
reducepowers) 6267152915256128623)
artimes!:


(c!:install 'lexer_word_continues '(lexer_word_continues !_
lexer_style!* !. !' land) 10021294736520097938)
lexer_word_continues


(c!:install 'quotfdx '(quotfdx dmode!* divd quotdd quotkx) 
2190569667429103273)
quotfdx


(c!:install 'simpexpt '(simpexpt !*qsum!-simpexpt qsum!-simpexpt
basic!-simpexpt) 7166383482056185520)
simpexpt


(c!:install 'lx2xx '(lx2xx lastnondomain delet xxsort) 
3267089086882027254)
lx2xx


(c!:install 'ibalp_negateat '(ibalp_negateat ibalp_op ibalp_arg2l
ibalp_arg2r ibalp_negatet ibalp_mk2) 11674072354734338620)
ibalp_negateat


(c!:install 'dip_fmon '(dip_fmon) 16129702713853537519)
dip_fmon


(c!:install 'maxtype '(maxtype) 12508132550171625112)
maxtype


(c!:install 'bind '(bind binding) 3225494593516835221)
bind


(c!:install 'freeoffl '(freeoffl freeoff) 15078241996436078632)
freeoffl


(c!:install 'triviallcm '(triviallcm xdiv) 9232098139641841924)
triviallcm


(c!:install 'aminusp!:1 '(aminusp!:1 !*sq "invalid in FOR statement"
!:minusp aeval!* reval msgpri) 7805626647496889307)
aminusp!:1


(c!:install 'dcombine '(dcombine (!:crn!: !:gi!:) (!:rd!: !:cr!:) cmpxfn
!:ps!: noconvert !:rd!: !:cr!: !:rn!: !:gi!: !:crn!: !*rounded
!*roundall divide !*rn2rd !*crn2cr int!-equiv!-chk) 8297924674976742843)
dcombine


(c!:install 'setk '(setk evalargfn matrix setk0 revlis) 
1991935475192031166)
setk


(c!:install 'lalr_resolve_conflicts '(lalr_resolve_conflicts
orderactions shift !:left !:right sort lalr_warn_reduce_reduce_conflict
lalr_precedence lalr_associativity lalr_warn_shift_reduce_conflict) 
3536485786551802083)
lalr_resolve_conflicts


(c!:install 'cl_atml1 '(cl_atml1 cl_atmlc cl_f2ml) 7205542292703730976)
cl_atml1


(c!:install 'mri_realvarp '(mri_realvarp mri_type real) 
9365097956254588946)
mri_realvarp


(c!:install 'cl_qb '(cl_qb ex all) 16899144078553875742)
cl_qb


(c!:install 'quotient!-mod!-p '(quotient!-mod!-p "b=0 in quotient-mod-p"
exact!-quotient!-flag errorf safe!-modular!-reciprocal
multiply!-by!-constant!-mod!-p xquotient!-mod!-p ordop) 
17360224290089459535)
quotient!-mod!-p


(c!:install 'matsm!*1 '(matsm!*1 mat !*sub2 subs2!* !*q2a) 
14068891089045412209)
matsm!*1


(c!:install 'dipprodin1 '(dipprodin1 dipzero nreverse evsum bcprod) 
336795414234623694)
dipprodin1


(c!:install 'gsugar '(gsugar !*gsugar sugar "*** missing sugar"
vdpgetprop backtrace vdptdeg gsetsugar) 6798198097628900815)
gsugar


(c!:install 'noncommuting '(noncommuting noncommutes) 
2165035912138483362)
noncommuting


(c!:install 'remcomma '(remcomma !*comma!*) 2662719881749733707)
remcomma


(c!:install 'mv!-domainlist!-!* '(mv!-domainlist!-!* nreverse) 
18354663546968624885)
mv!-domainlist!-!*


(c!:install 'modquotient!: '(modquotient!: general!-modular!-reciprocal
general!-modular!-times !*modular2f) 8939512638981961561)
modquotient!:


(c!:install 'conv!:mt '(conv!:mt !:rd!: msd ashift round!:last bflerrmsg
) 8776247917539304474)
conv!:mt


(c!:install 'multd!* '(multd!* kernel xtype value to multd) 
884659770052925628)
multd!*



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u15.lsp"

Reading "$reduce/cslbuild/generated-c/u16.lsp"

% u16.lsp           Machine generated Lisp

(c!:install "u16" 81729 1102922 2761808)
nil


(c!:install 'use!-berlekamp '(use!-berlekamp dpoly poly!-vector
current!-modulus remainder!-in!-vector times!-in!-vector
find!-null!-space) 10421087587991988417)
use!-berlekamp


(c!:install 'rread1 '(rread1 ttype!* !*quotenewnam quotenewnam !:dn!:
symbolic !( !+ !- " " nxtsym!* "Syntax error: improper number" minus
ptoken dnform rrdls symerr) 12546366611473069056)
rread1


(c!:install 'aex_mvartest '(aex_mvartest aex_ex sfto_mvartest) 
18072716557489035181)
aex_mvartest


(c!:install 'idsort '(idsort idcompare sort) 16171354139434438841)
idsort


(c!:install 'talp_subalchk '(talp_subalchk) 17141478711458429059)
talp_subalchk


(c!:install 'qqe_ofsf_chsimpterm '(qqe_ofsf_chsimpterm expt (ltail rtail
) qqe_op qqe_arg2l qqe_chsimpterm setcar) 14229263982680834276)
qqe_ofsf_chsimpterm


(c!:install 'pasf_sisub!-gand '(pasf_sisub!-gand and true false
pasf_sisub) 5209455540577850077)
pasf_sisub!-gand


(c!:install 'ibalp_negatet '(ibalp_negatet bnot) 13505881871668969693)
ibalp_negatet


(c!:install 'mapins '(mapins nreverse) 6208819712836974700)
mapins


(c!:install 'cird '(cird atts (type) char ci retattributes lex errorml
compress!*) 12338498677706727103)
cird


(c!:install 'bsubs '(bsubs bound binding) 7609595528360115474)
bsubs


(c!:install 'wedgepf '(wedgepf !*pf2wedgepf wedgepf2 !*wedgepf2pf) 
13071033742882856573)
wedgepf


(c!:install 'all_edge '(all_edge nreverse) 10186315727852983129)
all_edge


(c!:install 'mkid '(mkid "MKID root" "MKID index" typerr
get!-print!-name) 4804688465473772125)
mkid


(c!:install 'mv!-pow!-chk '(mv!-pow!-chk mv!-pow!-!- mv!-pow!-minusp) 
6252537058940825)
mv!-pow!-chk


(c!:install 'dp_neg '(dp_neg cali_bc_neg) 2538534716641995404)
dp_neg


(c!:install 'pappend '(pappend unpkp pkp) 1433589190293901459)
pappend


(c!:install 'b!:extmult '(b!:extmult b!:ordexn multf negf b!:extadd) 
13693123787237902409)
b!:extmult


(c!:install 'tr_write '(tr_write !*trsolve) 9464242599202146762)
tr_write


(c!:install 'difference!-mod!-p '(difference!-mod!-p minus!-mod!-p
plus!-mod!-p) 3422566790670487414)
difference!-mod!-p


(c!:install 'reduce!-degree!-mod!-p '(reduce!-degree!-mod!-p
multiply!-by!-constant!-mod!-p plus!-mod!-p mksp times!-term!-mod!-p) 
4277033915637549791)
reduce!-degree!-mod!-p


(c!:install 'lalr_make_compressed_action_row1 '(
lalr_make_compressed_action_row1 shift accept reduce
lalr_most_common_reduction) 5198313706442512203)
lalr_make_compressed_action_row1


(c!:install 'powers3 '(powers3) 3323641930007482181)
powers3


(c!:install 'ibalp_redclause '(ibalp_redclause ibalp_vmember) 
614149274002913780)
ibalp_redclause


(c!:install 'matrixrowrd '(matrixrowrd mathml) 8180101794268303607)
matrixrowrd


(c!:install 'opmtch '(opmtch rpt inf subfg!* sroot1 oldmtch) 
1273851279168509676)
opmtch


(c!:install 'mkinds '(mkinds) 1345525827787502947)
mkinds


(c!:install 'flatsizec '(flatsizec widelengthc) 5640450612806210361)
flatsizec


(c!:install 'general!-modular!-reciprocal '(general!-modular!-reciprocal
!*balanced_mod current!-modulus general!-reciprocal!-by!-gcd) 
5044102815253907391)
general!-modular!-reciprocal


(c!:install 'ra_transform '(ra_transform x negsq addsq to multsq
sfto_qsub1) 17488387270339013101)
ra_transform


(c!:install 'rl_prepfof '(rl_prepfof rl_csimpl rl_prepfof1) 
3787519806660725985)
rl_prepfof


(c!:install 'poly!-minusp '(poly!-minusp) 3466468193239228631)
poly!-minusp


(c!:install 'delet '(delet nreverse) 4196219192857472711)
delet


(c!:install 'ibalp_emptyclausep '(ibalp_emptyclausep) 
12892062950656430122)
ibalp_emptyclausep


(c!:install 'c!:extmult '(c!:extmult "should never get here" c!:ordexn
c!:subs2multf negf c!:extadd rederr) 571422204684123209)
c!:extmult


(c!:install 'dpmat_coldegs '(dpmat_coldegs nth) 3174626191889732937)
dpmat_coldegs


(c!:install 'nb '(nb) 376134941141328322)
nb


(c!:install 'lex_start_block_comment '(lex_start_block_comment !/ !*
lexer_style!* !( yypeek land) 9039175858474494968)
lex_start_block_comment


(c!:install 'setpage '(setpage title!* pgnum!*) 17822129394673273623)
setpage


(c!:install 'mri_pasf2mriat '(mri_pasf2mriat mri_0mk2) 
15615781468990213430)
mri_pasf2mriat


(c!:install 'qqe_simplterm '(qqe_simplterm (ltail rtail) (lhead rhead) (
ladd radd) qqe_op qqe_simplterm!-tail qqe_simplterm!-head
qqe_simplterm!-add) 1706402166110397533)
qqe_simplterm


(c!:install 'pasf_mkpos '(pasf_mkpos true false (cong ncong) minusf
pasf_anegateat negf) 8021095345706867023)
pasf_mkpos


(c!:install 'ibalp_process!-var '(ibalp_process!-var !! setcar) 
18440587624209677374)
ibalp_process!-var


(c!:install 'cgp_ci '(cgp_ci nth) 4627297506477717357)
cgp_ci


(c!:install 'diff!-k!-times!-mod!-p '(diff!-k!-times!-mod!-p
binomial!-coefft!-mod!-p times!-mod!-p mksp) 3948337365085810727)
diff!-k!-times!-mod!-p


(c!:install 'terpri!* '(terpri!* outputhandler!* terpri testing!-width!*
overflowed!* !*fort !*nat pline!* ymax!* ymin!* orig!* posn!* ycoord!*
fterpri scprint) 2556988473238841502)
terpri!*


(c!:install 'find_sub_df '(find_sub_df is_sub_df) 18402242121722157452)
find_sub_df


(c!:install 'redcodmat '(redcodmat rowmin rowmax testred) 
7242402052009170639)
redcodmat


(c!:install 'exchk1 '(exchk1 expt times exchk2 simpexpon assoc2 addsq
sqchk) 3243638504056923274)
exchk1


(c!:install 'modminusp!: '(modminusp!: !*balanced_mod current!-modulus) 
16263133944667833744)
modminusp!:


(c!:install 'unchecked_getmatelem '(unchecked_getmatelem mat matrix
"Matrix" "not set" rerror nth) 3837257970903198919)
unchecked_getmatelem


(c!:install 'termordp!! '(termordp!! guesspftype termordp) 
14621044041233121472)
termordp!!


(c!:install 'scal!*list '(scal!*list nreverse !:times) 
8705273445897821808)
scal!*list


(c!:install 'actual_alst '(actual_alst nreverse) 7220919755738193858)
actual_alst


(c!:install 'symbid '(symbid fname!* ftype!* (macro smacro inline)
!*comp !*cref constant!? "nonlocal use of undeclared variable"
"in procedure" lprim) 1282567562781113822)
symbid


(c!:install 'nzeros '(nzeros nreverse) 13195653878633323743)
nzeros


(c!:install 'cali_bc_inv '(cali_bc_inv qremf) 1879288417171672158)
cali_bc_inv


(c!:install 'subsetp '(subsetp) 7573611723859556093)
subsetp


(c!:install 'wi_new '(wi_new wi_number !: windex mkid) 
16180821180526704178)
wi_new



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u16.lsp"

Reading "$reduce/cslbuild/generated-c/u17.lsp"

% u17.lsp           Machine generated Lisp

(c!:install "u17" 178071 4720664 5981409)
nil


(c!:install 'simpatom '(simpatom dmode!* !:mod!: current!-modulus
"String" "identifier" !*numval constant lispapply !:rd!: scalar rd!:simp
!*d2q typerr lispeval mksq simp errorset!* errorp complexp getrtype) 
2731299654662377707)
simpatom


(c!:install 'get_goto '(get_goto parser_goto_table) 5242891756119734055)
get_goto


(c!:install 'aex_subrat1 '(aex_subrat1 aex_ex sfto_qsubhor1 kernels
aex_ctx ctx_filter aex_mk) 8596099509159613937)
aex_subrat1


(c!:install 'collect_cars '(collect_cars nreverse) 13682026793595834967)
collect_cars


(c!:install 'qremf '(qremf !*exp qremd praddf multf to negf addf ordop) 
8572729870254090815)
qremf


(c!:install 'updtemplate '(updtemplate reval!-without) 
6684292596128315330)
updtemplate


(c!:install 'tmsf '(tmsf sfp tmsf!*) 14540052551771722099)
tmsf


(c!:install 'talp_td '(talp_td talp_fargl lto_max) 3753277161145513143)
talp_td


(c!:install 'qqe_id!-nyt!-branchq '(qqe_id!-nyt!-branchq qqe_qtidp
qqe_nytidp qqe_qopaddp qqe_qoptailp) 11050168470374905022)
qqe_id!-nyt!-branchq


(c!:install 'pasf_vf '(pasf_vf true false (cong ncong) pasf_evalatp) 
18406771852544693406)
pasf_vf


(c!:install 'ibalp_readclause '(ibalp_readclause true false not
ibalp_arg2l ibalp_arg2r iequal setcar ibalp_process!-var) 
9540077995733504917)
ibalp_readclause


(c!:install 'expt!-mod!-p '(expt!-mod!-p times!-mod!-p) 
17085857477794159462)
expt!-mod!-p


(c!:install 'omsir '(omsir name atts cd (v e c t o r) (vectorml linalg1)
mmleq!* special_cases!* special_cases2!* valid_om!* find apply encodeir)
 15719045185100625031)
omsir


(c!:install 'ps!:expression '(ps!:expression !:ps!: ps!:getv) 
18283141111150797452)
ps!:expression


(c!:install 'evallessp '(evallessp evalgreaterp) 1093636265455228741)
evallessp


(c!:install 'dipilcomb1 '(dipilcomb1 !*gcd vbcsize evzero!? dipprod
evsum evcomp bcprod bczero!? bcsum) 14052257147707387263)
dipilcomb1


(c!:install 'mkprogn '(mkprogn progn) 16326704874711010330)
mkprogn


(c!:install 'getmatelem '(getmatelem "matrix element" matrix "matrix"
mat "Matrix" "not set" "positive integer" typerr rerror
reval_without_mod nth) 1667832788066605898)
getmatelem


(c!:install 'di_restore '(di_restore di_restore1) 7191922973657611938)
di_restore


(c!:install 'negate!-term '(negate!-term minus!-mod!-p) 
15424624617406357051)
negate!-term


(c!:install 'lalr_associativity '(lalr_associativity precedence_table) 
5173428193707042643)
lalr_associativity


(c!:install 'simplify!-filename '(simplify!-filename "/packages/"
starts!-with list2string) 16691211218299472791)
simplify!-filename


(c!:install 'wureducedpolysp '(wureducedpolysp wureducedp) 
14055942286802406885)
wureducedpolysp


(c!:install 'talp_smwrmknowl '(talp_smwrmknowl !*rlsusi cl_susirmknowl
cl_smrmknowl) 1099794248977726135)
talp_smwrmknowl


(c!:install 'setunion '(setunion) 942439817850394096)
setunion


(c!:install 'cl_pnf2 '(cl_pnf2 ex all or and true false not impl repl
equiv bex ball "cl_pnf2():" "invalid as operator" cl_pnf2!-quantifier
cl_pnf2!-junctor rl_external apply rederr) 2844749681406684364)
cl_pnf2


(c!:install 'attributesml '(attributesml ">" " " "=""" definitionurl
vectorml "vector" """" mathml_list2string) 314911681028717662)
attributesml


(c!:install 'spband_matrix '(spband_matrix spm
"Error in spband_matrix(second argument): should be an integer." list
"Error in spband_matrix(first argument): should be single value or list."
"Error in spband matrix(first argument): number of elements must be odd."
quotient
"Error in spband_matrix: too many elements. Band matrix is overflowing."
mkempspmat rederr reval nth letmtr3) 12477874448771780044)
spband_matrix


(c!:install 'dm!-eq '(dm!-eq dm!-difference !:zerop) 
11122949172106058183)
dm!-eq


(c!:install 'removeindices '(removeindices "u= " " x= "
"invalid arguments to removeindices" trwrite !*physopp isanindex idlistp
areallindices rederr2) 1411264797663108431)
removeindices


(c!:install 'il_simp '(il_simp il_simp1) 4935923963562041708)
il_simp


(c!:install 'b!:ordexp '(b!:ordexp) 6049226428041095357)
b!:ordexp


(c!:install 'invbf '(invbf bfone!* !:bprec!: divide!: normbf) 
11480348212648515783)
invbf


(c!:install 'xremainder!-mod!-p '(xremainder!-mod!-p minus!-mod!-p
quotient!-mod!-p multiply!-by!-constant!-mod!-p plus!-mod!-p mksp
times!-term!-mod!-p) 3946349209265973118)
xremainder!-mod!-p


(c!:install 'simpiden '(simpiden list nosimp !*sq odd nonzero ncmp!*
subfg!* linear opvalfn antisymmetric even valuechk aeval mksq fnreval
prepsqxx formlnr simp opmtch ordn repeats permp negsq minusf) 
17265303734153583015)
simpiden


(c!:install 'ra_refine1 '(ra_refine1 x sfto_avgq sfto_qsub1
ra_budancount) 4048150596571684560)
ra_refine1



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u17.lsp"

Reading "$reduce/cslbuild/generated-c/u18.lsp"

% u18.lsp           Machine generated Lisp

(c!:install "u18" 65019 3311847 2073648)
nil


(c!:install 'lex_restore_context '(lex_restore_context lex_fixed_code
lex_next_code lex_dipthong lex_code lex_codename lex_keyword_names
lex_cleanup) 8552250953619299359)
lex_restore_context


(c!:install 'outdefr '(outdefr outref) 18442974756550478845)
outdefr


(c!:install 'processpartitie1 '(processpartitie1 times ext
all_graded_der ordn processcarpartitie1 aeval nth) 5270571181269673177)
processpartitie1


(c!:install 'remove!-free!-vars!* '(remove!-free!-vars!*
!*!*noremove!*!* remove!-free!-vars) 4819420631164452905)
remove!-free!-vars!*


(c!:install 'degree!-in!-variable '(degree!-in!-variable
"Polynomial with a zero coefficient found" errorf max) 
10609189495188617154)
degree!-in!-variable


(c!:install 'constsml '(constsml "<cn" " type=""real""> "
" type=""integer""> " "> " " </cn>" constants!*
"<cn type=""constant""> " "<ci" " type=""list""> " " type=""vector""> "
" </ci>" printout listp) 5623348492682102215)
constsml


(c!:install 'ldt!-tvar '(ldt!-tvar df) 1507920018313660544)
ldt!-tvar


(c!:install 'maprin '(maprin outputhandler!* overflowed!* maprint) 
4776319739805101826)
maprin


(c!:install 'findnewvars '(findnewvars genp lastpair) 935728443037538372
)
findnewvars


(c!:install 'xord_gradlex '(xord_gradlex xord_lex) 15896039013277011291)
xord_gradlex


(c!:install 'physopaeval '(physopaeval !*sq psimpfn physopp !*q2a
opmtch!*) 12861057458750378330)
physopaeval


(c!:install 'contr1!-strand '(contr1!-strand contr2!-strand) 
11639404597423064168)
contr1!-strand


(c!:install 'simp!-sign '(simp!-sign reval simp!-sign1) 
8598755088569764858)
simp!-sign


(c!:install 'sqp '(sqp sfpx) 10901859175073036387)
sqp


(c!:install 'mo_from_a '(mo_from_a cali!=basering "dpoly variable"
ring_all_names typerr mo!=shorten mo!=deglist) 17438636991179603879)
mo_from_a


(c!:install 'get_action '(get_action parser_action_table) 
2610735660823891640)
get_action


(c!:install 'read_typed_name '(read_typed_name cursym!* !*colon!*
general scan read_type) 10497267313877367188)
read_typed_name


(c!:install 'rl_bestgaussp '(rl_bestgaussp rl_bestgaussp!* apply) 
16475081778650507996)
rl_bestgaussp


(c!:install 'mkkl '(mkkl) 18093329309246472598)
mkkl


(c!:install 'findremainder '(findremainder wupseudodivide) 
405066793970175807)
findremainder


(c!:install 'prepsq!* '(prepsq!* !*combinelogs ordl!* factors!*
prepsq!*fn ordop kord!* wtl!* !*rat !*div upl!* dnl!* prepsq!*2
setkorder lastpair sort formop prepsq!*1 replus sqform) 
5539442557942804057)
prepsq!*


(c!:install 'talp_eqtp '(talp_eqtp) 12077953681667779134)
talp_eqtp


(c!:install 'qqe_number!-of!-adds!-in!-qterm '(
qqe_number!-of!-adds!-in!-qterm (ladd radd) qqe_op qqe_arg2r qqe_arg2l) 
14869044607652472136)
qqe_number!-of!-adds!-in!-qterm


(c!:install 'subf '(subf alglist!* ncmp!* expt varstack!* !*d2q
noncomexpf subf1 kernord intersection setkorder reorder kernels prepsq
simp) 17978689418572348717)
subf


(c!:install 'cl_nnf1 '(cl_nnf1 not impl or repl equiv and true false ex
all bex ball cl_cflip rl_negateat) 4862873486018472541)
cl_nnf1


(c!:install 'cgp_number '(cgp_number nth) 3932898882118499463)
cgp_number


(c!:install 'nary '(nary e power exp "<apply>" "<" "/" "</apply>" unary
printout attributesml indent!* multi_elem) 11829697404901466361)
nary


(c!:install 'sacar '(sacar) 4142193243579579156)
sacar


(c!:install 'inshisto '(inshisto codmat maxvar codhisto headhisto min) 
11848284699196277464)
inshisto


(c!:install 'bcplus!? '(bcplus!?) 7742897583963382144)
bcplus!?


(c!:install 'groebbuchcrit4t '(groebbuchcrit4t) 8809090727100979647)
groebbuchcrit4t


(c!:install '!*pf2wedgepf '(!*pf2wedgepf nreverse wedgefax) 
458561407058774177)
!*pf2wedgepf


(c!:install 'pv_times1 '(pv_times1 pv_times2) 5264998160665848358)
pv_times1


(c!:install 'general!-reduce!-degree!-mod!-p '(
general!-reduce!-degree!-mod!-p general!-modular!-minus
general!-modular!-quotient general!-multiply!-by!-constant!-mod!-p
general!-plus!-mod!-p mksp general!-times!-term!-mod!-p) 
1728089144768213125)
general!-reduce!-degree!-mod!-p


(c!:install 'update_kc_list '(update_kc_list list_assoc addf) 
8917953687871662656)
update_kc_list


(c!:install 'ofsf_pow2q '(ofsf_pow2q to) 9555663570031789959)
ofsf_pow2q


(c!:install 'prepreform '(prepreform ordl!* factors!* prepreform1) 
5970433628684237291)
prepreform


(c!:install 'exptcompare '(exptcompare) 5372125586460383598)
exptcompare


(c!:install 'cl_smsimpl!-junct2 '(cl_smsimpl!-junct2 !*rlsichk !*rlsiso
rl_ordatp !*rlsisocx cl_sordp rl_smmkatl lto_insert sort cl_flip) 
10742815408394509146)
cl_smsimpl!-junct2


(c!:install 'cl_pnf2!-junctor '(cl_pnf2!-junctor all ex cl_pnf2 cl_qb
cl_interchange) 17851120715859743429)
cl_pnf2!-junctor


(c!:install 'aex_fvarl '(aex_fvarl aex_varl aex_ctx ctx_idl lto_setminus
) 750318054444415879)
aex_fvarl


(c!:install 'variablesir '(variablesir char (!/ o m b v a r) omvir lex) 
2307334160926180555)
variablesir


(c!:install 'freeoff '(freeoff sfp ndepends) 8924154528667918378)
freeoff


(c!:install 'deleteall '(deleteall) 8011811616758810551)
deleteall


(c!:install 'cstimes '(cstimes times) 13052923761714089834)
cstimes


(c!:install 'simprepart '(simprepart !*factor simp!* repartsq) 
15241199411347169298)
simprepart


(c!:install 'command '(command errmsg!* loopdelimslist!* !*demo ifl!*
!*slin !*reduce4 lreadfn!* crchar!* !$eol!$ !*struct !*pret (in out shut
) cursym!* end symbolic key!* quote nochange intfn list (setq setel setf
) !*mode !*debug "Parse: " !*semicol!* "Form: " commdemo setcloc!*
lispapply readch1 command1 structchk rprint form convertmode1
prettyprint n_form) 7395038323042452601)
command


(c!:install 'sf_member '(sf_member mvar_member) 14719990412433707996)
sf_member


(c!:install '!:divide '(!:divide poly "zero divisor" divide rerror
dividef dcombine) 229903107460967749)
!:divide


(c!:install 'b!:extadd '(b!:extadd addf b!:ordexp) 18403102327845111352)
b!:extadd


(c!:install 'in_list1 '(in_list1 in_list1a) 14837564741053915885)
in_list1



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u18.lsp"

Reading "$reduce/cslbuild/generated-c/u19.lsp"

% u19.lsp           Machine generated Lisp

(c!:install "u19" 80086 4912990 3394247)
nil


(c!:install 'polynomheadreduceby '(polynomheadreduceby
fluidbibasisreductionsmade monomisdivisibleby monomdivide
polynommultiplybymonom polynomadd) 9096444161962194715)
polynomheadreduceby


(c!:install 'wusort '(wusort wulessp!* sort) 18081394487224094920)
wusort


(c!:install 'talp_simplatat '(talp_simplatat equal talp_getl talp_mk2
talp_telp talp_simplt) 2110880859993528509)
talp_simplatat


(c!:install 'qqe_simplat1 '(qqe_simplat1 (qequal qneq) qequal qqe_op
qqe_simplbtat qqe_simplqequal qqe_simplqneq) 12685611520394717593)
qqe_simplat1


(c!:install 'cl_mkstrict '(cl_mkstrict true false or and not impl repl
equiv ex all bex ball "BUG IN cl_mkstrict" cl_flip rederr) 
14791651113633268151)
cl_mkstrict


(c!:install 'variableom '(variableom constantsom!* "<OMS " "cd=""" """ "
"name=""" """/>" "<OMV " printout) 12706099796162667316)
variableom


(c!:install 'onoff '(onoff "switch" rlisp "not defined as switch" !*
!*switchcheck simpfg progn !*raise !*!L!O!W!E!R !*lower typerr rerror
list2string lispeval) 9564493937238698320)
onoff


(c!:install 'guesspftype '(guesspftype (wedge d partdf hodge innerprod
liedf) xvarlistp mknwedge) 6617237155091291956)
guesspftype


(c!:install 'equalreplaceby '(equalreplaceby replaceby) 
5829985681306237097)
equalreplaceby


(c!:install 'prinfit '(prinfit !*nat testing!-width!* oprin maprint
layout!-formula putpline) 5379266790443549343)
prinfit


(c!:install 'gpexp1p '(gpexp1p gpexpp) 14677648976422768513)
gpexp1p


(c!:install 'copyd '(copyd !*savedef rlisp "has no definition in copyd"
lose getd rerror putd) 644475855128438402)
copyd


(c!:install 'class '(class ordering lex ord leftzeros) 
1327487842138551510)
class


(c!:install 'lexer_word_starter '(lexer_word_starter !_ lexer_style!* !'
!\ land) 4067608986831865765)
lexer_word_starter


(c!:install 'gcref_mkedges!-tgf '(gcref_mkedges!-tgf " " prin2t) 
410047465957300676)
gcref_mkedges!-tgf


(c!:install 'replus '(replus plus unplus) 8598976190420398820)
replus


(c!:install 'rl_subat '(rl_subat rl_subat!* apply) 3129701482753207433)
rl_subat


(c!:install 'subf1 '(subf1 dmode!* resimplify varstack!* wtl!*
asymplis!* k!* yetunknowntype list "substituted expression" frlis!*
simpatom !*d2q prepf simp degr wtchk subsublis getrtype
eval!-yetunknowntypeexpr typerr setkorder reordsq kernp prepsq simpexpt
exptsq subs2 multsq addsq sub2chk simprecip) 12224686838927291519)
subf1


(c!:install 'cl_rename!-vars1 '(cl_rename!-vars1 or and not impl repl
equiv ex all rl_varsubstat bex ball setcdr mkid setcar cl_apply2ats1) 
12642081936849877370)
cl_rename!-vars1


(c!:install 'bc_2sq '(bc_2sq) 2666237714914294559)
bc_2sq


(c!:install 'termorder '(termorder listsum termorder1) 
7713265788379872149)
termorder


(c!:install 'stats_getargs '(stats_getargs mathml) 13284419938155693538)
stats_getargs


(c!:install 'convchk '(convchk !*!*roundbf !:rd!: fl2bf read!:num normbf
bf2flck) 2300856283230210226)
convchk


(c!:install 'bcquot '(bcquot !*grmod!* !*vdpinteger quotientx bcfi
bcint2op quotfx quotsq) 10560766879555860784)
bcquot


(c!:install 'vdpputprop '(vdpputprop dipoly
"vdpputprop given a non-vdp as 1st parameter" rerror) 
6517493718410928961)
vdpputprop


(c!:install 'add2resultbuf '(add2resultbuf !*libreduce_active semic!* !$
statcounter !*mode symbolic !*reduce4 empty_list !*nosave!* ws alglist!*
resultbuflis!* lr_result lr_printer lr_statcounter lr_mode lr_posttext
putobject terminalp) 7966353812840996655)
add2resultbuf


(c!:install 'groeb!=better '(groeb!=better nth mo_compare) 
13353753091460686345)
groeb!=better


(c!:install 'ord2 '(ord2 ordp) 16225334524871574020)
ord2


(c!:install 'moduntag '(moduntag !:mod!: nreverse) 12941555493178756383)
moduntag


(c!:install 'mksq '(mksq subfg!* wtl!* k!* !*nosubs used!* asymplis!*
powlis!* (expt sqrt) !*sub2 mksqsubfn !*resubs fkern getpower multsq
aconc simpcar exptsq) 3239795195940164016)
mksq


(c!:install 'rrdls '(rrdls ttype!* !) !. " " nxtsym!*
"Invalid S-expression" rread1 ptoken symerr) 13495039264772142997)
rrdls


(c!:install 'read_namelist '(read_namelist cursym!* !*comma!*
valid_as_variable read_typed_name scan) 3194005069515663249)
read_namelist


(c!:install 'sfto_ucontentf1 '(sfto_ucontentf1 sfto_gcdf!*) 
3961881911748146012)
sfto_ucontentf1


(c!:install 'expnd1 '(expnd1 sfp multf exptf addf) 14859460201852111458)
expnd1


(c!:install 'ev_sum '(ev_sum) 3122904571819917221)
ev_sum


(c!:install 'mml2om '(mml2om "Intermediate representation: " mml2ir
terpri!* ir2om) 10393749499664844907)
mml2om


(c!:install 'vbcgcd '(vbcgcd (1 . 1) vbcsize gcdf!*) 
15164924111555833188)
vbcgcd


(c!:install 'mkarray1 '(mkarray1 symbolic) 6129314003741608478)
mkarray1


(c!:install 'idcons_ordp '(idcons_ordp atom_compare cons_ordp) 
17803095815279840494)
idcons_ordp


(c!:install 'general!-expt!-mod!-p '(general!-expt!-mod!-p
general!-times!-mod!-p) 12454319538062397665)
general!-expt!-mod!-p


(c!:install 'lex_start_line_comment '(lex_start_line_comment !%
lexer_style!* !# !/ land yypeek) 16879018531008787476)
lex_start_line_comment


(c!:install 'rl_atl '(rl_atl rl_atl!* apply) 6673392338047636236)
rl_atl


(c!:install 'om2mml '(om2mml "Intermediate representation:" om2ir
terpri!* ir2mml) 10011268629939126471)
om2mml


(c!:install 'floatprop '(floatprop !:rd!:) 9827860526588982079)
floatprop


(c!:install '!*wedgepf2pf '(!*wedgepf2pf nreverse mkuwedge) 
5371658738046325164)
!*wedgepf2pf


(c!:install 'delete!-dups '(delete!-dups nreverse) 12574236897102092115)
delete!-dups


(c!:install 'inttovec '(inttovec inttovec!-solve inttovec1) 
13972934414845309666)
inttovec



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u19.lsp"

Reading "$reduce/cslbuild/generated-c/u20.lsp"

% u20.lsp           Machine generated Lisp

(c!:install "u20" 81147 5184750 9366662)
nil


(c!:install 'physop!-ordop '(physop!-ordop physopname specoplist!*
!*physopp ordop2 opnum!*) 16931902939745874235)
physop!-ordop


(c!:install 'zero!-roads '(zero!-roads z!-roads) 3317503514972784561)
zero!-roads


(c!:install 'addgt '(addgt ordering lex plus eval) 8619459172360026762)
addgt


(c!:install 'lex_save_context '(lex_save_context lex_codename
lex_dipthong) 11187934857878174740)
lex_save_context


(c!:install 'ctx_filter '(ctx_filter ctx ctx_ial lastpair) 
17427181523192344843)
ctx_filter


(c!:install 'ofsf_entry2at '(ofsf_entry2at !*rlidentify ofsf_entry2at1
cl_identifyat) 12102495547416178926)
ofsf_entry2at


(c!:install 'monomdivide '(monomdivide) 13462168600263362237)
monomdivide


(c!:install 'rl_nnf '(rl_nnf rl_nnf!* apply) 3613698152756377119)
rl_nnf


(c!:install 'innprodkp '(innprodkp reversip2) 18318363658522855146)
innprodkp


(c!:install 'talp_rnf1 '(talp_rnf1 true false cl_simpl talp_atfp
talp_acfrp talp_raf talp_op talp_argl) 3402747954690578402)
talp_rnf1


(c!:install 'distribute!.multiplicity '(distribute!.multiplicity) 
499274864297745022)
distribute!.multiplicity


(c!:install 'ibalp_readform '(ibalp_readform and true !*rlverbose
"Detected empty clause" "Tautology detected"
"Deleted redundant clauses: " cl_mkstrict ibalp_readclause
ibalp_emptyclausep ibalp_clmember ibalp_redclause ibalp_undoclause
ioto_tprin2t) 5947913626491699670)
ibalp_readform


(c!:install 'ir2om '(ir2om ind indent "<OMOBJ>" "</OMOBJ>" printout
indent!* objectom) 13344185890426862144)
ir2om


(c!:install 'xord_deglex '(xord_deglex xdegreemon xord_lex) 
6562052768447853320)
xord_deglex


(c!:install 'contr '(contr nreverse split!-road) 14248345332913076555)
contr


(c!:install 'repasc '(repasc alg "key" "not found" rerror nreverse) 
17544293124976533301)
repasc


(c!:install 'general!-reduce!-mod!-p '(general!-reduce!-mod!-p
general!-modular!-number !*n2f) 13879095035151486545)
general!-reduce!-mod!-p


(c!:install 'ordexn '(ordexn ordop) 11796463192895462512)
ordexn


(c!:install 'ofsf_smmkatl1 '(ofsf_smmkatl1 and ofsf_smmkatl!-and
ofsf_smmkatl!-or) 5746707685276759436)
ofsf_smmkatl1


(c!:install 'ibalp_calcmom '(ibalp_calcmom) 12531742832238813395)
ibalp_calcmom


(c!:install 'groebcplistsortin '(groebcplistsortin groebcplistsortin1) 
6911557174824682766)
groebcplistsortin


(c!:install 'invp '(invp unit inverse (comm anticomm) quotient) 
12723263780771004771)
invp


(c!:install 'th_match '(th_match th_match0 dl_get) 16649238676373897991)
th_match


(c!:install '!:expt '(!:expt poly "0/0 formed" expt rerror fieldp
mkratnum !:recip) 1906246832538517278)
!:expt


(c!:install 'print_with_margin_sub '(print_with_margin_sub "(" " " ". "
" ." ")" "\" apply) 12678370922493737021)
print_with_margin_sub


(c!:install 'simp!*sq '(simp!*sq !*resimp resimp1) 5817631147132282818)
simp!*sq


(c!:install 'talp_invn '(talp_invn talp_op) 3909389058722197269)
talp_invn


(c!:install 'cl_susiminlevel '(cl_susiminlevel ignore min) 
14130220163383969551)
cl_susiminlevel


(c!:install 'tobvarir '(tobvarir bvar) 4702481268318296806)
tobvarir


(c!:install 'formcond '(formcond cond formcond1) 16529543232591512534)
formcond


(c!:install 'evalequal '(evalequal difference getrtype reval) 
9329211343958556356)
evalequal


(c!:install 'mv2sf1 '(mv2sf1 to) 1194448756361659613)
mv2sf1


(c!:install 'di_insert '(di_insert eqdummy) 17399345672664134114)
di_insert


(c!:install 'decprec2internal '(decprec2internal !!log2of10 ceiling) 
11314076629012560127)
decprec2internal


(c!:install 'carrassoc '(carrassoc "RASSOC trouble: " " "
"rassoc trouble" rassoc rederr) 3017662206685756414)
carrassoc


(c!:install 'make_tuple_type '(make_tuple_type unit times collect_cdrs) 
8488267518516290328)
make_tuple_type


(c!:install 'triplesetprolongset '(triplesetprolongset) 
2405898036471723158)
triplesetprolongset


(c!:install 'findnthroot '(findnthroot) 9176337541059857052)
findnthroot


(c!:install 'basic!-simpexpt '(basic!-simpexpt kord!* expt resimp carx
simpexpon simpexpon1 simpexpt1) 16670121342641082923)
basic!-simpexpt


(c!:install 'applyrd '(applyrd atts (type definitionurl encoding)
mmlatts char functions!* lex retattributes compress!* apply errorml) 
5937752342201095232)
applyrd


(c!:install 'merge!-ind!-vars '(merge!-ind!-vars !*nocommutedf
!*commutedf derad!* derad) 14484345647347537311)
merge!-ind!-vars


(c!:install 'vdpred '(vdpred vdp !*gsugar sugar vdpgetprop gsetsugar) 
8803224557537834395)
vdpred


(c!:install 'indexvarordp '(indexvarordp kord!* indxl!* ordop flatindxl
boundindp indordlp) 574791126496740713)
indexvarordp


(c!:install 'cut!:mt '(cut!:mt !:rd!: msd ashift bflerrmsg) 
17626522596820174603)
cut!:mt


(c!:install 'lispassignp '(lispassignp setq) 2642839349066567258)
lispassignp


(c!:install 'begin1a '(begin1a otime!* gctime ogctime!* otime3!*
otime2!* otime1!* ogctime3!* ogctime2!* ogctime1!* peekchar!*
!*semicol!* cursym!* curescaped!* !*nosave!* statcounter !*strind !*time
(showtime nil) !*output ofl!* !*defn !*lessspace tslin!* !*slin
lreadfn!* initl!* forkeywords!* delim repeatkeywords!* whilekeywords!*
!*int erfg!* end key!* ed promptexp!* (command) symbolic xmodule err2
err3 crbuf1!* "Closing object improperly removed. Redo edit." eof!*
"End-of-file read" (bye) crbuf!* "BEGIN invalid" !*errcont !*echo cmsg!*
"Continuing with parsing only ..." getd terminalp add2buflis
update_prompt lispeval sinitl comm1 printprompt errorset!* condterpri
errorp eval xmodloop begin11 lprim eofcheck resetparser lprie pause1) 
15464049452614239342)
begin1a


(c!:install 'bas_newnumber '(bas_newnumber) 16517938802484585713)
bas_newnumber


(c!:install 'traput '(traput toplv!*) 3292699011526603121)
traput


(c!:install 'ofsf_varlat '(ofsf_varlat !*rlbrkcxk kernels lto_lpvarl
lastpair) 832260251403056635)
ofsf_varlat


(c!:install 'rl_csimpl '(rl_csimpl !*rlsimpl rl_simpl getd) 
14355992846025687008)
rl_csimpl


(c!:install 'mkprod '(mkprod !*exp !*sub2 !*mcd !*sqfree !*factor !*gcd
!*group kernlp subs2 ckrn quotf expnd multf fctrf mksp!* tmsf) 
5396723553033127465)
mkprod


(c!:install 'lto_max1 '(lto_max1 max) 6102494270337772939)
lto_max1


(c!:install 'bc_fd '(bc_fd) 17852619050421096071)
bc_fd


(c!:install 'ir2mml '(ir2mml (indent) ind indent "<math>" "</math>"
fluid printout indent!* expression) 10494619312634463605)
ir2mml


(c!:install 'testredzz '(testredzz codmat maxvar testredh) 
13911561270740505926)
testredzz


(c!:install 'list!-mgen '(list!-mgen i mgenp) 11037495168508222293)
list!-mgen


(c!:install 'expand!-imrepart '(expand!-imrepart expand!-imrepartpow
multsq addsq) 4340953945397562236)
expand!-imrepart



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u20.lsp"

Reading "$reduce/cslbuild/generated-c/u21.lsp"

% u21.lsp           Machine generated Lisp

(c!:install "u21" 46859 36522 886874)
nil


(c!:install 'mvar_member '(mvar_member arglist_member) 
6863625781480248750)
mvar_member


(c!:install 'rnminusp!: '(rnminusp!:) 15441971619235793483)
rnminusp!:


(c!:install 'mo_times_ei '(mo_times_ei mo!=deglist) 17361248855841632455
)
mo_times_ei


(c!:install 'reverse!-num '(reverse!-num ilog2 reverse!-num1) 
18206649692555189733)
reverse!-num


(c!:install 'mkcr '(mkcr !:cr!: striptag) 8740268834466376872)
mkcr


(c!:install 'lalr_prin_rhs '(lalr_prin_rhs "<empty>" " "
lalr_prin_symbol) 14916345468253414621)
lalr_prin_rhs


(c!:install 'cl_nnf '(cl_nnf cl_nnf1) 8829395629140112282)
cl_nnf


(c!:install 'cl_simpl1 '(cl_simpl1 true false or and not ex all !*rlsism
bex ball impl repl equiv cl_simpl "cl_simpl1(): unknown operator"
cl_smsimpl!-junct cl_flip cl_atfp rl_negateat cl_negate!-invol
rl_smrmknowl cl_fvarl cl_simplbq cl_smsimpl!-imprep cl_smsimpl!-equiv
rl_external apply cl_simplat rl_smcpknowl rl_smupdknowl rl_smmkatl
rederr) 7900051791536078423)
cl_simpl1


(c!:install 'pasf_pdp '(pasf_pdp indef ndef pdef psdef nsdef) 
10778362112038030753)
pasf_pdp


(c!:install 'bc_zero!? '(bc_zero!?) 3361078047900863411)
bc_zero!?


(c!:install 'get!-height '(get!-height max) 14864850226468545265)
get!-height


(c!:install 'mchkopt1 '(mchkopt1 mchk) 10998985577953184966)
mchkopt1


(c!:install 'simprecip '(simprecip !*mcd recip carx simpexpt simp invsq)
 13770365170578457092)
simprecip


(c!:install 'rd!:prep '(rd!:prep !*noconvert rdprep1 rd!:onep rd!:minus)
 11603492088250160958)
rd!:prep


(c!:install 'evmtest!? '(evmtest!? evzero!?) 15886030283057574368)
evmtest!?


(c!:install 'expvec2a '(expvec2a dipvars!* expvec2a1) 
3930427775688298587)
expvec2a


(c!:install 'treesizep '(treesizep treesizep1) 10453696496790543754)
treesizep


(c!:install 'ncoeffs '(ncoeffs) 12409446099339202337)
ncoeffs


(c!:install 'next!-random!-number '(next!-random!-number unidev_next!*
unidev_nextp!* unidev_vec!* randommodulus!*) 9218661205682165902)
next!-random!-number


(c!:install 'nfactorial '(nfactorial fac!-part) 11955986384875425120)
nfactorial


(c!:install 'reducepowers '(reducepowers repowl!* multf addf to) 
12483380312515197174)
reducepowers


(c!:install 'setk0 '(setk0 frasc!* setelemfn alglist!* setkfn
setstructfn getrtype let2) 4233801245120844391)
setk0


(c!:install 'gcref_select '(gcref_select defd gcref_nolist!* lastpair) 
7902127832781297365)
gcref_select


(c!:install 'vintersection '(vintersection) 1055362262337549666)
vintersection


(c!:install 'cl_atl '(cl_atl rl_ordatp cl_atl1 sort) 
15765875926403321009)
cl_atl


(c!:install 'pasf_sisub '(pasf_sisub ex all bex ball and true false or
not impl repl equiv pasf_sisub!-gand subf pasf_simplat1) 
12594235870663624231)
pasf_sisub


(c!:install 'dipevlcomp '(dipevlcomp evcompless!?) 9202483066576761064)
dipevlcomp


(c!:install 'assert_format '(assert_format !! !) !  !- !> !, !: !() 
232553727999427196)
assert_format


(c!:install 'mv!-domainlist '(mv!-domainlist nreverse) 
11825405860212261670)
mv!-domainlist


(c!:install 'rnprep!: '(rnprep!: quotient prepf) 9263574273757246310)
rnprep!:


(c!:install 'rootrnd '(rootrnd acc!# rtrnda) 6336503232854120811)
rootrnd


(c!:install 'prin_with_margin '(prin_with_margin explode
print_with_margin_sub) 6076479413304500728)
prin_with_margin


(c!:install 'mk!+unit!+mat '(mk!+unit!+mat gen!+can!+bas) 
14051174035683025759)
mk!+unit!+mat


(c!:install 'fctrf1 '(fctrf1 dmode!* unitsfn lnc !:recip multd comfac
comfac!-to!-poly quotf to multf minusf negf factor!-prim!-f fac!-merge) 
10808334927500479478)
fctrf1


(c!:install 'sfto_b!:ordexn '(sfto_b!:ordexn) 17261733892501122236)
sfto_b!:ordexn


(c!:install 'dm!-gt '(dm!-gt dm!-difference !:minusp) 123006194363475270
)
dm!-gt


(c!:install 'chk '(chk bsubs freexp reval) 17717158727759000305)
chk


(c!:install 'coposp '(coposp contposp covposp) 11725766072842963279)
coposp


(c!:install 'partitexdf '(partitexdf partitop exdfpf) 
7123755117058510409)
partitexdf


(c!:install 'inttovec!-solve '(inttovec!-solve) 14272456348591913501)
inttovec!-solve


(c!:install 'contr2!-strand '(contr2!-strand contrsp contr2) 
12378258184561139660)
contr2!-strand


(c!:install 'sf2mv1 '(sf2mv1 nzeros) 1882801885337988282)
sf2mv1


(c!:install '!:rn2rd '(!:rn2rd !*roundall !*rounded !*rn2rd) 
10693778180305933844)
!:rn2rd


(c!:install 'tensorp '(tensorp tensor) 17302022901939332459)
tensorp


(c!:install 'ilcm '(ilcm) 2240973133276570764)
ilcm


(c!:install 'general!-reciprocal!-by!-gcd '(general!-reciprocal!-by!-gcd
alg "Invalid modular division" current!-modulus rerror) 
9632722898683028321)
general!-reciprocal!-by!-gcd


(c!:install 'lalr_precalculate_first_sets '(lalr_precalculate_first_sets
nonterminals lalr_first (nil) lalr_productions union) 
18330027650390435958)
lalr_precalculate_first_sets


(c!:install 'squared!+matrix!+p '(squared!+matrix!+p matrix!+p
get!+row!+nr get!+col!+nr) 14307445742045415676)
squared!+matrix!+p


(c!:install 'cl_flip '(cl_flip and or all ex ball bex true false
"cl_flip(): don't know" rederr) 5068947937171819402)
cl_flip


(c!:install 'rl_susitf '(rl_susitf rl_susitf!* apply) 
2152268618212021997)
rl_susitf


(c!:install 'vsl_boundtype '(vsl_boundtype vsl_boundtype1) 
3575532393259757734)
vsl_boundtype


(c!:install 'sfto_b!:extmult '(sfto_b!:extmult sfto_b!:ordexn multf negf
sfto_b!:extadd) 16650362805446348592)
sfto_b!:extmult



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u21.lsp"

Reading "$reduce/cslbuild/generated-c/u22.lsp"

% u22.lsp           Machine generated Lisp

(c!:install "u22" 115631 7526481 6375096)
nil


(c!:install 'ps!:expt!-erule '(ps!:expt!-erule ps quotient ps!:order
ps!:evaluate prepsqxx simpexpt multsq addsq quotsq) 4861335937420962614)
ps!:expt!-erule


(c!:install 'setmat '(setmat !*modular modular mod_was_on !*mod_was_on
off on reval simp mk!*sq letmtr) 10636488396691815209)
setmat


(c!:install 'coordp '(coordp coord!*) 11743679015531548263)
coordp


(c!:install 'indord2 '(indord2 indordp) 6229707147736923103)
indord2


(c!:install 'begin11 '(begin11 errmsg!* newrule!* cursym!* end
!*lisp_hook !*semicol!* curescaped!* !*nosave!* !*reduce4 retry
programl!* "No previous expression" program!* c eof!* (bye quit) bye
!*byeflag!* ed cedit "ED not supported" !*defn erfg!* key!* ignore quote
eval !*output ifl!* !*echo !*lessspace ulimit!* err2 symbolic noval
semic!* !$ !*debug "Value:" print !*mode assgnpri list only err3
"of type: " terminalp comm1 lprim eofcheck add2inputbuf getd lispeval
dfprint errorset_with_timeout errorset!* errorp getsetvars mkobject type
value add2resultbuf prin2t rapply1) 7088378187182402808)
begin11


(c!:install 'mv!-pow!-mv!-!+ '(mv!-pow!-mv!-!+ nreverse
mv!-pow!-mv!-term!-!+) 1405175115176094435)
mv!-pow!-mv!-!+


(c!:install 'moid_member '(moid_member mo_vdivides!?) 
8335995647837504883)
moid_member


(c!:install 'arglist_member '(arglist_member mvar_member) 
1448133497086074019)
arglist_member


(c!:install 'exc '(exc) 3033767915002397882)
exc


(c!:install 'sfto_kexp '(sfto_kexp to) 16941872972440124794)
sfto_kexp


(c!:install 'gcref_mkgraph '(gcref_mkgraph !*gcrefudg gcref_mkgraph!-udg
gcref_mkgraph!-tgf) 16501711106482065827)
gcref_mkgraph


(c!:install 'setqget '(setqget fluidbibasissetq) 3614657392984134839)
setqget


(c!:install 'ezgcdf1 '(ezgcdf1 factor!-level gcdlist poly!-abs) 
12619626237804511922)
ezgcdf1


(c!:install 'talp_eqnrhskernels '(talp_eqnrhskernels talp_varlt) 
15705245276850491214)
talp_eqnrhskernels


(c!:install 'ctx_new '(ctx_new ctx) 16190024625074221445)
ctx_new


(c!:install 'evaluate!-mod!-p '(evaluate!-mod!-p
"Variable=NIL in evaluate-mod-p" errorf horner!-rule!-mod!-p) 
8495381782169598297)
evaluate!-mod!-p


(c!:install 'getsetvars '(getsetvars (setel setk) setq nreverse
getsetvarlis) 18250301885244068347)
getsetvars


(c!:install 'ps!:minusp!: '(ps!:minusp!:) 12865032380111219041)
ps!:minusp!:


(c!:install 'xdegreecheck '(xdegreecheck xtruncate!* xdegree) 
16134868831849171205)
xdegreecheck


(c!:install 'indordp '(indordp indxl!*) 12196739466098183865)
indordp


(c!:install 'symbvarlst '(symbvarlst symbolic !*novarmsg
"local variable" "in procedure" fname!* "not used" lprim) 
11880543463868967817)
symbvarlst


(c!:install 'mv!-domainlist!-!+ '(mv!-domainlist!-!+ nreverse) 
8590847628761397511)
mv!-domainlist!-!+


(c!:install 'qremd '(qremd dmode!* !:recip multd !:divide qremf multf
praddf) 10425066619628788925)
qremd


(c!:install 'ad_numsort '(ad_numsort lambda_ygm6np4pcqv31 sort) 
16543228242407104281)
ad_numsort


(c!:install 'lambda_ygm6np4pcqv31 '(lambda_ygm6np4pcqv31) 
15088082726560262194)
lambda_ygm6np4pcqv31


(c!:install 'cde_delete '(cde_delete) 9823375113000725104)
cde_delete


(c!:install 'derivative!-mod!-p!-1 '(derivative!-mod!-p!-1
multiply!-by!-constant!-mod!-p mksp) 10394859023526844875)
derivative!-mod!-p!-1


(c!:install 'collect_cdrs '(collect_cdrs nreverse) 7170354752017259199)
collect_cdrs


(c!:install 'pasf_simplat1 '(pasf_simplat1 true false (cong ncong) (
equal neq) !*rlsifac pasf_zcong pasf_mkpos pasf_dt pasf_vf pasf_mr
pasf_cecong pasf_ceeq pasf_cein pasf_sc pasf_se pasf_or pasf_fact) 
16069071823626386981)
pasf_simplat1


(c!:install 'reln '(reln "<apply>" "<" "/" "</apply>" printout
attributesml indent!* multi_elem) 6783350485341983158)
reln


(c!:install 'diffsq '(diffsq difff multsq negsq addsq) 
16022676321092207227)
diffsq


(c!:install 'wedgek2 '(wedgek2 wedge deg!*form wedgef mksgnsq multpfsq
wedgewedge worderp multf addf wedgepf2) 3773862610735621281)
wedgek2


(c!:install 'fortexp '(fortexp fortexp1) 2129437788835831713)
fortexp


(c!:install 'repartf '(repartf i kord!* cmpxfn reorder int!-equiv!-chk
multf addf) 14224353227990139716)
repartf


(c!:install 'assert_uninstall1 '(assert_uninstall1 assert_installed
"assert not installed for" assert_noassertfn lprim copyd) 
607520633056819972)
assert_uninstall1


(c!:install 'setel1 '(setel1 "array index" rlisp "Array out of bounds"
typerr rerror) 3794863250471577185)
setel1


(c!:install 'fs!:times '(fs!:times fs!:timesterm fs!:plus) 
15873497473748151398)
fs!:times


(c!:install 'splitlist!: '(splitlist!: nreverse) 18308525391940220589)
splitlist!:


(c!:install 'resimpf '(resimpf varstack!* subf1) 2301003585008741541)
resimpf


(c!:install 'crprcd2 '(crprcd2 yy!! crprcd) 9422509343997585347)
crprcd2


(c!:install 'aex_mvar '(aex_mvar aex_ex sfto_mvarx) 825715285579730944)
aex_mvar


(c!:install '!*!*a2s '(!*!*a2s "tell Hearn!!" nochange getel random
lambda (!*uncached) progn (declare (special !*uncached)) !*!*a2sfn
rederr smember) 3091982019534209199)
!*!*a2s


(c!:install 'groebcplistsortin1 '(groebcplistsortin1 groebcpcompless!?) 
2335539680124099030)
groebcplistsortin1


(c!:install 'bytelist2id '(bytelist2id list2string) 12064254433591601924
)
bytelist2id


(c!:install 'mktails1 '(mktails1 replace_by_vector getroad mkinds) 
4039047385005761530)
mktails1


(c!:install 'one!-entry!-listp '(one!-entry!-listp one!-entryp) 
4274742246768401682)
one!-entry!-listp


(c!:install 'setelv '(setelv reval_without_mod setel) 
10897900906222372279)
setelv


(c!:install 'prepd1 '(prepd1 prepfn) 17356533224157260373)
prepd1


(c!:install 'pst_termnodep '(pst_termnodep) 9722157953327035154)
pst_termnodep


(c!:install 'ratn '(ratn !:rn!: arnum "Illegal domain in :ar:" rerror) 
11435966345470479614)
ratn


(c!:install 'quotfail!-in!-vector '(quotfail!-in!-vector
"Attempt to divide by zero" "Bad degrees in quotfail-in-vector"
"Quotient not exact in quotfail!-in!-vector" errorf) 2449513729194402360
)
quotfail!-in!-vector


(c!:install 'subsublis '(subsublis sqrt expt (quotient 1 2) subfunc !*sq
prepsq) 11015806341792197022)
subsublis


(c!:install 'homogp '(homogp lastnondomain listsum) 10718859950017304996
)
homogp


(c!:install 'unaryrd '(unaryrd mathml lex) 13082927852549454775)
unaryrd


(c!:install 'inttovec1 '(inttovec1 inttovec!-solve) 6831836483047742586)
inttovec1


(c!:install 'mkfortterpri '(mkfortterpri fortterpri) 
11375405539389178281)
mkfortterpri


(c!:install 'trwrite '(trwrite "**in procedure: ") 2614111771358147492)
trwrite


(c!:install 'lienjactest '(lienjactest lie_jtest difference plus times
lie_cc aeval setk aeval!* aminusp!: evalneq) 10602272048410938972)
lienjactest



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u22.lsp"

Reading "$reduce/cslbuild/generated-c/u23.lsp"

% u23.lsp           Machine generated Lisp

(c!:install "u23" 102378 8773268 1936030)
nil


(c!:install 'arplus!: '(arplus!: dmode!* !*exp !:ar!: addf) 
7059790470572779135)
arplus!:


(c!:install 'gfk '(gfk) 11262899965118494565)
gfk


(c!:install 'coeffs '(coeffs) 12529034742237044805)
coeffs


(c!:install 'dfprint '(dfprint dfprint!* cmsg!* progn lispapply
prettyprint) 2450076919034117572)
dfprint


(c!:install 'monomwrite '(monomwrite fluidbibasisnumberofvariables
fluidbibasisreversedvariables) 9581876070223371965)
monomwrite


(c!:install 'mkpartitions1 '(mkpartitions1) 7819729771628254956)
mkpartitions1


(c!:install 'rl_atnum '(rl_atnum rl_atnum!* apply) 8237877010188341013)
rl_atnum


(c!:install 'tayexp!-times2 '(tayexp!-times2 !*i2rn rntimes!:) 
13349100696667971078)
tayexp!-times2


(c!:install 'talp_subt '(talp_subt) 13420465045802095597)
talp_subt


(c!:install 'qqe_arg!-check '(qqe_arg!-check
"some arguments are not of queue type"
"some arguments are not of basic type" qqe_rqopp qqe_arg!-check!-lq!-rq
qqe_rbopp qqe_arg!-check!-lb!-rb qqe_qopheadp qqe_qoptailp
qqe_arg!-check!-q qqe_arg!-check!-marked!-ids!-rollback typerr
qqe_qopaddp qqe_arg!-check!-lb!-rq qqe_arg!-check!-b) 
5175762209027666479)
qqe_arg!-check


(c!:install 'sq2sstm '(sq2sstm mkzl sq2sscfpl mapins) 
5071099399776619737)
sq2sstm


(c!:install 'reform!-minus '(reform!-minus minus quotient) 
15276675690354575397)
reform!-minus


(c!:install 'dm!-minus '(dm!-minus !:minus) 10290397497140270953)
dm!-minus


(c!:install 'dip!-nc!-ev!-prod1 '(dip!-nc!-ev!-prod1 dip!-nc!-ev!-prod2)
 12179655020623235541)
dip!-nc!-ev!-prod1


(c!:install 'evgradlexcomp '(evgradlexcomp (0) iequal evtdeg) 
8775094928344431027)
evgradlexcomp


(c!:install 'collectphystype '(collectphystype physopp getphystype
deletemult!*) 13475269568287233990)
collectphystype


(c!:install 'replace1_parents '(replace1_parents replace2_parents) 
13308275718975735306)
replace1_parents


(c!:install 'pairxvars '(pairxvars scalar "Invalid parameter:" symerr
reversip!*) 9833767818965482635)
pairxvars


(c!:install 'scalprod '(scalprod matrix "Matrix mismatch" rerror multsq
addsq) 4771978532570979384)
scalprod


(c!:install 'simp!-prop!-order '(simp!-prop!-order prop!*) 
16175865636005428393)
simp!-prop!-order


(c!:install 'yypeek '(yypeek lex_char lex_peek_char yyreadch) 
11241116925781033268)
yypeek


(c!:install 'readprogn '(readprogn group cursym!* !*rsqbkt!* progn xread
aconc!* scan) 7154270127887575700)
readprogn


(c!:install 'rl_pnf '(rl_pnf rl_pnf!* apply) 5865664319110270144)
rl_pnf


(c!:install 'mri_pasf2mri '(mri_pasf2mri mri_pasf2mriat cl_apply2ats1) 
8416386070996061376)
mri_pasf2mri


(c!:install 'pasf_dt '(pasf_dt true false pdef (equal lessp leq) ndef (
equal greaterp geq) (neq greaterp geq) (neq lessp leq) psdef lessp nsdef
greaterp geq leq neq pasf_pdp) 7109903246663199772)
pasf_dt


(c!:install 'naryom '(naryom name var variance valid_om!* multiset
"<OMA>" indent "<OMS cd=""" """ name=""" """>" "</OMA>" printout multiom
) 1863984661094821308)
naryom


(c!:install 'subs4q '(subs4q slash opmtch slash!* quotient minus prepsq
reval simp!*) 7954872445197849127)
subs4q


(c!:install 'makeset '(makeset nreverse) 11107701159491364533)
makeset


(c!:install 'my_letmtr '(my_letmtr mat matrix "Matrix" "not set" hold
rerror reval numlis errpri2 nth pnth) 9315658091723113449)
my_letmtr


(c!:install 'xlcm '(xlcm nreverse factorordp) 13778369026778086959)
xlcm


(c!:install 'physopordchk '(physopordchk unit !*collectphysops
deletemult!* physopordchk!*) 14036063770928138049)
physopordchk


(c!:install 'def_edge '(def_edge) 16483285871857897044)
def_edge


(c!:install 'total!-degree!-in!-powers '(total!-degree!-in!-powers) 
12861997838909760792)
total!-degree!-in!-powers


(c!:install 'set!-global!-mode '(set!-global!-mode alglist!* !*mode null
setq) 15706706440601802369)
set!-global!-mode


(c!:install 'setel '(setel dimension rlisp "Incorrect array reference"
rerror setel1) 1520989627832643292)
setel


(c!:install 'groeb!=weight '(groeb!=weight mo_ecart bas_dpecart) 
12998200401714520111)
groeb!=weight


(c!:install 'general!-modular!-expt '(general!-modular!-expt alg
"0^0 formed" current!-modulus rerror primep general!-modular!-times
reverse!-num) 3819843854313685478)
general!-modular!-expt


(c!:install 'let2 '(let2 typeletfn direct frasc!* !*sq!* frlis!* mcond!*
"Unmatched free variable(s)" hold erfg!* getel immediate getrtype
lispapply errpri1 prepsq!* smemql setdiff lprie lispeval reval let3) 
12445699434854815159)
let2


(c!:install 'ordered!-gcd!-mod!-p '(ordered!-gcd!-mod!-p
reduction!-count reduce!-degree!-mod!-p monic!-mod!-p) 
819731155986328946)
ordered!-gcd!-mod!-p


(c!:install 'p_prinl2 '(p_prinl2 !*print!-level!* "#"
!*prinl_visited_nodes!* "=" "%(" !*print!-array!* !*print!-length!*
"..." ")" "(" "." p_princ gensymp p_prin gethash p_printref puthash) 
5430378124993520759)
p_prinl2


(c!:install 'talp_contains '(talp_contains) 10024885115666677780)
talp_contains


(c!:install 'qqe_eta!-in!-term '(qqe_eta!-in!-term (lhead rhead) qqe_op
qqe_eta!-in!-term1) 14466547472113716384)
qqe_eta!-in!-term


(c!:install 'ev_lexcomp '(ev_lexcomp iequal) 9797634101757613345)
ev_lexcomp


(c!:install 'row '(row expression) 10105843944902245972)
row


(c!:install 'xregister_wedge_pair '(xregister_wedge_pair) 
2318582258318504441)
xregister_wedge_pair


(c!:install 'gfdot '(gfdot gffdot gbfdot) 6877995353456363923)
gfdot


(c!:install '!:dmpluslst '(!:dmpluslst !:plus) 12550138157027600873)
!:dmpluslst


(c!:install 'putd '(putd funarg lambda "+++ " " not defined (LOSE flag)"
!*redefmsg " redefined" expr subr macro dm fexpr df
"Bad type ~S in putd" getd eval error) 7201762993093866511)
putd



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u23.lsp"

Reading "$reduce/cslbuild/generated-c/u24.lsp"

% u24.lsp           Machine generated Lisp

(c!:install "u24" 63807 1997501 6377117)
nil


(c!:install 'fs!:null!-angle '(fs!:null!-angle) 3383869902414511148)
fs!:null!-angle


(c!:install 'mo_equal!? '(mo_equal!? mo!=shorten) 15670774049899212826)
mo_equal!?


(c!:install 'st_sorttree '(st_sorttree st_sorttree1) 
15826997532839114877)
st_sorttree


(c!:install 'rlis '(rlis cursym!* !*reduce4 list lambda scan xread1
remcomma) 9247412777344633249)
rlis


(c!:install 'settinsert '(settinsert fluidbibasissett janettreeinsert) 
3518626782088466338)
settinsert


(c!:install 'get!*elements '(get!*elements elems) 8511605685852624688)
get!*elements


(c!:install 'dipcondense '(dipcondense dipevlist!* evcompless!? setcar
setcdr) 6483285118047512193)
dipcondense


(c!:install 'cut!:ep '(cut!:ep !:rd!: ashift bflerrmsg) 
4612005151744339248)
cut!:ep


(c!:install 'splitcomplex '(splitcomplex kord!* !*exp i expand!-imrepart
setkorder reorder subs2 take!-realpart take!-impart) 3105496883616040383
)
splitcomplex


(c!:install 'fs!:prin1 '(fs!:prin1 (1 . 1) "(" ")" "[" "-" "+"
fourier!-name!* "]" "1" prin2!* sqprint fs!:null!-angle) 
9305787713891364547)
fs!:prin1


(c!:install 'mo_lcm '(mo_lcm mo!=shorten mo!=deglist) 
3795952519888807833)
mo_lcm


(c!:install 'numlist_ordp '(numlist_ordp lambda_ygm6np4pcqv31 cons_ordp)
 12358394684798595155)
numlist_ordp


(c!:install 'lambda_ygm6np4pcqv31 '(lambda_ygm6np4pcqv31) 
15088082726560262194)
lambda_ygm6np4pcqv31


(c!:install 'remlocs '(remlocs !*globals locls!* begin " Lvar confused"
getd rederr error efface1) 12877371633144329667)
remlocs


(c!:install 'revalx '(revalx prepf reval) 8156248349020697701)
revalx


(c!:install 'rl_subalchk '(rl_subalchk rl_subalchk!* apply) 
1071720324883903940)
rl_subalchk


(c!:install 'pasf_zcong '(pasf_zcong (cong ncong) true false cong equal
neq ncong) 9907286930392888463)
pasf_zcong


(c!:install 'vdp_setsugar '(vdp_setsugar !*cgbsugar sugar vdp_putprop) 
11726319010469162367)
vdp_setsugar


(c!:install 'ps!:prepfn!: '(ps!:prepfn!:) 13254149713916799606)
ps!:prepfn!:


(c!:install 'ps!:putv '(ps!:putv !:ps!: tps "PS:PUTV: not a ps" eval
rerror) 1552922531143688513)
ps!:putv


(c!:install 'mktails '(mktails mktails1) 7834943372407695769)
mktails


(c!:install 'impartf '(impartf i kord!* cmpxfn reorder int!-equiv!-chk
addf multf) 6890187095049936448)
impartf


(c!:install 'riv_mk '(riv_mk iv) 9551821334654506150)
riv_mk


(c!:install 'aex_bvarl '(aex_bvarl aex_ctx ctx_idl) 18423336960980571701
)
aex_bvarl


(c!:install 'gcref_mkgraph!-tgf '(gcref_mkgraph!-tgf "#" calls
gcref_mknode!-tgf prin2t gcref_select gcref_mkedges!-tgf) 
8872697914026949222)
gcref_mkgraph!-tgf


(c!:install 'polynomlistreduce '(polynomlistreduce
polynomlistfinddivisor polynomreduceby polynomadd) 15512609324025294193)
polynomlistreduce


(c!:install 'opmtchrevop '(opmtchrevop !*val cons opmtch revlis) 
13637205868658300566)
opmtchrevop


(c!:install 'rl_eqnrhskernels '(rl_eqnrhskernels rl_eqnrhskernels!*
apply) 6620829222149597660)
rl_eqnrhskernels


(c!:install 'pasf_floor '(pasf_floor
"pasf_floor: not a domain valued sf in input" simp rederr) 
10610016429591635276)
pasf_floor


(c!:install 'bvarml '(bvarml "<bvar>" "</bvar>" printout indent!*
expression degreeml) 3283176515209679123)
bvarml


(c!:install 'band_matrix '(band_matrix
"Error in band_matrix(second argument): should be an integer." list
"Error in band_matrix(first argument): should be single value or list."
"Error in band matrix(first argument): number of elements must be odd."
quotient
"Error in band_matrix: too many elements. Band matrix is overflowing."
rederr reval mkmatrix nth setmat) 16171003517197563785)
band_matrix


(c!:install 'rd!:zerop!: '(rd!:zerop!: ft!:zerop round!* bfzerop!:) 
12671832289279500242)
rd!:zerop!:


(c!:install 'flatindl '(flatindl) 3390827990497104525)
flatindl


(c!:install 'formcond1 '(formcond1 nreverse formbool formc) 
7968214462921130653)
formcond1


(c!:install 'red_totalred '(red_totalred red_topred red_tailred) 
3900870141701127444)
red_totalred


(c!:install 'ilog2 '(ilog2 terrlst) 14882263704089128087)
ilog2


(c!:install 'lalr_prin_production '(lalr_prin_production " -> "
lalr_prin_symbol lalr_prin_rhs) 1726331608870260106)
lalr_prin_production


(c!:install 'defineargs '(defineargs name calledby hasarg instdof) 
18221869149588598285)
defineargs


(c!:install 'ofsf_ignshift '(ofsf_ignshift !*rlpos (equal neq) ignore
odd sfto_reorder) 4450930137153555454)
ofsf_ignshift


(c!:install 'tripleisprolongedby '(tripleisprolongedby) 
16701626957021610102)
tripleisprolongedby


(c!:install 'ofsf_smupdknowl '(ofsf_smupdknowl and false ofsf_negateat
ofsf_at2ir ofsf_sminsert setcdr) 17253290331117133432)
ofsf_smupdknowl


(c!:install 'cl_smsimpl!-junct1 '(cl_smsimpl!-junct1 !*rlsiidem true
false or and not impl repl equiv ex all bex ball cl_simpl1 cl_atfp
cl_flip rl_smupdknowl cl_smsimpl!-junct2) 5937380600637357641)
cl_smsimpl!-junct1


(c!:install 'om2ir '(om2ir (safe_atts char ch atts count temp space
temp2) space count ch temp2 char (o m o b j) "<omobj>" (!/ o m o b j)
"</omobj>" fluid list2string lex omobj errorml) 9072379775066504802)
om2ir


(c!:install 'mkmatrix '(mkmatrix mat) 13518421484045359134)
mkmatrix


(c!:install 'setdmode '(setdmode complex!-rational dmode!* complex
rational complex!-rounded rounded tag poly "Domain mode error:"
"is not a domain mode" package!-name !*complex onoff rerror
load!-package setcmpxmode setdmode1) 12705680654026163510)
setdmode


(c!:install 'gbfdot '(gbfdot csl_timbf plubf) 17363441284553368076)
gbfdot


(c!:install 'r2findindex '(r2findindex r2findindex1) 
14570535399614019817)
r2findindex


(c!:install 'comblog '(comblog domainlist!* plus times log nreverse
simp!* clogsq prepsq!*) 2258708424463560692)
comblog


(c!:install 'assert_check1 '(assert_check1 !*assertstatistics
assertstatistics!* assert_dyntypechk assert_ignore setcar apply
assert_error) 13554576978207690733)
assert_check1


(c!:install 'matop_pseudomod '(matop_pseudomod mod!*) 
7244224576917796558)
matop_pseudomod


(c!:install 'gcdout '(gcdout !*modular ljet ord gcdf!* pcdiv) 
11180239844353890253)
gcdout



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u24.lsp"

Reading "$reduce/cslbuild/generated-c/u25.lsp"

% u25.lsp           Machine generated Lisp

(c!:install "u25" 34501 2156620 9770729)
nil


(c!:install 'pa_coinc_split '(pa_coinc_split lambda_er1ez819f9yx2 upbve
sort) 126824076894980172)
pa_coinc_split


(c!:install 'lambda_er1ez819f9yx2 '(lambda_er1ez819f9yx2) 
13794168774309563647)
lambda_er1ez819f9yx2


(c!:install 'cde_position '(cde_position cde_position2) 
238037469412860599)
cde_position


(c!:install 'lto_sgnchg1 '(lto_sgnchg1 sgn) 261130623156442352)
lto_sgnchg1


(c!:install 'cl_pnf '(cl_pnf rl_nnf cl_pnf1) 8997355690223370541)
cl_pnf


(c!:install 'mri_prepat '(mri_prepat mri_2pasfat pasf_prepat) 
17918178496807478614)
mri_prepat


(c!:install 'vdp_make '(vdp_make vdp) 11832810818583622840)
vdp_make


(c!:install 'max!-degree '(max!-degree) 7631694807477571889)
max!-degree


(c!:install 'binaryrd '(binaryrd mathml lex) 8449682339876615316)
binaryrd


(c!:install 'rationalizesq '(rationalizesq !*structure !*sub2 dmode!*
rationalizefn (i 2 (nil . t) -1 nil) powlis!* !*algint !*rationalize
subs2q rationalizef multf gcdchk) 618899159186762670)
rationalizesq


(c!:install 'delhisto '(delhisto codmat maxvar codhisto min) 
12626252279824721122)
delhisto


(c!:install 'quoteequation '(quoteequation equation) 
13869360566276034417)
quoteequation


(c!:install 'gvarlis1 '(gvarlis1 gvar1 union) 15887984567229666111)
gvarlis1


(c!:install 'bcneg '(bcneg !*grmod!* current!-modulus negsq) 
10888953695802130557)
bcneg


(c!:install 'physopsimp '(physopsimp !*sq tensdimen antisymmetric minus
isanindex isavarindex physopsm!* prepsqxx opmtch!* scalopp tensopp nth
pnth ordn repeats permp vecopp listp putanewindex!*) 
17378261404484775512)
physopsimp


(c!:install 'ev!-denom2 '(ev!-denom2 ev!-edgeloop) 10469132586978593068)
ev!-denom2


(c!:install 'copy!-tree '(copy!-tree) 12578162027246836564)
copy!-tree


(c!:install 'safe!-modrecip '(safe!-modrecip !*msg !*protfg !:mod!:
general!-modular!-reciprocal erfg!* errorset errorp) 
14808290800131132436)
safe!-modrecip


(c!:install 'setk_super_vectorfield '(setk_super_vectorfield ext
variables "SETK_SUPER_VECTORFIELD:" "not a valid variable for" let2
msgpri) 16746388325699725758)
setk_super_vectorfield


(c!:install 'lalr_construct_fn '(lalr_construct_fn g lambda !*pwrds expr
lalr_make_arglist putd) 12504191962287692232)
lalr_construct_fn


(c!:install 'ctx_idl '(ctx_idl ctx_ial) 4891428736571764658)
ctx_idl


(c!:install 'wupseudodivide '(wupseudodivide setkorder reorder
wuconstantp gcdf!* quotf multf exptf qremf) 18397524205360628269)
wupseudodivide


(c!:install 'evaluatecoeffts '(evaluatecoeffts indexlist valuecoefft
!*multf addf) 5406277702025676168)
evaluatecoeffts


(c!:install 'vdp_getprop '(vdp_getprop vdp_plist) 10290374778868375321)
vdp_getprop


(c!:install 'dip_condense '(dip_condense) 7708418469248712677)
dip_condense


(c!:install 'mml2ir '(mml2ir mmlatts space count ch temp2 char (m a t h)
"<math>" (!/ m a t h) "</math>" list2string lex mathml errorml) 
4937673495003303041)
mml2ir


(c!:install 'pfordp '(pfordp termordp) 8068693215543952127)
pfordp


(c!:install 'prinlatom '(prinlatom font accent name "}" prin2la
testchar1) 6843894542313904978)
prinlatom


(c!:install 'exptpri '(exptpri !*utf8 !*list !*nat !*fort failed expt
!*eraise inbrackets indexprin !*ratpri quotient minus spare!* orig!*
posn!* "(" ")" utf8_exptpri layout!-formula indexpower negnumberchk
terpri!* prin2!* putpline oprin update!-pline) 1764904720989000181)
exptpri


(c!:install 'ordop2 '(ordop2 kord!* ordp) 1870441096632376356)
ordop2


(c!:install 'edges_parents '(edges_parents edge_new_parents) 
7989857538043128579)
edges_parents


(c!:install 'mo_zero '(mo_zero mo!=deglist) 17895098785328054484)
mo_zero


(c!:install '!*di2q0 '(!*di2q0 varlist!* ordering lex ljet pair multsq
addsq) 15148302668535177444)
!*di2q0


(c!:install 'dv_skel2factor1 '(dv_skel2factor1 !~dv !~dva minus listp) 
12834239992638262862)
dv_skel2factor1


(c!:install 'let3 '(let3 rtype avalue typeletfn yetunknowntype errpri1
getrtype lispapply typelet letscalar) 5648133096207602103)
let3


(c!:install 'lalr_print_compressed_action_table '(
lalr_print_compressed_action_table itemset_collection
"=== ACTION TABLE ===" "STATE" "TERMINAL" "ACTION" "<any>"
lalr_prin_symbol lalr_prin_action) 2209936760884675793)
lalr_print_compressed_action_table


(c!:install 'ofsf_subf '(ofsf_subf exptsq multsq addsq ofsf_pow2q) 
4899546410971666941)
ofsf_subf


(c!:install 'simpexpt11 '(simpexpt11 !*precise_complex simpexpt2 qremf
simpexpt1 multsq) 18016535449379762626)
simpexpt11


(c!:install 'quotelog '(quotelog logical) 17183556804632955927)
quotelog


(c!:install 'encodeir '(encodeir name char !  atts !$ semantic delall) 
1922988493163827553)
encodeir


(c!:install 'simpdf!* '(simpdf!* simpdf rootextractsq resimp) 
8201007124404162639)
simpdf!*


(c!:install 'evdif '(evdif (0)) 15090522352339989988)
evdif


(c!:install 'evaluate1 '(evaluate1 i dmode!* ivalue (nil)
"i used as indeterminate value" e pi !*evaluateerror "number"
force!-to!-dm apply rederr simp typerr evaluate2) 6309802894990943255)
evaluate1


(c!:install 'assert_install1 '(assert_install1 assert_installed
"assert already installed for" expr
"is not an expr procedure - ignoring assert" assert_noassertfn
assert_assertfn lprim getd copyd) 13732944119485760763)
assert_install1


(c!:install 'red!=cancelsimp '(red!=cancelsimp red_better bas_dpoly
dp_lmon mo_vdivides!?) 11561457350048644172)
red!=cancelsimp



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u25.lsp"

Reading "$reduce/cslbuild/generated-c/u26.lsp"

% u26.lsp           Machine generated Lisp

(c!:install "u26" 30665 1871264 4815787)
nil


(c!:install 'subs3t '(subs3t mchfg!* !*match subfg!* !*mcd sizchk mtchk
subs3f1 multsq to simpcar sfp simp kernp revop1 noncomp mksp multf
errach) 12893971692949833183)
subs3t


(c!:install 'dmconv0 '(dmconv0 !:rn!: !:gi!: !:crn!: dmd!*) 
1800770221870508758)
dmconv0


(c!:install 'ra_zerop '(ra_zerop ra_f) 156004460642436359)
ra_zerop


(c!:install 'refprint '(refprint cloc!* "*TTYINPUT*" pfiles!* curfun!* g
rccnam curlin!* locls!* globs!* calls!* anform outrefend) 
13080195673109096165)
refprint


(c!:install 'cl_f2ml '(cl_f2ml true false or and not impl repl equiv
plus2 ex all bex ball lto_almerge apply) 11115652893289182625)
cl_f2ml


(c!:install 'ofsf_at2ir '(ofsf_at2ir negf addf sfto_dcontentf quotf
quotsq) 7906019418542268564)
ofsf_at2ir


(c!:install 'expnd '(expnd !*really_off_exp !*sub2 expnd1 subs2f) 
11413463028146551512)
expnd


(c!:install 'groedeletip '(groedeletip setcdr) 16361312757688004926)
groedeletip


(c!:install 'insertparens '(insertparens !( !)) 9173971090588331245)
insertparens


(c!:install 'can_be_proved '(can_be_proved can_be_p) 
13352769274010193889)
can_be_proved


(c!:install 'log_assignment_list '(log_assignment_list log_assignment) 
3080942992296707352)
log_assignment_list


(c!:install 'dv_cambhead '(dv_cambhead expt minus listp) 
17214961675878932154)
dv_cambhead


(c!:install 'mod_eval_uni_poly '(mod_eval_uni_poly current!-modulus
mod!# general!-modular!-expt general!-modular!-plus) 
13950732281834820421)
mod_eval_uni_poly


(c!:install 'nonlnrsys '(nonlnrsys nonlnr) 16893386471568554588)
nonlnrsys


(c!:install 'lalr_make_arglist '(lalr_make_arglist !$ list2string) 
15120897132663416265)
lalr_make_arglist


(c!:install 'rl_bettergaussp '(rl_bettergaussp rl_bettergaussp!* apply) 
11229114519218706476)
rl_bettergaussp


(c!:install 'texstrlen '(texstrlen !!) 6161493772332996349)
texstrlen


(c!:install 'talp_list2vec '(talp_list2vec) 8253378456129271759)
talp_list2vec


(c!:install 'pasf_cein '(pasf_cein true false (leq greaterp geq lessp) (
leq greaterp) (geq lessp) pasf_deci sfto_dcontentf simp quotfx
pasf_floor negf pasf_ceil addf) 12169585565162376271)
pasf_cein


(c!:install 'unaryir '(unaryir name atts cd find encodeir) 
15303558210222542938)
unaryir


(c!:install 'ps!:evaluate!-next '(ps!:evaluate!-next ps ps!:erule
ps!:getv ps!:expression apply prepsqxx simp!* ps!:set!-term) 
1451468694344642539)
ps!:evaluate!-next


(c!:install 'vdpvevlcomp '(vdpvevlcomp dipevlcomp) 8388747943008313643)
vdpvevlcomp


(c!:install 'random '(random "positive number" unidev_fac!*
randommodulus!* typerr next!-random!-number) 12010203026302926177)
random


(c!:install 'getphystypecar '(getphystypecar getphystype) 
549554832887196808)
getphystypecar


(c!:install 'factorial '(factorial arith "invalid factorial argument"
rerror nfactorial) 6055321892875199978)
factorial


(c!:install 'random!-teeny!-prime '(random!-teeny!-prime all
teeny!-primes next!-random!-number) 10079275317954736717)
random!-teeny!-prime


(c!:install 'sfto_dgcd '(sfto_dgcd sfto_dcontentf sfto_gcdf) 
6977344806463788710)
sfto_dgcd


(c!:install 'outrefend '(outrefend calls!* calls toplv!* cinthis seen
seen!* calledby globs!* globs dclglb usedby gseen gseen!* usedunby
glb2rf glb2bd boundby glb2st setby union traput) 7779423426792506707)
outrefend


(c!:install 'simpcv '(simpcv "Invalid number of edges in vertex"
simpcgraph mul!* cerror aconc!* to) 4386196608547243983)
simpcv


(c!:install 'smemberlp '(smemberlp) 17268134400216882209)
smemberlp


(c!:install 'offexpchk '(offexpchk !*really_off_exp frlis!*
freevarinexptchk mkprod canprod) 8276034125479486993)
offexpchk


(c!:install 'formc!* '(formc!* !*!*a2sfn revalx formc) 
5216374250377475838)
formc!*


(c!:install 'physopordchk!* '(physopordchk!* ncmpchk invp) 
5368466983580771193)
physopordchk!*


(c!:install 'red_topredbe '(red_topredbe " reduce " bas_dpoly cali_trace
dp_print dp_lmon bas_dpecart red_divtestbe red_subst) 
17249925396800045955)
red_topredbe


(c!:install 'trailing!.coefft '(trailing!.coefft) 2741308890144995642)
trailing!.coefft


(c!:install 'gf2cr!: '(gf2cr!: !:cr!: striptag) 11144561141645672652)
gf2cr!:


(c!:install 'extmult '(extmult ordexn c!:subs2multf negf extadd) 
12972388777221124706)
extmult


(c!:install 'add2locs '(add2locs !*globals locls!* dclglb
"*** Variable " " nested declaration in " curfun!* glb2rf seen
"*** Function " " used as variable in " qerline princng newline globind)
 11177705230684184712)
add2locs


(c!:install 'monomcomparedeglex '(monomcomparedeglex) 
1333273324612623854)
monomcomparedeglex


(c!:install 'poly!-multfnc '(poly!-multfnc !*sstools!-loaded
!*!*processed sstools!-multfnc poly!-multf mkspm addf noncomp) 
4419973584290133566)
poly!-multfnc


(c!:install 'talp_telp '(talp_telp talp_invp talp_fargl) 
17432041448933105265)
talp_telp


(c!:install 'pasf_anegrel '(pasf_anegrel ((equal . equal) (neq . neq) (
leq . geq) (geq . leq) (lessp . greaterp) (greaterp . lessp) (cong .
cong) (ncong . ncong)) "pasf_anegrel: unknown operator " rederr) 
954062315791042135)
pasf_anegrel


(c!:install 'multi_args '(multi_args expression) 3695083030306321180)
multi_args


(c!:install 'getdec '(getdec symtabget implicitdec) 15548304567600766736
)
getdec


(c!:install 'memqcar '(memqcar) 3612662733220245317)
memqcar


(c!:install 'oprinla '(oprinla lapr lapop !  prin2la prinlatom) 
15336934279451026930)
oprinla


(c!:install 'gftimesn '(gftimesn gfftimes times!: difference!: plus!:) 
1300853096705473198)
gftimesn


(c!:install 'fieldconv '(fieldconv dmode!* !:rn!: quotient
"field conversion" dcombine multd errach simpgd divd) 
13145165320174665890)
fieldconv


(c!:install 'repeats '(repeats nreverse) 8853322230546325945)
repeats


(c!:install 'reduce!-mod!-p!* '(reduce!-mod!-p!* current!-modulus
general!-reduce!-mod!-p) 304745808878314680)
reduce!-mod!-p!*



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u26.lsp"

Reading "$reduce/cslbuild/generated-c/u27.lsp"

% u27.lsp           Machine generated Lisp

(c!:install "u27" 113617 1747335 6307610)
nil


(c!:install 'gcd!-in!-vector '(gcd!-in!-vector
"GCD with zero not allowed" errorf remainder!-in!-vector) 
9536082400961573796)
gcd!-in!-vector


(c!:install 'lalr_make_compressed_goto_column '(
lalr_make_compressed_goto_column goto_table gethash
lalr_most_common_dest) 770456876220403427)
lalr_make_compressed_goto_column


(c!:install 'aex_neg '(aex_neg aex_ex negsq aex_ctx aex_mk) 
17068603941868108587)
aex_neg


(c!:install 'innprodp2 '(innprodp2 innprodkp) 7780601364960729965)
innprodp2


(c!:install 'talp_subat '(talp_subat talp_op talp_arg2l talp_subt
talp_arg2r talp_mk2) 11237141710321951797)
talp_subat


(c!:install 'rl_updcache '(rl_updcache rl_bbl!* rl_cid!* rl_params
rl_servl!* rl_services) 9186472453951528676)
rl_updcache


(c!:install 'ioto_form2str1 '(ioto_form2str1 minus !( !) plus !,
ioto_prtb ioto_prtbpar ioto_prtbop) 11177515184618921647)
ioto_form2str1


(c!:install 'lambdafun '(lambdafun) 12041889918379956612)
lambdafun


(c!:install 'ft!:zerop '(ft!:zerop !:prec!:) 12657352824314599557)
ft!:zerop


(c!:install 'oldmtch '(oldmtch mcharg eval) 7900546910151258767)
oldmtch


(c!:install 'dipev2f '(dipev2f to multf) 4228879523329622026)
dipev2f


(c!:install 'sfpx1 '(sfpx1 assert_kernelp to ordpp) 2806206429579137979)
sfpx1


(c!:install 'pcdiv '(pcdiv cdiv) 12670010806150465859)
pcdiv


(c!:install 'sc_rep '(sc_rep g_sc_ve) 2373969952239389182)
sc_rep


(c!:install 'super_der_simp '(super_der_simp variables (ext) ext
even_dimension odd_dimension reval simp!* split_form nth split_ext
even_action odd_action addsq quotsq super_product_sq multf negsq
simpiden) 1026326478841048770)
super_der_simp


(c!:install 'yylex '(yylex lex_symbol_code lex_escaped lexer_style!*
yylval !#define "+++ " " => " !#eval lex_number_code lex_string_code
!*tracelex "yylex = " " type " lex_basic_token land
lex_process_directive read_s_expression errorset) 1838747078068114950)
yylex


(c!:install 'outrdefun '(outrdefun defd function dclglb locls!*
"**** Variable " " defined as function" naryarg naryargs gall curlin!*
globs!* calls!* curfun!* qtypnm recref qerline princng newline
defineargs) 11050453971390909373)
outrdefun


(c!:install 'ofsf_sippsubst '(ofsf_sippsubst ofsf_sippsubst1) 
16344775967043512851)
ofsf_sippsubst


(c!:install 'ofsf_surep '(ofsf_surep true cl_simpl) 17044374422311926793
)
ofsf_surep


(c!:install 'matpri '(matpri matpri1) 18350818851654774337)
matpri


(c!:install 'termorder1 '(termorder1) 8275765336605015274)
termorder1


(c!:install 'sfto_b!:extadd '(sfto_b!:extadd nreverse addf
sfto_b!:ordexp) 14555970045207833266)
sfto_b!:extadd


(c!:install 'matrixrowom '(matrixrowom "<OMA>"
"<OMS cd=""linalg1"" name=""matrixrow""/>" "</OMA>" printout indent!*
multiom) 1732016591589103317)
matrixrowom


(c!:install 'rootextractsq '(rootextractsq subs2q rootextractf) 
11993779801291799899)
rootextractsq


(c!:install 'meq '(meq unbound binding) 5890158521722239333)
meq


(c!:install 'edge_new_parent '(edge_new_parent new_edge_list) 
10693541134564247314)
edge_new_parent


(c!:install 'log_inlines '(log_inlines log_assignment log_freevars) 
4860750300544105035)
log_inlines


(c!:install 'red!=hidelt '(red!=hidelt bas_dpoly bas_nr bas_rep
red!=hide dp_sum bas_make1) 16913627379240696840)
red!=hidelt


(c!:install 'extract_dummy_ids '(extract_dummy_ids dummy_id!* nreverse) 
15585981994205037842)
extract_dummy_ids


(c!:install 'lalr_most_common_dest '(lalr_most_common_dest) 
5788833161221427184)
lalr_most_common_dest


(c!:install 'formrlis '(formrlis flagop list share algebraic !*comma!*
"identifier list" flag reversip!* formlis idlistp typerr) 
7385820666190966159)
formrlis


(c!:install 'get!-free!-form '(get!-free!-form frasc!* !~ (!! !~ !! !~)
(!! !~) optional) 15166660826411836818)
get!-free!-form


(c!:install 'get_char_value '(get_char_value
"error in get character element" rederr) 11725546894135015819)
get_char_value


(c!:install 'qqe_arg!-check!-q '(qqe_arg!-check!-q qqe_id!-nyt!-branchq
qqe_btidp qqe_nytidp qqe_qtid qqe_add2rollbackids qqe_arg!-check) 
3226144097054095863)
qqe_arg!-check!-q


(c!:install 'fortranname '(fortranname !*notfortranfuns!* !*stdout!*
"*** WARNING: " " is not an intrinsic Fortran function" !*double
!*doublename!* !*fortranname!* stringtoatom prin2t) 8730742722275511588)
fortranname


(c!:install 'assert_error '(assert_error !*lower !*assertstatistics
assertstatistics!* "declaration" "violated by result" "violated by" arg
!*assertbreak setcar assert_format mkid rederr lprim) 
6325146045031417776)
assert_error


(c!:install 'nf '(nf gg!* redtails gv!* tred "r e d u c t i o n :  " "/"
stars "*" reductions!* nforms!* zeros!* dless dd gcdf!* cdiv pcmult
dquot pdmult pdif gcdout) 4254518414598757272)
nf


(c!:install 'lalr_make_compressed_action_table '(
lalr_make_compressed_action_table itemset_collection !*lalr_verbose
lalr_make_compressed_action_row lalr_print_compressed_action_table) 
7857996445380963171)
lalr_make_compressed_action_table


(c!:install 'outref '(outref curfun!* calls!* globs!* locls!* toplv!* (
anp!!atom anp!!idb anp!!eq anp!!unknown) anp!!eq sameas alsois outrdefun
add2locs anform remlocs traput add2calls outrefend) 5769129379516808474)
outref


(c!:install 'ofsf_smwmkatl '(ofsf_smwmkatl !*rlsusi cl_susimkatl
ofsf_smmkatl) 14250039879880194131)
ofsf_smwmkatl


(c!:install 'ioto_smaprinbuf '(ioto_smaprinbuf !! rlsmaprinbuf!*) 
18419973655955222314)
ioto_smaprinbuf


(c!:install 'lambdavar '(lambdavar) 13345965240957427380)
lambdavar


(c!:install 'n_nary '(n_nary e power exp "<apply>" "<" "/>" indent
"</apply>" unary printout multi_elem) 17889661689617899542)
n_nary


(c!:install 'gcd2 '(gcd2) 18207054630592118474)
gcd2



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u27.lsp"

Reading "$reduce/cslbuild/generated-c/u28.lsp"

% u28.lsp           Machine generated Lisp

(c!:install "u28" 96065 1706130 30271)
nil


(c!:install 'inprint '(inprint times !*nat !*asterisk times2 infix prtch
" " plus !*revpri not setq tag setprifn inbrackets "(" ")" !*nosplit
testing!-width!* (setq !*comma!*) oprin getrtype prin2!* maprint prinfit
negnumberchk) 5888655686248825375)
inprint


(c!:install 'mksetq '(mksetq setq setfn "assignment argument" typerr) 
1047142451462299460)
mksetq


(c!:install 'general!-evaluate!-mod!-p '(general!-evaluate!-mod!-p
"Variable=NIL in GENERAL-EVALUATE-MOD-P" errorf
general!-horner!-rule!-mod!-p) 11683667927005855121)
general!-evaluate!-mod!-p


(c!:install 'bndtst '(bndtst tentothetenth!*!* abs!: greaterp!:) 
14872575748311463317)
bndtst


(c!:install 'setk1 '(setk1 !*uncached "not found" avalue scalar alg
"Invalid syntax: improper assignment" wtl!* !*sqrtrulep kvalue msgpri
put!-avalue rerror revlis delasc put!-kvalue updoldrules) 
18042705366889534398)
setk1


(c!:install 'lex_export_codes '(lex_export_codes lex_codename ordopcar
sort) 2806139020963600379)
lex_export_codes


(c!:install 'comm1 '(comm1 end cursym!* !*semicol!* (end else then until
!*rpar!* !*rsqbkt!*) "END-COMMENT NO LONGER SUPPORTED" scan lprim) 
12682233057318969179)
comm1


(c!:install 'createtriplewithancestor '(createtriplewithancestor
fluidbibasistripleid) 2496970852756381967)
createtriplewithancestor


(c!:install 'qqe_ofsf_simpat '(qqe_ofsf_simpat (qequal qneq) qqe_arg2l
qqe_ofsf_chsimpterm qqe_arg2r qqe_arg!-check qqe_op qqe_simpat
ofsf_simpat) 15868148505977473450)
qqe_ofsf_simpat


(c!:install 'ev_mtest!? '(ev_mtest!?) 5121257538194335172)
ev_mtest!?


(c!:install 'ombindir '(ombindir (!/ o m b i n d) lex omobj variablesir
tobvarir checktag) 1324113408450774951)
ombindir


(c!:install 'rowdel '(rowdel codmat maxvar delhisto downwght) 
16951615583918496840)
rowdel


(c!:install 'string!-of!-list '(string!-of!-list "" !; lastpair
list2string) 360023129920980546)
string!-of!-list


(c!:install 'rdcos!* '(rdcos!* convprec cos cos!* mkround) 
12803570736682264085)
rdcos!*


(c!:install 'mk!-numr '(mk!-numr difference nreverse) 
1867480981460826744)
mk!-numr


(c!:install 'assert_stat1 '(assert_stat1 !*lpar!*
"expecting '(' in assert but found" cursym!* !*rpar!* !*comma!*
"expecting ',' or ')' in assert but found" scan rederr) 
18363279491029694016)
assert_stat1


(c!:install 'mo_2a '(mo_2a cali!=basering ring_all_names mo!=expvec2a1) 
7244578972536245603)
mo_2a


(c!:install 'lalr_collect_terminals '(lalr_collect_terminals
nonterminals setdiff) 11963650507052955258)
lalr_collect_terminals


(c!:install 'gcref_remprops '(gcref_remprops seen!* (gall calls globs
calledby alsois sameas) (seen cinthis defd) gcref_exportl!* (exported)
gseen!* (usedby usedunby boundby setby) (dclglb gseen glb2rf glb2bd
glb2st) tseen!* funs haveargs!* rempropss remflagss) 
11893567273362530779)
gcref_remprops


(c!:install 'prepreform1 '(prepreform1 (plus difference minus times
quotient) !*sq sqhorner!* prepsq!* simp!*) 9267720552194100395)
prepreform1


(c!:install 'cl_atl1 '(cl_atl1 cl_atml1) 3748637150208340714)
cl_atl1


(c!:install 'internal!-factorf '(internal!-factorf current!-modulus
m!-image!-variable !*kernreverse kernord setkorder reorder minusf negf
comfac comfac!-to!-poly quotf1 factorize!-primitive!-polynomial
distribute!.multiplicity fctrf1 to fac!-merge) 16295624143771728723)
internal!-factorf


(c!:install 'sfto_b!:ordexp '(sfto_b!:ordexp) 17719563479385124546)
sfto_b!:ordexp


(c!:install 'nextcomb '(nextcomb i initcomb) 15020475301782554861)
nextcomb


(c!:install 'gcompatible '(gcompatible gmodule!* gevcompatible1) 
4395588156138570702)
gcompatible


(c!:install 'contr!-strand '(contr!-strand contr1!-strand) 
14991622701045679338)
contr!-strand


(c!:install 'nzero '(nzero nreverse) 15339904031012778709)
nzero


(c!:install 'merge '(merge) 11618120737974801924)
merge


(c!:install 'insert '(insert gg!* dless) 7587831350715892853)
insert


(c!:install 'charnump!: '(charnump!: !0 !1 !2 !3 !4 !5 !6 !7 !8 !9 !10
!11 !12 !13) 6078668565724893638)
charnump!:


(c!:install 'build!-null!-vector '(build!-null!-vector) 
9747352268713284531)
build!-null!-vector


(c!:install 'lalr_generate_collection '(lalr_generate_collection
itemset_collection !*lalr_verbose lalr_lr0_itemset_to_lalr_kernel
lalr_analyze_lookaheads carrassoc lalr_add_lookahead
lalr_propagate_lookaheads lalr_closure lalr_print_collection) 
11474905777161151162)
lalr_generate_collection


(c!:install 'normalform '(normalform fluidbibasisnormalforms
janettreefind polynomheadreduceby polynomadd) 396056162021076215)
normalform


(c!:install 'wureducedp '(wureducedp wuconstantp deginvar) 
5890090197619083285)
wureducedp


(c!:install 'get!-denom!-ll '(get!-denom!-ll nreverse get!-denom!-l lcmn
) 9865865357402086746)
get!-denom!-ll


(c!:install 'mksp!* '(mksp!* kernlp exptf minusf negf mksp) 
13752564552538872899)
mksp!*


(c!:install 'talp_try '(talp_try rl_pnf talp_invtscsimpl talp_lssimpl
talp_try1) 5158418108379367388)
talp_try


(c!:install 'vunion '(vunion) 10411977164311836912)
vunion


(c!:install 'cnrd '(cnrd atts type base char constant (real integer)
based_integer string (rational complex!-cartesian complex!-polar)
rational complex!-cartesian complex_cartesian complex!-polar
complex_polar find lex compress!* seprd) 5452920217414400978)
cnrd


(c!:install 'doublep '(doublep !:rd!:) 620829993394421821)
doublep


(c!:install 'groebsavelterm '(groebsavelterm !*groelterms
groebsaveltermbc) 8937397724607374132)
groebsavelterm


(c!:install 'permp '(permp) 7444515488059382937)
permp


(c!:install 'getphystypeor '(getphystypeor getphystype) 
15248518432785527981)
getphystypeor


(c!:install 'l!-subst '(l!-subst nreverse) 13157143314028632447)
l!-subst


(c!:install 'formde '(formde procedure symbolic expr progn formproc) 
6755753224063973974)
formde


(c!:install 'sqhorner!* '(sqhorner!* !*horner ordl!* kord!* reorder
hornerf hornersq) 11381696496110012456)
sqhorner!*


(c!:install 'delasc '(delasc) 1435038776993638387)
delasc


(c!:install 'lalr_prin_reduction '(lalr_prin_reduction reduction_info
"reduce by #" ": " " -> [" " symbols] " getv16 lalr_prin_nonterminal
getv8 getd prin_with_margin) 10719599618159484594)
lalr_prin_reduction


(c!:install 'co_new '(co_new) 12258803853388898570)
co_new


(c!:install 'ofsf_negateat '(ofsf_negateat ofsf_lnegrel) 
15688301884629082179)
ofsf_negateat


(c!:install 'mk!+conjugate!+sq '(mk!+conjugate!+sq conjsq) 
3432473840545199005)
mk!+conjugate!+sq


(c!:install 'dm!-mkfloat '(dm!-mkfloat !:rd!:) 13213154614696441939)
dm!-mkfloat


(c!:install 'bcfd '(bcfd !*grmod!* !:mod!: "Invalid modular coefficient"
mkbc bcfi rederr) 13380973671788613610)
bcfd


(c!:install 'vevstrictlydivides!? '(vevstrictlydivides!? vevmtest!?) 
5512672298824972725)
vevstrictlydivides!?


(c!:install 'equalreval '(equalreval substitution equal reval evalequal)
 954477476166961243)
equalreval


(c!:install 'contract!-strand '(contract!-strand zero!-roads
contr!-strand) 9470292292988133312)
contract!-strand


(c!:install 'sf2mv '(sf2mv sf2mv1) 6528544541958700990)
sf2mv


(c!:install 'fs!:prepfn!: '(fs!:prepfn!:) 17069206186485597780)
fs!:prepfn!:


(c!:install 'all_sml_opchar '(all_sml_opchar lexer_style!* sml_opchar
land) 12095717356018498271)
all_sml_opchar



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u28.lsp"

Reading "$reduce/cslbuild/generated-c/u29.lsp"

% u29.lsp           Machine generated Lisp

(c!:install "u29" 8587 9814989 8628605)
nil


(c!:install 'mkfil!* '(mkfil!* "file name" typerr eval string!-downcase)
 3379737960481829301)
mkfil!*


(c!:install 'sortedtriplelistinsert '(sortedtriplelistinsert
monomcompare) 2071273669837285275)
sortedtriplelistinsert


(c!:install 'cquotegex '(cquotegex !*guardian gex) 9110622552156672349)
cquotegex


(c!:install 'ofsf_facequal!* '(ofsf_facequal!* !*rlsifac !*rlsiexpla
!*rlsiexpl or equal ofsf_facequal) 18031237623516468984)
ofsf_facequal!*


(c!:install 'talp_copy '(talp_copy) 11070956600525334828)
talp_copy


(c!:install 'factor!-prim!-f '(factor!-prim!-f ncmp!* dmode!*
sqfrfactorfn !*factor factorfn lnc !:recip multd sqfrf
factor!-prim!-sqfree!-f fac!-merge) 8991535671753454553)
factor!-prim!-f


(c!:install 'evrevgradlexcomp '(evrevgradlexcomp (0) iequal evtdeg
evinvlexcomp) 1094894507621156151)
evrevgradlexcomp


(c!:install 'critical_element '(critical_element) 9077207970580493474)
critical_element


(c!:install 'bfplusn '(bfplusn plus!:) 12942028341686078589)
bfplusn


(c!:install 'st_consolidate '(st_consolidate !*) 14539257175106891559)
st_consolidate


(c!:install 'ratminus '(ratminus) 18049951065176878264)
ratminus


(c!:install 'cde_odd_derivatives '(cde_odd_derivatives
n_all_parametric_ext n_all_principal_ext svf_ext mkid super_vectorfield
set_svf) 7059385793284244930)
cde_odd_derivatives


(c!:install 'hasarg '(hasarg name haveargs!* maxarg!* "**** " " has "
" arguments" bldmsg number!-of!-args qerline newline) 
12062232363733440706)
hasarg


(c!:install 'ofsf_posvarp '(ofsf_posvarp and true false or not impl repl
equiv ex all bex ball ofsf_posvarpat) 5415125431123009782)
ofsf_posvarp


(c!:install 'rndifference!: '(rndifference!: mkrn) 3998651677307980197)
rndifference!:


(c!:install 'mk!+trace '(mk!+trace "no square matrix in add" !*sub2
squared!+matrix!+p rederr get!+row!+nr get!+mat!+entry addsq subs2) 
17172931487973600807)
mk!+trace


(c!:install 'talp_specsubat '(talp_specsubat talp_op talp_arg2l
talp_specsubt talp_arg2r talp_mk2 talp_simpat) 13087732386055039465)
talp_specsubat


(c!:install 'vdp_sugar '(vdp_sugar !*cgbsugar sugar vdp_zero!?
vdp_getprop) 15378252953677045083)
vdp_sugar


(c!:install 'unresidp '(unresidp !*reservedops!*) 17723194268344580602)
unresidp


(c!:install 'physop!-multfnc '(physop!-multfnc !*contract2 !*!*processed
physop!-multf physopp mkspm addf noncommuting physop!-ordop) 
16166522819702933346)
physop!-multfnc


(c!:install 'edge_new_parents '(edge_new_parents old_edge_list
edge_new_parent) 4434932712476921496)
edge_new_parents


(c!:install 'groeb!=newpair '(groeb!=newpair bas_dpoly dp_lmon mo_lcm
groeb!=weight) 10758289609240160604)
groeb!=newpair


(c!:install 'quotof '(quotof minus lcx quotofd mksp carx raddf to ordop)
 7735635630518353880)
quotof


(c!:install 'ra_wrapper1 '(ra_wrapper1 off1 apply on1) 
11745660691622589799)
ra_wrapper1


(c!:install 'negind '(negind) 3888326271223543550)
negind


(c!:install 'tayexp!-minus '(tayexp!-minus rnminus!:) 
9378126259797931177)
tayexp!-minus


(c!:install 'cl_rename!-vars '(cl_rename!-vars cl_replace!-varl
cl_rename!-vars1) 18151438177595091197)
cl_rename!-vars


(c!:install 'rl_susipost '(rl_susipost rl_susipost!* apply) 
5661986307684209988)
rl_susipost


(c!:install 'dip_f2dip1 '(dip_f2dip1 bc_fd bc_prod dip_fmon dip_f2dip2
dip_sum) 9099426871510152039)
dip_f2dip1


(c!:install 'omfir '(omfir atts dec name "wrong att" find errorml) 
9251066245444986048)
omfir


(c!:install 'getphystypetimes '(getphystypetimes
"PHYSOP type mismatch in" collectphystype deleteall rederr2) 
13992417970549162867)
getphystypetimes


(c!:install 'prop!-simp2 '(prop!-simp2) 8845509374503537807)
prop!-simp2


(c!:install 'quotpri '(quotpri !*ratpri !*nat !*fort !*list !*mcd failed
dmode!* ratmode ratfunpri1) 9313002402001459369)
quotpri


(c!:install 'red_tailred '(red_tailred !*noetherian red_topred
red_topredbe red_tailreddriver) 14658725045549140417)
red_tailred


(c!:install 'no_dum_varp '(no_dum_varp list splitlist!:) 
10014103318866339878)
no_dum_varp


(c!:install 'arminusp!: '(arminusp!: minusf) 7589179714353625469)
arminusp!:


(c!:install 'idtomind '(idtomind i2m_jetspace!* i2m_jetspace_odd!*) 
3282693554831447091)
idtomind


(c!:install 'expansion_name '(expansion_name lalr_internal_
expansion_count) 15783678150400557790)
expansion_name


(c!:install 'quotkx '(quotkx quotfx1) 10357113706780567590)
quotkx


(c!:install 'ifstat '(ifstat cursym!* then if else cond xread symerr
aconc!* scan xread1) 17341454388754897150)
ifstat


(c!:install 'add!-degrees '(add!-degrees tayexp!-plus2) 
11237719534741168631)
add!-degrees


(c!:install 'cl_sordpl '(cl_sordpl cl_sordp) 121928515430233144)
cl_sordpl


(c!:install 'pasf_or '(pasf_or true false (lessp greaterp leq geq) lessp
leq greaterp geq pasf_deci simp addf negf) 820847617144401066)
pasf_or


(c!:install 'sfto_subfwd '(sfto_subfwd to) 13000020750751605308)
sfto_subfwd


(c!:install 'opfneval '(opfneval noval nosimp fnreval lispeval) 
17387910540412874572)
opfneval


(c!:install 'initarg '(initarg op symm p r identity assoc !*sym!-assoc
mcontract acontract expand i upb comb ident mgenp list!-mgen initcomb) 
11987421245099069190)
initarg


(c!:install 'sc_geq '(sc_geq sc_subtrsq sc_minussq) 4195705267722748303)
sc_geq


(c!:install 'boolvalue!* '(boolvalue!*) 4038980927605819518)
boolvalue!*


(c!:install 'no!-side!-effect!-listp '(no!-side!-effect!-listp
no!-side!-effectp) 850758379198238797)
no!-side!-effect!-listp


(c!:install 'lalr_cleanup '(lalr_cleanup symbols lalr_produces
lalr_first lalr_nonterminal_code) 4255005295855002291)
lalr_cleanup


(c!:install 'open '(open input output append "bad direction ~A in open"
internal!-open error) 14317167635950447697)
open


(c!:install 'pushback '(pushback) 8836067283905998773)
pushback


(c!:install 'talp_getinvfsym '(talp_getinvfsym talp_getextl) 
9177800204687041786)
talp_getinvfsym


(c!:install 'qqe_eta!-in!-term1 '(qqe_eta!-in!-term1 qepsilon
qqe_simplterm qqe_op) 3218916659083563987)
qqe_eta!-in!-term1


(c!:install 'pasf_fact '(pasf_fact true false (equal neq) equal or and (
leq lessp geq greaterp) fctrf minusf pasf_anegrel pasf_fact1) 
12536055379840675589)
pasf_fact


(c!:install 'acfsf_0mk2 '(acfsf_0mk2) 3673531778556882783)
acfsf_0mk2


(c!:install 'degree!-order '(degree!-order) 3790283495092693237)
degree!-order


(c!:install 'lambdaom '(lambdaom "<OMBIND>"
"<OMS cd=""fns1"" name=""lambda""/>" "<OMBVAR>" "</OMBVAR>" "</OMBIND>"
printout indent!* objectom) 847063321728976000)
lambdaom


(c!:install 'inprinla '(inprinla alt maprintla oprinla negnumberchk) 
14378767123408814437)
inprinla



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u29.lsp"

Reading "$reduce/cslbuild/generated-c/u30.lsp"

% u30.lsp           Machine generated Lisp

(c!:install "u30" 169932 8869143 2112391)
nil


(c!:install 'pterpri '(pterpri !*pprinbuf!* !*outchanl!* gentranlang!*
fortran !*posn!* fprin2) 8185548319256861553)
pterpri


(c!:install 'assert_declarestat1 '(assert_declarestat1 assert!:
noassert!: a list de assert_check1 put (quote assert_assertfn) (quote
assert_noassertfn) (quote assert_installed) cond not member
assert_functionl!* setq cons progn mkid) 3292435740705044339)
assert_declarestat1


(c!:install 'mksf '(mksf !*sub2 mksq mksp) 16383421118374179651)
mksf


(c!:install 'dvfsf_susitf '(dvfsf_susitf) 8904607512669943908)
dvfsf_susitf


(c!:install 'ofsf_smmkatl '(ofsf_smmkatl !*rlsippatl ofsf_smmkatl1
ofsf_sippatl) 5237972885042561372)
ofsf_smmkatl


(c!:install 'cl_nnfnot '(cl_nnfnot cl_nnf1) 11231145940357742317)
cl_nnfnot


(c!:install 'fctrf '(fctrf !*exp ncmp!* !*ezgcd !*gcd !*limitedfactors
dmode!* !*mcd poly "Factorization invalid with MCD off" !:rn!: alglist!*
!*trfac "This polynomial is homogeneous - variables scaled" noncomfp
rerror resimp !*q2f prepf simp sf2ss homogp prin2t listsum subs0 ss2sf
fctrf1 rconst sort!-factors quotf!* setcar) 13332295977068126080)
fctrf


(c!:install 'ev_insert '(ev_insert nreverse) 12499144344132413115)
ev_insert


(c!:install 'testpr '(testpr jsi codmat maxvar pnthxzz dm!-times
dm!-difference zeropp) 5415271785955096851)
testpr


(c!:install 'embed!-null!-fn '(embed!-null!-fn null!-fn lastpair) 
17022345701138273670)
embed!-null!-fn


(c!:install 'vdpcondense '(vdpcondense dipcondense) 7472009799357661127)
vdpcondense


(c!:install 'subla!-q '(subla!-q quote go lambda prog delasc) 
9807319529802026966)
subla!-q


(c!:install 'changearg '(changearg nreverse) 3622155650508054526)
changearg


(c!:install 'cons_ordp '(cons_ordp) 5587147247341243531)
cons_ordp


(c!:install 'general!-ordered!-gcd!-mod!-p '(
general!-ordered!-gcd!-mod!-p reduction!-count
general!-reduce!-degree!-mod!-p general!-monic!-mod!-p) 
12646109401517478620)
general!-ordered!-gcd!-mod!-p


(c!:install 'gcref_off '(gcref_off btime!* pfiles!* cref_name !*gcrefall
seen!* !*saveprops gcref_off1 gcref_select gcref_mkgraph gcref_eselect
gcref_mkegraph gcref_remprops) 12454789395406789858)
gcref_off


(c!:install 'checku '(checku) 15822881287339415887)
checku


(c!:install 'make!-modular!-symmetric '(make!-modular!-symmetric
modulus!/2 current!-modulus !*n2f) 6815586440753749212)
make!-modular!-symmetric


(c!:install 'opfneval1 '(opfneval1 tracealg "+++ Calling %p (%w:%w)%n"
defined!-in!-file defined!-on!-line "Arg%w = %@p%n" quote !*backtrace
"+++ Error in call to %p (%w:%w)%n" "%p => %p%n" "%p => %@p%n"
printf_internal errorset!* errorp) 15613979931203860423)
opfneval1


(c!:install 'atomlis '(atomlis) 6501944974261703121)
atomlis


(c!:install 'bcminus!? '(bcminus!? !*grmod!* minusf) 6378942423523588168
)
bcminus!?


(c!:install 'dipprod '(dipprod diplength dipprodin) 14131312737934490340
)
dipprod


(c!:install 'basisformp '(basisformp basisforml!*) 4086774854439652781)
basisformp


(c!:install 'sgn1 '(sgn1 sgn) 4395985868830635280)
sgn1


(c!:install 'deginvar '(deginvar kord!* wuconstantp reorder) 
4021669980146091331)
deginvar


(c!:install 'dfconst '(dfconst zlist vp2) 15827301056878358237)
dfconst


(c!:install 'domainvalchk '(domainvalchk dmode!* valuechk mk!*sq) 
17043547302922129578)
domainvalchk


(c!:install 'qqe_arg!-check!-lb!-rb '(qqe_arg!-check!-lb!-rb
"type conflict: arguments don't fit
             binary op with basic type args" qqe_arg!-check!-b
qqe_arg!-check!-marked!-ids!-rollback typerr) 7561473729744837887)
qqe_arg!-check!-lb!-rb


(c!:install 'relnrd '(relnrd atts (type definitionurl) char relations!*
lex retattributes compress!* apply) 7698492374233116587)
relnrd


(c!:install 'unify '(unify op r p "UNIFY:pattern over-run for function "
symm comb identity mcontract acontract expand i upb resume ident mgenp
pm!:free genp initarg nextarg suspend bind chk mval unbind meq) 
5085765813978083439)
unify


(c!:install 'dipsum '(dipsum evcomp iequal bcsum bczero!? setcdr) 
17754619527837437931)
dipsum


(c!:install 'locate_member '(locate_member) 4764278102994726603)
locate_member


(c!:install 'repartsq '(repartsq splitcomplex multsq addsq invsq) 
1876562266233041932)
repartsq


(c!:install 'harmonicp '(harmonicp fourier!-angle) 6327494936315734929)
harmonicp


(c!:install 'simp!-prop2 '(simp!-prop2 propvars!* prop!* not_prop!*
union simp!-prop!-condense) 18327063984962764399)
simp!-prop2


(c!:install 'reverse!-num1 '(reverse!-num1 reverse!-num!-table!*) 
4190109204128489908)
reverse!-num1


(c!:install 'qtypnm '(qtypnm function seen seen!* tseen !( !) tseen!*
rccnam funs traput) 14045573743009214131)
qtypnm


(c!:install 'ofsf_siatsubf '(ofsf_siatsubf exptsq multsq addsq
ofsf_pow2q) 9348361271224187083)
ofsf_siatsubf


(c!:install 'ofsf_simplat1 '(ofsf_simplat1 (equal neq leq geq lessp
greaterp) true false !*rlsiatadv equal neq leq geq lessp greaterp
ofsf_evalatp sfto_dcontentf quotf minusf negf ofsf_anegrel
ofsf_simplequal ofsf_simplneq ofsf_simplleq ofsf_simplgeq
ofsf_simpllessp ofsf_simplgreaterp) 15985813956325357611)
ofsf_simplat1


(c!:install 'drop_rl_with '(drop_rl_with rl_with) 3316639232002376194)
drop_rl_with


(c!:install 'width '(width textag "cannot find item " fatal tri!-error) 
6407596289288209404)
width


(c!:install 'qqe_simplterm!-tail '(qqe_simplterm!-tail qepsilon (ladd
radd) ltail radd rtail ladd qqe_arg2l qqe_op qqe_arg2r qqe_simplterm) 
3376354025590589708)
qqe_simplterm!-tail



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u30.lsp"

Reading "$reduce/cslbuild/generated-c/u31.lsp"

% u31.lsp           Machine generated Lisp

(c!:install "u31" 85054 7291130 1149592)
nil


(c!:install 'factor!-prim!-sqfree!-f '(factor!-prim!-sqfree!-f !*msg
!*rounded !*complex !*rational rational !*limitedfactors dmode!*
internal!-factorf sqfrfactorfn factorfn factorf rounded univariatep
unifactor on resimp exptf factor!-prim!-sqfree!-f!-1) 
8599318140327015233)
factor!-prim!-sqfree!-f


(c!:install 'derad '(derad nreverse ordp) 6903141748124374193)
derad


(c!:install 'dip2vdp '(dip2vdp !*groebsubs vdp dipsubs2 a2bc) 
15231011002842528392)
dip2vdp


(c!:install 'indordn '(indordn indord2 indordad) 1270862301250861552)
indordn


(c!:install 'generic!-sub '(generic!-sub dfp list dfp!-sub) 
17996181599572078420)
generic!-sub


(c!:install 'symbol '(symbol !*utf8 !*utf82d utf8_2d!-symbol!-character
utf8_symbol!-character symbol!-character) 13739637880224446540)
symbol


(c!:install 'modp '(modp) 14828617985740440421)
modp


(c!:install 'horner!-rule!-for!-one!-var '(horner!-rule!-for!-one!-var
!*n2f multf addf) 3366819904428384819)
horner!-rule!-for!-one!-var


(c!:install 'letscalar '(letscalar hold df "operator" avalue rtype
antisymmetric infix kvalue linear noncom op opmtch simpfn symmetric
wtl!* opfn expt frlis!* sqrt !*sqrtrulep (quotient 1 2) varstack!*
!*precise errpri2 letdf getrtype reval let2 redmsg mkop let3 delasc
rmsubs to letexprn simp0 errpri1) 16640623747715855073)
letscalar


(c!:install 'ra_l '(ra_l ra_iv riv_l) 3312224385655881070)
ra_l


(c!:install 'lalr_process_productions '(lalr_process_productions
nonterminals lalr_produces carrassoc) 11669776550209890589)
lalr_process_productions


(c!:install 'read_signature '(read_signature cursym!* rlisp
"invalid as formal parameter name" !*semicol!* general !*colon!*
!*lpar!* !*rpar!* "found where right parenthesis expected"
valid_as_variable rerror scan read_type symerr read_typed_name
read_namelist) 15436169951084997305)
read_signature


(c!:install 'ofsf_smordtable '(ofsf_smordtable ((equal (equal . false) (
neq equal . t) (geq equal . t) (leq . false) (greaterp equal . t) (lessp
. false)) (neq (equal equal) (neq) (geq) (leq leq) (greaterp) (lessp
lessp)) (geq (equal . false) (neq geq . t) (geq geq . t) (leq . false) (
greaterp geq . t) (lessp . false)) (leq (equal equal) (neq) (geq) (leq
leq) (greaterp) (lessp lessp)) (greaterp (equal . false) (neq greaterp .
t) (geq greaterp . t) (leq . false) (greaterp greaterp . t) (lessp .
false)) (lessp (equal equal) (neq) (geq) (leq leq) (greaterp) (lessp
lessp)))) 14560317248216607311)
ofsf_smordtable


(c!:install 'mk!+squared!+norm '(mk!+squared!+norm mk!+inner!+product) 
3644133023429157522)
mk!+squared!+norm


(c!:install 'cgp_mk '(cgp_mk cgp) 1967345575831606739)
cgp_mk


(c!:install 'semanticml '(semanticml "<apply>" "<fn>" "<semantic>"
"<ci><mo>" "</mo></ci>" "<annotation-xml encoding=""OpenMath"">" "<" ">"
"</annotation-xml>" "</semantic>" "</fn>" "</apply>" printout indent!*
mathml_list2string multi_elem) 10713627020240037658)
semanticml


(c!:install 'evalvars '(evalvars intfn setelemfn nreverse
revlis_without_mode revlis) 9040418125506089064)
evalvars


(c!:install 'vdp2a '(vdp2a dip2a) 13099992034530689081)
vdp2a


(c!:install 'overall_factor '(overall_factor xval) 13640985980635654836)
overall_factor


(c!:install 'nconc2 '(nconc2) 8019592056523493459)
nconc2


(c!:install 'testchar1 '(testchar1 nochar!* nochar1!*) 
3304520668572494504)
testchar1


(c!:install 'gparg1p '(gparg1p gpargp) 11507040959066206646)
gparg1p


(c!:install 'formsetq '(formsetq symbolic list cons formsetq0 formsetq1
formsetq2) 14303897429664626038)
formsetq


(c!:install 'mv!-pow!-!> '(mv!-pow!-!>) 15823260743438036790)
mv!-pow!-!>


(c!:install 'red!=subst1 '(red!=subst1 !*bcsimp "---> " "." " uses "
bas_dpoly dp_lc bas_rep cali_bc_inv cali_bc_prod cali_bc_fi cali_bc_gcd
cali_bc_divmod dp_lmon mo_diff dp_times_bc dp_times_bcmo dp_diff
cali_trace dp_print bas_nr bas_make1) 9007145003661642186)
red!=subst1


(c!:install 'lalr_process_reductions '(lalr_process_reductions
nonterminals lalr_nonterminal_code lalr_productions mkvect16 mkvect8
putv16 putv8 lalr_construct_fn) 4573902986117076329)
lalr_process_reductions


(c!:install 'monomgetfirstmultivar '(monomgetfirstmultivar) 
13534559078993598004)
monomgetfirstmultivar


(c!:install 'talp_noffcts '(talp_noffcts talp_getl) 4637553578255174733)
talp_noffcts


(c!:install 'lesspcdadr '(lesspcdadr) 7964605696148437830)
lesspcdadr


(c!:install 'matrix_rows '(matrix_rows "<matrixrow>" "</matrixrow>"
printout indent!* row) 12368609926542696831)
matrix_rows


(c!:install 'noncomexpf '(noncomexpf noncomp) 5575421815131349904)
noncomexpf


(c!:install 'xriterion_1 '(xriterion_1 spoly_pair !*trxideal
"criterion 1 hit" last xval xdiv make_spoly_pair find_item writepri) 
13595331840087151417)
xriterion_1


(c!:install 'gfplusn '(gfplusn gffplus plus!:) 17488025135662503742)
gfplusn


(c!:install 'sign!-of '(sign!-of simp!-sign) 9585081512023966144)
sign!-of


(c!:install 'assert_stat!-parse '(assert_stat!-parse !*colon!*
"expecting ':' in assert but found" cursym!* difference greaterp
"expecting '->' in assert but found" "expecting end of assert but found"
scan rederr assert_stat1) 12520463969237406079)
assert_stat!-parse


(c!:install 'comb '(comb) 16651735446486970447)
comb


(c!:install 'gcref_off1 '(gcref_off1 dfprint!* !*defn !*algebraics
algebraic newnam seen!* calledby entpts!* tseen!* tseen funs rccnam
gseen!* usedunby undefg!* undefdchk idsort) 16304191943616561554)
gcref_off1


(c!:install 'sfto_updecf '(sfto_updecf !*sfto_yun !*sfto_musser
"sfto_updecf: select a decomposition method" sfto_yun!-updecf
sfto_musser!-updecf rederr) 9570799290316021347)
sfto_updecf


(c!:install 'simpexpt1 '(simpexpt1 !*allfac !*div e log alg
"0**0 formed" "Zero divisor" !*mcd expt simp simp!* prepsq!* simpexpt11
rerror minusf !*d2q !:expt resimp domainvalchk exptsq invsq expf mksfpf
multf subs2!*) 11760113747554941655)
simpexpt1


(c!:install 'get_char_group '(get_char_group) 8299995027405440554)
get_char_group



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u31.lsp"

Reading "$reduce/cslbuild/generated-c/u32.lsp"

% u32.lsp           Machine generated Lisp

(c!:install "u32" 143801 5677735 4526528)
nil


(c!:install 'talp_atnum '(talp_atnum or and not impl repl equiv ex all
true false) 11551283075179441224)
talp_atnum


(c!:install 'minusml '(minusml "<apply><minus/>" "</apply>" printout
indent!* multiminus) 1217897309786682102)
minusml


(c!:install 'exptplus '(exptplus "Bad exponent sum" interr) 
15800345272466755993)
exptplus


(c!:install 'add_minus '(add_minus !:rd!: minus) 16653397504775846537)
add_minus


(c!:install 'dipnumcontent '(dipnumcontent bcone!? vbcgcd) 
2900635658430140763)
dipnumcontent


(c!:install 'sc_getrow '(sc_getrow sc_igetv) 3551891752755930172)
sc_getrow


(c!:install 'f2dip11 '(f2dip11 !*notestparameters vdpvars!*
"occurs in a parameter and is member of the groebner variables." list
"groebner: LIST not allowed." rederr) 7234983498125750140)
f2dip11


(c!:install 'eqexpr '(eqexpr equalopr) 3505042047303045823)
eqexpr


(c!:install 'formatfort '(formatfort !*lower !*posn!* maxint !*double e
!D !E (d !0) fortlinelen!* lispeval i2rd!* fortcontline pprin2) 
11603302336187822563)
formatfort


(c!:install 'one!-entryp '(one!-entryp) 1880773745218423214)
one!-entryp


(c!:install 'subsq '(subsq alg "0/0 formed" "Zero divisor" subf subs2!*
rerror quotsq) 2328511050533666755)
subsq


(c!:install 'groeb!=rf1 '(groeb!=rf1 red_totalred) 7915201577852284808)
groeb!=rf1


(c!:install 'length_multiindex '(length_multiindex) 692022526224992757)
length_multiindex


(c!:install 'lex_basic_token '(lex_basic_token lex_peeked
lex_peeked_yylval yylval lex_peeked_escaped lex_escaped lex_char ! 
!$eol!$ !	 !$eof!$ lex_eof_code !! lexer_style!* !*raise !*lower
comment !; !$ lex_code !' lex_is_typename lex_typename_code
lex_symbol_code !~ !0 x !X lex_number_code !. e !E !+ !- !" !\
lex_string_code lex_char_code quote lex_list_code !` backquote !#
lex_dipthong sml_opchar (if else elif endif define eval)
lex_start_line_comment lex_skip_line_comment lex_start_block_comment
lex_skip_block_comment yyreadch lexer_word_starter land
lexer_word_continues list2widestring yypeek lex_hexval read_s_expression
widestring2list all_sml_opchar list2string) 6007149577768455066)
lex_basic_token


(c!:install 'in_list1a '(in_list1a !*echo !*reduce4 string !| !$ !/ !\
ifl!* !. (!/ !.) input linelist!* curline!* ipl!* contl!*
"FILE STACK CONFUSION" type typerr value mkfil!* list2string pipe!-open
open begin1a rederr) 5447568939486315732)
in_list1a


(c!:install 'formboollis '(formboollis formbool formc!* reversip!*) 
5288393440562812093)
formboollis


(c!:install 'talp_specsubt '(talp_specsubt talp_eqtp) 
3456373075680382027)
talp_specsubt


(c!:install 'multiminus '(multiminus expression) 3843225591671845349)
multiminus


(c!:install 'dm!-min '(dm!-min dm!-gt) 13325087570768997749)
dm!-min


(c!:install 'indxchk '(indxchk indxl!* nosuml!* union !*num2id) 
12525549298977096173)
indxchk


(c!:install 'incident '(incident incident1) 232370014167487459)
incident


(c!:install 'simp!-prop1 '(simp!-prop1 !'and !'or not implies or equiv
and true false (or !*true (not !*true)) (and !*true (not !*true))
boolean prop!* not_prop!* propvars!* multf addf reval simp) 
12573422058316044628)
simp!-prop1


(c!:install '!*di2q '(!*di2q varlist!* !*di2q0) 16228567822902602514)
!*di2q


(c!:install 'st_ad_numsorttree '(st_ad_numsorttree st_ad_numsorttree1) 
14827553760693438293)
st_ad_numsorttree


(c!:install 'expand_rule '(expand_rule expand_terminal) 
7297132048270984005)
expand_rule


(c!:install 'cl_susiupdknowl1 '(cl_susiupdknowl1 and cl_susiupdknowl2
rl_negateat) 14302886500742299120)
cl_susiupdknowl1


(c!:install 'ev_max!# '(ev_max!#) 15773274042070445237)
ev_max!#


(c!:install 'containerml '(containerml integer_interval interval "<" ""
"</" ">" printout attributesml indent!* multi_elem) 17496795682551813199
)
containerml


(c!:install 'ps!:constmult!-erule '(ps!:constmult!-erule ps!:evaluate
multsq) 14878993956804742982)
ps!:constmult!-erule


(c!:install 'mkempspmat '(mkempspmat sparsemat) 13492359742304325991)
mkempspmat


(c!:install 'insoccs '(insoccs subscriptedvarp insertocc constp) 
6756413965020670852)
insoccs


(c!:install 'module '(module !*mode mode!-list!* alglist!* symbolic) 
17191246551011286226)
module


(c!:install '!*xadd '(!*xadd) 17463717805747166282)
!*xadd


(c!:install 'chkrn!* '(chkrn!* !*!*roundbf bf2flck) 4426900711315584015)
chkrn!*


(c!:install '!*a2f '(!*a2f simp!* !*q2f) 1157670281669662903)
!*a2f


(c!:install 'lalr_extract_nonterminals '(lalr_extract_nonterminals
"Malformed production"
"(RHS should be a list of tokens, not a non-nil atom)" lex_fixed_code
"(atomic item in token list should be symbol or string)" (opt seq star
plus list listplus or) "(unrecognised item in rule)" nreverse rederr) 
14495628518251421958)
lalr_extract_nonterminals



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u32.lsp"

Reading "$reduce/cslbuild/generated-c/u33.lsp"

% u33.lsp           Machine generated Lisp

(c!:install "u33" 103635 4357356 7513239)
nil


(c!:install 'triplesetprolongedby '(triplesetprolongedby) 
18341923192646002043)
triplesetprolongedby


(c!:install '!*tayexp2q '(!*tayexp2q) 13103823873588407608)
!*tayexp2q


(c!:install 'vdelete '(vdelete nreverse) 1364860348438815528)
vdelete


(c!:install 'omatpir '(omatpir (!/ o m a t p) lex omsir omobj checktag) 
14637756025774761808)
omatpir


(c!:install 'suchp '(suchp such!-that) 2237043806669000480)
suchp


(c!:install '!*pf2sq '(!*pf2sq to multsq addsq) 13586119113996823355)
!*pf2sq


(c!:install 's_actual_world1 '(s_actual_world1) 13857407108230127468)
s_actual_world1


(c!:install 'subs2chk '(subs2chk subfg!* subs2f) 3120225543026791882)
subs2chk


(c!:install 'simp!-prop!-condense '(simp!-prop!-condense
lambda_rfde09ec49c92 sort subsetp ordn) 16837942846282228103)
simp!-prop!-condense


(c!:install 'lambda_rfde09ec49c92 '(lambda_rfde09ec49c92) 
4700859260019140216)
lambda_rfde09ec49c92


(c!:install 'skp_ordp '(skp_ordp atom_compare cons_ordp) 
18096101897370550795)
skp_ordp


(c!:install 'gitimes!: '(gitimes!: mkgi) 8275366031935422847)
gitimes!:


(c!:install 'ofsf_ir2atl '(ofsf_ir2atl ofsf_entry2at lastpair) 
3437061213404465222)
ofsf_ir2atl


(c!:install 'repr_a '(repr_a addf) 13167846556635871198)
repr_a


(c!:install 'dip_ilcomb2r '(dip_ilcomb2r ev_comp iequal bc_prod bc_sum
bc_zero!?) 6725495761887343420)
dip_ilcomb2r


(c!:install 'ev_2a '(ev_2a dip_vars!* ev_2a1) 40967775589971858)
ev_2a


(c!:install 'bvarrd '(bvarrd char (d e g r e e) "<bvar>" (!/ d e g r e e
) "</degree>" (!/ b v a r) bvar "</bvar>" lex errorml mathml2 mathml
error) 7637494499477649831)
bvarrd


(c!:install '!:dmtimeslst '(!:dmtimeslst !:times) 7422364972943705268)
!:dmtimeslst


(c!:install 'prop!-simp '(prop!-simp prop!-simp1) 8182520842950749849)
prop!-simp


(c!:install 'red_topred '(red_topred !*noetherian bas_dpoly red_topredbe
dp_lmon red_divtest red_subst red_update) 14392805755887232125)
red_topred


(c!:install 'list_is_all_free '(list_is_all_free nodum_varp) 
15714767976063944508)
list_is_all_free


(c!:install 'general!-horner!-rule!-mod!-p '(
general!-horner!-rule!-mod!-p general!-expt!-mod!-p
general!-times!-mod!-p general!-plus!-mod!-p) 6014534191802679692)
general!-horner!-rule!-mod!-p


(c!:install '!*a2k '(!*a2k kernel simp!* kernp typerr) 
4159766344436415377)
!*a2k


(c!:install 'formbool '(formbool symbolic boolvalue!* boolfn boolean
boolargs "Too many formbools" where bool!-eval formc formc!* intexprlisp
formclis formboollis rederr) 12736169941840665603)
formbool


(c!:install 'talp_sumd '(talp_sumd rl_atl talp_arg2l talp_td talp_arg2r)
 14348405121939397515)
talp_sumd


(c!:install 'sets '(sets "<apply>" "<" "/" "</apply>" printout
attributesml indent!* multi_elem) 535982809161287800)
sets


(c!:install 'alg_plus '(alg_plus plus aeval) 13889267068724863557)
alg_plus


(c!:install 'matrixp '(matrixp mat sparsemat reval) 14228403379404342080
)
matrixp


(c!:install 'amatch '(amatch r p !*semantic equal mval unify suchp
resume) 5585579030456768667)
amatch


(c!:install 'groebnormalform '(groebnormalform groebnormalform0) 
9246680682546895048)
groebnormalform


(c!:install 'evload '(evload) 11219261006708819634)
evload


(c!:install 'toolongexpp '(toolongexpp maxexpprintlen!* numprintlen) 
10528370960806224087)
toolongexpp


(c!:install 'find_buble '(find_buble is_buble) 12981048816766530333)
find_buble


(c!:install 'log_assignment '(log_assignment quote function setq
"+++ Assignment to parameter of inline: " "+++ Macro was: " inlineinfo
cond log_assignment_list_list log_assignment_list) 8320727009848696406)
log_assignment


(c!:install 'arglength '(arglength !*intstr reval) 8071143878740418471)
arglength


(c!:install 'fs!:onep!: '(fs!:onep!: fs!:onep) 16865939965197051073)
fs!:onep!:


(c!:install 'red!=hide '(red!=hide mo_neg mo_times_ei) 
5964687500655226768)
red!=hide


(c!:install 'dummyp '(dummyp minus g_dvnames g_dvbase listp !*id2num
upbve ad_splitname) 10097767703930092657)
dummyp


(c!:install 'ratdif '(ratdif ratminus ratplusm) 8523472214507921043)
ratdif


(c!:install 'letexprn '(letexprn times difference quotient mcond!*
!*match used!* df opmtch asymplis!* powlis!* replace frasc!* powlis1!*
let!-prepf let2 kernlp term!-split quotf!* klistt rmsubs xadd!* smember
fkern setk1 errpri1 xadd delasc) 17876340611196469351)
letexprn


(c!:install 'poly!-to!-vector '(poly!-to!-vector poly!-vector !*d2n) 
3599356024780753765)
poly!-to!-vector


(c!:install 'lex_process_directive '(lex_process_directive yylval
!#endif if_depth "+++ #endif not follopwing #if" !$eof!$
"+++ #endif missing at end of file" !#if !#else !#elif read_s_expression
errorset errorp lex_skip_to_else_or_endif) 7603308210475858270)
lex_process_directive


(c!:install 'arg1of2 '(arg1of2) 4218017190104628163)
arg1of2


(c!:install 'profile_a_package '(profile_a_package !*errcont cpulimit
jlisp lispsystem!* conslimit "PROFILING: " !*backtrace !*int
reduce_regression_tests folder "$reduce/packages/" testdirectory "/"
".tst" alglist!* algebraic !*mode "[Profile] " quit expr posn errorset
in_list1 erfg!* profile_compare_fn "buildlogs/flaguse.log" append
!*savedef lambda "profile.dat" "% +++++ Error: Resource limit exceeded"
"% @@@@@ Resources used: " !*resources!* "(" "  (" " " ")" "  )" input
!$eof!$ orderp ((symbol!-make!-fastget (quote lose) 1) (
symbol!-make!-fastget (quote noncom) 0)) (lose noncom) processed
symbol!-make!-fastget "buildlogs/fastgets.lsp" output
"% fastgets.lsp generated by profiling" progn "% end of fastgets.lsp"
"Profiling complete" (remake profile_a_package) get_configuration_data
load!-package concat list!-to!-string window!-heading getd putd
resource!-limit sort open bytecounts load!-source md60 prettyprint
restart!-csl) 2815953169272495238)
profile_a_package


(c!:install 'vp2 '(vp2 nreverse) 12682152641767427105)
vp2


(c!:install 'pasf_exprng '(pasf_exprng !*rlsism and true false or ball
bex not impl repl equiv pasf_exprng!-gand pasf_exprng!-gball cl_simpl) 
18106096511587248063)
pasf_exprng



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u33.lsp"

Reading "$reduce/cslbuild/generated-c/u34.lsp"

% u34.lsp           Machine generated Lisp

(c!:install "u34" 171997 7140639 1743420)
nil


(c!:install 'mapcarcar '(mapcarcar) 6573486607489535135)
mapcarcar


(c!:install 'matrixom '(matrixom "<OMA>"
"<OMS cd=""linalg1"" name=""matrix""/>" "</OMA>" printout indent!*
matrixrowom) 14726143653554891393)
matrixom


(c!:install 'close_forall '(close_forall flagg "</apply>" printout) 
14878609875013610813)
close_forall


(c!:install 'lispreadp '(lispreadp read) 7798977045561721809)
lispreadp


(c!:install 'reval3 '(reval3 simp mk!*sq) 5760933334693659966)
reval3


(c!:install 'color!-roads '(color!-roads) 17298579009205451982)
color!-roads


(c!:install 'remchkf '(remchkf remchkf1 kernels intersection) 
7564202488979874806)
remchkf


(c!:install 'split_cov_cont_ids '(split_cov_cont_ids minus) 
11739611569100803353)
split_cov_cont_ids


(c!:install 'proper!-simpsqrt '(proper!-simpsqrt carx simpsqrti) 
12726400845289891393)
proper!-simpsqrt


(c!:install 'make!-x!-to!-p '(make!-x!-to!-p dpoly poly!-vector
times!-in!-vector remainder!-in!-vector) 6629668419058198533)
make!-x!-to!-p


(c!:install 'lex_skip_line_comment '(lex_skip_line_comment lex_char
!$eol!$ !$eof!$ yyreadch) 17954792529991133834)
lex_skip_line_comment


(c!:install 'sortedpolynomlistinsert '(sortedpolynomlistinsert
polynomcompare) 15826984959678356939)
sortedpolynomlistinsert


(c!:install 'multdfconst '(multdfconst nreverse multsq subs2q) 
18239574063977063315)
multdfconst


(c!:install 'mri_congp '(mri_congp (cong ncong) mri_opn) 
8707192043286087915)
mri_congp


(c!:install 'rat_abs '(rat_abs absf) 8422367871539374234)
rat_abs


(c!:install 'applyfnrd '(applyfnrd fnrd stats_getargs) 
17843552477246788365)
applyfnrd


(c!:install 'ps!:times!-erule '(ps!:times!-erule ps ps!:order
ps!:evaluate multsq addsq) 11748419915097130968)
ps!:times!-erule


(c!:install 'matsm1 '(matsm1 !*div sparsemat mat matrix
"Matrix mismatch" sparse "Non square matrix" subfg!* inversefn
lnrsolvefn !*sub2 "Zero divisor" "Matrix" "not set" spmultm lispapply
multsm multm lchk rerror xsimp checksp spmatsm matsm subs2 revpr
generateident) 11861811968647949886)
matsm1


(c!:install 'recaliasbacksubst '(recaliasbacksubst constp) 
7026364058141692205)
recaliasbacksubst


(c!:install 'dipprodin '(dipprodin dipzero dipprodin1 dipsum) 
17397364834695958208)
dipprodin


(c!:install 'difference!: '(difference!: !:rd!: minus!: ashift) 
13627056831675126278)
difference!:


(c!:install 'evaluate!-horner '(evaluate!-horner horner!-cache!* simp!*
hornerf prepsq) 3733419029157992492)
evaluate!-horner


(c!:install 'indexsymmetrize '(indexsymmetrize indxsymmetrize) 
13445894356302575475)
indexsymmetrize


(c!:install 'po!:statep '(po!:statep state) 14306850752333635111)
po!:statep


(c!:install 'color!-strand '(color!-strand nreverse color!-roads) 
13048520133353012665)
color!-strand


(c!:install 'greaterpcdr '(greaterpcdr) 8968584287361009996)
greaterpcdr


(c!:install 'clogsq!* '(clogsq!* !*div !*combinelogs !*expandlogs
!*uncached prepsq simp prepsq!* comblog simp!*) 15398099386031094604)
clogsq!*


(c!:install 'fs!:prin '(fs!:prin " 0 " " + " prin2!* fs!:prin1) 
6908279454003400687)
fs!:prin


(c!:install 'dfprintfn '(dfprintfn !*nat !*fort !*dfprint failed !!df!!
layout!-formula putpline) 6576352468631490110)
dfprintfn


(c!:install 'msolve!-poly1 '(msolve!-poly1 erfg!* current!-modulus expt
safe!-modrecip negf multf moduntag general!-modular!-number lowestdeg
simp quotf general!-reduce!-mod!-p general!-evaluate!-mod!-p lastpair
prepf) 12122992026913452271)
msolve!-poly1


(c!:install 'cde_replace_nth '(cde_replace_nth nreverse) 
958148222290834626)
cde_replace_nth


(c!:install 'ra_qmk '(ra_qmk !:ra!: riv_mk) 3819616673865121068)
ra_qmk


(c!:install 'aex_lc '(aex_lc aex_mvartest aex_ex sfto_lcx quotsq kernels
aex_ctx ctx_filter aex_mk) 17965101807908454800)
aex_lc


(c!:install 'polynomwrite '(polynomwrite nreverse monomwrite) 
8019372385341136277)
polynomwrite


(c!:install 'taydegree!< '(taydegree!< tayexp!-greaterp tayexp!-lessp) 
13743525140988364063)
taydegree!<


(c!:install 'gen!+can!+bas '(gen!+can!+bas) 4195692412070013370)
gen!+can!+bas


(c!:install 'cl_bvarl1 '(cl_bvarl1 cl_varl1) 9380843449797521470)
cl_bvarl1


(c!:install 'qqe_ofsf_varlat '(qqe_ofsf_varlat qqe_ofsf_prepat qqe_arg2l
qqe_ofsf_varlterm qqe_arg2r union) 15296253903470199447)
qqe_ofsf_varlat


(c!:install 'cl_susiinter '(cl_susiinter delete ignore add lto_delqip) 
3710122244307141011)
cl_susiinter


(c!:install 'ev_dif '(ev_dif) 17835376965745009896)
ev_dif


(c!:install 'bc_mkat '(bc_mkat) 11608354390859674424)
bc_mkat


(c!:install 'vectorml '(vectorml "<vector" "" "</vector>" printout
attributesml indent!* multi_elem) 11686521336891622087)
vectorml


(c!:install 'delyzz '(delyzz nreverse) 3317795321810317837)
delyzz


(c!:install 'make!-unique!-freevars '(make!-unique!-freevars gen
freevarlist!* pm!:gensym) 2618527914134102580)
make!-unique!-freevars


(c!:install 'fieldp '(fieldp) 10650134519085569632)
fieldp


(c!:install 'dipsimpcont '(dipsimpcont !*vdpinteger !*groebdivide
dipsimpconti dipsimpcontr) 603366294860614937)
dipsimpcont


(c!:install 'greaterp!: '(greaterp!: !:bprec!: normbf ashift) 
7774966988171925016)
greaterp!:


(c!:install 'calc_coeff '(calc_coeff calc_world) 15849626058100044138)
calc_coeff



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u34.lsp"

Reading "$reduce/cslbuild/generated-c/u35.lsp"

% u35.lsp           Machine generated Lisp

(c!:install "u35" 183161 6110864 8115840)
nil


(c!:install 'log_freevars_list '(log_freevars_list log_freevars) 
5289505311670650718)
log_freevars_list


(c!:install 'ratfunpri1 '(ratfunpri1 spare!* posn!* orig!* ycoord!*
pline!* ymin!* ymax!* bar quotient p!*!* "(" ")" layout!-formula max
terpri!* update!-pline min symbol prin2!* maprint oprin negnumberchk) 
10056120397460243885)
ratfunpri1


(c!:install 'mo_zero!? '(mo_zero!? mo!=zero) 7961466638273179982)
mo_zero!?


(c!:install '!*f2di '(!*f2di varlist!* addgt pdmult pcmult psum) 
17461722156329616849)
!*f2di


(c!:install 'msolve!-polyn '(msolve!-polyn current!-modulus
msolve!-poly1 subf lastpair) 2360298124392123331)
msolve!-polyn


(c!:install 'reduce!-mod!-eigf '(reduce!-mod!-eigf !*sub2 cancel negsq
reduce!-eival!-powers subs2) 18377647075100431114)
reduce!-mod!-eigf


(c!:install 'ra_u '(ra_u ra_iv riv_u) 2540618869296221511)
ra_u


(c!:install 'vdp_putprop '(vdp_putprop) 16409054744709111877)
vdp_putprop


(c!:install 'listrd '(listrd atts (order) list retattributes
stats_getargs) 14769749089062405773)
listrd


(c!:install 'ps!:sqrt!-erule '(ps!:sqrt!-erule ps (quotient 1 2)
ps!:order ps!:evaluate prepsqxx simpexpt multsq addsq quotsq) 
10183546414698764261)
ps!:sqrt!-erule


(c!:install 'resume '(resume substitution amatch chk bsubs) 
17394164173255456306)
resume


(c!:install 'evinvlexcomp '(evinvlexcomp (0) evlexcomp iequal) 
3644866760103350735)
evinvlexcomp


(c!:install 'vdpilcomb1 '(vdpilcomb1 !*gsugar dipilcomb1 dip2vdp gsugar
vevtdeg max gsetsugar) 10167637561307787401)
vdpilcomb1


(c!:install 'unplus '(unplus plus nreverse) 554904849496138922)
unplus


(c!:install '!*!*a2i '(!*!*a2i ieval intexprnp) 17857848832979299686)
!*!*a2i


(c!:install 'dv_ind2var '(dv_ind2var g_dvnames g_dvbase upbve mkid) 
17529332376884670646)
dv_ind2var


(c!:install 'lalr_warn_shift_reduce_conflict '(
lalr_warn_shift_reduce_conflict "+++ Shift/reduce conflict in itemset #"
" on lookahead " "Reduce: " "Shift: to state #"
"Resolved in favour of the shift operation" lalr_prin_symbol
lalr_prin_production) 1635230266327942899)
lalr_warn_shift_reduce_conflict


(c!:install 'dvfsf_v '(dvfsf_v dvfsf_p!* qremf) 2793621462146063365)
dvfsf_v


(c!:install 'plusdf '(plusdf nreverse !*addsq orddf) 
10154485941733850895)
plusdf


(c!:install 'get!*inverse '(get!*inverse inverse give!*position nth) 
10046119299683993777)
get!*inverse


(c!:install 'cgp_lbc '(cgp_lbc cgp_rp dip_lbc) 6931679935384486887)
cgp_lbc


(c!:install 'getargsrd '(getargsrd char (b v a r) bvarrd lex) 
15523628145975880371)
getargsrd


(c!:install 'valuecoefft '(valuecoefft "Valuecoefft - no value" interr) 
11085630856475024248)
valuecoefft


(c!:install 'evaluate '(evaluate !*evaluateerror !*protfg !*msg
evaluate0 "error during function evaluation (e.g. singularity)" pair
errorset errorp rederr) 8549248470219636633)
evaluate


(c!:install 'assert_procstat!-argl '(assert_procstat!-argl cursym!*
!*rpar!* "Expecting identifier but found" !*colon!*
"Expecting type but found" (!*comma!* !*rpar!*)
"Expecting ',' or ')' but found" !*comma!* nxtsym!* !: returnvalue
eolcheck assert_rederr scan assert_typesyntaxp) 6719104097586060276)
assert_procstat!-argl


(c!:install 'ad_splitname '(ad_splitname charnump!:) 9997322121145538574
)
ad_splitname


(c!:install 'difbf '(difbf !:rd!: !:bprec!: minus!: msd ashift inorm) 
17984220760392890790)
difbf


(c!:install 'order_of_der_mind '(order_of_der_mind length_multiindex) 
501712109400027303)
order_of_der_mind


(c!:install 'lalr_get_lex_codes '(lalr_get_lex_codes lex_context
lex_save_context lex_cleanup lex_keywords lex_export_codes
lex_restore_context) 4037498215424840796)
lalr_get_lex_codes


(c!:install 'polynomcompare '(polynomcompare monomcompare) 
1281604190181789875)
polynomcompare


(c!:install 'ofsf_smcpknowl '(ofsf_smcpknowl) 16842228859866707994)
ofsf_smcpknowl


(c!:install 'multdf '(multdf multerm plusdf) 6296682842725154736)
multdf


(c!:install 'talp_specsub '(talp_specsub true false talp_atfp
talp_specsubat talp_op talp_argl) 8843642639735014270)
talp_specsub


(c!:install 'ithlistelem '(ithlistelem nth) 4936962979496750233)
ithlistelem


(c!:install 'maxl '(maxl max) 15330531340632273549)
maxl


(c!:install 'sc_subtrsq '(sc_subtrsq negsq addsq) 8269713965318093498)
sc_subtrsq


(c!:install 'getrlist '(getrlist list !*sq "list" prepsq typerr) 
13081520870141105431)
getrlist


(c!:install 'plubf '(plubf !:rd!: !:bprec!: msd ashift inorm) 
14385353088373813766)
plubf


(c!:install 'sublap '(sublap app sublap1) 3082966434538444150)
sublap


(c!:install 'min0 '(min0 min max) 12393225392512410134)
min0


(c!:install 'indordl2 '(indordl2 indordlp) 3423120191165119766)
indordl2


(c!:install 'getphystypeall '(getphystypeall "PHYSOP type mismatch in"
deleteall collectphystype rederr2) 11919110940414140279)
getphystypeall


(c!:install 'deletez1 '(deletez1 nreverse) 14734844965284007186)
deletez1


(c!:install 'realvaluedp '(realvaluedp realvalued alwaysrealvalued
condrealvalued realvaluedlist apply) 16698413258289320559)
realvaluedp


(c!:install 'assert_formproc '(assert_formproc symbolic
"asserted procedures are available in symbolic mode only" procedure expr
!*assert progn rederr formproc assert_declarestat1) 5727630391390359241)
assert_formproc


(c!:install 'subeval1 '(subeval1 subfn alg
"No substitution defined for type" !*sub2 getrtype rerror simp subsq
subs2 mk!*sq) 6660071289924290963)
subeval1


(c!:install 'remchkf1 '(remchkf1 !*trcompact "*** Remainder smaller"
termsf xremf prin2t) 9278271335112080814)
remchkf1


(c!:install 'subcare '(subcare subfunc nreverse) 16246309351900561860)
subcare


(c!:install 'mo!=zero '(mo!=zero) 13998459805112765093)
mo!=zero


(c!:install 'gvar1 '(gvar1 i !*complex (plus times expt difference minus
) quotient gvarlis1) 10478615922619036053)
gvar1


(c!:install 'ofsf_lnegrel '(ofsf_lnegrel equal neq leq greaterp lessp
geq "ofsf_lnegrel: unknown operator " rederr) 3663283369911138634)
ofsf_lnegrel



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u35.lsp"

Reading "$reduce/cslbuild/generated-c/u36.lsp"

% u36.lsp           Machine generated Lisp

(c!:install "u36" 166848 263349 8516143)
nil


(c!:install 'mk!+real!+inner!+product '(mk!+real!+inner!+product
"wrong dimensions in innerproduct" !*sub2 get!+vec!+dim rederr
get!+vec!+entry multsq addsq subs2) 7960805276825046221)
mk!+real!+inner!+product


(c!:install 'sqfrf '(sqfrf !*gcd !*msg !*rounded rational !*ezgcd
dmode!* rounded failed "sqfrf failure" on resimp diff gcdf quotf!-fail
lnc !:recip multd degr quotf multf rassoc rootxf aconc errach) 
10937586061064161386)
sqfrf


(c!:install 'fnrd '(fnrd char (c i) lex errorml mathml2) 
12513979410557079019)
fnrd


(c!:install 'physoptimes '(physoptimes tstack!* mul!* scalar physopsim!*
getphystype physop2sq multsq mk!*sq physopaeval physopordchk multopop!*)
 11430047265275158506)
physoptimes


(c!:install 'prop!-simp1 '(prop!-simp1 prop!-simp2) 8390697124977389921)
prop!-simp1


(c!:install 'liennewstruc '(liennewstruc lie_a expt difference plus
lie_lamb quotient times lientrans lie_cc minus matrix aeval setk aeval!*
aminusp!: clear) 5169052911349024914)
liennewstruc


(c!:install 'dp_neworder '(dp_neworder dp!=mocompare mo_neworder sort) 
14657201897860316967)
dp_neworder


(c!:install 'rl_fvarl '(rl_fvarl rl_fvarl!* apply) 4349438644931979515)
rl_fvarl


(c!:install 'give!*position '(give!*position "error in give position"
nth rederr) 12727423134272017288)
give!*position


(c!:install 'pasf_smwcpknowl '(pasf_smwcpknowl !*rlsusi cl_susicpknowl
cl_smcpknowl) 5549258679422128435)
pasf_smwcpknowl


(c!:install 'ciml '(ciml "<ci" "" "</ci>" printout attributesml) 
6087610867310095924)
ciml


(c!:install 'sparpri '(sparpri quote setq first (quote !$) last writepri
) 2859011705861866031)
sparpri


(c!:install 'groebspolynom3 '(groebspolynom3 groebspolynom4
groebsavelterm) 8179078728466715752)
groebspolynom3


(c!:install 'evalb '(evalb algebraic true false formbool eval) 
5861203536084675183)
evalb


(c!:install 'string2bytelist '(string2bytelist string2list) 
17726575049732048458)
string2bytelist


(c!:install 'lf!=zero '(lf!=zero) 4076842374495190263)
lf!=zero


(c!:install 'clean_numid '(clean_numid nreverse !*id2num) 
6328967194023589078)
clean_numid


(c!:install 'drnconv '(drnconv dmd!*) 12269271242945414679)
drnconv


(c!:install 'ra_intequiv0 '(ra_intequiv0 x ra_zerop ra_f negf ra_iv
riv_l riv_u negsq addsq sfto_greaterq ra_refine1 sfto_floorq addf
sfto_lessq sfto_fsub1) 14207901402562713221)
ra_intequiv0


(c!:install 'lex_init '(lex_init last64 last64p which_line if_depth
!*tracelex "yylex initialized" lex_peeked yyreadch) 2545617430861042629)
lex_init


(c!:install 'ofsf_sippsubst1 '(ofsf_sippsubst1 ofsf_siatsubf) 
8204819944402773185)
ofsf_sippsubst1


(c!:install 'even_action_sf '(even_action_sf even_action_term addsq) 
17992264046879664529)
even_action_sf


(c!:install 'maxfrom1 '(maxfrom1 nth max) 2038400951185798313)
maxfrom1


(c!:install 'get!-denom!-l '(get!-denom!-l lcmn) 1688803098278549094)
get!-denom!-l


(c!:install 'talp_maxd '(talp_maxd rl_atl talp_arg2l talp_td talp_arg2r)
 12517072239011711715)
talp_maxd


(c!:install 'symbolsom '(symbolsom name valid_om!* diff condition
"<condition> tag not supported in MathML" "<OMA>" int defint
"<OMS cd=""" """ name=""" """/>" lambda "</OMA>" errorml printout
indent!* objectom lambdaom) 16932333532394267659)
symbolsom


(c!:install 'degreef '(degreef max) 9999072322222969174)
degreef


(c!:install 'sc_mkmatrix '(sc_mkmatrix sc_simp sc_iputv) 
6937630376715149540)
sc_mkmatrix


(c!:install 'collectphysops_reversed '(collectphysops_reversed physopp
collectindices removeindices) 11260692883010774105)
collectphysops_reversed


(c!:install 'contr2 '(contr2 contr nreverse split!-road) 
18339366017502773054)
contr2


(c!:install 'listsub '(listsub subeval1 makelist) 8833380159140679301)
listsub


(c!:install 'fs!:make!-nullangle '(fs!:make!-nullangle) 
12989559702858593445)
fs!:make!-nullangle


(c!:install 'groeb!=crita '(groeb!=crita groeb!=testa listminimize) 
8426495118868161396)
groeb!=crita


(c!:install 'split!-further '(split!-further number!-needed
work!-vector1 dwork1 work!-vector2 dwork2 copy!-vector gcd!-in!-vector
quotfail!-in!-vector) 9811635046772757884)
split!-further


(c!:install 'rl_transform '(rl_transform rl_transform!* apply) 
4830843859496009028)
rl_transform


(c!:install 'evalnumberp '(evalnumberp !*sq numbertag aeval) 
16980738746779213824)
evalnumberp


(c!:install 'rl_convertarg '(rl_convertarg rl_conversionfunction apply) 
16762408709431988432)
rl_convertarg


(c!:install 'mconv1 '(mconv1 drnconv nreverse) 4365271436971912269)
mconv1


(c!:install 'setrd '(setrd atts (type) set retattributes stats_getargs) 
12239785899950230790)
setrd


(c!:install 'exdff0 '(exdff0 multsqpf exdfp0 multpfsq addpf) 
13966361513958058173)
exdff0


(c!:install 'r2findindex1 '(r2findindex1 "index not found" rederr) 
89207632565066563)
r2findindex1


(c!:install 'chkint!* '(chkint!* !*!*roundbf !:rd!: !!maxbflexp fl2bf
read!:num normbf msd rndbfon) 15655245400453327677)
chkint!*


(c!:install 'innprodpex '(innprodpex innprodp2 negf) 1676869073879482307
)
innprodpex


(c!:install 'rootextractf '(rootextractf sqrt expt quotient multd
simpexpt multf addf to) 13444072459892712479)
rootextractf



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u36.lsp"

Reading "$reduce/cslbuild/generated-c/u37.lsp"

% u37.lsp           Machine generated Lisp

(c!:install "u37" 151279 6388377 1372549)
nil


(c!:install 'lessppair '(lessppair) 2231640877476236480)
lessppair


(c!:install 'lalr_print_first_information '(lalr_print_first_information
"=== FIRST sets for each nonterminal ===" nonterminals ":" lalr_first
" " lalr_prin_symbol) 4398663868268776971)
lalr_print_first_information


(c!:install 'smt_prin2x '(smt_prin2x outl!*) 8183548821376389510)
smt_prin2x


(c!:install 'ofsf_simplequal '(ofsf_simplequal stsq false !*rlsitsqspl
!*rlsiexpla !*rlsiexpl and tsq ofsf_posdefp sfto_sqfpartf
ofsf_tsqsplequal ofsf_facequal!*) 11100723496419915682)
ofsf_simplequal


(c!:install 'pasf_exprng!-gand '(pasf_exprng!-gand and true false
pasf_exprng) 2135285197525282512)
pasf_exprng!-gand


(c!:install 'bvarom '(bvarom bvar objectom) 200324488163534067)
bvarom


(c!:install 's!-nextarg '(s!-nextarg !*udebug comb i upb (null!-fn)
acontract op mcontract null!-fn expand identity uprint initcomb getcomb
mval) 937573037739323696)
s!-nextarg


(c!:install 'wedgef '(wedgef hodge dimex!* d noxpnd lftshft!* dim!<deg
deg!*form deg!*farg mkuniquewedge1 hodgepf mkunarywedge wedgepf2 negf
addf multf mksgnsq multpfsq mkwedge smemqlp dwedge exdfk negsq addpf) 
2346008126061763515)
wedgef


(c!:install 'apply_e '(apply_e
"randpoly expons function must return an integer" apply rederr) 
11501076928014919792)
apply_e


(c!:install 'diff_vertex '(diff_vertex !_0edge nreverse) 
13748214954855354062)
diff_vertex


(c!:install 'assert_kernelp '(assert_kernelp exlist!*) 
15597765434816421582)
assert_kernelp


(c!:install 'evalgreaterp '(evalgreaterp difference "number" simp!*
minusf negsq mk!*sq typerr !:minusp) 12669567216885518850)
evalgreaterp


(c!:install 'solvealgdepends '(solvealgdepends root_of) 
4136039985782752003)
solvealgdepends


(c!:install 'make!-image '(make!-image m!-image!-variable
evaluate!-in!-order !*n2f) 4739506351694943003)
make!-image


(c!:install 'giplus!: '(giplus!: mkgi) 12497355129620666169)
giplus!:


(c!:install 'ext_mult '(ext_mult ext merge_lists !*a2k to) 
9547799705883413000)
ext_mult


(c!:install 'gcd!-with!-number '(gcd!-with!-number dmode!* gcddd) 
6716578182061466631)
gcd!-with!-number


(c!:install 'aex_sgn '(aex_sgn !*rlanuexsgnopt !*rlverbose
!*rlanuexverbose "[aex_sgn:num!]" aex_simpleratp aex_ex rat_sgn
aex_containment rat_0 iv_lb rat_less iv_rb aex_mvar aex_ctx ctx_get
aex_unbind aex_reduce aex_mklcnt aex_deg anu_dp aex_diff aex_mult
aex_sturmchain anu_iv aex_stchsgnch1) 8206311508880259828)
aex_sgn


(c!:install 'containerom '(containerom name "<OMA>" vectorml vector
valid_om!* set multiset multiset1 "vector" "<OMS cd=""" """ name="""
"""/>" "</OMA>" printout indent!* multiom) 13983074625164896069)
containerom


(c!:install 'mkexdf '(mkexdf d opmtch partitop mkupf) 
4388880663920067806)
mkexdf


(c!:install 'z!-roads '(z!-roads) 9627785030673955102)
z!-roads


(c!:install 'msolve!-psys1 '(msolve!-psys1 subf moduntag
general!-reduce!-mod!-p msolve!-poly) 5325365900206753023)
msolve!-psys1


(c!:install 'ratlessp '(ratlessp ratdif) 885470824671184428)
ratlessp


(c!:install 'lastcar '(lastcar) 9426693423145988947)
lastcar


(c!:install 'aex_divposcnt '(aex_divposcnt aex_ex sfto_ucontentf quotfx
kernels aex_ctx ctx_filter aex_mk aex_sgn aex_neg) 16751357098986179580)
aex_divposcnt


(c!:install 'settcollectnonmultiprolongations '(
settcollectnonmultiprolongations fluidbibasissett
fluidbibasissinglevariablemonomialss monomgetfirstmultivar
tripleisprolongedby polynommultiplybymonom triplesetprolongedby
createtriplewithancestor triplesetprolongset sortedtriplelistinsert) 
11180923753170602520)
settcollectnonmultiprolongations


(c!:install 'processpartitie1list1 '(processpartitie1list1
processpartitie1) 8905402871218447299)
processpartitie1list1


(c!:install 'mk!+outer!+list '(mk!+outer!+list list) 1120975289848745138
)
mk!+outer!+list


(c!:install 'repr_ldeg '(repr_ldeg) 15289004046501352154)
repr_ldeg


(c!:install 'dip_f2dip2 '(dip_f2dip2 dip_vars!* ev_insert dip_f2dip1
bc_pmon bc_prod) 16425107332824954865)
dip_f2dip2


(c!:install 'setfuncsnaryrd '(setfuncsnaryrd multiset mmlatts mathml) 
11760292879859386480)
setfuncsnaryrd


(c!:install 'sqprint '(sqprint !*prin!# orig!* !*nat posn!* !*pri wtl!*
" / " sqhorner!* prepsq!* prepreform maprin xprinf prin2!* xprinf2) 
181925929491622368)
sqprint


(c!:install 'red_tailreddriver '(red_tailreddriver bas_dpoly red!=hidelt
red!=recover) 11140311213774555509)
red_tailreddriver


(c!:install 'getavalue '(getavalue) 9120817111259796697)
getavalue


(c!:install 'reduce!-eival!-powers '(reduce!-eival!-powers
reduce!-eival!-powers1) 17145472828341619245)
reduce!-eival!-powers


(c!:install 'find!-null!-space '(find!-null!-space null!-space!-basis
clear!-column tidy!-up!-null!-vectors) 3931527872299889541)
find!-null!-space


(c!:install 'set_parser '(set_parser parser_action_table reduction_fn
reduction_rhs_n reduction_lhs parser_goto_table nonterminal_codes
terminal_codes lex_restore_context) 1610539588129598405)
set_parser


(c!:install 'sq_member '(sq_member sf_member) 383677299105792360)
sq_member


(c!:install 'orddf '(orddf "Orddf = case" "Orddf v longer than u"
"Orddf u longer than v" interr exptcompare) 10175549868695206343)
orddf


(c!:install 'cl_susiupdknowl '(cl_susiupdknowl false break
cl_susiupdknowl1) 5680824578260435233)
cl_susiupdknowl


(c!:install 'gftimes '(gftimes gfftimes gbftimes) 5154146903667630288)
gftimes


(c!:install 'calc_den_tar '(calc_den_tar denlist constimes) 
2091616914098872757)
calc_den_tar


(c!:install 'no!-side!-effectp '(no!-side!-effectp quote nosideeffects
no!-side!-effect!-listp) 8966344571412724319)
no!-side!-effectp


(c!:install 'atom_compare '(atom_compare) 14638703734338634116)
atom_compare


(c!:install 'lalr_expand_grammar '(lalr_expand_grammar pending_rules!*
lalr_check_grammar expand_rule) 3272494871112121132)
lalr_expand_grammar


(c!:install 'aex_stchsgnch1 '(aex_stchsgnch1 aex_subrat1 aex_sgn
lto_sgnchg) 14323618828463299304)
aex_stchsgnch1


(c!:install 'janettreenodebuild '(janettreenodebuild
monomgetvariabledegree setcdr) 2912401590804738272)
janettreenodebuild


(c!:install 'even_action_term '(even_action_term multf even_action_pow
even_action_sf addsq) 3380478610553922700)
even_action_term


(c!:install 'testord '(testord) 2601262472684569069)
testord


(c!:install 'my!+nullsq!+p '(my!+nullsq!+p) 13231798978309316526)
my!+nullsq!+p


(c!:install 'pasf_varlat '(pasf_varlat (cong ncong) !*rlbrkcxk kernels
lto_lpvarl lastpair) 495821386021008051)
pasf_varlat


(c!:install 'rl_surep '(rl_surep rl_surep!* apply) 1119419072422884408)
rl_surep


(c!:install 'minusrd '(minusrd mathml lex) 8109520012474094012)
minusrd


(c!:install 'assoc2 '(assoc2) 15546565872355360023)
assoc2


(c!:install 'rewrite '(rewrite findrow letmtr3) 16768568789508608917)
rewrite


(c!:install 'ndepends '(ndepends frlis!* depl!* domain!-depends!-fn
lndepends atomf) 4110452451038505699)
ndepends



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u37.lsp"

Reading "$reduce/cslbuild/generated-c/u38.lsp"

% u38.lsp           Machine generated Lisp

(c!:install "u38" 46748 6457982 2322238)
nil


(c!:install 'weak_xreduce1 '(weak_xreduce1 !*trxmod "   " first wedge
" +" last xval xdiv mknwedge wedgepf quotsq negsq multpfsq addpf subs2pf
writepri preppf) 10067255446068332118)
weak_xreduce1


(c!:install 'intrdsortin '(intrdsortin nreverse !:difference !:minusp) 
12946241828873678541)
intrdsortin


(c!:install 'all_defined_vertex '(all_defined_vertex al1_defined_vertex)
 7230922704161179724)
all_defined_vertex


(c!:install 'listeval0 '(listeval0 simpcount!* simplimit!* rlisp
"Simplification recursion too deep" array rerror eval getrtype getelv) 
16941628648368689335)
listeval0


(c!:install 'num_signsort '(num_signsort lambda_ygm6np4pcqv31
ad_signsort) 9981247964616828867)
num_signsort


(c!:install 'lambda_ygm6np4pcqv31 '(lambda_ygm6np4pcqv31) 
15088082726560262194)
lambda_ygm6np4pcqv31


(c!:install 'lpos '(lpos) 392504631650382707)
lpos


(c!:install 'makeqn!-maybe '(makeqn!-maybe equal) 10780296787096721220)
makeqn!-maybe


(c!:install 'lalr_lr0_initial_itemset '(lalr_lr0_initial_itemset !S!' !.
lalr_productions lalr_lr0_closure) 4845558967770285634)
lalr_lr0_initial_itemset


(c!:install 'aex_mklcnt '(aex_mklcnt aex_simpleratp aex_ctx ctx_idl
aex_fvarl aex_lc aex_nullp aex_red aex_sgn aex_0) 8386333306630211088)
aex_mklcnt


(c!:install 'multerm '(multerm !*multsq mulpower multdfconst) 
12104691084579091829)
multerm


(c!:install 'mri_opn '(mri_opn mri_op) 2036384330803727972)
mri_opn


(c!:install 'dip_sum '(dip_sum dip_evlmon ev_comp iequal dip_lbc
dip_moncomp dip_mred bc_sum setcdr) 3983088786451406200)
dip_sum


(c!:install 'ofsf_factsf '(ofsf_factsf negf addf multf) 
4753044934003228333)
ofsf_factsf


(c!:install 'determinantrd '(determinantrd mathml lex) 
13299823222255331775)
determinantrd


(c!:install 'greatertype '(greatertype optlang!* fortran conversion eval
typerror) 14283713471881068885)
greatertype


(c!:install 'mkupf '(mkupf mksq sfp partitsq!*) 350955710441535672)
mkupf


(c!:install '!:!:quotient '(!:!:quotient i2rd!* !:quotient) 
15132540149930532904)
!:!:quotient


(c!:install 'calc_coeffmap_ '(calc_coeffmap_ times calc_map_ calc_coeff)
 3656005963211299502)
calc_coeffmap_


(c!:install 'lalr_make_compressed_goto_table '(
lalr_make_compressed_goto_table nonterminals !S!' lalr_nonterminal_code
!*lalr_verbose lalr_make_compressed_goto_column
lalr_print_compressed_goto_table) 16494174393177441415)
lalr_make_compressed_goto_table


(c!:install 'setqinsertlist '(setqinsertlist fluidbibasissetq
monomcompare) 7255240212151745159)
setqinsertlist


(c!:install 'cl_bvarl '(cl_bvarl ordp cl_bvarl1 sort) 208407522678842217
)
cl_bvarl


(c!:install 'pasf_smwupdknowl '(pasf_smwupdknowl !*rlsusi
cl_susiupdknowl cl_smupdknowl) 14896785202626796851)
pasf_smwupdknowl


(c!:install 'omattrir '(omattrir (!/ o m a t t r) csymbol cn ci lex
omatpir omobj checktag) 15199935747480460102)
omattrir


(c!:install 'sptransmat '(sptransmat spm matlength aeval mkempspmat
letmtr3) 11078188207137486602)
sptransmat


(c!:install 'vdpcleanup '(vdpcleanup dipevlist!*) 9726310706373385971)
vdpcleanup


(c!:install 'contposp '(contposp) 8182456738789676309)
contposp


(c!:install 'toolongassignp '(toolongassignp toolongexpp) 
4118697004373164395)
toolongassignp


(c!:install 'simppartdf '(simppartdf partitpartdf !*pf2sq) 
18226010435382712502)
simppartdf


(c!:install 's_world_names '(s_world_names) 15003719730143642310)
s_world_names


(c!:install 'dp_from_ei '(dp_from_ei cali_bc_fi mo_from_ei dp_term) 
1551402700809790358)
dp_from_ei


(c!:install 'createmonomunit '(createmonomunit) 15320518510719391198)
createmonomunit


(c!:install 'pickbasicset '(pickbasicset wuvarlist!* symbollessp
wureducedpolysp) 11600875189995843870)
pickbasicset


(c!:install 'mri_ofsf2mriat '(mri_ofsf2mriat mri_0mk2) 
16306935581848189185)
mri_ofsf2mriat


(c!:install 'intervalom '(intervalom name lowupperlimit integer_interval
valid_om!* interval!* "<OMA>" "<OMS cd=""" """ name=""" """/>" "</OMA>"
printout indent!* multiom) 17922406443138092447)
intervalom


(c!:install 'remzzzz '(remzzzz nreverse) 12941972615663851898)
remzzzz


(c!:install 'sc_rowscalarproduct '(sc_rowscalarproduct sc_simp
fast!-column!-dim sc_getmat sc_multsq sc_addsq) 12509885332419258561)
sc_rowscalarproduct


(c!:install 'simpunion '(simpunion union empty_set applysetop ordn mksp)
 10879639108873967154)
simpunion


(c!:install 'gbfplus '(gbfplus plubf) 12825317034124909812)
gbfplus


(c!:install 'indxsymp '(indxsymp) 15395267106291607297)
indxsymp


(c!:install 'getphystypeexpt '(getphystypeexpt scalar getphystypecar) 
2421237881282221574)
getphystypeexpt


(c!:install 'fs!:minusp '(fs!:minusp minusf) 16879958195719117773)
fs!:minusp


(c!:install 'squashsqrt '(squashsqrt sqrtflag sqrt expt !*multfsqrt addf
prefix!-rational!-numberp !*multfexpt) 11918770788985965987)
squashsqrt


(c!:install 'ofsf_decdeg2 '(ofsf_decdeg2 !*gcd !*rlbrkcxk odd
ofsf_cxkdgcd cl_atl1 ofsf_ignshift sfto_reorder gcdf quotf) 
11775432427567021001)
ofsf_decdeg2


(c!:install 'mk!+scal!+mult!+mat '(mk!+scal!+mult!+mat
"no matrix in add" !*sub2 matrix!+p rederr multsq subs2) 
8701325537221077134)
mk!+scal!+mult!+mat


(c!:install 'cl_susiupdknowl2 '(cl_susiupdknowl2 false rl_susibin
cl_susiinter) 14100854535063077308)
cl_susiupdknowl2


(c!:install 'gcdld '(gcdld gcd!-with!-number) 1316750812650340790)
gcdld


(c!:install 'matrixelems '(matrixelems nreverse) 6488175335555744394)
matrixelems


(c!:install 'f2dip1 '(f2dip1 f2dip11 bcfd bcprod f2dip2 dipsum) 
14214282398288548756)
f2dip1


(c!:install 'add_item '(add_item !*xset!* setcar setcdr monordp) 
5074126693414448741)
add_item


(c!:install 'bflessp '(bflessp grpbf) 6727009590002545733)
bflessp


(c!:install 'spp '(spp kernelp) 2104866104876182072)
spp


(c!:install 's_noparents '(s_noparents nreverse has_parents) 
15571569376697139997)
s_noparents


(c!:install 'xremf '(xremf qremd termsf addf qremf multf to negf ordop) 
10707079095879704584)
xremf


(c!:install 'vector!-to!-poly '(vector!-to!-poly !*n2f to) 
12971166603679893390)
vector!-to!-poly



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u38.lsp"

Reading "$reduce/cslbuild/generated-c/u39.lsp"

% u39.lsp           Machine generated Lisp

(c!:install "u39" 152894 4012351 3584107)
nil


(c!:install 'lex_keywords '(lex_keywords
"Empty string passed to lex_keywords" lex_code lex_keyword_names
lex_next_code lex_codename !*tracelex "Token '" "' allocated code "
"dipthong data '" "' plus '" "' => '" "'" lex_dipthong widestring2list
rederr list2widestring lastcar) 5650203126095189328)
lex_keywords


(c!:install 'cl_atnum '(cl_atnum or and not impl repl equiv ex all bex
ball true false rl_external apply) 16613845702167105898)
cl_atnum


(c!:install 'cl_pnf1 '(cl_pnf1 cl_rename!-vars cl_pnf2 cl_qb) 
598750603176606671)
cl_pnf1


(c!:install 'fnom '(fnom "<OMA>" "<OMATTR>" "<OMATP>"
"<OMS cd=""typmml"" name=""type""/>" "<OMS cd=""typmml"" name="""
"fn_type" """/>" "</OMATP>" "</OMATTR>" "</OMA>" printout indent!*
objectom multiom) 11254068639714551012)
fnom


(c!:install 'plusrd '(plusrd mathml alg_plus) 353584120376949198)
plusrd


(c!:install 'simpimpart '(simpimpart !*factor simp!* impartsq) 
1318661892495599752)
simpimpart


(c!:install 'genexp '(genexp genp) 8146647324349884369)
genexp


(c!:install 'exdfprn '(exdfprn "d" prin2!* rembras) 5596773582070494333)
exdfprn


(c!:install 'aceq '(aceq) 12405514265448346600)
aceq


(c!:install 'log_freevars '(log_freevars constant!?
"+++ Use of free variable in smacro/inline body: " "+++ Macro was: "
inlineinfo quote function go prog lambda cond log_freevars_list
log_freevars_list_list) 17921410601274168701)
log_freevars


(c!:install 'bas_make '(bas_make dp_ecart) 11969008909803901740)
bas_make


(c!:install 'pst_subpst '(pst_subpst) 468417355526156341)
pst_subpst


(c!:install 'appn '(appn) 10856915010899932549)
appn


(c!:install 'multivariatep '(multivariatep) 6455206724317581613)
multivariatep


(c!:install 'lalr_augment_grammar '(lalr_augment_grammar !S!') 
6209230831193506242)
lalr_augment_grammar


(c!:install 'createsinglevariablemonom '(createsinglevariablemonom) 
8112136363574510503)
createsinglevariablemonom


(c!:install 'my_freeof '(my_freeof depl!* smember freeofdepl) 
17062619644645782754)
my_freeof


(c!:install 'giintgcd '(giintgcd !:gi!:) 13740428451164188103)
giintgcd


(c!:install 'talp_nextt1 '(talp_nextt1 talp_nextt!-atom talp_invp
talp_fargl setcdr setcar talp_get!-idx talp_get!-minfct) 
18100725233100552879)
talp_nextt1


(c!:install 'rl_onp '(rl_onp !* eval) 12324384732156656671)
rl_onp


(c!:install 'vectorrd '(vectorrd atts (type other) vectorml
retattributes matrixrowrd) 6733517731623441737)
vectorrd


(c!:install 'ldf!-simp '(ldf!-simp to prepf simp comfac quotf absf) 
15588029444650465051)
ldf!-simp


(c!:install 'transmat1 '(transmat1 spm avalue sparse rtype aeval
matlength mkempspmat letmtr3) 13407070583228247971)
transmat1


(c!:install 'on!-double1 '(on!-double1 !*double doublep) 
13186537529071107945)
on!-double1


(c!:install 'getupper '(getupper metricu!*) 15186515998889084419)
getupper


(c!:install 'replace2_parents '(replace2_parents) 14609136266563362727)
replace2_parents


(c!:install 'prepsq!*1 '(prepsq!*1 factors!* expt kord!* dnl!* !*allfac
upl!* !*div minus quotient prepsq!*0 to quotfm mksp nconc!* kernlp mkkl
ckrn ckrn!* quotof canonsq prepf addfactors rmplus exchk prepsq aconc!*
retimes) 8623262739272361502)
prepsq!*1


(c!:install 'reduce '(reduce !*yyy !*xxx reduce!-ratios set!-weights
reduce!-columns reduce!-weights) 9150259719354933981)
reduce


(c!:install 'fs!:minusp!: '(fs!:minusp!: fs!:minusp) 
12591440367648243122)
fs!:minusp!:


(c!:install 'xnsiz '(xnsiz !!log2of10 xnsiz1 ceiling) 
5834800755168866135)
xnsiz


(c!:install 'lalr_collect_nonterminals '(lalr_collect_nonterminals
lalr_remove_duplicates) 3662969860216128040)
lalr_collect_nonterminals


(c!:install 'simpexpt2 '(simpexpt2 expt !*precise_complex !*precise abs
sqrt !*keepsqrts times !*modular quotient !*mcd minus dmode!* frlis!*
simp multsq simpexpt1 split!-sign retimes posnump prepsq simp!* simpexpt
quotsq prepf simpx1 mksq) 15655962808424643348)
simpexpt2


(c!:install 'pasf_uprap '(pasf_uprap pasf_uprap1) 3232069444272176219)
pasf_uprap


(c!:install 'lowupperlimitrd '(lowupperlimitrd char (!/ l o w l i m i t)
"</lowlimit>" lowupperlimit mathml lex upperlimitrd errorml) 
17356792950860261456)
lowupperlimitrd


(c!:install 'spcol_dim '(spcol_dim !*fast_la
"Error in spcol_dim: input should be a matrix." matrixp rederr
spmatlength) 1864137754474694627)
spcol_dim


(c!:install 'inszzz '(inszzz nreverse dm!-plus zeropp) 
17252360909060105119)
inszzz


(c!:install 'qsum!-simpexpt1 '(qsum!-simpexpt1 minus (minus 1)
inside!-qsum!-simpexpt!* basic!-simpexpt multsq) 153397332093767487)
qsum!-simpexpt1


(c!:install 'simp_without_resimp '(simp_without_resimp !*resimp simp) 
8992338469488600133)
simp_without_resimp


(c!:install 'groebinvokecritm '(groebinvokecritm mcount!*
buchvevdivides!? groedeletip) 590440005261952739)
groebinvokecritm


(c!:install 'sc_columnscalarproduct '(sc_columnscalarproduct sc_simp
fast!-row!-dim sc_getmat sc_multsq sc_addsq) 14476979503128174459)
sc_columnscalarproduct


(c!:install 'mkbc '(mkbc !*grmod!* (1 . 1) f2dip11 bcfi minusf negf gcdf
quotfx) 188726536352607870)
mkbc


(c!:install 'applysetop '(applysetop list setvalued "set" setdiff reval
delete!-dups make!-set typerr aeval) 9669029901271027468)
applysetop


(c!:install 'mod!-dump1 '(mod!-dump1 nreverse l!-subst) 
5509476665427990407)
mod!-dump1


(c!:install 'quotodd '(quotodd mkrn int!-equiv!-chk lowest!-terms) 
680472806820485415)
quotodd



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u39.lsp"

Reading "$reduce/cslbuild/generated-c/u40.lsp"

% u40.lsp           Machine generated Lisp

(c!:install "u40" 135533 5952200 101974)
nil


(c!:install 'lengthreval '(lengthreval alg
"LENGTH called with wrong number of arguments" list dimension lengthfn
sparse "LENGTH not defined for argument of type" "LENGTH argument"
rerror arrayp aeval getrtype lprie typerr) 7036667717362130412)
lengthreval


(c!:install 'ra_intequiv '(ra_intequiv ra_intequiv0 ra_wrapper) 
4966337950892696655)
ra_intequiv


(c!:install 'component_action '(component_action ext_mult multsq addsq) 
7495819328308817992)
component_action


(c!:install 'fctargs '(fctargs depl!*) 7492744808037637563)
fctargs


(c!:install 'rl_mk!*fof '(rl_mk!*fof rl_csimpl rl_mk!*fof1) 
4409157602058082763)
rl_mk!*fof


(c!:install 'rl_bnfsimpl '(rl_bnfsimpl rl_bnfsimpl!* apply) 
12102889295070448289)
rl_bnfsimpl


(c!:install 'repr_n '(repr_n "repr_n : invalid REPR structure" rederr) 
9234101115622280862)
repr_n


(c!:install 'matrixrd '(matrixrd atts (type) char (m a t r i x r o w) (
!/ m a t r i x r o w) "</matrixrow>" matrix matrixrow retattributes lex
matrixrowrd errorml) 13063924941624522107)
matrixrd


(c!:install 'fnreval '(fnreval nreverse reval1) 14280642333297093583)
fnreval


(c!:install 'evweightedcomp1 '(evweightedcomp1 evweightedcomp2) 
1864450719058990833)
evweightedcomp1


(c!:install 'pa_list2vect '(pa_list2vect min eval) 5451357368922459589)
pa_list2vect


(c!:install 'fd2q '(fd2q !:ar!: !:rn!: multsq addsq) 7324173800691249502
)
fd2q


(c!:install 'outer!-simpsqrt '(outer!-simpsqrt !*inside!-int!*
proper!-simpsqrt simpsqrt) 18058139613902210605)
outer!-simpsqrt


(c!:install 'oddext '(oddext odd_var all_parametric_odd!* ext
all_principal_odd!* n_all_parametric_ext
"the argument of oddext must be an odd variable" cde_position rederr) 
2547200403774432413)
oddext


(c!:install 'polynomread '(polynomread fluidbibasisvariables
fluidbibasissinglevariablemonomialsa createmonomunit
polynommultiplybymonom polynomadd) 2488681923758697205)
polynomread


(c!:install 'expf '(expf frlis!* expt mkrn !:expt mksp!* fkern to sfp
exptf multf) 4757765179415139813)
expf


(c!:install 'mri_2ofsfat '(mri_2ofsfat mri_op mri_arg2l) 
9666639455723432082)
mri_2ofsfat


(c!:install 'quotfx1 '(quotfx1 quotfxerr quotfdx lt!* rnconc to cutf
multf negf addf aconc!* ordop quotkx) 9940331203536447535)
quotfx1


(c!:install 'rl_multsurep '(rl_multsurep rl_multsurep!* apply) 
3445218919925543971)
rl_multsurep


(c!:install 'upperlimitrd '(upperlimitrd char (u p l i m i t)
"<uplimit>" (!/ u p l i m i t) "</uplimit>" lex errorml mathml) 
2308004473999083423)
upperlimitrd


(c!:install 'compl '(compl nreverse) 9091191792981206695)
compl


(c!:install 'suspend '(suspend op r p amatch) 17827214845217231143)
suspend


(c!:install 'vdpequal '(vdpequal number vdpgetprop dipequal) 
17003390932381677455)
vdpequal


(c!:install 'evinsert '(evinsert nreverse) 9473338652992442538)
evinsert


(c!:install 'simpwedge '(simpwedge partitwedge !*pf2sq) 
8774782948149901481)
simpwedge


(c!:install 'divide!-by!-power!-of!-ten '(divide!-by!-power!-of!-ten
bften!* !:bprec!: bflerrmsg divide!: normbf lshift times!: cut!:mt) 
11769155870995793676)
divide!-by!-power!-of!-ten


(c!:install 'cvitimes2 '(cvitimes2 times) 1452841355575771990)
cvitimes2


(c!:install 'ratnump '(ratnump !:rn!: simp!*) 12588082219399414369)
ratnump


(c!:install 'miller!-rabin '(miller!-rabin set!-modulus) 
14156322706059773842)
miller!-rabin


(c!:install 'dfp!-sub '(dfp!-sub generic_function list dfp listsub reval
pair dfp!-sub1) 7670772426438171903)
dfp!-sub


(c!:install 'redall '(redall gg!* shortway!* thirdway!* gv!* path
" ==> " " --> " conds!* bv!* ljet nf ord dd insert) 862425875582441527)
redall


(c!:install 'get!-current!-representation '(get!-current!-representation
currep) 5098454424683034082)
get!-current!-representation


(c!:install 'prepsq!*0 '(prepsq!*0 gcdf quotf!-fail prepsq!*1) 
1045838241206605395)
prepsq!*0


(c!:install 'isimp1 '(isimp1 !*cvit calc_spurx spur0 multd index_simp
emult multf isimp2 addf) 16874276077515923660)
isimp1


(c!:install 'rl_qefsolset '(rl_qefsolset rl_qefsolset!* apply) 
18185265947675789221)
rl_qefsolset


(c!:install 'intervalrd '(intervalrd atts (closure) char (!/ i n t e r v
a l) interval "</interval>" retattributes mathml lex errorml) 
5723057958792845697)
intervalrd


(c!:install 'prlist '(prlist nreverse) 9664766906394956166)
prlist


(c!:install 'letmtr '(letmtr mat matrix "Matrix" "not set" hold rerror
revlis numlis errpri2 nth pnth) 508084208141511444)
letmtr


(c!:install 'a2bc '(a2bc !*grmod!* " Invalid coefficient " rederr bcfd
simp!*) 15749005389575975235)
a2bc


(c!:install 'gfplus '(gfplus gffplus gbfplus) 12495226635554652173)
gfplus


(c!:install 'numprintlen '(numprintlen !:rd!: (!:cr!: !:crn!: !:gi!:)
plus rd!:explode lispeval) 5981142656198358253)
numprintlen


(c!:install 'mk_binding '(mk_binding can_be_proved edge_bind) 
11011753991814478595)
mk_binding


(c!:install 'equiv!-coeffs '(equiv!-coeffs nzeros nreverse mv!-pow!-!>) 
8249380351838145758)
equiv!-coeffs


(c!:install 'taylorp '(taylorp taylor) 18210632415241541829)
taylorp


(c!:install 'lesspcar '(lesspcar) 10263904006278182342)
lesspcar


(c!:install 'rl_qe '(rl_qe rl_qe!* apply) 17320963409233102897)
rl_qe


(c!:install 'cl_apply2ats1 '(cl_apply2ats1 true false ex all bex ball or
and not impl repl equiv apply) 5930425794114745903)
cl_apply2ats1


(c!:install 'maxfrom '(maxfrom maxfrom1) 13525207612058789982)
maxfrom


(c!:install 'mk!+mat!+plus!+mat '(mk!+mat!+plus!+mat "no matrix in add"
"wrong dimensions in add" !*sub2 matrix!+p rederr get!+col!+nr
get!+row!+nr get!+mat!+entry addsq subs2) 13087818988067160932)
mk!+mat!+plus!+mat


(c!:install 'ezgcd!-comfac '(ezgcd!-comfac poly!-abs gcdlist) 
14275248721658190430)
ezgcd!-comfac


(c!:install 'transposerd '(transposerd mathml lex) 14810617089545403103)
transposerd



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u40.lsp"

Reading "$reduce/cslbuild/generated-c/u41.lsp"

% u41.lsp           Machine generated Lisp

(c!:install "u41" 117463 7222334 47046)
nil


(c!:install 'extbrsea '(extbrsea rowmin rowmax codmat maxvar times
initbrsea extbrsea1 expandprod shrinkprod) 18359082246896174113)
extbrsea


(c!:install 'copy_mat '(copy_mat matrix_input_test size_of_matrix
mkmatrix getmat setmat) 16348247403971186796)
copy_mat


(c!:install 'exdf0 '(exdf0 exdff0 negf multpfsq addpf) 
9904970085747053740)
exdf0


(c!:install 'multiply!-by!-power!-of!-ten '(multiply!-by!-power!-of!-ten
bften!* !:bprec!: bflerrmsg times!: normbf lshift cut!:mt) 
18394915745764875788)
multiply!-by!-power!-of!-ten


(c!:install 'formsetq0 '(formsetq0 quote symbolic !*savedef inline
smacro "+++ Assign via inline or smacro: " "assignment" setel vector
vecfn part list setpart!* setqfn !*rlisp88 structfetch rsetf setk
algebraic reserved setv convertmode typerr macrochk arrayp intargfn
putvect formlis aconc applsmacro form1 rsverr symbid mksetshare mksetq) 
3471389308416153098)
formsetq0


(c!:install 'simp!-prop!-dist '(simp!-prop!-dist plus times
lambda_iff2c8okfzyq1 simp!-prop!-order sort) 12624899860164811202)
simp!-prop!-dist


(c!:install 'lambda_iff2c8okfzyq1 '(lambda_iff2c8okfzyq1 ordp) 
2988551691672434219)
lambda_iff2c8okfzyq1


(c!:install 'lambda_iff2c8okfzyq1 '(lambda_iff2c8okfzyq1 ordp) 
2988551691672434219)
lambda_iff2c8okfzyq1


(c!:install 'list2vect!* '(list2vect!* algebraic nth symb_to_alg) 
6362396843862643552)
list2vect!*


(c!:install 'which_first '(which_first) 5362535682633495787)
which_first


(c!:install 'talp_trygaussvar '(talp_trygaussvar and or failed talp_atfp
talp_qesolset talp_gaussand talp_gaussor) 14921329553473086716)
talp_trygaussvar


(c!:install 'cl_gand!-col '(cl_gand!-col true and !*rlsichk cl_cflip
cl_flip cl_simpl1) 6160713033187959660)
cl_gand!-col


(c!:install 'pasf_susibinad '(pasf_susibinad false true (delete . t)
equal cl_susiminlevel pasf_susibineq pasf_dec pasf_susibinord kernels
negf pasf_subfof1 pasf_susibinad1) 13184230421889198236)
pasf_susibinad


(c!:install 'ctx_get '(ctx_get ctx_ial) 10695835100804838133)
ctx_get


(c!:install 'symbolsrd '(symbolsrd char (b v a r) "" "<bvar>" (l o w l i
m i t) (i n t e r v a l) (c o n d i t i o n) lex bvarrd errorml
lowupperlimitrd intervalrd conditionrd mathml2) 4467914345170814651)
symbolsrd


(c!:install 'findelem2 '(findelem2 sparsemat) 3441519714088510835)
findelem2


(c!:install 'init '(init fluidbibasisvariables
fluidbibasisreversedvariables fluidbibasissinglevariablemonomialss
fluidbibasissinglevariablemonomialsa fluidbibasissetq
fluidbibasisreductionsmade fluidbibasisnormalforms
fluidbibasisnonzeronormalforms initmonomials settreset) 
3772679028213484507)
init


(c!:install 'size_of_matrix '(size_of_matrix matrix_input_test) 
10923826081544999356)
size_of_matrix


(c!:install 'fl2bf '(fl2bf "Floating point infinity or NaN" !!nbfpd
!:rd!: fp!-finite rederr frexp normbf) 1498310614408507700)
fl2bf


(c!:install 'list!-evaluate '(list!-evaluate evaluate) 
16287211716014147173)
list!-evaluate


(c!:install 'consrecip '(consrecip recip) 706964435408471715)
consrecip


(c!:install 'splitup '(splitup) 2771208093256628215)
splitup


(c!:install 'simpquot '(simpquot alg "0/0 formed" "Zero divisor" dmode!*
(!:rd!: !:cr!:) !*modular simpcar simp rerror !:onep divd simprecip
multsq) 3293748250358531092)
simpquot


(c!:install 'mchsarg '(mchsarg times mtp noncomfree noncomperm pair
mcharg2 lastpair reversip!*) 15121871990663945559)
mchsarg


(c!:install 'algmodep '(algmodep (aeval aeval!*)) 17401596320637496471)
algmodep


(c!:install 'xnp '(xnp) 3670401420781418878)
xnp


(c!:install 'lalr_set_nonterminal_codes '(lalr_set_nonterminal_codes
nonterminals !S!' lalr_nonterminal_code !*lalr_verbose nonterminal_codes
) 4786341589204017049)
lalr_set_nonterminal_codes


(c!:install 'talp_invtscc '(talp_invtscc talp_arg2l talp_arg2r
talp_noffcts talp_invp talp_td talp_invarg) 13303176109906050936)
talp_invtscc


(c!:install 'pasf_sacat '(pasf_sacat) 3607541727113827278)
pasf_sacat


(c!:install 'diffrd '(diffrd char (b v a r) lex bvarrd mathml2 diff2) 
11168113424929237913)
diffrd


(c!:install 'insertocc '(insertocc) 16473203438804115313)
insertocc


(c!:install 'xreadlist '(xreadlist !*rcbkt!* list group cursym!*
!*semicol!* "Syntax error: semicolon in list" !*comma!*
"Syntax error: invalid comma in list" scan xread1 aconc nconc2 symerr) 
8996391974605582747)
xreadlist


(c!:install 'incident1 '(incident1) 11612625159021577600)
incident1


(c!:install 'set!-weights '(set!-weights) 7860336305574161332)
set!-weights


(c!:install '!*g2lex '(!*g2lex psum) 12149569950736608275)
!*g2lex


(c!:install '!*n2a '(!*n2a !*q2a) 13658156341575576597)
!*n2a


(c!:install 'basic!-kern '(basic!-kern basic!-kern1 union) 
13055878441452632155)
basic!-kern


(c!:install 'noncomfree '(noncomfree) 14852152156915043048)
noncomfree


(c!:install 'gadd '(gadd a ndims!* hephys
"Gamma5 not allowed unless vecdim is 4" rerror) 17275387982430996422)
gadd


(c!:install 'mk!+equation '(mk!+equation equal) 3655977449687579310)
mk!+equation


(c!:install 'talp_invtscsimpl '(talp_invtscsimpl or and (ex all)
talp_rnf talp_atfp talp_invtscc talp_simpat talp_invtscsimplat talp_op
talp_argl) 8503326907152582869)
talp_invtscsimpl


(c!:install 'repr_new '(repr_new "repr_new : invalid coefficient list"
rederr) 15740683123080672425)
repr_new


(c!:install 'prsubsetrd '(prsubsetrd mathml) 2207896389365212214)
prsubsetrd



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u41.lsp"

Reading "$reduce/cslbuild/generated-c/u42.lsp"

% u42.lsp           Machine generated Lisp

(c!:install "u42" 63265 8278215 5229974)
nil


(c!:install 'findoptrow '(findoptrow codmat maxvar roccup1 newnjsi
newjsi roccup2 pnthxzz testpr) 13494316580563076789)
findoptrow


(c!:install 'diplmon2sq '(diplmon2sq dipvars!* dipev2f multsq) 
15227123221674441372)
diplmon2sq


(c!:install 'remove_least_item '(remove_least_item
"How did we get here?" rederr remove_root_item) 4979620738984819027)
remove_least_item


(c!:install 'listpri '(listpri !*lcbkt!* orig!* posn!* listpri_depth!*
!*comma!* !*rcbkt!* prin2!* treesizep negnumberchk maprint oprin
terpri!*) 16221603008393779124)
listpri


(c!:install 'r2speclist1 '(r2speclist1 times r2speclist2) 
13339648047941911489)
r2speclist1


(c!:install 'mkassign '(mkassign setq) 1784845354946001370)
mkassign


(c!:install 'ev!-edgeloop '(ev!-edgeloop ndim!* binc) 
10671481024158201592)
ev!-edgeloop


(c!:install 'primep27 '(primep27 set!-modulus miller!-rabin) 
9158665175866916215)
primep27


(c!:install 'nonmult '(nonmult vjets!* nth) 6527037553161993770)
nonmult


(c!:install 'xquotient!-mod!-p '(xquotient!-mod!-p exact!-quotient!-flag
quotient!-mod!-p times!-mod!-p difference!-mod!-p mksp negate!-term
times!-term!-mod!-p plus!-mod!-p) 2976120306900312689)
xquotient!-mod!-p


(c!:install 'mkcrn '(mkcrn !:crn!:) 3117764722230454000)
mkcrn


(c!:install 'extadd '(extadd addf setcdr ordexp) 1336103341634382315)
extadd


(c!:install 'read!-comment1 '(read!-comment1 !*lower !*raise
named!-character!* crchar!* !$eol!$ !  id2string string!-length delcp
readch1 condterpri) 3003596910571484168)
read!-comment1


(c!:install 'sfto_yun!-updecf '(sfto_yun!-updecf !*gcd diff sfto_gcdf
quotf negf addf multf setcar setcdr) 10250296188671186867)
sfto_yun!-updecf


(c!:install 'rl_identity1 '(rl_identity1) 491532843247411839)
rl_identity1


(c!:install 'pasf_anegateat '(pasf_anegateat true false (cong ncong)
pasf_anegrel pasf_mkop negf) 9996326776010047622)
pasf_anegateat


(c!:install 'bc_sum '(bc_sum addsq) 2470970195362364800)
bc_sum


(c!:install 'ciom '(ciom "<OMATTR>" "<OMATP>"
"<OMS cd=""typmml"" name=""type"">" "<OMS cd=""typmml"" name="""
mmltypes!* """>" "</OMATP>" "</OMATTR>" printout indent!* objectom) 
414213925339740331)
ciom


(c!:install 'f4 '(f4 pi "<pi/>" euler_gamma "<eulergamma/>" true
"<true/>" false "<false/>" !Na!N "<notanumber/>" infinity !*web
"<cn type=""constant"">" "<cn type=&quot;constant&quot;>" "&infin;"
"</cn>" e "&ExponentialE;" i "&ImaginaryI;" "<cn" " type=""real"">"
" type=&quot;real&quot;>" " type=""integer"">"
" type=&quot;integer&quot;>" ">" "<ci" " type=""list"">"
" type=&quot;list&quot;>" " type=""vector"">"
" type=&quot;vector&quot;>" "</ci>" printout listp) 13386084776726673023
)
f4


(c!:install 'evzero '(evzero dipvars!*) 16713074392839796302)
evzero


(c!:install 'chksymmetries!&sub1 '(chksymmetries!&sub1 indxsymp) 
10352781567040591900)
chksymmetries!&sub1


(c!:install 'strand!-alg!-top '(strand!-alg!-top deletez1 color!-strand
contract!-strand dstr!-to!-alg) 3372204842910521221)
strand!-alg!-top


(c!:install 'cali!=min '(cali!=min listtest) 16234821378511320355)
cali!=min


(c!:install 'appr '(appr) 7217817733980180627)
appr


(c!:install 'sfto_psrem '(sfto_psrem sfto_lcx sfto_dgcd quotfx sfto_kexp
multf negf addf sfto_vardeg) 7530110796061676935)
sfto_psrem


(c!:install 'co_hfn '(co_hfn cl_fvarl1 rl_atnum) 8041559398047499050)
co_hfn


(c!:install 'ofsf_updsigndom '(ofsf_updsigndom equal greaterp lessp
"something wrong in ofsf_updSignDom:" rederr) 65917844509290034)
ofsf_updsigndom


(c!:install 'change!+int!+to!+sq '(change!+int!+to!+sq) 
14816472864499624533)
change!+int!+to!+sq


(c!:install 'cl_subfof '(cl_subfof rl_subalchk rl_eqnrhskernels
lto_alunion cl_varl1 lto_nconcn cl_subfof1) 3324571847770003605)
cl_subfof


(c!:install 'rl_sacatlp '(rl_sacatlp rl_sacatlp!* apply) 
1265259771237399829)
rl_sacatlp


(c!:install 'conditionml '(conditionml "<condition>" "</condition>"
printout indent!* expression) 7439993112548794210)
conditionml


(c!:install 'simpu '(simpu u ordn mksp) 8431280624889325808)
simpu


(c!:install 'qsimpcomb_standard_integer_part_sf '(
qsimpcomb_standard_integer_part_sf) 2059597484296139354)
qsimpcomb_standard_integer_part_sf


(c!:install 'a2vdp '(a2vdp vdp a2dip) 12718446759882275070)
a2vdp


(c!:install 'markedvarp '(markedvarp !*marked!*) 2259735358532423556)
markedvarp


(c!:install 'evalwhereexp '(evalwhereexp aeval where carx evalletsub) 
17778069659015691080)
evalwhereexp


(c!:install 'mv!-compact2 '(mv!-compact2 equiv!-coeffs mv!-domainlist
reduce mv!-domainlist!-!- mv!-coeff!-replace mv!-!+) 
18366684156009604270)
mv!-compact2


(c!:install 'extract_vars '(extract_vars variable nreverse raiseind!:) 
581001641406960949)
extract_vars


(c!:install 'expand_terminal '(expand_terminal opt (nil) pending_rules!*
seq star (cons !$1 !$2) plus (list !$1) list (cons !$2 !$3) listplus or
"Invalid item in a rule" expansion_name rederr) 15818890523742089676)
expand_terminal


(c!:install 'not_included '(not_included) 13035740386792352516)
not_included


(c!:install 'valuechk '(valuechk variadic !:rd!: !:rn!:
!*strict_argcount alg "Wrong number of arguments to" list rerror lprim
opfchk!! znumrnil) 3047585610233842763)
valuechk


(c!:install 'cgp_greenp '(cgp_greenp cgp_rp) 14495413788687484424)
cgp_greenp


(c!:install 'integralir '(integralir atts name (bvar x 1) defint lambda
find lex omobj lambdavar lambdafun) 16370928631215989033)
integralir


(c!:install 'specrd!:times '(specrd!:times minus add_minus mkround
rd!:times) 8213566267099448959)
specrd!:times


(c!:install 'dip2a '(dip2a dip2a1 dipreplus) 11861845728545505400)
dip2a


(c!:install 'evalmember '(evalmember getrlist) 5286359330849485084)
evalmember


(c!:install 'gbfdiff '(gbfdiff difbf) 11601477481004078606)
gbfdiff


(c!:install 'gpargp '(gpargp gpexpp gplogexpp) 3658154410741724482)
gpargp


(c!:install 'indexvp '(indexvp) 11663335178243527811)
indexvp


(c!:install 'mk_simpl_map_ '(mk_simpl_map_ mk_simpl_map_1) 
11429407052348500504)
mk_simpl_map_


(c!:install 'simpdfp '(simpdfp frlis!* dfp list generic_function (list)
dfp_commute kord!* ordp "generic differential" reval mksq simpdf
dfp!-normalize simp sort typerr) 18210698244860926008)
simpdfp


(c!:install 'balance_mod '(balance_mod) 9394762873806819714)
balance_mod


(c!:install 'super_vectorfield '(super_vectorfield "SUPER_VECTORFIELD:"
"is not an identifier" simpfn super_der_simp full list ext
"not a valid odd variable" variables even_dimension odd_dimension setkfn
setk_super_vectorfield msgpri max) 1658243385334407921)
super_vectorfield


(c!:install 'rtypepart '(rtypepart yetunknowntype getrtypecar) 
3648361854817758982)
rtypepart


(c!:install 'fctlength '(fctlength fctargs) 3620606859388514100)
fctlength



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u42.lsp"

Reading "$reduce/cslbuild/generated-c/u43.lsp"

% u43.lsp           Machine generated Lisp

(c!:install "u43" 27781 1588339 5383411)
nil


(c!:install 'gigcdsq '(gigcdsq giintgcd quotf) 2701479337646345197)
gigcdsq


(c!:install 'subtractinds '(subtractinds) 1781800755294678369)
subtractinds


(c!:install 'mk!+resimp!+mat '(mk!+resimp!+mat resimp) 
624978839118700389)
mk!+resimp!+mat


(c!:install 'freeof!-dfl '(freeof!-dfl freeof!-df) 7723985767789675549)
freeof!-dfl


(c!:install 'pasf_coeflst '(pasf_coeflst setkorder reorder negf) 
2841843459196695079)
pasf_coeflst


(c!:install 'vdp_mred '(vdp_mred vdp_poly dip_mred vdp_zero dip_lbc
dip_evlmon vdp_make vdp_sugar vdp_setsugar) 14120986251177878325)
vdp_mred


(c!:install 'vsl_subatsq '(vsl_subatsq ofsf_subf) 17394022548472661751)
vsl_subatsq


(c!:install 'numir '(numir atts name complex_cartesian plus times
!&imaginaryi!; complex_polar exp rational divide find lex omobj) 
204094701760676937)
numir


(c!:install 'diford '(diford lengthn) 7054798114156165767)
diford


(c!:install 'remdiff '(remdiff difference plus minus constp) 
14005009348996126671)
remdiff


(c!:install 'xpartitop '(xpartitop simp!* xpartitsq) 7201581560387780161
)
xpartitop


(c!:install 'gfdiffer '(gfdiffer gffdiff gbfdiff) 16488884687865265734)
gfdiffer


(c!:install 'reduce!-columns '(reduce!-columns red!-weight
mv!-domainlist!-!* mv!-domainlist!-!- red!-weight!-less!-p more!-apartp)
 5786827969176873939)
reduce!-columns


(c!:install 'groeb!=testc1 '(groeb!=testc1 nth bas_dpoly dp_lmon mo_sum
mo_equal!?) 8189644749997674322)
groeb!=testc1


(c!:install 'mk_dummy_ids '(mk_dummy_ids dummy reserved dummy_id!*
intersection clean_numid union) 3153376571271088760)
mk_dummy_ids


(c!:install 'aex_mult '(aex_mult aex_simplenullp aex_0 aex_ex multsq
aex_ctx ctx_union aex_mk) 7618504733165833430)
aex_mult


(c!:install 'createtriple '(createtriple fluidbibasistripleid) 
6471021107549576289)
createtriple


(c!:install 'mksfpf '(mksfpf asymplis!* subfg!* mkprod !:expt mksp
exptf2) 17030763414840607855)
mksfpf


(c!:install 'enter!-sorted '(enter!-sorted nreverse taydegree!<) 
17819389047023974106)
enter!-sorted


(c!:install 'pasf_premf '(pasf_premf remf pasf_premf1) 
3607949355089863932)
pasf_premf


(c!:install 'vsl_boundtype1 '(vsl_boundtype1 ub lb minusf) 
9650985489234634930)
vsl_boundtype1


(c!:install 'cols2rows2 '(cols2rows2 ithlistelem) 11761456053114286748)
cols2rows2


(c!:install 'reduceroots '(reduceroots sqrt tryreduction) 
3350904232692937563)
reduceroots


(c!:install 'ps!:set!-term '(ps!:set!-term tps "less than the order of "
"less than power of last term of " !:ps!: ps!:order rerror
ps!:last!-term ps!:getv ps!:putv) 14937873030979197144)
ps!:set!-term


(c!:install 'ldf!-dep!-var '(ldf!-dep!-var depl!* ldt!-tvar makeset) 
12329147144362832437)
ldf!-dep!-var


(c!:install 'o!-nextarg '(o!-nextarg !*udebug i upb (null!-fn) acontract
op mcontract null!-fn expand identity uprint first0 last0 mval) 
13277592091299982766)
o!-nextarg


(c!:install 'e!* '(e!* !:bprec!: !:e) 15144487963355805024)
e!*


(c!:install 'physoppri '(physoppri "x= " " y= " "nat= " !*nat
" contract= " !*contract !" "(" obrkp!* !*comma!* ")" !- !1 !+ " z= "
" x1= " expt trwrite prin2!* inprint pnth exptpri) 3600671553507879763)
physoppri


(c!:install 'ev!-poles '(ev!-poles) 8441536304507899222)
ev!-poles


(c!:install 'quotofd '(quotofd nreverse quotodd) 6958130723683420292)
quotofd


(c!:install 'negex '(negex nreverse negf) 2507449366090575275)
negex


(c!:install 'revalpart '(revalpart alg "part called without arguments"
!*intstr list listfn !*hold "Invalid argument" "to part" partop rerror
getrtype reval listeval0 parterr2 msgpri nth) 16122698882590425009)
revalpart


(c!:install 'prepcadr '(prepcadr prepsq) 17465412849862105063)
prepcadr


(c!:install 'ra_wrapper '(ra_wrapper dmode!* ra_wrapper1 !*backtrace
"caught error - restoring domain mode" errorset errorp lprim on1) 
17490729383560982244)
ra_wrapper


(c!:install 'qqe_simplbtat '(qqe_simplbtat neq false true equal
rl_prepat qqe_op qqe_arg2l qqe_eta!-in!-term qqe_arg2r rl_simpat) 
13126731773829347008)
qqe_simplbtat


(c!:install 'pasf_ordatp '(pasf_ordatp true false ordp pasf_ordrelp) 
9850023449766335042)
pasf_ordatp


(c!:install 'conditionrd '(conditionrd char (!/ c o n d i t i o n)
"</condition>" condition mathml lex errorml) 13950345929221872061)
conditionrd



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u43.lsp"

Reading "$reduce/cslbuild/generated-c/u44.lsp"

% u44.lsp           Machine generated Lisp

(c!:install "u44" 46891 2685123 9816267)
nil


(c!:install 'diffp '(diffp !*sq dfform plus wtl!* k!* dmode!* powlis!*
!*depend !*expanddf depl!* df !*commutedf !*simpnoncomdf int
!*allowdfint !*df_partial (!! !! !_) simpfn simpiden (df int)
"Possible inconsistent dependencies in" noncomp simpdf simpexpt multsq
to addsq difff diffsq dfn_prop simp pair int!-equiv!-chk rationalizesq
depends df!-chain!-rule opmtch mksq quotsq simp!* not_df_p mk!*sq reval
smember get!-all!-kernels ldepends merge!-ind!-vars find_sub_df mkid
dependsl msgpri) 10518100153410283175)
diffp


(c!:install 'get!:const '(get!:const save!:c not_found round!:mt
bflerrmsg) 14945302858520531928)
get!:const


(c!:install 'nspaces '(nspaces !! ! ) 9403753038800802083)
nspaces


(c!:install 'all_defined_map_ '(all_defined_map_ al1_defined_map_) 
11847781095836290666)
all_defined_map_


(c!:install 'quotexf!* '(quotexf!* nreverse quotfexf!*1) 
16925846353836221873)
quotexf!*


(c!:install 'general!-multiply!-by!-constant!-mod!-p '(
general!-multiply!-by!-constant!-mod!-p general!-modular!-times !*n2f) 
13076077458684898091)
general!-multiply!-by!-constant!-mod!-p


(c!:install 'rl_nnfnot '(rl_nnfnot rl_nnfnot!* apply) 
11366376447126177282)
rl_nnfnot


(c!:install 'makecoeffpairshom '(makecoeffpairshom ((nil))
tayexp!-difference tayexp!-times2 tayexp!-minusp tayexp!-plus2 lastpair)
 15245645716957047788)
makecoeffpairshom


(c!:install 'pasf_exprng!-gball '(pasf_exprng!-gball
"pasf_exprng: bad bound " " with free variables " !*rlexprngnatural and
true false cl_fvarl rederr pasf_exprng pasf_qff2ivl pasf_sisub) 
7187494486004864692)
pasf_exprng!-gball


(c!:install 'matrixml '(matrixml "<matrix" "" matrixrow "</matrix>"
printout attributesml indent!* matrix_rows cols2rows) 
14211731179809632096)
matrixml


(c!:install 'convprc2 '(convprc2 yy!! !*roundbf !:rd!: convprec fl2bf
read!:num normbf) 2754024750176128811)
convprc2


(c!:install 'findhr '(findhr headhisto codhisto psi npsi codmat maxvar
rcoccup) 13838382850889596042)
findhr


(c!:install 'r2oaddspecies '(r2oaddspecies "new species: " prin2t) 
13662323801649141225)
r2oaddspecies


(c!:install 'ordpl '(ordpl ordp) 17076256259373343265)
ordpl


(c!:install 'evalletsub '(evalletsub alg "Invalid simplification"
evalletsub2 errorp rerror) 336294914740379549)
evalletsub


(c!:install 'lieninstruc '(lieninstruc difference lie_cc lienstrucin
minus plus aeval!* aminusp!: setk) 1855164136878405455)
lieninstruc


(c!:install 'gcdlist '(gcdlist "Term content division failed" poly!-abs
gcdld mapcarcar powers1 numeric!-content vintersection gcddd mksp multf
quotfail1 gcdlist1) 14143677021300326377)
gcdlist


(c!:install 'nlist '(nlist nreverse) 10472874980530235129)
nlist


(c!:install 'pasf_ceil '(pasf_ceil
"pasf_ceil: not a domain valued sf in input" simp rederr) 
14816327850986668498)
pasf_ceil


(c!:install 'lowupperlimitml '(lowupperlimitml "<lowlimit>"
"</lowlimit>" "<uplimit>" "</uplimit>" printout indent!* expression) 
8410065134618955200)
lowupperlimitml


(c!:install 'ps!:plus!-erule '(ps!:plus!-erule ps!:evaluate addsq) 
13435718629095729272)
ps!:plus!-erule


(c!:install 'make_spoly_pair '(make_spoly_pair spoly_pair pfordp xval
xlcm triviallcm mknwedge xdegreecheck) 16730509289712052345)
make_spoly_pair


(c!:install 'simpsetdiff '(simpsetdiff setdiff empty_set applysetop mksp
) 7728987522191007542)
simpsetdiff


(c!:install 'defined_all_edge '(defined_all_edge def_edge p_def_edge
rep_edge_prop_) 7466336925229487161)
defined_all_edge



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u44.lsp"

Reading "$reduce/cslbuild/generated-c/u45.lsp"

% u45.lsp           Machine generated Lisp

(c!:install "u45" 95899 2283492 5024683)
nil


(c!:install 'applsmacro '(applsmacro name inlineinfo rlisp
"Argument mismatch for SMACRO" !*loginlines g lambda rerror log_inlines
no!-side!-effect!-listp one!-entry!-listp pair subla!-q
no!-side!-effectp one!-entryp aconc) 10980045500133507434)
applsmacro


(c!:install 'prsum '(prsum nreverse to) 4168678173511487947)
prsum


(c!:install 'subs2p '(subs2p simp exptsq to multsq) 14762464268078506714
)
subs2p


(c!:install 'prim!-part '(prim!-part comfac comfac!-to!-poly quotf1) 
1260543398647750397)
prim!-part


(c!:install 'totalcompareconstants '(totalcompareconstants equal less
greater wukord!* wuvarlist!* symbollessp) 1087222859431793036)
totalcompareconstants


(c!:install 'quotientml '(quotientml !*web "<cn type=""rational""> "
"<cn type=&quot;rational&quot;> " " <sep/> " " </cn>" "<apply>" "<" "/>"
"</apply>" printout indent!* expression) 2636813940372006033)
quotientml


(c!:install 'simpsqrtsq '(simpsqrtsq simpsqrt2) 16857662672342576259)
simpsqrtsq


(c!:install 'ps!:arg!-values '(ps!:arg!-values !:ps!: ps!:value) 
15612600895103978694)
ps!:arg!-values


(c!:install 'wedgewedge '(wedgewedge wedgepf2) 17383049050819657757)
wedgewedge


(c!:install 'mksqrt '(mksqrt !*keepsqrts expt quotient !*!*sqrt (x) (
let00 (quote ((equal (expt (sqrt x) 2) x)))) sqrt forall aeval) 
6961194266824060434)
mksqrt


(c!:install 'fermionicp '(fermionicp fermionic d df s s_changes_parity
t_changes_parity) 1561662599579503643)
fermionicp


(c!:install 'rule '(rule !*sq!* mcond!* "Unmatched free variable(s)"
hold erfg!* getel errpri1 prepsq!* smemql setdiff lprie lispeval let3) 
17927910212934432100)
rule


(c!:install 'depend!-f '(depend!-f depend!-p) 7582361734257302030)
depend!-f


(c!:install 'mri_ofsf2mri '(mri_ofsf2mri mri_ofsf2mriat cl_apply2ats1) 
9220106144109790875)
mri_ofsf2mri


(c!:install 'csymbolrd '(csymbolrd fnrd stats_getargs) 
2269378548414956256)
csymbolrd


(c!:install '!*rn2rd '(!*rn2rd r2bf chkrn!* mkround) 4804769577357159913
)
!*rn2rd


(c!:install 'dipcontevmin '(dipcontevmin) 5891717190099008862)
dipcontevmin


(c!:install 'subfindices '(subfindices alglist!* (wedge d partdf
innerprod liedf hodge vardf) sfp exptsq simpindexvar subindk simp multsq
addsq) 8932382147427070096)
subfindices


(c!:install 'gd_gcasesimpl '(gd_gcasesimpl gd_simpl) 3106971393313232138
)
gd_gcasesimpl


(c!:install 'ofsf_sippsignchkf '(ofsf_sippsignchkf unknown
ofsf_updsigndom ofsf_updsignvar ofsf_updsignpow ofsf_updsignmult
ofsf_updsignadd) 14134957242467567077)
ofsf_sippsignchkf


(c!:install 'mri_prifloor '(mri_prifloor !*nat failed "[" "]" prin2!*
maprin) 3143759303351340392)
mri_prifloor


(c!:install 'make!-image!-mod!-p '(make!-image!-mod!-p unlucky!-case
degree!-in!-variable make!-univariate!-image!-mod!-p) 
8264417465749283354)
make!-image!-mod!-p


(c!:install 'matrixir '(matrixir matrixcolumn matrixrow matrix lex
omobjs matrixelems) 16908110675907796155)
matrixir


(c!:install 'simpdf '(simpdf subfg!* df "kernel or integer"
domain!-diff!-fn dmode!* alglist!* "kernel" mksq simp!* prepsq typerr
prepf prekernp diffsq d2int) 10496397630730647885)
simpdf


(c!:install 'findhc '(findhc njsi jsi codmat maxvar) 538885150119599152)
findhc


(c!:install 'gfstorval '(gfstorval !*xnlist) 12264309616471478407)
gfstorval


(c!:install 'fortassign '(fortassign mkffortassign) 6624076633711203064)
fortassign


(c!:install 'new_prove '(new_prove new_provev) 13959116656364361077)
new_prove


(c!:install 'sign!-abs '(sign!-abs minus sign!-of simp) 
6340523605258900088)
sign!-abs


(c!:install 'setmatelem '(setmatelem "matrix element" matrix "matrix"
mat "Matrix" "not set" "positive integer" typerr rerror
reval_without_mod nth pnth) 9548262577267566440)
setmatelem


(c!:install 'dfp!-rule!-found '(dfp!-rule!-found dfp) 
9877567616346544088)
dfp!-rule!-found


(c!:install 'fs!:timescoeff '(fs!:timescoeff (nil . 1) "zero in times"
multsq) 5406645140491289302)
fs!:timescoeff


(c!:install 'mkindxlist '(mkindxlist minus !*num2id) 4162138526201494400
)
mkindxlist


(c!:install 'inormmat '(inormmat ilcm) 17106946690286213239)
inormmat


(c!:install 'no_of_tm_sf_limited '(no_of_tm_sf_limited) 
15651175340902815823)
no_of_tm_sf_limited


(c!:install 'settreset '(settreset fluidbibasisjanettreerootnode
fluidbibasissett) 11886008700691594736)
settreset


(c!:install 'ofsf_updsignvar '(ofsf_updsignvar equal greaterp lessp geq
leq neq unknown) 6623497294712404882)
ofsf_updsignvar


(c!:install 'mkexpt '(mkexpt expt) 5754935854877136791)
mkexpt


(c!:install 'iv_cutn '(iv_cutn iv_cut) 18130037756634153349)
iv_cutn


(c!:install 'bc_gcd '(bc_gcd gcdf!*) 4947837562519671859)
bc_gcd


(c!:install 'cnml '(cnml "<cn" "" "</cn>" printout attributesml) 
14691654203402877146)
cnml


(c!:install 'znumrnil '(znumrnil znumr) 3406126826241646652)
znumrnil


(c!:install 'scar '(scar) 14714868972199026410)
scar


(c!:install 'copy_vect '(copy_vect sparsemat fullcopy) 
1385142974386378902)
copy_vect


(c!:install 'partitwedge '(partitwedge partitop xpndwedge mkuniquewedge)
 17466341504292213163)
partitwedge


(c!:install 'endmodule '(endmodule mode!-list!*
"ENDMODULE called outside module" exportslist!* importslist!* alglist!*
!*mode rederr) 13502524214384896680)
endmodule


(c!:install 'mkforttab '(mkforttab forttab fortcurrind!*) 
3348229086508012781)
mkforttab


(c!:install 'coeff_calc '(coeff_calc plus coeff1_calc reval) 
7462814040679763528)
coeff_calc


(c!:install 'split!-comfac!-part '(split!-comfac!-part split!-comfac) 
16472164186914038891)
split!-comfac!-part


(c!:install 'listminimize '(listminimize cali!=min) 12763062043939354477
)
listminimize


(c!:install 'zfactor1 '(zfactor1 !*primelist!* nreverse add!-factor
mcfactor!*) 5360192074139528345)
zfactor1


(c!:install 'precision '(precision arith "positive number required"
rerror precision1) 13453333914508305559)
precision


(c!:install 'mkrootsql '(mkrootsql !*d2q mkrootsq exptsq multsq) 
7401308018124398825)
mkrootsql


(c!:install 'talp_simplatlinv '(talp_simplatlinv talp_simplt talp_invp
talp_mk2 talp_simplat2) 12087196483435887150)
talp_simplatlinv



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u45.lsp"

Reading "$reduce/cslbuild/generated-c/u46.lsp"

% u46.lsp           Machine generated Lisp

(c!:install "u46" 154649 3418922 6913421)
nil


(c!:install 'pasf_smwmkatl '(pasf_smwmkatl !*rlsusi cl_susimkatl
cl_smmkatl) 14491224678262139805)
pasf_smwmkatl


(c!:install 'gb_searchinlist '(gb_searchinlist vdp_evlmon
gb_buch!-ev_divides!?) 13011741950046030798)
gb_searchinlist


(c!:install 'd2int '(d2int !:rd!: !!fleps1) 2860821044592396078)
d2int


(c!:install 'tchscheme2 '(tchscheme2 rowmax removechild to!*scheme) 
10670630006658404031)
tchscheme2


(c!:install 'sroot1 '(sroot1 freevars substitution rpt inf !*trpm
"Trying rule  " "against      " "producing    " "failed" findnewvars
union newenv rprint amatch embed!-null!-fn restorenv) 
4065155521512325602)
sroot1


(c!:install 'xregister_spoly_pair '(xregister_spoly_pair) 
16809458969016319347)
xregister_spoly_pair


(c!:install 'evaluate2 '(evaluate2 !:dn!: plus times dmarith!* dn!:simp
evaluate1 !:dmpluslst !:dmtimeslst apply prepf simp force!-to!-dm) 
6157296650697590590)
evaluate2


(c!:install 'mv!-compact '(mv!-compact mv!-reverse mv!-pow!-chk
mv!-pow!-mv!-!+ mv!-compact2 mv!-pow!-!+ mv!-pow!-assoc) 
9240000233549075625)
mv!-compact


(c!:install 'simp!-prop '(simp!-prop propvars!* and or !'and !'or !'true
!'false times not full boolean reval simp!-prop1 prepf simp
simp!-prop!-dist simp!-prop2 simp!-prop!-form to) 14478673112857946646)
simp!-prop


(c!:install 'try!-all!-constants '(try!-all!-constants number!-needed
current!-modulus split!-further) 14167453229868141545)
try!-all!-constants


(c!:install 'polynomlistautoreduce '(polynomlistautoreduce
polynomlistreduce monomisdivisibleby pushback) 1357424796153139693)
polynomlistautoreduce


(c!:install 'ofsf_qesubqat '(ofsf_qesubqat !*rlqesubf !*rlqelocal equal
neq geq ofsf_varlat prepsq subf ofsf_subf ofsf_qesubqat!-local
ofsf_surep sfto_pdecf multf) 10452000760203204783)
ofsf_qesubqat


(c!:install 'tayexp!-max2 '(tayexp!-max2 tayexp!-lessp) 
17858461924541832237)
tayexp!-max2


(c!:install 'cl_replace!-varl '(cl_replace!-varl cl_varl1) 
1771464919472448494)
cl_replace!-varl


(c!:install 'qqe_simplqneq '(qqe_simplqneq qequal true false qneq
qqe_mk2 qqe_simplqequal qqe_arg2l qqe_arg2r) 12147848576444979923)
qqe_simplqneq


(c!:install 'pdiffvars '(pdiffvars ind nth) 11152193338476678657)
pdiffvars


(c!:install 'rnfix!* '(rnfix!*) 3256443848001070039)
rnfix!*


(c!:install 'newsym1 '(newsym1 cindex!* cname!*) 426404548351141204)
newsym1


(c!:install 'nestzerop!: '(nestzerop!: simp) 1274628154170026995)
nestzerop!:


(c!:install 'dipdivmon '(dipdivmon nreverse evdif bcquot) 
17103397929728998226)
dipdivmon


(c!:install 'sc_scalarproduct '(sc_scalarproduct sc_simp fast!-row!-dim
sc_getmat sc_multsq sc_addsq) 14834557765495777788)
sc_scalarproduct


(c!:install 'delete_edge '(delete_edge nreverse) 15292113970921095755)
delete_edge


(c!:install 'mkimpart '(mkimpart impart sfp realvaluedp!-sf impartsq
realvaluedp mksq) 18194972465079704462)
mkimpart


(c!:install 'mv2sf '(mv2sf mv2sf1 addf) 1593951586347486978)
mv2sf


(c!:install 'nodum_varp '(nodum_varp g_dvbase !~dv !~dva listp
ad_splitname) 3996221814626008533)
nodum_varp


(c!:install 'mkrootsq '(mkrootsq (minus 1) i expt !*precise_complex
factorbound!* !*ifactor quotient !*d2q simp exptsq zfactor1 mkrootsql
mksqrt opmtch mksq) 447351031222923455)
mkrootsq


(c!:install 'ofsf_facequal '(ofsf_facequal equal or and true false
sfto_fctrf) 12995514954362860058)
ofsf_facequal


(c!:install 'polynomreduceby '(polynomreduceby
fluidbibasisreductionsmade monomisdivisibleby monomdivide
polynommultiplybymonom polynomadd) 3389395153734211277)
polynomreduceby


(c!:install 'cl_sacat '(cl_sacat keep) 18128826745512667418)
cl_sacat


(c!:install 'aex_simplenumberp '(aex_simplenumberp aex_fvarl) 
16106721348376309280)
aex_simplenumberp


(c!:install 'operator_fn '(operator_fn "<apply>" "<csymbol>" "<ci>"
"</ci>" "</csymbol>" "</apply>" printout indent!* multi_args) 
4202184310625661376)
operator_fn


(c!:install 'qsum!-simpexpt '(qsum!-simpexpt inside!-qsum!-simpexpt!*
!*exp !*factor !*mcd !*precise !*allfac qsum!-simpexpt1 rmsubs) 
1865262126138033327)
qsum!-simpexpt


(c!:install 'calc_atlas '(calc_atlas calc_map_2d) 9734104227373875648)
calc_atlas


(c!:install 'rfirst '(rfirst list "list or bag" reval bagp typerr
parterr) 4610944224751221558)
rfirst


(c!:install 'reduce!-ratios '(reduce!-ratios red!-ratios1
mv!-domainlist!-!* mv!-domainlist!-!- reddom_zeros) 9374687512318225182)
reduce!-ratios


(c!:install 'check_letop '(check_letop letop
"Presence of letop, jetspace too small!" freeof rederr) 
3231886767849345546)
check_letop


(c!:install 'cl_identifyonoff '(cl_identifyonoff cl_identify!-atl!*) 
111440064799115096)
cl_identifyonoff


(c!:install 'mri_simplat1 '(mri_simplat1 !*rlsimplfloor int real mri_op
mri_arg2l mri_simplfloor mri_type mri_0mk2 mri_dettype mri_2pasfat
pasf_simplat1 mri_pasf2mri mri_congp mri_2ofsfat ofsf_simplat1
mri_ofsf2mri) 11559093591740106542)
mri_simplat1


(c!:install 'limitom '(limitom "<OMA>"
"<OMS cd=""limit1"" name=""limit""/>" lowlimit
"<OMS cd=""limit1"" name=""null""/>" condition
"<OMS cd=""limit1"" name=""" """/>" limit "</OMA>" printout indent!*
objectom lambdaom) 3650259326440300538)
limitom


(c!:install 'solvealgtrig01 '(solvealgtrig01 (sin cos tan cot sinh cosh
tanh coth) constant_exprp union) 8913583277979887080)
solvealgtrig01


(c!:install 'gfftimes '(gfftimes) 16571310599605003544)
gfftimes


(c!:install 'asymmetrize!-inds '(asymmetrize!-inds nth repeats indordn
indordln permp flatindl pair) 12851078889283767221)
asymmetrize!-inds


(c!:install 'ctx_union '(ctx_union arg1of2 ctx ordopcar ctx_ial
lto_almerge sort) 17896863293973972637)
ctx_union


(c!:install 'monomcomparelex '(monomcomparelex) 11051507336604097688)
monomcomparelex



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u46.lsp"

Reading "$reduce/cslbuild/generated-c/u47.lsp"

% u47.lsp           Machine generated Lisp

(c!:install "u47" 157940 6721509 9423787)
nil


(c!:install 'ofsf_smmkatl!-and1 '(ofsf_smmkatl!-and1 (lessp greaterp)
and ofsf_smmkat!-and2 ofsf_entry2at lastpair) 9168707611537321621)
ofsf_smmkatl!-and1


(c!:install 'simpx1 '(simpx1 !*minus!* quotient expt i frlis!* !*mcd
!*notseparate !*keepsqrts sqrt minus plus !*expandexpt times used!* (
minus 1) difference (quotient 1 2) simp simpexpt multsq negsq smemqlp
mksq invsq exptsq simp!* simprad) 217428944454050099)
simpx1


(c!:install 'vdp_monp '(vdp_monp vdp_poly dip_monp) 7810046384283950709)
vdp_monp


(c!:install 'dip!-nc!-ev!-prod '(dip!-nc!-ev!-prod bcprod
dip!-nc!-ev!-prod1) 13753880069992538933)
dip!-nc!-ev!-prod


(c!:install 'lndepends '(lndepends ndepends) 245971449668139068)
lndepends


(c!:install 'listquotient '(listquotient list quotient reval1
listquotient2) 6929506952944788535)
listquotient


(c!:install 'vecsimp!* '(vecsimp!* vecp vecsm!*) 15537020803561331903)
vecsimp!*


(c!:install 'verify_tens_ids '(verify_tens_ids cantens
"are inconsistent lists of indices" extract_dummy_ids repeats rerror) 
2124580761287725659)
verify_tens_ids


(c!:install 'evaluate!-in!-order!-mod!-p '(evaluate!-in!-order!-mod!-p
!*d2n horner!-rule!-in!-order!-mod!-p) 11194639884761491694)
evaluate!-in!-order!-mod!-p


(c!:install 'domainp_list '(domainp_list) 12010184099986036243)
domainp_list


(c!:install '!*a2kwoweight '(!*a2kwoweight !*uncached wtl!* kernel
simp!* kernp typerr) 10341696069689992804)
!*a2kwoweight


(c!:install 'drop_dec_with '(drop_dec_with dec_with_rl dec_with) 
4637449164887897132)
drop_dec_with


(c!:install 'cl_sordp '(cl_sordp true false or and not impl repl equiv
ex all bex ball rl_ordatp cl_ordopp ordp cl_sordpl) 1766985440902024458)
cl_sordp


(c!:install 'rl_sacat '(rl_sacat rl_sacat!* apply) 944955371135587480)
rl_sacat


(c!:install 'acfsf_clnegrel '(acfsf_clnegrel acfsf_lnegrel) 
12459359460298823286)
acfsf_clnegrel


(c!:install 'dipretimes '(dipretimes times) 14088869305807271599)
dipretimes


(c!:install 'indordln '(indordln indordl2 indordlad) 
16254463786900959556)
indordln


(c!:install 'free '(free freeind) 5972707798710380332)
free


(c!:install '!*multf '(!*multf !*noncomp (expt sqrt) sqrt expt
squashsqrt multd multf ordop addf makeupsf !*multfsqrt
prefix!-rational!-numberp !*multfexpt mkspm) 3112641827313326709)
!*multf


(c!:install 'nonlnr '(nonlnr freeofl) 8210815413809985732)
nonlnr


(c!:install 'janettreeinsert '(janettreeinsert
fluidbibasisjanettreerootnode janettreenodebuild monomgetvariabledegree
setcar setcdr) 6692586595300419199)
janettreeinsert


(c!:install 'ofsf_smeqtable '(ofsf_smeqtable ((equal (equal . equal) (
neq . false) (geq . equal) (leq . equal) (greaterp . false) (lessp .
false)) (neq (neq . neq) (geq . greaterp) (leq . lessp) (greaterp .
greaterp) (lessp . lessp)) (geq (geq . geq) (leq . equal) (greaterp .
greaterp) (lessp . false)) (leq (leq . leq) (greaterp . false) (lessp .
lessp)) (greaterp (greaterp . greaterp) (lessp . false)) (lessp (lessp .
lessp)))) 8132877551901091129)
ofsf_smeqtable


(c!:install 'ev_init '(ev_init) 1151919986852689506)
ev_init


(c!:install 'spinnerprod '(spinnerprod plus times) 4756109932931016172)
spinnerprod


(c!:install 'dipequal '(dipequal evequal) 2402755849245862783)
dipequal


(c!:install 'natnump '(natnump) 3143551995880890331)
natnump


(c!:install 'defined_vertex '(defined_vertex memq_edgelist) 
12315488129214510238)
defined_vertex


(c!:install 'reduce!-weights '(reduce!-weights red!-weight
mv!-domainlist!-!+ red!-weight!-less!-p mv!-domainlist!-!-) 
10521538158462096126)
reduce!-weights


(c!:install 'fs!:prin!: '(fs!:prin!: "[" "]" prin2!* fs!:prin) 
12620491596942070734)
fs!:prin!:


(c!:install 'bagp '(bagp bag) 17072741318794064055)
bagp


(c!:install 'bfminus '(bfminus minus!:) 13086388068205214699)
bfminus


(c!:install 'get!-new!-prime '(get!-new!-prime !*force!-prime all
smallest!-prime random!-teeny!-prime random!-small!-prime) 
16039629042702163743)
get!-new!-prime


(c!:install 'girationalize!: '(girationalize!: !*gcd !:gi!: conjgd addf
negf multf gcdf quotf quotf!-fail gigcdsq) 5436218136478886805)
girationalize!:


(c!:install 'talp_lssimpl '(talp_lssimpl or and (ex all) talp_rnf
talp_atfp talp_op talp_argl talp_lssimpl1) 10177797432189751992)
talp_lssimpl


(c!:install 'bc_dcont '(bc_dcont sfto_dcontentf) 756698739986786000)
bc_dcont


(c!:install 'cr!:prep '(cr!:prep !:rd!: rd!:prep crprep1) 
5680819172236842863)
cr!:prep


(c!:install 'vdplsort '(vdplsort vdpvevlcomp sort) 11562137722065177216)
vdplsort



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u47.lsp"

Reading "$reduce/cslbuild/generated-c/u48.lsp"

% u48.lsp           Machine generated Lisp

(c!:install "u48" 63073 7272097 8612076)
nil


(c!:install 'maprintla '(maprintla laprifn fulla failed indexed !:rd!:
!*nat ncharspr!* laline!* orig!* posn!* equal !( !) minus prinlatom
prin2la apply prinidop rd!:prin oprinla prinpopargs inprinla) 
10666225449942779319)
maprintla


(c!:install 'mkdmoderr '(mkdmoderr lambda (!*x!*) dmoderr) 
560371362299189013)
mkdmoderr


(c!:install 'reset_opnums '(reset_opnums oporder!* opnum !*xadd) 
5325307124938520491)
reset_opnums


(c!:install 'mk_names_map_2 '(mk_names_map_2) 6630788302055002628)
mk_names_map_2


(c!:install 'njets '(njets combin) 13405465310925955507)
njets


(c!:install 'pst_mkpst '(pst_mkpst pst_mkpst1 pst_equitable) 
17260450864783093708)
pst_mkpst


(c!:install 'general!-modular!-difference '(general!-modular!-difference
current!-modulus) 3483344910142386874)
general!-modular!-difference


(c!:install 'aex_psrem '(aex_psrem aex_fvarl aex_0 aex_ex aex_lc aex_sgn
sfto_psrem kernels aex_ctx ctx_union ctx_filter aex_mk aex_mklcnt) 
4904291359702063744)
aex_psrem


(c!:install 'f2df '(f2df zlist dfconst vp2df multdf plusdf multdfconst) 
7539343109042374941)
f2df


(c!:install 'get_dimension_in '(get_dimension_in id get_rep_matrix_in
mk!+trace change!+sq!+to!+int) 14407917089983539275)
get_dimension_in


(c!:install 'talp_qesolset '(talp_qesolset ignore equal failed
talp_arg2l talp_arg2r talp_contains) 3902272268693375787)
talp_qesolset


(c!:install 'cl_susicpknowl '(cl_susicpknowl) 360722150036072037)
cl_susicpknowl


(c!:install 'gpexpp '(gpexpp (!:rd!: !:cr!: !:crn!: !:gi!:) plus (minus
recip) (difference quotient expt) times !:rd!: (!:cr!: !:crn!: !:gi!:)
gpexp1p unresidp gparg1p) 1997977812855299707)
gpexpp


(c!:install 'mo_support '(mo_support cali!=basering ring_names mo_from_a
mo_divides!?) 18038819699181796544)
mo_support


(c!:install 'addnew '(addnew gv!* bv!* ljet insert) 6824181854034253868)
addnew


(c!:install 'flattens1 '(flattens1) 12333193806801555492)
flattens1


(c!:install 'mkexpvec '(mkexpvec dipvars!* "dipoly variable" typerr) 
1312027724317386792)
mkexpvec


(c!:install 'qroundup '(qroundup) 10750519726693016495)
qroundup


(c!:install 'aex_unbind '(aex_unbind aex_ex aex_ctx ctx_remove aex_mk) 
9664124840895833839)
aex_unbind


(c!:install 'min2!-order '(min2!-order nreverse tayexp!-plus2
tayexp!-greaterp tayexp!-min2) 13926684584939521754)
min2!-order


(c!:install 'mk!+inner!+product '(mk!+inner!+product
"wrong dimensions in innerproduct" !*complex !*sub2 get!+vec!+dim rederr
mk!+conjugate!+vec get!+vec!+entry multsq addsq subs2) 
18064794597700778148)
mk!+inner!+product


(c!:install 'mri_simplfloor1 '(mri_simplfloor1 mri_simplfloor
mri_irsplit addf exptf multf) 16810088525014662784)
mri_simplfloor1


(c!:install 'cl_bnfsimpl '(cl_bnfsimpl !*rlbnfsac cl_sac) 
6603799946669511995)
cl_bnfsimpl


(c!:install 'vdp_zero '(vdp_zero invalid vdp_make) 17290158580285103512)
vdp_zero


(c!:install 'countof '(countof) 5339181945143252659)
countof


(c!:install 'evalgeq '(evalgeq evallessp) 6541910110406929399)
evalgeq


(c!:install 'lengthn '(lengthn) 6286815763906199918)
lengthn


(c!:install 'spmatlength '(spmatlength sparsemat matrix "Matrix"
"not set" list rerror) 5714151694477294631)
spmatlength


(c!:install 'sfpf '(sfpf sfp) 17563026604267880041)
sfpf


(c!:install 'pnth!* '(pnth!*) 13080433998780208293)
pnth!*


(c!:install 'generic_arguments '(generic_arguments list generic_function
) 14840104320580484157)
generic_arguments


(c!:install 'fs!:subang '(fs!:subang make!-term fs!:plus) 
9132207302041089259)
fs!:subang


(c!:install 'cali_bc_from_a '(cali_bc_from_a simp!* bc!=simp) 
5173823590854030894)
cali_bc_from_a


(c!:install 'dv_skel2factor '(dv_skel2factor st_ad_numsorttree
st_flatten dv_ind2var dv_skel2factor1) 7917221492997085944)
dv_skel2factor


(c!:install 'alistp '(alistp) 15293333801659366688)
alistp


(c!:install 'add!-factor '(add!-factor) 7843512598483340436)
add!-factor


(c!:install 'dfdeg '(dfdeg) 10704968414028685461)
dfdeg


(c!:install 'talp_get!-idx '(talp_get!-idx talp_fop talp_invf talp_invn)
 6245453212222089412)
talp_get!-idx


(c!:install 'iv_new '(iv_new) 3426832229457806045)
iv_new


(c!:install 'mulpower '(mulpower sqrtlist zlist addexptsdf reduceroots
multdf) 14418985785262293380)
mulpower


(c!:install 'parfool '(parfool) 5261984326391102730)
parfool


(c!:install 'spmatsm!* '(spmatsm!* sparsemat spmatsm matsm!*1) 
1097875971497327075)
spmatsm!*


(c!:install 'matsm!* '(matsm!* matsm matsm!*1) 14890198389059652316)
matsm!*


(c!:install 'f2dip '(f2dip evzero bcfd f2dip1) 9587368216975151565)
f2dip


(c!:install 'dim!<!=deg '(dim!<!=deg dimex!* deg!*form negf addf) 
15432143120275206384)
dim!<!=deg


(c!:install 'mk_parents_prim '(mk_parents_prim s_noparents
mk_edge_parents) 2468381646525202115)
mk_parents_prim


(c!:install 'expand!-imrepartpow '(expand!-imrepartpow !*exp cmpxsplitfn
i to mkrepart simp mkimpart multsq addsq exptsq) 12425961166904866094)
expand!-imrepartpow


(c!:install 'bfrsq '(bfrsq csl_timbf plubf) 6817557628069572305)
bfrsq


(c!:install 'sfchk '(sfchk sfp prepf) 8894828728941178290)
sfchk


(c!:install 'replace!-next '(replace!-next nreverse) 
14091638087168046101)
replace!-next


(c!:install 'talp_mkinvop '(talp_mkinvop inv_) 6289931570559624594)
talp_mkinvop


(c!:install 'bc_zero '(bc_zero) 15962626216446594231)
bc_zero


(c!:install 'gfquotient '(gfquotient gffquot gbfquot) 
11165314299645826300)
gfquotient


(c!:install 'mkrepart '(mkrepart repart sfp realvaluedp!-sf to repartsq
realvaluedp mksq) 1938415490342039633)
mkrepart


(c!:install 'mo!=expvec2a1 '(mo!=expvec2a1 expt nreverse) 
17299033867504388525)
mo!=expvec2a1


(c!:install 'sub01 '(sub01 nreverse) 5029894297379851509)
sub01


(c!:install 'depend!-sq '(depend!-sq depend!-f) 6771514811325703769)
depend!-sq


(c!:install 'mri_irsplit1 '(mri_irsplit1 to exptf mri_realvarp multf
addf) 13947086387411447854)
mri_irsplit1


(c!:install 'pasf_smordtable '(pasf_smordtable "abused smordtable"
pasf_smordtable2 pasf_smordtable1 rederr) 15835215276850649327)
pasf_smordtable


(c!:install 'den '(den simp!* mk!*sq) 11489848385305094078)
den


(c!:install 'groebcplistmerge '(groebcplistmerge groebcpcompless!?) 
2832212071468860374)
groebcplistmerge


(c!:install 'subs2pf '(subs2pf resimp subs2) 12462583401050515357)
subs2pf


(c!:install '!:log2 '(!:log2 not_found bftwo!* get!:const log!:
save!:const) 9908259478374416725)
!:log2


(c!:install 'lispcodeexp '(lispcodeexp e exp 1.0 (!:rd!: !:cr!: !:crn!:
!:gi!:) irena!-constants expt (quotient 1 2) sqrt !:rd!: (1 . 2)
quotient recip !*period difference plus minus !*lisparithexpops!*
!*lisplogexpops!* check!-for!-irena!-constants realrat) 
4974330400605947032)
lispcodeexp


(c!:install 'physopsubs '(physopsubs alglist!* physoplist!* rtype simpfn
simpiden (dot) physopfn dot physop physop2sq subs2 !*q2a) 
12042423606794197418)
physopsubs



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u48.lsp"

Reading "$reduce/cslbuild/generated-c/u49.lsp"

% u49.lsp           Machine generated Lisp

(c!:install "u49" 74332 6242435 4565881)
nil


(c!:install 'mk_world1 '(mk_world1 map_2_from_map_1) 
11864793233031236250)
mk_world1


(c!:install 'fs!:zerop!: '(fs!:zerop!:) 9574036079916408229)
fs!:zerop!:


(c!:install 'dp!=retimes '(dp!=retimes times) 7894493552316191125)
dp!=retimes


(c!:install 'st_sorttree1 '(st_sorttree1 !* !+ cdr_sort cdr_signsort) 
18254977221322318624)
st_sorttree1


(c!:install 'even_action '(even_action even_action_sf addsq) 
587366358427156605)
even_action


(c!:install 'dvfsf_0mk2 '(dvfsf_0mk2) 16558020518709937741)
dvfsf_0mk2


(c!:install 'nextu '(nextu subtractinds evaluatecoeffts) 
17007332787641938455)
nextu


(c!:install 'xadd!* '(xadd!* newrule!* plus difference times expt
powlisp simp prepsq updoldrules) 17515286503557943635)
xadd!*


(c!:install 'pasf_smordtable2 '(pasf_smordtable2 ((lessp (lessp 2) (leq
2) (equal 2) (neq nil) (geq nil) (greaterp nil) (cong nil) (ncong nil))
(leq (lessp 2) (leq 2) (equal 2) (neq nil) (geq nil) (greaterp nil) (
cong nil) (ncong nil)) (equal (lessp false) (leq false) (equal false) (
neq 1) (geq 1) (greaterp 1) (cong nil) (ncong nil)) (neq (lessp 2) (leq
2) (equal 2) (neq nil) (geq nil) (greaterp nil) (cong nil) (ncong nil))
(geq (lessp false) (leq false) (equal false) (neq 1) (geq 1) (greaterp 1
) (cong nil) (ncong nil)) (greaterp (lessp false) (leq false) (equal
false) (neq 1) (geq 1) (greaterp 1) (cong nil) (ncong nil)))) 
9462935011446529459)
pasf_smordtable2


(c!:install 'rat_leq '(rat_leq negsq addsq rat_sgn) 4872512845191832278)
rat_leq


(c!:install 'prload '(prload) 18162336246972013353)
prload


(c!:install 'dipcontenti '(dipcontenti !*groebrm dipcontenti1) 
6332376665279487617)
dipcontenti


(c!:install '!:log10 '(!:log10 not_found bften!* get!:const log!:
save!:const) 7733354448000993096)
!:log10


(c!:install 'monic '(monic lcof quotient aeval) 2125350396752250749)
monic


(c!:install 'pa_part2list '(pa_part2list upbve copy lastpair) 
1920806523503313950)
pa_part2list


(c!:install 'baglistp '(baglistp list bag) 16976112971610824149)
baglistp


(c!:install 'random!-small!-prime '(random!-small!-prime
small!-random!-number primep) 9679341110865623475)
random!-small!-prime


(c!:install 'acell_getsp '(acell_getsp nth) 13917821517315204692)
acell_getsp


(c!:install 'ofsf_smmkatl!-and '(ofsf_smmkatl!-and !*rlsipw !*rlsipo and
ofsf_irl2atl ofsf_ir2atl ofsf_smmkatl!-and1 lastpair) 
15202418740806621157)
ofsf_smmkatl!-and


(c!:install 'impartsq '(impartsq splitcomplex multsq negsq addsq invsq) 
3210318514076963511)
impartsq


(c!:install 'qqe_length!-graph!-neighbor!-edge '(
qqe_length!-graph!-neighbor!-edge) 2958539446646825932)
qqe_length!-graph!-neighbor!-edge


(c!:install 'ev_divides!? '(ev_divides!? ev_mtest!?) 1493885560001405582
)
ev_divides!?


(c!:install 'addexptsdf '(addexptsdf "X too long" "Y too long" nreverse
interr exptplus) 1213714791709377960)
addexptsdf


(c!:install 'mkunarywedge '(mkunarywedge nreverse) 17561137377864885515)
mkunarywedge


(c!:install 'newvar '(newvar "free variable" != typerr id2bytelist
bytelist2id) 3759729610965086259)
newvar


(c!:install 'endofstmtp '(endofstmtp cursym!* (!*semicol!* !*rsqbkt!*
end)) 7315433669680639686)
endofstmtp


(c!:install 'get!-all!-kernels '(get!-all!-kernels simp kernels union) 
5093584196795559363)
get!-all!-kernels


(c!:install 'evaluate!-in!-vector '(evaluate!-in!-vector) 
12859432698374091534)
evaluate!-in!-vector


(c!:install 'atree_rootcell '(atree_rootcell nth) 11382204984858785124)
atree_rootcell


(c!:install 'ofsf_anegrel '(ofsf_anegrel ((equal . equal) (neq . neq) (
leq . geq) (geq . leq) (lessp . greaterp) (greaterp . lessp))
"ofsf_anegrel: unknown operator " rederr) 5691787172200909886)
ofsf_anegrel


(c!:install 'mktag '(mktag texprec !\!( !\!) texexplode makefunc) 
16006631035263225041)
mktag


(c!:install 'makecoeffpairs '(makecoeffpairs makecoeffpairs1) 
757218381450057705)
makecoeffpairs


(c!:install 'pasf_leqp '(pasf_leqp minf pinf) 4630993796736544245)
pasf_leqp


(c!:install 'ldf!-deg '(ldf!-deg degreef maxl) 7875327071353158834)
ldf!-deg


(c!:install '!*ff2a '(!*ff2a wtl!* cancel prepsq mk!*sq) 
15086146504593339516)
!*ff2a


(c!:install 'groebcplistsort '(groebcplistsort groebcplistsortin) 
9083304943977416811)
groebcplistsort


(c!:install 'groebreduceonestepint '(groebreduceonestepint secondvalue!*
!*groebdivide !*groebprot vdpvars!* thirdvalue!* vdpred vevdif vbcfi
vbcgcd vbcquot vdpvbcprod vbcneg groebreductionprotocol vevmaptozero1
vdpilcomb1) 4658219020147169405)
groebreduceonestepint


(c!:install 'mk!-contract!-coeff '(mk!-contract!-coeff ndim!* mk!-numr
constimes) 17958584504185035815)
mk!-contract!-coeff


(c!:install 'isimp2 '(isimp2 cons g eps xnp dotsum esum isimp1 multf
appn gadd nb multd!*) 8588240526968828927)
isimp2


(c!:install 'derivative!-mod!-p '(derivative!-mod!-p
derivative!-mod!-p!-1) 10459348148582663089)
derivative!-mod!-p


(c!:install 'ofsf_bestgaussp '(ofsf_bestgaussp failed gignore lin con) 
8187982741908739180)
ofsf_bestgaussp


(c!:install 'taymindegreel '(taymindegreel nreverse tayexp!-plus2
tayexp!-min2) 14005103839088980420)
taymindegreel


(c!:install 'vdp_fdip '(vdp_fdip vdp_zero dip_lbc dip_evlmon vdp_make) 
4680168212571246300)
vdp_fdip


(c!:install 'ldf!-sep!-var '(ldf!-sep!-var ldf!-pow!-var ldf!-dep!-var
compl ldf!-spf!-var) 2549914095850826325)
ldf!-sep!-var


(c!:install 'sprow_dim '(sprow_dim !*fast_la
"Error in sprow_dim: input should be a matrix." matrixp rederr
spmatlength) 11838293185522517120)
sprow_dim


(c!:install 'dm!-lt '(dm!-lt dm!-difference !:minusp) 
8816706277676926929)
dm!-lt


(c!:install 'vdpsimpcont '(vdpsimpcont monfac dipsimpcont dip2vdp
evzero!? evtdeg vdpputprop) 13090543412159800981)
vdpsimpcont


(c!:install 'force!-to!-dm '(force!-to!-dm "number" dmode!*
"conversion error with " prepf typerr apply rederr) 1724544386227275857)
force!-to!-dm


(c!:install 'is_buble '(is_buble diff_vertex) 4718446988208433996)
is_buble


(c!:install 'positive!-powp '(positive!-powp (abs norm)) 
13879753600986516090)
positive!-powp


(c!:install 'reddom_zeros '(reddom_zeros) 14712597886441177874)
reddom_zeros


(c!:install 'red_prepare '(red_prepare bas_nr bas_dpoly bas_rep
dp_from_ei dp_sum bas_make1) 7814434015006136767)
red_prepare


(c!:install 'general!-difference!-mod!-p '(general!-difference!-mod!-p
general!-minus!-mod!-p general!-plus!-mod!-p) 14228395893305165229)
general!-difference!-mod!-p


(c!:install 'remainder!-mod!-p '(remainder!-mod!-p
"b=0 in remainder-mod-p" errorf xremainder!-mod!-p) 6513881754727781303)
remainder!-mod!-p


(c!:install 'ofsf_sippatl '(ofsf_sippatl true and false equal
!*rlsippsubst !*rlsiatadv !*rlsippsignchk cl_cflip ofsf_clnegrel
ofsf_exploitknowl ofsf_vareqnp ofsf_sippsubst ofsf_simplat1
sfto_varisnump ofsf_sippsignchk lto_insert) 15685455572427254218)
ofsf_sippatl


(c!:install 'constructinvolutivebasis '(constructinvolutivebasis
fluidbibasissetq fluidbibasisnonzeronormalforms fluidbibasissett
polynomlistautoreduce createtriple sortedtriplelistinsert setqget
normalform monomisdivisibleby setqdeletedescendants janettreedelete
createtriplewithancestor settinsert triplesetprolongset
settcollectnonmultiprolongations setqinsertlist sortedpolynomlistinsert)
 15826317613969295670)
constructinvolutivebasis



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u49.lsp"

Reading "$reduce/cslbuild/generated-c/u50.lsp"

% u50.lsp           Machine generated Lisp

(c!:install "u50" 111547 2521697 6761785)
nil


(c!:install 'ofsf_sminsert1 '(ofsf_sminsert1 false true negsq addsq
ofsf_smeqtable minusf ofsf_smordtable) 7042807841916849358)
ofsf_sminsert1


(c!:install 'opfchk!! '(opfchk!! integer !:rn!: !*numval dmode!* (!:rd!:
!:cr!:) !:rd!: simprn simparg simprd !*complex list expt !:cr!: alg
"is not defined as complex function" apply revlis simpcr rd!:minusp
rerror errorset2 errorp complexp intconv) 17814999030478090392)
opfchk!!


(c!:install 'get!*order '(get!*order get!*elements) 1961358405182470548)
get!*order


(c!:install 'talp_try2 '(talp_try2 cl_bvarl cl_fvarl talp_try3) 
2404501336677580567)
talp_try2


(c!:install 'reprod '(reprod multf) 1680435243969883784)
reprod


(c!:install 'groebmakepair '(groebmakepair !*gsugar vevlcm gsugar vevdif
vevtdeg max) 4704970316871433)
groebmakepair


(c!:install 'al1_defined_vertex '(al1_defined_vertex re_parents
defined_edge) 519817027080077876)
al1_defined_vertex


(c!:install 'coeffs!-to!-form1 '(coeffs!-to!-form1 to) 
17890572078723803509)
coeffs!-to!-form1


(c!:install 'freeoflist '(freeoflist freeof) 14086139525761355974)
freeoflist


(c!:install 'updkorder '(updkorder kord!* alglist!*) 7384907054091313147
)
updkorder


(c!:install 'ofsf_smwrmknowl '(ofsf_smwrmknowl !*rlsusi ofsf_susirmknowl
ofsf_smrmknowl) 4692894082393399308)
ofsf_smwrmknowl


(c!:install 'gd_simpl '(gd_simpl !*guardian !*rlnzden !*rladdcond
rl_simp rl_simpl rl_prepfof) 10364476088586607859)
gd_simpl


(c!:install '!*multsq '(!*multsq !*multf gcdf quotf!-fail minusf negf) 
9851859899492044261)
!*multsq


(c!:install 'talp_simplatfn '(talp_simplatfn equal neq and or talp_getl
talp_telp talp_simplt talp_mk2 talp_fop talp_fargl talp_simplat2) 
6220938308204958416)
talp_simplatfn


(c!:install 'qqe_length!-graph!-neighbors '(qqe_length!-graph!-neighbors
neighbors) 15934635560574021975)
qqe_length!-graph!-neighbors


(c!:install 'arprep!: '(arprep!: !*reexpress express!-in!-arvars prepf) 
11457261624739346880)
arprep!:


(c!:install 'make_wedge_pair '(make_wedge_pair !*twosided xtruncate!*
wedge_pair xval xlcm overall_factor mknwedge xdegreecheck) 
11385409692619205938)
make_wedge_pair


(c!:install 'coeff_sortl '(coeff_sortl coeff_ordn coeff_sortl1) 
15799877296695268259)
coeff_sortl


(c!:install 'rule!-list '(rule!-list frasc!* mcond!* list "rule list"
equal "Please use => instead of = in rules" replaceby "rule" when
algebraic typerr lprim remove!-free!-vars remove!-free!-vars!* formbool
rule!*) 14925885083637867660)
rule!-list


(c!:install 'df!-chain!-rule '(df!-chain!-rule df simp multsq addsq) 
5715389787073769380)
df!-chain!-rule


(c!:install 'cali_bc_power '(cali_bc_power exptf bc!=simp) 
2670688499088435073)
cali_bc_power


(c!:install 'test!-bool '(test!-bool boolean!-eval1 simp!-prop mk!*sq) 
8932349539925656937)
test!-bool


(c!:install 'pst_d1 '(pst_d1 sc_kern pa_coinc_split ordn) 
14917182381630739938)
pst_d1


(c!:install 'dnform '(dnform e dnform1) 6931039935746521334)
dnform


(c!:install 'count!-linear!-factors!-mod!-p '(
count!-linear!-factors!-mod!-p linear!-factors dpoly poly!-vector
current!-modulus make!-x!-to!-p copy!-vector gcd!-in!-vector
quotfail!-in!-vector) 13301651501611471653)
count!-linear!-factors!-mod!-p


(c!:install 'ofsf_smdbgetrel '(ofsf_smdbgetrel) 3992396472067234109)
ofsf_smdbgetrel


(c!:install 'qqe_length!-graph!-marked '(qqe_length!-graph!-marked
blockmark) 1172609336130959371)
qqe_length!-graph!-marked


(c!:install 'pasf_dnf '(pasf_dnf and dnf pasf_puregconp pasf_pnf
pasf_pbnf) 15208486177393031025)
pasf_dnf


(c!:install 'division!-test '(division!-test quotf) 7457882569290507332)
division!-test


(c!:install 'ldf!-spf!-var '(ldf!-spf!-var x u kernels makeset prlist
sacar appends) 2160313964912260152)
ldf!-spf!-var


(c!:install 'dipreplus '(dipreplus plus) 6843528938903311371)
dipreplus


(c!:install 'ratmean '(ratmean ratplusm) 13316605428599453302)
ratmean


(c!:install 'indordlp '(indordlp indordp) 10004274357578542948)
indordlp


(c!:install 'simp!-prop!-form '(simp!-prop!-form (nil) !'true not_prop!*
not !'and !'or) 3505596857183068138)
simp!-prop!-form


(c!:install 'can_rep_cell '(can_rep_cell) 15670187556956593219)
can_rep_cell


(c!:install 'even_action_pow '(even_action_pow to component_action
multsq find_active_components diffp addsq) 4093906823777950090)
even_action_pow


(c!:install 'quotf!* '(quotf!* "DIVISION FAILED" quotf rationalizesq
errach) 5639812097743456829)
quotf!*


(c!:install 'talp_cocc '(talp_cocc) 1370978426573660718)
talp_cocc


(c!:install 'sfto_deggcd1 '(sfto_deggcd1) 6311198043120278180)
sfto_deggcd1


(c!:install 'vdpfmon '(vdpfmon vdp !*gsugar vevtdeg gsetsugar) 
223532249635937953)
vdpfmon


(c!:install 'xexptpf '(xexptpf wedgepf) 11225990668432378292)
xexptpf


(c!:install 'latexprint '(latexprint prinlabegin latexprin prinlaend) 
1824421567986552037)
latexprint


(c!:install 'denlist '(denlist nreverse ev!-denom2 ev!-denom3) 
10869545544147735135)
denlist


(c!:install 'hdiff '(hdiff hdiffterm fs!:plus) 16897863673431883770)
hdiff


(c!:install 'eval!-yetunknowntypeexpr '(eval!-yetunknowntypeexpr !*sq
!:dn!: yetunknowntype getrtype) 16027293666846484104)
eval!-yetunknowntypeexpr


(c!:install 'gigcd!: '(gigcd!: gizerop!: fqa giremainder) 
7630160909363877681)
gigcd!:


(c!:install 'matrix_input_test '(matrix_input_test mat "ERROR: `"
"' is non matrix input." rederr) 4007855338312678546)
matrix_input_test



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u50.lsp"

Reading "$reduce/cslbuild/generated-c/u51.lsp"

% u51.lsp           Machine generated Lisp

(c!:install "u51" 10910 47199 2836573)
nil


(c!:install 'symmetrize!-inds '(symmetrize!-inds nth indordn indordln
flatindl pair) 2360766767333337586)
symmetrize!-inds


(c!:install 'combin '(combin) 6188018515752389102)
combin


(c!:install 'dv_skelsplit '(dv_skelsplit list !~dv !* symtree !+
antisymmetric !- !~dva idcons_ordp listp dummyp max st_sorttree
dv_skelsplit1 st_consolidate) 17835299216557388271)
dv_skelsplit


(c!:install 'simpdot '(simpdot dotord mkvarg) 13792885305380750406)
simpdot


(c!:install 'coeff_totder '(coeff_totder all_mind_table!* i2m_jetspace!*
i2m_jetspace_odd!* letop idtomind nth cde_lassoc2) 5042501430904969717)
coeff_totder


(c!:install 'ofsf_smmkatl!-or1 '(ofsf_smmkatl!-or1 (lessp greaterp equal
) or ofsf_smmkat!-or2 ofsf_entry2at lastpair) 3420829671504393222)
ofsf_smmkatl!-or1


(c!:install 'change!+sq!+to!+int '(change!+sq!+to!+int
"no integer in change!+sq!+to!+int" prepsq simp!* rederr) 
11238142442414323586)
change!+sq!+to!+int


(c!:install 'qqe_simplqequal '(qqe_simplqequal true qepsilon false
qequal qqe_arg2r qqe_arg2l qqe_qprefix!-var
qqe_number!-of!-adds!-in!-qterm qqe_number!-of!-tails!-in!-qterm
qqe_simplterm qqe_mk2) 2927715472686800828)
qqe_simplqequal


(c!:install 'acfsf_varlat '(acfsf_varlat acfsf_arg2l kernels) 
3942176160301289890)
acfsf_varlat


(c!:install 'gb_buchcrit4t '(gb_buchcrit4t ev_disjointp) 
16397767877925019400)
gb_buchcrit4t


(c!:install 'transferrow1 '(transferrow1 codmat maxvar) 
5971399830087691577)
transferrow1


(c!:install 'vdpmember '(vdpmember vdpequal) 8126623404930661228)
vdpmember


(c!:install 'exptbf '(exptbf csl_timbf lshift) 8829827129529104822)
exptbf


(c!:install 'preproc '(preproc preproc1) 2399640409246907490)
preproc


(c!:install 'coeff1_calc '(coeff1_calc nreverse calc_coeffmap_) 
15732296808858211155)
coeff1_calc


(c!:install 'subs2chkex '(subs2chkex subs2chk) 4517560909162540544)
subs2chkex


(c!:install 'red_redpol '(red_redpol !*red_total red_prepare
red_totalred red_topred red_extract) 9464429379661830263)
red_redpol


(c!:install 'ofsf_smmkatl!-or '(ofsf_smmkatl!-or or ofsf_ir2atl
ofsf_smmkatl!-or1 lastpair) 1775478292988938837)
ofsf_smmkatl!-or


(c!:install 'simp!-sign2 '(simp!-sign2 sign rd!-sign simpiden) 
17273752521537108984)
simp!-sign2


(c!:install 'talp_try1 '(talp_try1 true false or and talp_rnf talp_atfp
talp_op talp_argl cl_nnfnot talp_try2 cl_simpl) 18378002882174921029)
talp_try1


(c!:install 'tchscheme '(tchscheme rowmax codmat maxvar transferrow
chscheme) 8755550966450153547)
tchscheme


(c!:install 'cos!* '(cos!* !:bprec!: cos!:) 10648388374146150234)
cos!*


(c!:install 'requote1 '(requote1 (nil t) quote list) 1995016711071816972
)
requote1


(c!:install 'store_edges '(store_edges) 8426183693797107597)
store_edges


(c!:install 'normmat '(normmat lcm quotf multf) 1653959013059661494)
normmat


(c!:install 'extract_numid '(extract_numid !*id2num) 
17844419327560288190)
extract_numid


(c!:install 'eval_uni_poly '(eval_uni_poly) 6078601229241481536)
eval_uni_poly


(c!:install 'exports '(exports exportslist!* union) 10515641968720128232
)
exports


(c!:install 'smt_liter '(smt_liter (!~ !! !@ !$ !% !^ !& !* !_ !- !+ !=
!< !> !. !? !/ !:)) 4415757495831977008)
smt_liter


(c!:install 'giprim '(giprim i times) 8790229893788072726)
giprim


(c!:install 'qqe_prefix!-length '(qqe_prefix!-length (rtail ltail rhead
lhead)) 1891945703389096981)
qqe_prefix!-length


(c!:install 'rl_simplb '(rl_simplb rl_simplb!* apply) 
7197064830390758941)
rl_simplb


(c!:install 'intconv '(intconv dmode!* (!:rd!: !:cr!:)) 
12045065025164598034)
intconv


(c!:install 'splitrec '(splitrec list!-pq multf addf) 
14915310745069651795)
splitrec


(c!:install 'f2dip2 '(f2dip2 dipvars!* evinsert to multsq f2dip1) 
7346907586331285505)
f2dip2


(c!:install 'xpartitk '(xpartitk (wedge partdf) memqcar reval xpartitop)
 12829369561745651506)
xpartitk


(c!:install 'sqprla '(sqprla prepsq!* maprintla) 13712036929237112709)
sqprla


(c!:install 'physop!*sq '(physop!*sq physop !*q2a !*collectphysops) 
10075154655632502267)
physop!*sq


(c!:install 'precision1 '(precision1 !!rdprec !*roundbf minprec!#
!:prec!: !:print!-prec!: !:bprec!: !:rd!: epsqrt!* rd!-tolerance!*
cr!-tolerance!* !!flprec !*!*roundbf rmsubs max decprec2internal) 
14929182774852078873)
precision1


(c!:install 'merge_lists '(merge_lists reversip2) 10914131982876991318)
merge_lists


(c!:install 'update_components '(update_components) 7941079195352256761)
update_components


(c!:install 'ofsf_irl2atl '(ofsf_irl2atl ofsf_ir2atl lastpair) 
6610879085232105334)
ofsf_irl2atl


(c!:install 'ofsf_evalatp '(ofsf_evalatp equal neq leq geq lessp
greaterp "ofsf_evalatp: unknown operator " minusf rederr) 
6454550597136181537)
ofsf_evalatp



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u51.lsp"

Reading "$reduce/cslbuild/generated-c/u52.lsp"

% u52.lsp           Machine generated Lisp

(c!:install "u52" 129220 4952234 7549015)
nil


(c!:install 'mk_resimp_rep '(mk_resimp_rep get_group_in get!*elements
get_rep_matrix_in mk!+resimp!+mat) 8996840146166686658)
mk_resimp_rep


(c!:install 'bc_minus!? '(bc_minus!? minusf) 13892838142220692503)
bc_minus!?


(c!:install 'expttermp '(expttermp expt expttermp1) 18192048704841883576
)
expttermp


(c!:install 'expvec2a1 '(expvec2a1 expt nreverse) 3707321210302595183)
expvec2a1


(c!:install 'multsqpf '(multsqpf nreverse multsq) 10980860386620252559)
multsqpf


(c!:install 'rand!-mons!-sparse '(rand!-mons!-sparse binomial min
rand!-comb !*kp2f inttovec multf) 1302733689150682916)
rand!-mons!-sparse


(c!:install 'exp!* '(exp!* !:bprec!: exp!:) 18040129415916644653)
exp!*


(c!:install 'atlas_edges '(atlas_edges map__edges den__edges union_edges
coeff_edges) 8039082428745456416)
atlas_edges


(c!:install 'actual_arguments '(actual_arguments list generic_function) 
10022761296659648807)
actual_arguments


(c!:install 'dp!=comp '(dp!=comp nreverse dp_lmon mo_comp) 
14670774762518676824)
dp!=comp


(c!:install 'rl_identifyonoff '(rl_identifyonoff rl_identifyonoff!*
apply) 264122958181467562)
rl_identifyonoff


(c!:install 'addfactors '(addfactors times prepf aconc!* retimes) 
9069149108209877443)
addfactors


(c!:install 'rule!* '(rule!* frasc!* mcond!* old newrule!* rtype props!*
avalue expt asymplis!* updoldrules rule) 15917324397672373224)
rule!*


(c!:install 'constant_exprp '(constant_exprp constant i realvalued
alwaysrealvalued (plus minus difference times quotient) !:rd!: !*complex
!:cr!: constant_expr_listp) 18109207819067230144)
constant_exprp


(c!:install 'pasf_smordtable1 '(pasf_smordtable1 ((lessp (lessp 1) (leq
1) (equal false) (neq 1) (geq false) (greaterp false) (cong nil) (ncong
nil)) (leq (lessp 1) (leq 1) (equal false) (neq 1) (geq false) (greaterp
false) (cong nil) (ncong nil)) (equal (lessp 1) (leq 1) (equal false) (
neq 1) (geq false) (greaterp false) (cong nil) (ncong nil)) (neq (lessp
nil) (leq nil) (equal 2) (neq nil) (geq 2) (greaterp 2) (cong nil) (
ncong nil)) (geq (lessp nil) (leq nil) (equal 2) (neq nil) (geq 2) (
greaterp 2) (cong nil) (ncong nil)) (greaterp (lessp nil) (leq nil) (
equal 2) (neq nil) (geq 2) (greaterp 2) (cong nil) (ncong nil)))) 
7103508956278523470)
pasf_smordtable1


(c!:install 'ps!:difference!-erule '(ps!:difference!-erule ps!:evaluate
negsq addsq) 16135774197856350921)
ps!:difference!-erule


(c!:install 'getvariables '(getvariables varsinsf) 11726400517569850811)
getvariables


(c!:install 'gbftimes '(gbftimes csl_timbf difbf plubf) 
6762068369789808492)
gbftimes


(c!:install 'r2oreaction '(r2oreaction times expt difference plus aeval
reval) 13610110260629005727)
r2oreaction


(c!:install 'binc '(binc mk!-numr constimes factorial listquotient) 
14077582727497147310)
binc


(c!:install 'dp_2a '(dp_2a dp!=2a dp!=replus) 18083363694407178011)
dp_2a


(c!:install 'cde_list2id '(cde_list2id
"argument for cde_list2id must be a list" rederr lastpair) 
14000377831304568398)
cde_list2id


(c!:install 'subdf '(subdf subf subs2q !*multf plusdf) 
2743108251233153828)
subdf


(c!:install 'talp_mk!-invs '(talp_mk!-invs talp_mkinvop) 
5785843035114066455)
talp_mk!-invs


(c!:install 'qqe_dfs '(qqe_dfs) 5543017835140133068)
qqe_dfs


(c!:install 'i2ps '(i2ps) 5840660322852784483)
i2ps


(c!:install 'ldf!-pow!-var '(ldf!-pow!-var x u kernels makeset prlist) 
14977998401672650340)
ldf!-pow!-var


(c!:install 'fast!-augment!-columns '(fast!-augment!-columns
fast!-row!-dim sc_getmat sc_iputv sc_getrow nth sc_igetv) 
13224245610267281169)
fast!-augment!-columns


(c!:install 'decimal2internal '(decimal2internal !:rd!:
divide!-by!-power!-of!-ten) 14631323547991593864)
decimal2internal


(c!:install 'dvertex!-to!-projector '(dvertex!-to!-projector mktails
repeatsp prop!-simp mk!-contract!-coeff dpropagator) 6329309849721072789
)
dvertex!-to!-projector


(c!:install 'clogsq '(clogsq clogf) 12458012163820066603)
clogsq


(c!:install 'lf!=tovarlessp '(lf!=tovarlessp mo_compare) 
18012836837064206136)
lf!=tovarlessp


(c!:install 'dummy_nam '(dummy_nam symbolic g_dvnames ordn list2vect!*) 
13516216293254312689)
dummy_nam


(c!:install 'st_extract_symcells1 '(st_extract_symcells1 !* listp) 
9261528819786944218)
st_extract_symcells1


(c!:install 'mod!/ '(mod!/ current!-modulus general!-reciprocal!-by!-gcd
) 18103756201143973339)
mod!/


(c!:install 'cr2rderr '(cr2rderr
"complex to real type conversion requires zero imaginary part" error) 
11159384114148402351)
cr2rderr


(c!:install 'quotfexf!*1 '(quotfexf!*1 !*rationalize matrix
"Catastrophic division failure" quotf rationalizesq rerror) 
11249899643196219485)
quotfexf!*1


(c!:install 'texexplode '(texexplode texname !  texcollect strcollect
texexplist) 4644564349813911594)
texexplode


(c!:install 'dip_monp '(dip_monp) 602049357356881825)
dip_monp


(c!:install 'parseml '(parseml space count ch temp2 char (m a t h)
"<math>" (!/ m a t h) "</math>" list2string lex mathml errorml aeval) 
10857081456934169098)
parseml


(c!:install 'mkratnum '(mkratnum !:gi!: !:crn!: !:rn!: !*i2rn) 
4938996573169262951)
mkratnum


(c!:install 'poly!-remainder '(poly!-remainder remainder poly!-divide!*)
 6768570781226289743)
poly!-remainder


(c!:install 'xpartitsq '(xpartitsq sfp xexptpf cancel wedgepf xvarp
xpartitk multpfsq addpf) 3770491268411413216)
xpartitsq


(c!:install 'acmemb '(acmemb aceq) 13271867179498849625)
acmemb


(c!:install 'redassignp '(redassignp setq redassign1p) 
11307624572096717668)
redassignp


(c!:install 'adjp '(adjp unit adjoint comm anticomm) 7425062376879180506
)
adjp


(c!:install 'calc_world '(calc_world s_world_names actual_alst
calc_atlas reval) 6347126962586917981)
calc_world


(c!:install '!*sq2fourier '(!*sq2fourier cos fourier tag
fs!:make!-nullangle) 5891675253994263450)
!*sq2fourier


(c!:install '!*v2j '(!*v2j ordering lex varlist!* sub01) 
1976701608171549133)
!*v2j


(c!:install 'ic_taglist '(ic_taglist) 13395911804679478804)
ic_taglist


(c!:install 'initmonomials '(initmonomials fluidbibasisvariables
fluidbibasisnumberofvariables fluidbibasissinglevariablemonomialss
fluidbibasistripleid createsinglevariablemonom) 16303829755948409025)
initmonomials


(c!:install 'depend!-p '(depend!-p !*sq depend!-f depend!-sq depend!-l) 
8314922715292353285)
depend!-p


(c!:install 'ofsf_simpat '(ofsf_simpat !*rlnzden !*rlposden
"atomic formula" !*rladdcond (lessp leq greaterp geq) and greaterp neq
simp typerr negsq addsq multf) 16117239508109601768)
ofsf_simpat


(c!:install 'force!-lc '(force!-lc) 17754422174457067786)
force!-lc


(c!:install 'simpsqrt2 '(simpsqrt2 gaussiani minusf iequal negf
simpsqrt3 multf) 13180318253061721077)
simpsqrt2


(c!:install 'cr!:zerop '(cr!:zerop !:rd!:) 6552380167070519668)
cr!:zerop


(c!:install 'varsinsf '(varsinsf union) 15554101783376022867)
varsinsf


(c!:install 'row_dim '(row_dim !*fast_la
"Error in row_dim: input should be a matrix." matrixp rederr
size_of_matrix) 16864272506304451716)
row_dim


(c!:install 'xpndwedge '(xpndwedge partitop mkunarywedge wedgepf2) 
3250510587247370634)
xpndwedge


(c!:install 'find_bubles_coeff '(find_bubles_coeff find_bubles1_coeff) 
2751637220975430738)
find_bubles_coeff


(c!:install 'lf!=less '(lf!=less cali varlessp lf!=lvar) 
16141227712057728171)
lf!=less


(c!:install 'general!-negate!-term '(general!-negate!-term
general!-minus!-mod!-p) 16591824657730650749)
general!-negate!-term


(c!:install 'allbkern '(allbkern kernels basic!-kern union) 
514249563188008739)
allbkern



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u52.lsp"

Reading "$reduce/cslbuild/generated-c/u53.lsp"

% u53.lsp           Machine generated Lisp

(c!:install "u53" 92302 6804259 9274664)
nil


(c!:install 'ofsf_sminsert '(ofsf_sminsert false true ofsf_sminsert1
setcdr) 18000105277674831219)
ofsf_sminsert


(c!:install 'addinds '(addinds "Powrhs too long" "Powu too long"
nreverse interr) 8783814793223218724)
addinds


(c!:install 'multtaylorsq '(multtaylorsq taylor!* !*taylorkeeporiginal
multsq subs2!* resimp) 9919477787510602169)
multtaylorsq


(c!:install 'talp_nextt '(talp_nextt talp_getl talp_mk!-invs lastpair
talp_list2vec talp_invp talp_nextt1) 6462205596091280055)
talp_nextt


(c!:install 'qqe_length!-graph!-bterm '(qqe_length!-graph!-bterm (lhead
rhead) qqe_op qqe_length!-graph!-bterm!-update!-headmin) 
14798580470036677714)
qqe_length!-graph!-bterm


(c!:install '!*kp2q '(!*kp2q "Zero divisor" mksq rederr revpr) 
3599326762998707582)
!*kp2q


(c!:install 'physopplus '(physopplus "type mismatch in plus "
physopsim!* getphystype rederr2 physop2sq addsq mk!*sq) 
16067418966038295158)
physopplus


(c!:install 'mk!-strand!-vertex '(mk!-strand!-vertex incident
mk!-strand!-vertex2) 1642583444989583446)
mk!-strand!-vertex


(c!:install 'lchk '(lchk) 8834554188476547679)
lchk


(c!:install 'rationalizef '(rationalizef expt quotient i (quotient 1 2)
sqrt (quotient 1 3) (quotient 1 4) kernels lowertowerp mkmain
conjquadratic conjcubic conjquartic) 7151580781870530831)
rationalizef


(c!:install 'all_index_lst '(all_index_lst list listp) 
3654155541323541217)
all_index_lst


(c!:install 'bfprin0x '(bfprin0x bfexplode0x bfprin!:lst) 
18248937376260990662)
bfprin0x


(c!:install 'addcoeffs '(addcoeffs smallest!-increment common!-increment
makecoeffpairs multsq addsq) 15259186419355437484)
addcoeffs


(c!:install 'mrv_constantp '(mrv_constantp constant freeof) 
7453527344230814969)
mrv_constantp


(c!:install 'equal!+matrices!+p '(equal!+matrices!+p !*complex
same!+dim!+squared!+p mk!+scal!+mult!+mat mk!+mat!+plus!+mat
mk!+conjugate!+sq multsq addsq change!+sq!+to!+algnull) 
13192663332799596718)
equal!+matrices!+p


(c!:install 'bc_pmon '(bc_pmon to) 109842801484838358)
bc_pmon


(c!:install 'vevzero!?1 '(vevzero!?1) 10157384379837683846)
vevzero!?1


(c!:install 'remove_critical_pairs '(remove_critical_pairs remove_items)
 12426658889339854311)
remove_critical_pairs


(c!:install 'noncom1 '(noncom1 !*ncmp noncom) 11419460836052736216)
noncom1


(c!:install 'bassoc '(bassoc th_match) 16440937476530816831)
bassoc


(c!:install 'gak '(gak aconc) 12594716863303144844)
gak


(c!:install 'square!-free!-mod!-p '(square!-free!-mod!-p
derivative!-mod!-p gcd!-mod!-p) 11016584804240126921)
square!-free!-mod!-p


(c!:install 'sfto_b!:cquot '(sfto_b!:cquot nreverse quotf1) 
9581205324701258159)
sfto_b!:cquot


(c!:install 'operator '(operator mkop) 1409021900333175665)
operator


(c!:install 'tidysqrt '(tidysqrt tidysqrtf invsq multsq) 
17637639424542550931)
tidysqrt


(c!:install 'subscriptedvarp2 '(subscriptedvarp2 symtabget) 
2356643343232798268)
subscriptedvarp2


(c!:install 'expttermp1 '(expttermp1 expt) 16300050658521353563)
expttermp1


(c!:install 'dipcontenti1 '(dipcontenti1 vbcgcd dipcontevmin bcone!?) 
821378543249485162)
dipcontenti1


(c!:install 'evalsubset '(evalsubset subset evalsetbool evalsymsubset) 
18227868268543170902)
evalsubset


(c!:install 'all_defined '(all_defined map__edges defined_append
all_defined_map_) 6100698165411242067)
all_defined


(c!:install 'pa_vect2list '(pa_vect2list upbve ordn) 
17456351985825694030)
pa_vect2list


(c!:install 'lowestdeg '(lowestdeg expt "exponents must be integers"
simp!* !*q2f erase_pol_cst !*a2k setkorder reorder rederr) 
18356434283429461902)
lowestdeg


(c!:install 'rl_ex '(rl_ex rl_ex!* apply) 159967248458196071)
rl_ex


(c!:install 'ofsf_exploitknowl '(ofsf_exploitknowl equal !*rlsippsubst
greaterp geq lessp leq neq sfto_varp negsq lto_insertq) 
6407292417331235835)
ofsf_exploitknowl


(c!:install 'get!*nr!*real!*irred!*reps '(get!*nr!*real!*irred!*reps
realrepnumber) 6749148416422812882)
get!*nr!*real!*irred!*reps


(c!:install 'constant_expr_listp '(constant_expr_listp constant i
constant_exprp) 11204786086360299674)
constant_expr_listp


(c!:install 'qqe_simpat '(qqe_simpat) 9761063186935570134)
qqe_simpat


(c!:install 'ieval '(ieval reval !*s2i) 10970267165119146512)
ieval


(c!:install 'column_dim '(column_dim !*fast_la
"Error in column_dim: input should be a matrix." matrixp rederr
size_of_matrix) 9644095049462376249)
column_dim


(c!:install 'vdpappendmon '(vdpappendmon vdp vdpfmon vbczero!? dipsum) 
5462317633277046724)
vdpappendmon


(c!:install 'xriterion_2 '(xriterion_2 wedge_pair !*trxideal
"criterion 2 hit" last xdiv make_wedge_pair find_item writepri) 
5623418408247858791)
xriterion_2


(c!:install 'gffdot '(gffdot) 16874205848873527026)
gffdot


(c!:install 'r2speclist '(r2speclist plus r2speclist1) 
5879233124307570045)
r2speclist


(c!:install 'new_provev '(new_provev) 6302738449472206509)
new_provev


(c!:install 'dpmat_gbtag '(dpmat_gbtag nth) 7853934172546639414)
dpmat_gbtag


(c!:install 'general!-minus!-mod!-p '(general!-minus!-mod!-p nreverse
general!-modular!-minus) 12214029244195715542)
general!-minus!-mod!-p


(c!:install 'simprd '(simprd !:rd!: dmode!* simplist) 
15671832098548929442)
simprd


(c!:install 'cde_alglistp '(cde_alglistp list listp) 4533279857863766319
)
cde_alglistp


(c!:install 'find_active_components '(find_active_components depl!*
update_components) 15779492601999883025)
find_active_components


(c!:install '!*invsq '(!*invsq sqrtflag invsq sqrt2top) 
18396166173782830709)
!*invsq


(c!:install 'null!+vec!+p '(null!+vec!+p mk!+squared!+norm my!+nullsq!+p
) 9320904567712483426)
null!+vec!+p


(c!:install 'cl_strict!-gdnf '(cl_strict!-gdnf cl_strict!-gdnf1 rl_simpl
cl_mkstrict rl_bnfsimpl) 1349976826570922730)
cl_strict!-gdnf


(c!:install 'bc_abs '(bc_abs absf) 17823449427386136621)
bc_abs


(c!:install 'dip_comp1 '(dip_comp1 dip_evlmon ev_comp) 
15677524538554573974)
dip_comp1


(c!:install 'subsubf '(subsubf equal sub subsublis reversip!* aeval
aconc!* subeval mksp mk!*sq) 7039029750313157863)
subsubf


(c!:install 'deflate1 '(deflate1 ncoeffs times!: plus!:) 
4509771127112034283)
deflate1


(c!:install 'ev!-tades '(ev!-tades ndim!* nreverse binc) 
5470766975652506745)
ev!-tades


(c!:install 'restore_props '(restore_props props!*) 6152622342977608834)
restore_props


(c!:install 'sc_create '(sc_create symbolic list2vect!*) 
7753972097936331166)
sc_create



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u53.lsp"

Reading "$reduce/cslbuild/generated-c/u54.lsp"

% u54.lsp           Machine generated Lisp

(c!:install "u54" 80309 4310984 5630701)
nil


(c!:install 'rtrnda '(rtrnda rlval!# round!:dec1 decimal2internal) 
10001363363297517072)
rtrnda


(c!:install 'radd '(radd !*reduced i prepf nrootnn to multd) 
4883045765788106847)
radd


(c!:install 'coeffs!-to!-form '(coeffs!-to!-form coeffs!-to!-form1) 
4460287134275495432)
coeffs!-to!-form


(c!:install 'aex_psremseq '(aex_psremseq aex_mklcnt aex_divposcnt
aex_deg aex_psrem aex_neg aex_simplenullp) 1759062070613365367)
aex_psremseq


(c!:install 'rl_!*qe '(rl_!*qe rl_qe apply) 17173489639086840913)
rl_!*qe


(c!:install 'mkuniquewedge '(mkuniquewedge mkuniquewedge1 multpfsq addpf
) 6436937546738158185)
mkuniquewedge


(c!:install 'minprec '(minprec !*bftag !:prec!: !!nfpd) 
1602854570656589848)
minprec


(c!:install 'tvectorp '(tvectorp deg!*form) 2698767616585058183)
tvectorp


(c!:install 'ext_edges '(ext_edges !_0edge nreverse delete_edge) 
5784848160875481775)
ext_edges


(c!:install 'liendimcom '(liendimcom lie_dim difference lie_cc lie_p
lie_q plus quotient times lie_help lie_s lientrans lie_kk!* lie_tt aeval
setk aeval!* aminusp!: evalneq evalequal) 14036051703278256262)
liendimcom


(c!:install 'mo!=pair '(mo!=pair nreverse) 4859534959121366847)
mo!=pair


(c!:install 'gi '(gi gg!* class) 12570059923375073769)
gi


(c!:install '!*sf2exb '(!*sf2exb degr nreverse) 16721578175864221016)
!*sf2exb


(c!:install 'prepsqyy '(prepsqyy !*sq prepsqxx) 17138303528519497267)
prepsqyy


(c!:install 'ordexp '(ordexp ordop) 10875341827804411375)
ordexp


(c!:install 'cde_mkset '(cde_mkset nreverse) 13656224451752460396)
cde_mkset


(c!:install 'small!-random!-number '(small!-random!-number 1.0 1.5
1.0e+06 next!-random!-number exp) 11705891558564500348)
small!-random!-number


(c!:install 'ofsf_updsignpow '(ofsf_updsignpow (equal greaterp geq neq)
(lessp leq) unknown ofsf_canegrel) 12183535377953807471)
ofsf_updsignpow


(c!:install 'chrstrem '(chrstrem !*trwu !*trchrstrem
"--------------------------------------------------------"
"The new pol-set in ascending order is" "which is trivially trivial"
inconsistent "A basic set is" "The remainder of "
"wrt the basic set is " "which is a non-zero constant, and so"
"the equations are inconsistent." "The final characteristic set is:"
terpri!* prin2t!* wusort printsf wuconstantp pickbasicset setdiff
prin2!* findremainder prin2t absf union) 5892555042781459775)
chrstrem


(c!:install 'no_of_tm_sf '(no_of_tm_sf) 14650371380341364919)
no_of_tm_sf


(c!:install 'giminusp!: '(giminusp!:) 7111611823332749510)
giminusp!:


(c!:install 'qqe_qadd!-inside '(qqe_qadd!-inside a qqe_qadd!-location!*
d qqe_op qqe_qopaddp) 16452016970455392057)
qqe_qadd!-inside


(c!:install 'dip_reduceconti '(dip_reduceconti dip_lbc bc_quot
dip_evlmon dip_mred dip_moncomp) 12536364206078477054)
dip_reduceconti


(c!:install 'crprimp '(crprimp i minus times) 17061817778349731192)
crprimp


(c!:install 'rewrite2 '(rewrite2) 494596473675394549)
rewrite2


(c!:install 'weak_xreduce '(weak_xreduce !*trxmod " =" last "   " first
preppf writepri weak_xreduce1) 14660389791441603175)
weak_xreduce


(c!:install 'rand!-comb '(rand!-comb random) 9507653342872797240)
rand!-comb



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u54.lsp"

Reading "$reduce/cslbuild/generated-c/u55.lsp"

% u55.lsp           Machine generated Lisp

(c!:install "u55" 84207 3657721 4602479)
nil


(c!:install 'partitindexvar '(partitindexvar minus metricu!* covariant
indxsymmetries revalind !*num2id deg!*form getlower simp multpfsq addpf
getupper coposp mkupf mksq indexsymmetrize negsq) 15859767580377981061)
partitindexvar


(c!:install 'mk!-coeff1 '(mk!-coeff1 times getroad factorial eval) 
4284856049728081327)
mk!-coeff1


(c!:install 'modroots1 '(modroots1 g plus times modroots2 subf
reduce!-mod!-p!* modp) 12220486894174093238)
modroots1


(c!:install 'mkg1 '(mkg1 nospur g mksf) 10874375751637765688)
mkg1


(c!:install 'gd_newtype '(gd_newtype gec geg ger) 4854955074096824815)
gd_newtype


(c!:install 'dfmax '(dfmax dfrel) 5932994387667960604)
dfmax


(c!:install 'uterm '(uterm rhs!* addinds evaluatecoeffts plusdf) 
5304631242153271363)
uterm


(c!:install 'talp_try3 '(talp_try3 true false and equal talp_atfp
talp_argl talp_op talp_arg2l talp_arg2r talp_contains talp_td
talp_extlftrs talp_chsbstres talp_try1 talp_rnf) 5507210192899200995)
talp_try3


(c!:install 'simpsqrt3 '(simpsqrt3 listofallsqrts listofnewsqrts
knowntobeindep actualsimpsqrt) 4810146213398586859)
simpsqrt3


(c!:install 'ps!:value '(ps!:value !:ps!: ps!:getv) 8457495156308057488)
ps!:value


(c!:install 'setprev '(setprev codmat maxvar) 10823251145123251282)
setprev


(c!:install 'gvarlis '(gvarlis ordop gvarlis1 sort) 701878123664886157)
gvarlis


(c!:install 'xreduce1 '(xreduce1 weak_xreduce1 nreverse) 
11959619420246598109)
xreduce1


(c!:install 'calc_map_tar '(calc_map_tar ev!-poles constimes ev!-tades
strand!-alg!-top) 4380444771427007829)
calc_map_tar


(c!:install '!*ex2sf '(!*ex2sf nreverse subs2chk to) 
11567801212848725998)
!*ex2sf


(c!:install 'red_extract '(red_extract bas_rep dp_comp bas_nr bas_dpoly
dp_diff bas_make1) 18351211877572852818)
red_extract


(c!:install '!*hfac '(!*hfac avector "Invalid index" hfactors rerror
getavalue) 10654156801179525459)
!*hfac


(c!:install 'sep_tens_from_other '(sep_tens_from_other translate1 !*n2f
multf fullcopy setcar tensorp no_dum_varp) 13688086569006268499)
sep_tens_from_other


(c!:install 'sqlessp '(sqlessp negsq addsq !:minusp) 
17809746572932323716)
sqlessp


(c!:install 'generate_multiindex '(generate_multiindex n_indep_var nth
cde_replace_nth) 12093244824212738996)
generate_multiindex


(c!:install 'sfto_mindeg1 '(sfto_mindeg1) 14523690705715977540)
sfto_mindeg1


(c!:install 'cl_ex '(cl_ex ex cl_closure) 11384483825904126705)
cl_ex


(c!:install 'ofsf_canegrel '(ofsf_canegrel ofsf_anegrel) 
15037791649800802071)
ofsf_canegrel


(c!:install 'get_rep_of_generator '(get_rep_of_generator id
" error in get rep of generators" get!+row!+nr mk!+unit!+mat rederr) 
17062428417663879104)
get_rep_of_generator


(c!:install 'rl_reval '(rl_reval rl_simp1 rl_prepfof rl_mk!*fof) 
14443807258000341238)
rl_reval


(c!:install 'pasf_univnlp '(pasf_univnlp setkorder reorder) 
16237862166288005420)
pasf_univnlp


(c!:install 'remk '(remk degr multf negf to addf) 6335627113382538221)
remk


(c!:install 'irp_aex '(irp_aex nth) 9099467238542619998)
irp_aex


(c!:install 'mod!-domainvalchk '(mod!-domainvalchk expt failed
mod!-expt!-fract) 3596140922650879438)
mod!-domainvalchk


(c!:install 'remove_root_item '(remove_root_item setcar setcdr) 
10602874536531986244)
remove_root_item


(c!:install 'calc_map_2d '(calc_map_2d mk_names_map_2 mk_binding
coeff_calc) 4378061536774923404)
calc_map_2d


(c!:install 'depend1 '(depend1 depl!* "has no prior dependence on" !*a2k
union repasc lprim) 1640192312911088508)
depend1


(c!:install 'zfactor '(zfactor zfactor1) 2511242439935552506)
zfactor


(c!:install 'simprad '(simprad !*reduced !*rationalize quotient
!*precise radfa invsq multsq exptf multf radf minusf negf retimes simp
prepf mkrootsq negsq prepsq) 3068384987609076058)
simprad


(c!:install 'crn!:zerop '(crn!:zerop) 14471836097984589314)
crn!:zerop


(c!:install 'imports '(imports importslist!* union) 14856359103180957613
)
imports


(c!:install 'monomispommaretdivisibleby '(monomispommaretdivisibleby) 
15831018813323069051)
monomispommaretdivisibleby


(c!:install 'talp_raf '(talp_raf equal neq and or talp_op talp_arg2l
talp_tcfrp talp_arg2r talp_getinvfsym talp_mkinv talp_mk2 talp_simpat
talp_getl talp_fargl nth talp_rnf1 talp_mkn) 15957899528406532110)
talp_raf



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u55.lsp"

Reading "$reduce/cslbuild/generated-c/u56.lsp"

% u56.lsp           Machine generated Lisp

(c!:install "u56" 56422 5399638 6265814)
nil


(c!:install 'search_att '(search_att (stop) !  != !" !$ find2 errorml) 
44845976647922481)
search_att


(c!:install 'mo_from_ei '(mo_from_ei mo_zero mo!=deglist) 
602087789336090225)
mo_from_ei


(c!:install 'boolean!-eval2 '(boolean!-eval2 boolean and or not !*protfg
algebraic bool!-break!* erfg!* formbool errorset errorp) 
13535939763071878538)
boolean!-eval2


(c!:install 'distri_pol '(distri_pol addfd multf) 13109417853935887981)
distri_pol


(c!:install 'aex_xtothen '(aex_xtothen sfto_kexp ctx_new aex_mk) 
4843311709874545003)
aex_xtothen


(c!:install 'get!-min!-degreelist '(get!-min!-degreelist confusion
tayexp!-plus2 taymindegreel) 8744899286662908442)
get!-min!-degreelist


(c!:install 'available!*p '(available!*p "this is no group identifier"
available rederr) 3388754601504852178)
available!*p


(c!:install 'talp_get!-minfct '(talp_get!-minfct talp_invp talp_fop
talp_mktn) 10298220219146545044)
talp_get!-minfct


(c!:install 'mri_irsplit '(mri_irsplit floor to simp mri_simplfloor
mri_irsplit1 prepf !*a2k) 11148388974111862795)
mri_irsplit


(c!:install 'subsqnew '(subsqnew prepsq subf quotsq) 
12642540119680760180)
subsqnew


(c!:install 'implicitdec '(implicitdec !*decs!* symtabget isimplicit
firstmatch implicittype) 7614714412425999913)
implicitdec


(c!:install 'bccheckz '(bccheckz !*bcsubs2 bczerodivl!* subs2 qremf) 
5935526042975367298)
bccheckz


(c!:install 'xnormalise '(xnormalise invsq multpfsq) 
11085071778112155648)
xnormalise


(c!:install 'unshift '(unshift !*xo (0.0 . 0.0) gfplus gfadjust) 
18342691400931012398)
unshift


(c!:install 'simpabs '(simpabs abs revlis mksq sign!-abs simp!* simpabs1
quotsq) 3087722267708201599)
simpabs


(c!:install '!*sf2ex '(!*sf2ex nreverse) 12934913102930594307)
!*sf2ex


(c!:install 'compactf3 '(compactf3 mv!-vars!* sf2mv mv!-compact mv2sf) 
10919652603236884479)
compactf3


(c!:install 'extodd '(extodd ext
"the argument of extodd must be an ext variable" n_all_parametric_ext
all_principal_odd!* all_parametric_odd!* rederr nth) 5870015481548055222
)
extodd


(c!:install 'ofsf_facneq!* '(ofsf_facneq!* !*rlsifac !*rlsiexpla
!*rlsiexpl and neq ofsf_facneq) 9484445756966266993)
ofsf_facneq!*


(c!:install 'cl_subfof1 '(cl_subfof1 true false ex all bex ball or and
not impl repl equiv lastpair cl_newv cl_subvarsubstat rl_subat) 
13040601500932645714)
cl_subfof1


(c!:install 'applyml '(applyml char rdlist!* (i d e n t !/) (c o m p o s
e !/) (i n v e r s e !/) lex compress!* apply errorml) 
3404595783190816155)
applyml


(c!:install 'product!-set2 '(product!-set2) 5753609067411079214)
product!-set2


(c!:install 'dip!-nc!-m!*p!-distleft '(dip!-nc!-m!*p!-distleft
dip!-nc!-ev!-prod dipsum) 14884225942062731859)
dip!-nc!-m!*p!-distleft


(c!:install 'vdplsortin '(vdplsortin vdplsortin1) 7299351269199537602)
vdplsortin


(c!:install 'validrule '(validrule validrule1) 2742724852769084751)
validrule


(c!:install 'preproc1 '(preproc1 !:rd!: !:dn!: !*sq procedure !*params!*
!*getdecs (real integer) deftype!* declare (subroutine function)
!*type!* setq (cond progn) (plus times difference quotient minus) (
!:cr!: !:crn!: !:gi!:) quotient (!~for for) (integer) fl2bf read!:num
normbf decimal2internal prepsq symtabput lastpair preprocdec
migrate!-setqs simp!*) 6528805567621417354)
preproc1


(c!:install 'basisvectorp '(basisvectorp basisvectorl!*) 
18044454894974143165)
basisvectorp


(c!:install 'new_edge '(new_edge new_edge_list mk_edge_name) 
17926538594436632476)
new_edge


(c!:install 'solvevars '(solvevars allbkern constant_exprp ordad) 
15451545184830350089)
solvevars


(c!:install 'rlval '(rlval !:rd!: !:bprec!: r2flbf ncoeffs times!:
plus!: inorm) 7083699386214399275)
rlval


(c!:install 'ra_i2ra '(ra_i2ra ra_i2ra0 ra_wrapper) 12117492331715179625
)
ra_i2ra



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u56.lsp"

Reading "$reduce/cslbuild/generated-c/u57.lsp"

% u57.lsp           Machine generated Lisp

(c!:install "u57" 37636 8344457 1915989)
nil


(c!:install 'gcdlist1 '(gcdlist1 reduction!-count lesspcdr vunion
vintersection vdelete sort mapcarcar setkorder reorder gcdlist3 gcdlist2
split!-wrt!-variables total!-degree!-in!-powers) 10504323934466736076)
gcdlist1


(c!:install 'preptaylor!*!* '(preptaylor!*!* convert!-taylor!*
preptaylor!*) 2636884274083186405)
preptaylor!*!*


(c!:install 'ev_2f '(ev_2f iequal to multf) 17482014940251731800)
ev_2f


(c!:install 'redpar '(redpar) 16185300438157177557)
redpar


(c!:install 'cr!:minusp '(cr!:minusp) 1518570810801810726)
cr!:minusp


(c!:install 'vdpenumerate '(vdpenumerate number pcount!* vdpsave
vdpgetprop vdpputprop) 11111691383406042490)
vdpenumerate


(c!:install 'listofvarnames '(listofvarnames
"invalid argument to listofvarnames" free listp rederr domain!*p) 
14668539973731296408)
listofvarnames


(c!:install 'p_eq_vertex '(p_eq_vertex) 7973572559622386248)
p_eq_vertex


(c!:install 'intargfn '(intargfn integer list algebraic convertmode
form1 reversip!*) 11697267623635908172)
intargfn


(c!:install 'fillin '(fillin fillin1) 10080940669004967705)
fillin


(c!:install 'compactf1 '(compactf1 intersection compactf11) 
6316266038581973281)
compactf1


(c!:install 'tensor_has_dummy_idx '(tensor_has_dummy_idx smember) 
3965533702827161558)
tensor_has_dummy_idx


(c!:install 'cdr_signsort '(cdr_signsort copy apply) 
13787353986175638556)
cdr_signsort


(c!:install 'x!*!*p!-w '(x!*!*p!-w to general!-difference!-mod!-p) 
5260913038693974719)
x!*!*p!-w


(c!:install 'uniquifyf '(uniquifyf uniquifyk) 3625876549047266440)
uniquifyf


(c!:install 'add!-to!-sorted!-tree '(add!-to!-sorted!-tree nreverse) 
16019473893027424821)
add!-to!-sorted!-tree


(c!:install 'getsetvarlis '(getsetvarlis "getsetvarlis" (setel setk)
setq nreverse errach) 10814118241406422205)
getsetvarlis


(c!:install 'gd_applyscheme '(gd_applyscheme a mkid gd_getscheme) 
3715577770368755209)
gd_applyscheme


(c!:install 'absodeg '(absodeg plus eval) 15211225628975707552)
absodeg


(c!:install 'depend!-l '(depend!-l simp depend!-sq) 11705703878846753641
)
depend!-l


(c!:install 'rl_print!*fof '(rl_print!*fof reval maprin) 
8948476633242711435)
rl_print!*fof


(c!:install 'cl_susimkatl '(cl_susimkatl true false and inctheo or
lastpair rl_susipost cl_cflip rl_negateat rl_susitf) 
12591663934806987540)
cl_susimkatl


(c!:install 'ev_compless!? '(ev_compless!? ev_comp iequal) 
12235098990192970880)
ev_compless!?


(c!:install 'appends '(appends) 4527622923441649088)
appends


(c!:install 'groebsaveltermbc '(groebsaveltermbc glterms vbc2a
constant_exprp simp fctrf prepf) 2234765308638356198)
groebsaveltermbc


(c!:install 'simpintersection '(simpintersection intersection empty_set
applysetop ordn mksp) 18333976700864013619)
simpintersection


(c!:install 'rand!-mons!-dense '(rand!-mons!-dense mksq max multf
lastpair) 4000640762977857342)
rand!-mons!-dense


(c!:install 'lispcondp '(lispcondp cond) 15172181409483727939)
lispcondp


(c!:install 'actual_world '(actual_world exclude_edges union_edges) 
17227129322063686337)
actual_world


(c!:install 'groeb!=testb '(groeb!=testb mo_comp nth mo_divides!?
bas_dpoly dp_lmon mo_lcm mo_equal!?) 9387346251175807984)
groeb!=testb


(c!:install 'nrootnn '(nrootnn !*primelist!* mcfactor!* iroot) 
5942300179902464672)
nrootnn


(c!:install 'ofsf_qesubq '(ofsf_qesubq ofsf_qesubqat cl_apply2ats1) 
3485473431444974310)
ofsf_qesubq


(c!:install 'makecoeffpairs1 '(makecoeffpairs1 ((nil)) tayexp!-minus
makecoeffpairshom lastpair) 1976336402385581849)
makecoeffpairs1


(c!:install 'ev_lcm '(ev_lcm) 17226768181776415381)
ev_lcm


(c!:install 'cd_ordatp '(cd_ordatp neq equal ordp) 7200805220082662935)
cd_ordatp


(c!:install 'unary '(unary "<apply>" "<" "/>" indent "</apply>" printout
expression) 17628353546270141862)
unary


(c!:install 'tidysqrtf '(tidysqrtf i (sqrt -1) sqrt mksp simp exptsq
multsq tidysqrt addsq) 3822664086723673521)
tidysqrtf


(c!:install 'dm!-quotient '(dm!-quotient !*noequiv dm!-mkfloat
!:quotient) 6686076476757985430)
dm!-quotient


(c!:install 'rm_neg_pow '(rm_neg_pow to multsq addsq) 
2919842033772231034)
rm_neg_pow


(c!:install 'mkuniquewedge1 '(mkuniquewedge1 wedgemtch!* wedge mkupf
wedgemtch partitop) 17022987313366560229)
mkuniquewedge1


(c!:install '!:dmexpt '(!:dmexpt !*complex !:dm2fix !:expt force!-to!-dm
crexpt!* rdexpt!*) 16196288233956649776)
!:dmexpt


(c!:install 'rep_parents '(rep_parents) 10604531587366957043)
rep_parents


(c!:install 'dp_prod '(dp_prod dp!=prod) 12661104930869960654)
dp_prod



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u57.lsp"

Reading "$reduce/cslbuild/generated-c/u58.lsp"

% u58.lsp           Machine generated Lisp

(c!:install "u58" 167482 1588833 6511275)
nil


(c!:install 'sc_repkern '(sc_repkern !* lambda_1x539vlzlwg93
pa_list2vect sort) 8973480175038941953)
sc_repkern


(c!:install 'lambda_1x539vlzlwg93 '(lambda_1x539vlzlwg93) 
17810050070257344241)
lambda_1x539vlzlwg93


(c!:install 'super_product_sq '(super_product_sq (ext) split_ext multsq
ext_mult addsq) 17325628299063995866)
super_product_sq


(c!:install 'setqdeletedescendants '(setqdeletedescendants
fluidbibasissetq) 7347142229758694898)
setqdeletedescendants


(c!:install 'ofsf_ordrelp '(ofsf_ordrelp (equal neq leq lessp geq
greaterp)) 677969609291168617)
ofsf_ordrelp


(c!:install 'yetunknowntypeeval '(yetunknowntypeeval
eval!-yetunknowntypeexpr reval1) 16888849423757944204)
yetunknowntypeeval


(c!:install 'let0 '(let0 frasc!* let00) 7391967956783306752)
let0


(c!:install 'get_rep_matrix_entry '(get_rep_matrix_entry
get_rep_matrix_in get!+mat!+entry) 5359477799238910142)
get_rep_matrix_entry


(c!:install 'mri_dettype '(mri_dettype int real mri_arg2l kernels
mri_realvarp) 12589705886688684344)
mri_dettype


(c!:install 'qqe_length!-graph!-remove!-mark '(
qqe_length!-graph!-remove!-mark) 377600596588172727)
qqe_length!-graph!-remove!-mark


(c!:install 'aex_fromsf '(aex_fromsf aex ctx_new) 6306651090152265251)
aex_fromsf


(c!:install 'ps!:expansion!-point '(ps!:expansion!-point !:ps!: ps!:getv
) 16036982018896120238)
ps!:expansion!-point


(c!:install 'nestprep!: '(nestprep!: co simp prepsq) 
13873545229761536726)
nestprep!:


(c!:install 'bfdivide '(bfdivide !:bprec!: divide!: normbf) 
8889576880326804828)
bfdivide


(c!:install 'calc_map_ '(calc_map_ quotient actual_alst calc_map_tar
reval calc_den_tar) 13813670919727514222)
calc_map_


(c!:install 'rappend '(rappend "append has TWO arguments" "list or bag"
rederr reval baglistp typerr) 15804337383496172293)
rappend


(c!:install 'formclear '(formclear clear formclear1) 
11707879931340615398)
formclear


(c!:install 'partsym_zerop '(partsym_zerop !- repeats) 
5809084812164251243)
partsym_zerop


(c!:install 'modroots2 '(modroots2 (-1 0 1) modroots4 modroots3) 
1868084021990693538)
modroots2


(c!:install 'r2flbf '(r2flbf !*bftag r2bf r2fl) 11486658120533823622)
r2flbf


(c!:install 'order_of_der '(order_of_der i2o_jetspace!*
i2o_jetspace_odd!*) 13228324747429960556)
order_of_der


(c!:install 'talp_gaussand '(talp_gaussand failed ignore
talp_trygaussvar) 16419365261122652967)
talp_gaussand


(c!:install 'rl_b2atl '(rl_b2atl rl_b2atl!* apply) 2138926909353740864)
rl_b2atl


(c!:install 'rat_0 '(rat_0) 1405448541570817653)
rat_0


(c!:install 'ldt!-dep '(ldt!-dep depl!* ldt!-tvar) 507311575391496787)
ldt!-dep


(c!:install 'pm!:gensym '(pm!:gensym !? !_ pm!:gensym!-count!*) 
2925043532280623506)
pm!:gensym


(c!:install 'groebsimpcontnormalform '(groebsimpcontnormalform
!*groebprot quotient gsugar vdpsimpcont gsetsugar vbc2a reval
groebreductionprotocol2) 17945831652982038263)
groebsimpcontnormalform


(c!:install '!:quotient '(!:quotient poly "Zero divisor" dmode!* times
quotient rerror !:recip dcombine) 846785812012007106)
!:quotient


(c!:install 'matcheq '(matcheq !*exp (plus difference) diff eval
matchlinear) 11712912479545871603)
matcheq


(c!:install 'tot!-asym!-indp '(tot!-asym!-indp indordp indxchk indordlp)
 16378113130650151290)
tot!-asym!-indp


(c!:install '!*s2arg '(!*s2arg quote nochange mkarg) 4918202841384322310
)
!*s2arg


(c!:install 'com43 '(com43 liemat bb ff algebraic l_z cc minus det
quotient plus times comcom0 comcom1 comcom3 matrix aeval arrayfn aeval!*
setk evalneq evalequal clear) 15034922302418064058)
com43


(c!:install 'affinep '(affinep belong_to_space get_sign_space) 
17023873794737433173)
affinep


(c!:install 'deg '(deg gdmode!* dmode!* simp!* tstpolyarg numrdeg) 
11030504842515431628)
deg


(c!:install 'odd_action '(odd_action !*a2k negsq component_action addsq)
 1775369681381575803)
odd_action


(c!:install 'ra_onep '(ra_onep ra_onep0 ra_wrapper) 8756972081977403643)
ra_onep


(c!:install 'aex_diff '(aex_diff aex_ex diffsq kernels aex_ctx
ctx_filter aex_mk) 4163020938676067037)
aex_diff


(c!:install 'lto_hentry '(lto_hentry) 8213524916477710154)
lto_hentry


(c!:install 'put!-avalue '(put!-avalue scalar !*sq !*reduce4 generic
avalue sq_member recursiveerror putobject smember) 6185992911340267878)
put!-avalue


(c!:install 'talp_prepat '(talp_prepat talp_op talp_arg2l talp_prepterm
talp_arg2r) 4257837775421311319)
talp_prepat



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u58.lsp"

Reading "$reduce/cslbuild/generated-c/u59.lsp"

% u59.lsp           Machine generated Lisp

(c!:install "u59" 131655 2833294 5332876)
nil


(c!:install 'pasf_premf1 '(pasf_premf1 minusf addf to exptf multf) 
14196132484071525895)
pasf_premf1


(c!:install 'search4facf '(search4facf tryfactorf) 7022717262781964485)
search4facf


(c!:install 'frlp '(frlp frlis!*) 8131105772210933591)
frlp


(c!:install 'xvarp '(xvarp xvars!* (wedge d partdf hodge innerprod liedf
) xdegree) 10414475765977978179)
xvarp


(c!:install 'kernelp '(kernelp) 8367153360350514607)
kernelp


(c!:install 'mo_deletecomp '(mo_deletecomp mo!=deglist) 
12018199225992509237)
mo_deletecomp


(c!:install 'algebnp '(algebnp !:ar!:) 14842853218592494742)
algebnp


(c!:install 'ratleqp '(ratleqp ratdif) 9146806343219559736)
ratleqp


(c!:install 'gcdk '(gcdk !*heugcd !*ezgcd modular!-multicheck !*mcd
dmode!* degr quotf1 heu!-gcd getd remk addlc prim!-part) 
1808524218234108726)
gcdk


(c!:install 'interglue '(interglue !\co!  !+ !- ord clo !\cdot! ) 
4372386679573287132)
interglue


(c!:install 'pasf_qff2ivl '(pasf_qff2ivl
"pasf_qff2ivl : uniform Presburger arithmetic formula in input"
pasf_uprap rederr pasf_dnf pasf_qff2ivl1) 8801269133230318599)
pasf_qff2ivl


(c!:install 'cfrmconstant '(cfrmconstant cfrmcrd!* freeoffl) 
6322864059352167629)
cfrmconstant


(c!:install 'cflot '(cflot bf2flr) 7804044446289640211)
cflot


(c!:install 'partitpartdf '(partitpartdf !*a2k mknatvec simppartdf0) 
14341146793199646748)
partitpartdf


(c!:install 'propagator '(propagator plus repeatsp permutations propag) 
10586453555647518637)
propagator


(c!:install 'invbase!* '(invbase!* thirdway!* shortway!* !*trinvbase
maxord!* path gg!* varlist!* bv!* "---------- ORDER = " " ----------"
alglist!* list plus gv!* invtempbasis "Maximum degree bound exceeded."
ng!* redall newbasis ord !*di2q prepsq rederr max ljet class nonmult
pdmult nf stat dim) 9973221616266214468)
invbase!*


(c!:install 'st_flatten '(st_flatten copy lastpair) 5319316849813223378)
st_flatten


(c!:install 'dependsp '(dependsp !*sq taylorvariable depends involvesq
taylorp) 6918631214116765078)
dependsp


(c!:install 'bf2rn1 '(bf2rn1 !:rd!: !:bprec!: minus!: lshift normbf
difbf divide!: abs!: bfzerop!: greaterp!: invbf) 2108707566568556354)
bf2rn1


(c!:install 'anu_mk '(anu_mk anu) 3254050022557752615)
anu_mk


(c!:install 'conjgd '(conjgd cmpxfn realtype !:minus multf addf) 
13020833553470071081)
conjgd


(c!:install 'mk_character '(mk_character get_group_in get!*elements
get_rep_matrix_in mk!+trace) 18096703642181927895)
mk_character


(c!:install 'rl_cput '(rl_cput) 7354026563348624443)
rl_cput


(c!:install 'acfsf_smmkatl '(acfsf_smmkatl acfsf_irl2atl) 
11923196781002189479)
acfsf_smmkatl


(c!:install 'vp1 '(vp1 "Var not in z-list after all" interr nreverse vp2
) 10060692868592383623)
vp1


(c!:install 'ps!:depvar '(ps!:depvar !:ps!: ps!:getv) 
8317194183459206185)
ps!:depvar


(c!:install 'numberofoccs '(numberofoccs) 16872300168531133303)
numberofoccs


(c!:install '!:mod!:units '(!:mod!:units current!-modulus) 
13487510028733908380)
!:mod!:units


(c!:install 'idealp '(idealp i list) 2769528687974037603)
idealp


(c!:install 'lexorder '(lexorder gv!* !*g2lex gcdout ljet insert) 
1576949871607660531)
lexorder


(c!:install 'pst_partition '(pst_partition lambda_sorneshiwvd12 pst_d
sort) 17217556705073099669)
pst_partition


(c!:install 'lambda_sorneshiwvd12 '(lambda_sorneshiwvd12 numlist_ordp) 
9272889440585894424)
lambda_sorneshiwvd12


(c!:install 'bibasis '(bibasis list "is not a polynomial list"
"polynomial list is empty" "is not a variable list"
"variable list is empty" lex deglex degrevlex
" is unsupported monomial ordering" fluidbibasisvariables
fluidbibasismonomialorder fluidbibasisrunningtime fluidbibasisgctime
!*sq mathprint rederr init reval simp polynomread
sortedpolynomlistinsert constructinvolutivebasis polynomwrite) 
17894068981020192354)
bibasis


(c!:install 'evalleq '(evalleq evalgreaterp) 6043315464523647766)
evalleq


(c!:install 'taysimpsq!* '(taysimpsq!* !*taylorautoexpand taysimpsq) 
2248755144385674747)
taysimpsq!*


(c!:install 'repr_atfnew '(repr_atfnew (cong ncong) pasf_coeflst minusf
pasf_anegrel multf repr_new) 6288618993290193868)
repr_atfnew


(c!:install 'ev_disjointp '(ev_disjointp) 3858179724726596528)
ev_disjointp


(c!:install 'exdfp0 '(exdfp0 subfg!* sfp exformp exdff0 exdfk to
multpfsq) 17662055604185616268)
exdfp0


(c!:install 'rand_functionp '(rand_functionp lambda getd) 
14753800750502375528)
rand_functionp


(c!:install 'partdff '(partdff !*product!-rule partdft multsq partdfpow
addsq) 12896297760294010173)
partdff


(c!:install 'find_triangl_coeff '(find_triangl_coeff find_triangle_coeff
) 8985799429492222322)
find_triangl_coeff



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u59.lsp"

Reading "$reduce/cslbuild/generated-c/u60.lsp"

% u60.lsp           Machine generated Lisp

(c!:install "u60" 22407 1213094 3477608)
nil


(c!:install 'lie4 '(lie4 l_f algebraic ordv cc minus plus times
"not a Lie algebra" quotient det mat !*tr_lie
"Your Lie algebra is commutative" only lie_class list liealg comtab
liemat com43 com41 com42 matrix aeval arrayfn setk aeval!* evalneq clear
rederr evalequal revalx boolvalue!* assgnpri) 1845459913678695374)
lie4


(c!:install 'make!-image!-lc!-list1 '(make!-image!-lc!-list1 varlist
polyzero !*d2n horner!-rule!-for!-one!-var) 17533059322250563800)
make!-image!-lc!-list1


(c!:install 'rdzchk '(rdzchk 0.0 !!fleps1 rd!-tolerance!* bfz!* abs!:
times!: lessp!:) 5246679473715637252)
rdzchk


(c!:install 'memlis '(memlis) 18427748568451626524)
memlis


(c!:install 'modular!-factor!-count '(modular!-factor!-count
poly!-vector null!-space!-basis known!-factors poly!-mod!-p dpoly
poly!-to!-vector count!-linear!-factors!-mod!-p use!-berlekamp) 
14804056382089455950)
modular!-factor!-count


(c!:install 'ofsf_chsimpat1 '(ofsf_chsimpat1 (lessp leq equal neq geq
greaterp) lastcar) 13648608397240875860)
ofsf_chsimpat1


(c!:install 'clearrules '(clearrules !*sqrtrulep rule!-list) 
11581933298131554450)
clearrules


(c!:install 'negdf '(negdf nreverse negsq) 10195938657571290765)
negdf


(c!:install 'get!*generators '(get!*generators generators) 
16180433573324945269)
get!*generators


(c!:install 'formopr '(formopr symbolic flag opfn operator mkarg) 
9957583606918413146)
formopr


(c!:install 'rnfloor!* '(rnfloor!*) 5445137748960396329)
rnfloor!*


(c!:install 'codfac '(codfac rowmin codmat maxvar times samefar
commonfac) 12553701744991344560)
codfac


(c!:install 'qsimpcomb_standard_qexp_part_sf '(
qsimpcomb_standard_qexp_part_sf expt times simp addsq) 
546438383342275915)
qsimpcomb_standard_qexp_part_sf


(c!:install 'xreorder '(xreorder xpartitop reordsq multpfsq addpf) 
280604788576102600)
xreorder


(c!:install 'exdfpf '(exdfpf exdf0 exdfk multpfsq wedgepf2 mkuniquewedge
addpf) 2490051800327718576)
exdfpf


(c!:install 'texaeval1 '(texaeval1 !*latex tex texaeval) 
13851481172056204705)
texaeval1


(c!:install 'getphystypestate '(getphystypestate state statep!*) 
5587074674463140564)
getphystypestate



% End of generated Lisp code


Finished reading "$reduce/cslbuild/generated-c/u60.lsp"

nil


<< initreduce();
   date!* := "Bootstrap version";
   preserve('begin, "REDUCE", t) >>;

The system will be preserved on file "reduce.img(InitialImage)"
REDUCE


nil


Reading "$reduce/cslbuild/generated-c/u01.lsp"

nil

mchkopt

smember

!*n2f

setdiff

nth

terminalp

multf

monomgetvariabledegree

quotelist

num!-exponents

simpcar

wuconstantp

mkcopy

revpr

talp_getl

kernels

qqe_rqopp

powers

lto_hashid

noncomfp

ioto_prtb

delall

ordop

ps!:getv

prepf

c!:ordxp

zero2nil

mval

reval

evcomp

evmatrixcomp2

xval

times!:

mkvar

physopp

memq_edgelist

mo_comp

c_zero

sieve_pv0

listp

modzerop!:

getrtypeor

lalr_productions

random_new_seed

monomcompare

makelist

quotf

mchk!*

get!+mat!+entry

talp_getextl

ibalp_clmember

aex_ex

argsofopr

find2

noncomp

ps!:order

prepf1a

pm!:free

vbcsize

pnth

wedgefax

convprec

!*physopp

wideid2list

termsf

mkspm

dssoc

noncomlistp

rnzerop!:

mksp

aeval

lalr_first

addcomment

arrayp

cl_cflip

subs3f

kernlp

talp_invp

qqe_rbopp

sub2chk

butes

ps!:last!-term

exchk

expchk

dm!-abs

binding

evlexcomp

sc_getmat

getrtypecar

isanindex

poly!-multf

mo_divides!?

dlesslex

hasonevector

reduce_pv0

modonep!:

remainder!-in!-vector

smemql

lalr_add_lookahead

setkorder

mtchp1

get!+row!+nr

rl_negateat

kernels1

lpri

addd

compress!*

noncomfp1

ldepends

numlis

!:minusp

evzero!?

factorordp

degr

mkround

collectindices

union_edge

ring_ecart

mtp

reduce_pv

rnequiv

general!-modular!-times

multd

lalr_lr0_move_dot

aex_ctx

prin2x

minusf

reorder

aconc!*

Finished reading "$reduce/cslbuild/generated-c/u01.lsp"

Reading "$reduce/cslbuild/generated-c/u02.lsp"

nil

mchk

quotsq

tayexp!-greaterp

!*d2q

talp_simplt

qqe_qoptailp

multdm

!*q2a

!:onep

buchvevdivides!?

vevmtest!?

sublistp

csl_normbf

round!*

collectindices_reversed

reval_without_mod

mo!=sprod

pappl

!*i2mod

general!-modular!-plus

!*d2n

delcp

getpower

sort

finde

sfp

tayexp!-lessp

get!+vec!+entry

rl_simplat1

mri_floorkernelp

get_token

xsimp

prepsqxx

aeval!*

adddm

cali_bc_prod

sieve_pv

lalr_closure

list2wideid

rl_varlat

monomclone

comfac!-to!-poly

mtchk

exptchksq

talp_varlt

lprim

notstring

c!:ordexn

constp

bczero!?

multpfsq

negnumberchk

opmtch!*

sinitl

smemqlp

angles!-equal

pappl0

rnonep!:

multiply!-by!-constant!-mod!-p

lalr_prin_symbol

aex_mk

monomisdivisibleby

setcdr

powers0

remove!-free!-vars!-l

get!+vec!+dim

rl_ordatp

qqe_qopaddp

attributes

fast!-row!-dim

evmatrixcomp1

i2rd!*

getphystype!*sq

union_edges

mo!=modiv1

unpkp

modtimes!:

times!-in!-vector

gcdfd

cdrassoc

cl_atmlc

delallasc

rank

sizchk

rl_smcpknowl

qqe_qopheadp

lto_hashequalq

get_content

ps!:evaluate

!:zerop

initcomb

bcprod

Finished reading "$reduce/cslbuild/generated-c/u02.lsp"

Reading "$reduce/cslbuild/generated-c/u03.lsp"

nil

rd!:zerop

ordpp

monordp

!*physopp!*

cdiv

pv_multc

upbve

striptag

lalr_compute_lr0_goto

monomcomparedegrevlex

lt!*

subs2f

talp_simpat

kernord!-sort

printout

mgenp

evcompless!?

evmatrixcomp

wedgepf2

pprin2

!*collectphysops_reversed

constimes

errorp

timesip

fs!:timestermterm

mo_vdivides!?

dless

pkp

!*i2rn

gcdfd1

lalr_propagate_lookaheads

add2calls

getrtype2

maxdeg

symbollessp

multsq

rl_smupdknowl

ibalp_varlt

get!-print!-name

bftrim!:

on1

bcint2op

atomf

negsq

hasonephysop

arraychk

fs!:angle!-order

cali_trace

pcmult

pv_renorm

plus!-mod!-p

split_form

lalr_goto

toknump

getrtype

rmultpf

mtchp

nocp

subs2q

qqe_nytidp

subs2!*

off1

prepsq

evsum

rd!:minusp

reordop

errorset!*

fs!:timesterm

!:minus

rev

!*!*s2a

lnc

stable!-sortip

qqe_btidp

Finished reading "$reduce/cslbuild/generated-c/u03.lsp"

Reading "$reduce/cslbuild/generated-c/u04.lsp"

nil

lex

ps!:get!-term

!*q2a1

replus1

peel

quotfm

idlistp

formlis

bas_rep

pv_sort2

ofsf_posdefp

quotf!-fail

free!-powerp

invsq

kernord

negf

mkwedge

scprint

qassoc

nonzero!-length

mo_ecart

add_prin_char

pv_sort

general!-modular!-number

bfzerop!:

flatten!-sorted!-tree

ordopcar

checkargcount

treesizep1

listeval

get!+col!+nr

cl_simplat

fac!-merge

retimes

vevcompless!?

ordad

round!:last

update!-pline

fprin2

tensopp

widestring2list

mo!=sum

lcm

arzerop!:

simpexpon

lalr_lr0_closure

rat_sgn

anform

praddf

tayexp!-plus2

tmsf!*

cl_smrmknowl

isvalid

revlis

rmsubs

getroad

expdrmacro

mo!=degcomp

dquot

insert_pv

noncomp1

rntimes!:

noncomdel

frvarsof

orderactions

ofsf_clnegrel

quotf1

remove!-free!-vars

tayexp!-minusp

subs2

mri_floorp

xxsort

lambda_qrvi5bym67r22

Finished reading "$reduce/cslbuild/generated-c/u04.lsp"

Reading "$reduce/cslbuild/generated-c/u05.lsp"

nil

ibalp_cequal

vdp_poly

ev_comp

fullcopy

dm!-times

getrtype1

vevtdeg

safe!-fp!-minus

prin2!-downcase

readch1

fs!:plus

mo!=shorten

prin2!*

insert_pv1

noncomp!*

mkgi

polynomclone

gcdf

reordsq

addsq

ckrn1

talp_negateat

sort!-factors

mathml_list2string

findrow

groebsearchinlist

find_item

prin2la

command1

getel1

prepsqx

mo_sum

resimp

pv_add

sgn

xcomment

absf

talp_mkinv

rl_prepat

ev_tdeg

listsum

indent!*

multi_isarb_int

c!:ordexp

int!-equiv!-chk

!*collectphysops

dp_term

pv_sort1

modplus!:

ofsf_vareqnp

polynomadd

rl_smmkatl

setcar

multi_isarb_compl

minus!:

depends

dm!-difference

rd!:onep

simpminus

xdiv

getrmacro

mo_compare

vecp

pv_applp

aronep!:

mod!#

gen!-mult!-by!-const!-mod!-p

copy!-vector

aconc

Finished reading "$reduce/cslbuild/generated-c/u05.lsp"

Reading "$reduce/cslbuild/generated-c/u06.lsp"

nil

lalr_print_collection

convertmode

subs3q

talp_smwcpknowl

qqe_qtidp

algid

emtch

pnthxzz

csl_timbf

putpline

!:times

mkrn

gperm1

evaluate!-in!-order

delete_from_alglist

gcdf!*

prin2t

reval1

sfto_dcontentf1

sqchk

removev

talp_simplat1

ibalp_varlat

quotfd

mathml

sortcolelem

prepf1a_reversed

comm_kernels

fast!-column!-dim

evtdeg

mknwedge

!:plus

getelv

dp!=ecart

tsym4

set_svf

gcddd

anform1

freeofl

mri_type

pasf_dec

cgp_evlmon

times!-mod!-p

omobj

sqform

mk!*sq

subscriptedvarp

exptchk

order!:

areallindices

!*ssave

red!-weight

dp_diff

resimp1

pv_sort2a

starts!-with

sfto_davp

talp_varlt1

mri_simplfloor

qqe_prepat

eolcheck

mcharg1

boundindp

chundexp

red!-char!-downcase

physopp!*

macrochk

getel

mo!=lexcomp

gperm

copy

!*modular2f

general!-modular!-quotient

minus!-mod!-p

Finished reading "$reduce/cslbuild/generated-c/u06.lsp"

Reading "$reduce/cslbuild/generated-c/u07.lsp"

nil

clear!-column

lalr_add_goto

wulessp

talp_smwupdknowl

mri_0mk2

rl_simpat

ibalp_varlt1

ev_invlexcomp

powers2

find

simp!*

downwght

freexp

termordp

gizerop!:

repeatsp

bc!=simp

gperm2

exptmod!:

convprec!*

rat_numrn

freeof

gcdf1

talp_smupdknowl

qqe_id!-nyt!-branchb

pasf_deci

ibalp_litlp

mintype

prepd

quotematrix

deg!*farg

make!-set

optype

setcloc!*

red_divtestbe

pappl_pv

!*i2ar

general!-modular!-minus

lalr_analyze_lookaheads

powers1

cl_atfp

quotk

multi_elem

letmtr3

nextarg

diplength

divide!:

list2widestring

groeb!=testa

dv_skelhead

rnplus!:

lalr_remove_duplicates

sfto_gcdf

totallessp

talp_tcfrp

pasf_susitf

times!-term!-mod!-p

omobjs

bound

freeindexchk

worderp

vecopp

sroad

simpplus

mv!-pow!-mv!-term!-!+

dp_ecart

adddummy1a

Finished reading "$reduce/cslbuild/generated-c/u07.lsp"

Reading "$reduce/cslbuild/generated-c/u08.lsp"

nil

general!-plus!-mod!-p

get_first_kernel

lalr_precedence

diff

talp_varlat

rl_gettype

quotfail!-mod!-p

retattributes

round!:mt

eofcheck

divd

dp_times_bc

pdmult

mcharg2

cancel

canonsq

rassoc

anforml

cdarx

talp_atfp

ibalp_simpat

checktag

subs2f1

bcsum

vevmaptozero1

deg!*form

physopsim!*

rread

reval2

red!-weight1

bas_make1

hevenp

yyreadch

talp_candp

ibalp_litp

rationalizei

genp

xdegreemon

evaluate0

domain!*p

rnquotient!:

gintequiv!:

procstat

!*sqprint

mcharg

tayexp!-min2

talp_smupdknowl1

ibalp_atomp

isarb_int

retimes1

vdpsave

gsetsugar

add2inputbuf

simpdiff

mv!-pow!-minusp

mo!=deglist

psum

pv_neg

klistt

Finished reading "$reduce/cslbuild/generated-c/u08.lsp"

Reading "$reduce/cslbuild/generated-c/u09.lsp"

nil

quotdd

xread

prepsq!*2

talp_invf

bc_prod

redmsg

multiom

isarb_compl

rdprep1

variables

layout!-formula

noncomp2f

contrsp2

token1

ckpreci!#

mo_diff

pneg

th_match0

general!-times!-term!-mod!-p

abs!:

gionep!:

cde_position2

valid_as_variable

talp_simplat2

cl_varl2

ev_revgradlexcomp

equal!:

difff

symtabget

getphystype

lispapply

mv!-pow!-!+

kernp

conv!:bf2i

qcputx

rmplus

comfac

talp_ordatp

searchpl

intexprnp

lpriw

testred

off_mod_reval

simpindexvar

dim!<deg

opnum!*

mapcons

!*i2gi

Finished reading "$reduce/cslbuild/generated-c/u09.lsp"

Reading "$reduce/cslbuild/generated-c/u10.lsp"

nil

ptoken

formc

wuorderp

freevarinexptchk

talp_smwmkatl

chknewnam

smtp

take!-realpart

assert_analyze

lambda_46uwl1lq71ua2

dp_sum

!*q2f

exptf1

portable_print

polynommultiplybymonom

wulessp!*

matrix!+p

cl_fvarl1

lastnondomain

numeric!-content

objectom

initbrsea

!:difference

statep!*

take!-impart

errorset2

maprint

dl_get

lalr_list_of_actions

aex_simpleratp

polynomlistfinddivisor

diffp1

removeg

poly!-abs

freeofdepl

talp_acfrp

searchtm

rl_simpbop

vdp_zero!?

spmultm2

on

covposp

contrsp

cali_bc_fi

oprin

split_ext

aex_simplenullp

ofsf_ordatp

janettreefind

talp_simplt1

mri_2pasfat

qqe_number!-of!-tails!-in!-qterm

ibalp_simpatom

dip_moncomp

omair

off

xord_lex

has_parents

Finished reading "$reduce/cslbuild/generated-c/u10.lsp"

Reading "$reduce/cslbuild/generated-c/u11.lsp"

nil

form1

ord

!*id2num

sc_kern

list_assoc

get_action_without_lookahead

revv0

rl_external

quotfx

ibalp_clauselp

expression

ident

vdpgetprop

xdegree

sfpx

mv!-domainlist!-!-

exptf

lalr_generate_lr0_collection

convertmode1

ofsf_posvarpat

monommultiplybyvariable

totalcompare

tayexp!-difference

cl_smcpknowl

exchk2

mkuwedge

formop

leftzeros

arintequiv!:

reduce!-mod!-p

mconv

lalr_lr0_itemset_to_lalr_kernel

formclis

preptayexp

ofsf_prepat

image!-of!-power

addpf

id2bytelist

scan

ra_budancount

lalr_prin_nonterminal

remflagss

ordpa

rl_smrmknowl

kernord!-split

basicom

dfn_prop

initwght

bcone!?

vdplength

plus!:

getphystypesf

split!-road

Finished reading "$reduce/cslbuild/generated-c/u11.lsp"

Reading "$reduce/cslbuild/generated-c/u12.lsp"

nil

simp

red!-weight!-less!-p

pv_times3

raiseind!:

set!-general!-modulus

ra_budan!-transform

lalr_make_compressed_action_row

ofsf_smwcpknowl

color1

cl_simpl

ibalp_clausep

omiir

writepri

argnochk

compactfmatch2

make!-term

listtest

lalr_prin_action

formprogn

processcarpartitie1

subs3f1

get_rep_matrix_in

cl_fvarl

qsort

integerom

c!:extadd

lessp!:

condterpri

red_better

gperm3

ordn

rnminus!:

split_f

rl_simp

get_group_in

ibalp_simpterm

gb_buch!-ev_divides!?

cgb_buch!-ev_divides!?

naryrd

sc_setmat

flatindxl

gfrsq

ncmpchk

mv!-pow!-!-

dp!=mocompare

eqdummy

b!:ordexn

horner!-rule

cde_lassoc2

gcdf2

qqe_arg!-check!-b

rl_susibin

aex_varl

omvir

spquotematrix

vdpzero

tokquote

red!-ratios1

multop

red_divtest

pdif

pv_intequiv

crprcd

simpexpon1

talp_simplatrinv

mkzl

Finished reading "$reduce/cslbuild/generated-c/u12.lsp"

Reading "$reduce/cslbuild/generated-c/u13.lsp"

nil

ibalp_vequal

lesspcdr

sub_math

rd!:minus

zeropp

comm_kernels1

sc_null

fortranop

simptimes

dividef

noncomperm

lalr_most_common_reduction

undefdchk

mk!+mat!+mult!+mat

talp_chkknowl

qqe_ofsf_prepat

powers4

unbind

listdiff

deletemult!*

aminusp!:

mo_neg

wtchk

put!-kvalue

removeg1

cl_varl1

qqe_ofsf_varlterm

rl_simp1

wedget2

set!-ordp

map__edges

assert_dyntypep

dd

pv_times2

exptsq

p_princ

gcref_mknode!-tgf

quotfail1

msappend

exceeds!-order

ckrn

talp_rnf

qqe_qprefix!-var

Finished reading "$reduce/cslbuild/generated-c/u13.lsp"

Reading "$reduce/cslbuild/generated-c/u14.lsp"

nil

xread1

binomial!-coefft!-mod!-p

!*kp2f

revalind

scalopp

lalr_reduction_index

rempropss

rl_simpl

cl_smmkatl

ibalp_vmember

make!-univariate!-image!-mod!-p

minusp!:

isimplicit

getmat

groebcpcompless!?

vevdif

red!-ratios2

cali_bc_zero!?

gperm0

portable_prin

aex_deg

ofsf_smwupdknowl

removeg2

pasf_susipost

vdp_plist

mathml2

setdmode1

sc_minussq

vevlcm

mksgnsq

defined_edge

rnconc

evalneq

dp_times_bcmo

ra_budan!-0!-1

p_prin

ofsf_entry2at1

polynommultiplybyvariable

intexprlisp

cl_sitheo

qqe_ofsf_simplat1

sf2ss

Finished reading "$reduce/cslbuild/generated-c/u14.lsp"

Reading "$reduce/cslbuild/generated-c/u15.lsp"

nil

diff!-over!-k!-mod!-p

c!:subs2multf

testredh

getcomb

bc2a

lid

list!+list

physop!-multf

form

lengthcdr

mo_neworder

dl_get2

general!-times!-mod!-p

efface1

rsubla

cl_smsimpl!-junct

sq2sspl

sq2sscfpl

horner!-rule!-mod!-p

downwght1

newenv

arg2of2

evenfree

fortranprecedence

assert_typesyntaxp

mo!=revlexcomp

artimes!:

lexer_word_continues

quotfdx

simpexpt

lx2xx

ibalp_negateat

dip_fmon

maxtype

bind

freeoffl

triviallcm

aminusp!:1

dcombine

setk

lalr_resolve_conflicts

cl_atml1

mri_realvarp

cl_qb

quotient!-mod!-p

matsm!*1

dipprodin1

gsugar

noncommuting

remcomma

mv!-domainlist!-!*

modquotient!:

conv!:mt

multd!*

Finished reading "$reduce/cslbuild/generated-c/u15.lsp"

Reading "$reduce/cslbuild/generated-c/u16.lsp"

nil

use!-berlekamp

rread1

aex_mvartest

idsort

talp_subalchk

qqe_ofsf_chsimpterm

pasf_sisub!-gand

ibalp_negatet

mapins

cird

bsubs

wedgepf

all_edge

mkid

mv!-pow!-chk

dp_neg

pappend

b!:extmult

tr_write

difference!-mod!-p

reduce!-degree!-mod!-p

lalr_make_compressed_action_row1

powers3

ibalp_redclause

matrixrowrd

opmtch

mkinds

flatsizec

general!-modular!-reciprocal

ra_transform

rl_prepfof

poly!-minusp

delet

ibalp_emptyclausep

c!:extmult

dpmat_coldegs

nb

lex_start_block_comment

setpage

mri_pasf2mriat

qqe_simplterm

pasf_mkpos

ibalp_process!-var

cgp_ci

diff!-k!-times!-mod!-p

terpri!*

find_sub_df

redcodmat

exchk1

modminusp!:

unchecked_getmatelem

termordp!!

scal!*list

actual_alst

symbid

nzeros

cali_bc_inv

subsetp

wi_new

Finished reading "$reduce/cslbuild/generated-c/u16.lsp"

Reading "$reduce/cslbuild/generated-c/u17.lsp"

nil

simpatom

get_goto

aex_subrat1

collect_cars

qremf

updtemplate

tmsf

talp_td

qqe_id!-nyt!-branchq

pasf_vf

ibalp_readclause

expt!-mod!-p

omsir

ps!:expression

evallessp

dipilcomb1

mkprogn

getmatelem

di_restore

negate!-term

lalr_associativity

simplify!-filename

wureducedpolysp

talp_smwrmknowl

setunion

cl_pnf2

attributesml

spband_matrix

dm!-eq

removeindices

il_simp

b!:ordexp

invbf

xremainder!-mod!-p

simpiden

ra_refine1

Finished reading "$reduce/cslbuild/generated-c/u17.lsp"

Reading "$reduce/cslbuild/generated-c/u18.lsp"

nil

lex_restore_context

outdefr

processpartitie1

remove!-free!-vars!*

degree!-in!-variable

constsml

ldt!-tvar

maprin

findnewvars

xord_gradlex

physopaeval

contr1!-strand

simp!-sign

sqp

mo_from_a

get_action

read_typed_name

rl_bestgaussp

mkkl

findremainder

prepsq!*

talp_eqtp

qqe_number!-of!-adds!-in!-qterm

subf

cl_nnf1

cgp_number

nary

sacar

inshisto

bcplus!?

groebbuchcrit4t

!*pf2wedgepf

pv_times1

general!-reduce!-degree!-mod!-p

update_kc_list

ofsf_pow2q

prepreform

exptcompare

cl_smsimpl!-junct2

cl_pnf2!-junctor

aex_fvarl

variablesir

freeoff

deleteall

cstimes

simprepart

command

sf_member

!:divide

b!:extadd

in_list1

Finished reading "$reduce/cslbuild/generated-c/u18.lsp"

Reading "$reduce/cslbuild/generated-c/u19.lsp"

nil

polynomheadreduceby

wusort

talp_simplatat

qqe_simplat1

cl_mkstrict

variableom

onoff

guesspftype

equalreplaceby

prinfit

gpexp1p

copyd

class

lexer_word_starter

gcref_mkedges!-tgf

replus

rl_subat

subf1

cl_rename!-vars1

bc_2sq

termorder

stats_getargs

convchk

bcquot

vdpputprop

add2resultbuf

groeb!=better

ord2

moduntag

mksq

rrdls

read_namelist

sfto_ucontentf1

expnd1

ev_sum

mml2om

vbcgcd

mkarray1

idcons_ordp

general!-expt!-mod!-p

lex_start_line_comment

rl_atl

om2mml

floatprop

!*wedgepf2pf

delete!-dups

inttovec

Finished reading "$reduce/cslbuild/generated-c/u19.lsp"

Reading "$reduce/cslbuild/generated-c/u20.lsp"

nil

physop!-ordop

zero!-roads

addgt

lex_save_context

ctx_filter

ofsf_entry2at

monomdivide

rl_nnf

innprodkp

talp_rnf1

distribute!.multiplicity

ibalp_readform

ir2om

xord_deglex

contr

repasc

general!-reduce!-mod!-p

ordexn

ofsf_smmkatl1

ibalp_calcmom

groebcplistsortin

invp

th_match

!:expt

print_with_margin_sub

simp!*sq

talp_invn

cl_susiminlevel

tobvarir

formcond

evalequal

mv2sf1

di_insert

decprec2internal

carrassoc

make_tuple_type

triplesetprolongset

findnthroot

basic!-simpexpt

applyrd

merge!-ind!-vars

vdpred

indexvarordp

cut!:mt

lispassignp

begin1a

bas_newnumber

traput

ofsf_varlat

rl_csimpl

mkprod

lto_max1

bc_fd

ir2mml

testredzz

list!-mgen

expand!-imrepart

Finished reading "$reduce/cslbuild/generated-c/u20.lsp"

Reading "$reduce/cslbuild/generated-c/u21.lsp"

nil

mvar_member

rnminusp!:

mo_times_ei

reverse!-num

mkcr

lalr_prin_rhs

cl_nnf

cl_simpl1

pasf_pdp

bc_zero!?

get!-height

mchkopt1

simprecip

rd!:prep

evmtest!?

expvec2a

treesizep

ncoeffs

next!-random!-number

nfactorial

reducepowers

setk0

gcref_select

vintersection

cl_atl

pasf_sisub

dipevlcomp

assert_format

mv!-domainlist

rnprep!:

rootrnd

prin_with_margin

mk!+unit!+mat

fctrf1

sfto_b!:ordexn

dm!-gt

chk

coposp

partitexdf

inttovec!-solve

contr2!-strand

sf2mv1

!:rn2rd

tensorp

ilcm

general!-reciprocal!-by!-gcd

lalr_precalculate_first_sets

squared!+matrix!+p

cl_flip

rl_susitf

vsl_boundtype

sfto_b!:extmult

Finished reading "$reduce/cslbuild/generated-c/u21.lsp"

Reading "$reduce/cslbuild/generated-c/u22.lsp"

nil

ps!:expt!-erule

setmat

coordp

indord2

begin11

mv!-pow!-mv!-!+

moid_member

arglist_member

exc

sfto_kexp

gcref_mkgraph

setqget

ezgcdf1

talp_eqnrhskernels

ctx_new

evaluate!-mod!-p

getsetvars

ps!:minusp!:

xdegreecheck

indordp

symbvarlst

mv!-domainlist!-!+

qremd

ad_numsort

lambda_ygm6np4pcqv31

cde_delete

derivative!-mod!-p!-1

collect_cdrs

pasf_simplat1

reln

diffsq

wedgek2

fortexp

repartf

assert_uninstall1

setel1

fs!:times

splitlist!:

resimpf

crprcd2

aex_mvar

!*!*a2s

groebcplistsortin1

bytelist2id

mktails1

one!-entry!-listp

setelv

prepd1

pst_termnodep

ratn

quotfail!-in!-vector

subsublis

homogp

unaryrd

inttovec1

mkfortterpri

trwrite

lienjactest

Finished reading "$reduce/cslbuild/generated-c/u22.lsp"

Reading "$reduce/cslbuild/generated-c/u23.lsp"

nil

arplus!:

gfk

coeffs

dfprint

monomwrite

mkpartitions1

rl_atnum

tayexp!-times2

talp_subt

qqe_arg!-check

sq2sstm

reform!-minus

dm!-minus

dip!-nc!-ev!-prod1

evgradlexcomp

collectphystype

replace1_parents

pairxvars

scalprod

simp!-prop!-order

yypeek

readprogn

rl_pnf

mri_pasf2mri

pasf_dt

naryom

subs4q

makeset

my_letmtr

xlcm

physopordchk

def_edge

total!-degree!-in!-powers

set!-global!-mode

setel

groeb!=weight

general!-modular!-expt

let2

ordered!-gcd!-mod!-p

p_prinl2

talp_contains

qqe_eta!-in!-term

ev_lexcomp

row

xregister_wedge_pair

gfdot

!:dmpluslst

putd

Finished reading "$reduce/cslbuild/generated-c/u23.lsp"

Reading "$reduce/cslbuild/generated-c/u24.lsp"

nil

fs!:null!-angle

mo_equal!?

st_sorttree

rlis

settinsert

get!*elements

dipcondense

cut!:ep

splitcomplex

fs!:prin1

mo_lcm

numlist_ordp

lambda_ygm6np4pcqv31

remlocs

revalx

rl_subalchk

pasf_zcong

vdp_setsugar

ps!:prepfn!:

ps!:putv

mktails

impartf

riv_mk

aex_bvarl

gcref_mkgraph!-tgf

polynomlistreduce

opmtchrevop

rl_eqnrhskernels

pasf_floor

bvarml

band_matrix

rd!:zerop!:

flatindl

formcond1

red_totalred

ilog2

lalr_prin_production

defineargs

ofsf_ignshift

tripleisprolongedby

ofsf_smupdknowl

cl_smsimpl!-junct1

om2ir

mkmatrix

setdmode

gbfdot

r2findindex

comblog

assert_check1

matop_pseudomod

gcdout

Finished reading "$reduce/cslbuild/generated-c/u24.lsp"

Reading "$reduce/cslbuild/generated-c/u25.lsp"

nil

pa_coinc_split

lambda_er1ez819f9yx2

cde_position

lto_sgnchg1

cl_pnf

mri_prepat

vdp_make

max!-degree

binaryrd

rationalizesq

delhisto

quoteequation

gvarlis1

bcneg

physopsimp

ev!-denom2

copy!-tree

safe!-modrecip

setk_super_vectorfield

lalr_construct_fn

ctx_idl

wupseudodivide

evaluatecoeffts

vdp_getprop

dip_condense

mml2ir

pfordp

prinlatom

exptpri

ordop2

edges_parents

mo_zero

!*di2q0

dv_skel2factor1

let3

lalr_print_compressed_action_table

ofsf_subf

simpexpt11

quotelog

encodeir

simpdf!*

evdif

evaluate1

assert_install1

red!=cancelsimp

Finished reading "$reduce/cslbuild/generated-c/u25.lsp"

Reading "$reduce/cslbuild/generated-c/u26.lsp"

nil

subs3t

dmconv0

ra_zerop

refprint

cl_f2ml

ofsf_at2ir

expnd

groedeletip

insertparens

can_be_proved

log_assignment_list

dv_cambhead

mod_eval_uni_poly

nonlnrsys

lalr_make_arglist

rl_bettergaussp

texstrlen

talp_list2vec

pasf_cein

unaryir

ps!:evaluate!-next

vdpvevlcomp

random

getphystypecar

factorial

random!-teeny!-prime

sfto_dgcd

outrefend

simpcv

smemberlp

offexpchk

formc!*

physopordchk!*

red_topredbe

trailing!.coefft

gf2cr!:

extmult

add2locs

monomcomparedeglex

poly!-multfnc

talp_telp

pasf_anegrel

multi_args

getdec

memqcar

oprinla

gftimesn

fieldconv

repeats

reduce!-mod!-p!*

Finished reading "$reduce/cslbuild/generated-c/u26.lsp"

Reading "$reduce/cslbuild/generated-c/u27.lsp"

nil

gcd!-in!-vector

lalr_make_compressed_goto_column

aex_neg

innprodp2

talp_subat

rl_updcache

ioto_form2str1

lambdafun

ft!:zerop

oldmtch

dipev2f

sfpx1

pcdiv

sc_rep

super_der_simp

yylex

outrdefun

ofsf_sippsubst

ofsf_surep

matpri

termorder1

sfto_b!:extadd

matrixrowom

rootextractsq

meq

edge_new_parent

log_inlines

red!=hidelt

extract_dummy_ids

lalr_most_common_dest

formrlis

get!-free!-form

get_char_value

qqe_arg!-check!-q

fortranname

assert_error

nf

lalr_make_compressed_action_table

outref

ofsf_smwmkatl

ioto_smaprinbuf

lambdavar

n_nary

gcd2

Finished reading "$reduce/cslbuild/generated-c/u27.lsp"

Reading "$reduce/cslbuild/generated-c/u28.lsp"

nil

inprint

mksetq

general!-evaluate!-mod!-p

bndtst

setk1

lex_export_codes

comm1

createtriplewithancestor

qqe_ofsf_simpat

ev_mtest!?

ombindir

rowdel

string!-of!-list

rdcos!*

mk!-numr

assert_stat1

mo_2a

lalr_collect_terminals

gcref_remprops

prepreform1

cl_atl1

internal!-factorf

sfto_b!:ordexp

nextcomb

gcompatible

contr!-strand

nzero

merge

insert

charnump!:

build!-null!-vector

lalr_generate_collection

normalform

wureducedp

get!-denom!-ll

mksp!*

talp_try

vunion

cnrd

doublep

groebsavelterm

permp

getphystypeor

l!-subst

formde

sqhorner!*

delasc

lalr_prin_reduction

co_new

ofsf_negateat

mk!+conjugate!+sq

dm!-mkfloat

bcfd

vevstrictlydivides!?

equalreval

contract!-strand

sf2mv

fs!:prepfn!:

all_sml_opchar

Finished reading "$reduce/cslbuild/generated-c/u28.lsp"

Reading "$reduce/cslbuild/generated-c/u29.lsp"

nil

mkfil!*

sortedtriplelistinsert

cquotegex

ofsf_facequal!*

talp_copy

factor!-prim!-f

evrevgradlexcomp

critical_element

bfplusn

st_consolidate

ratminus

cde_odd_derivatives

hasarg

ofsf_posvarp

rndifference!:

mk!+trace

talp_specsubat

vdp_sugar

unresidp

physop!-multfnc

edge_new_parents

groeb!=newpair

quotof

ra_wrapper1

negind

tayexp!-minus

cl_rename!-vars

rl_susipost

dip_f2dip1

omfir

getphystypetimes

prop!-simp2

quotpri

red_tailred

no_dum_varp

arminusp!:

idtomind

expansion_name

quotkx

ifstat

add!-degrees

cl_sordpl

pasf_or

sfto_subfwd

opfneval

initarg

sc_geq

boolvalue!*

no!-side!-effect!-listp

lalr_cleanup

open

pushback

talp_getinvfsym

qqe_eta!-in!-term1

pasf_fact

acfsf_0mk2

degree!-order

lambdaom

inprinla

Finished reading "$reduce/cslbuild/generated-c/u29.lsp"

Reading "$reduce/cslbuild/generated-c/u30.lsp"

nil

pterpri

assert_declarestat1

mksf

dvfsf_susitf

ofsf_smmkatl

cl_nnfnot

fctrf

ev_insert

testpr

embed!-null!-fn

vdpcondense

subla!-q

changearg

cons_ordp

general!-ordered!-gcd!-mod!-p

gcref_off

checku

make!-modular!-symmetric

opfneval1

atomlis

bcminus!?

dipprod

basisformp

sgn1

deginvar

dfconst

domainvalchk

qqe_arg!-check!-lb!-rb

relnrd

unify

dipsum

locate_member

repartsq

harmonicp

simp!-prop2

reverse!-num1

qtypnm

ofsf_siatsubf

ofsf_simplat1

drop_rl_with

width

qqe_simplterm!-tail

Finished reading "$reduce/cslbuild/generated-c/u30.lsp"

Reading "$reduce/cslbuild/generated-c/u31.lsp"

nil

factor!-prim!-sqfree!-f

derad

dip2vdp

indordn

generic!-sub

symbol

modp

horner!-rule!-for!-one!-var

letscalar

ra_l

lalr_process_productions

read_signature

ofsf_smordtable

mk!+squared!+norm

cgp_mk

semanticml

evalvars

vdp2a

overall_factor

nconc2

testchar1

gparg1p

formsetq

mv!-pow!-!>

red!=subst1

lalr_process_reductions

monomgetfirstmultivar

talp_noffcts

lesspcdadr

matrix_rows

noncomexpf

xriterion_1

gfplusn

sign!-of

assert_stat!-parse

comb

gcref_off1

sfto_updecf

simpexpt1

get_char_group

Finished reading "$reduce/cslbuild/generated-c/u31.lsp"

Reading "$reduce/cslbuild/generated-c/u32.lsp"

nil

talp_atnum

minusml

exptplus

add_minus

dipnumcontent

sc_getrow

f2dip11

eqexpr

formatfort

one!-entryp

subsq

groeb!=rf1

length_multiindex

lex_basic_token

in_list1a

formboollis

talp_specsubt

multiminus

dm!-min

indxchk

incident

simp!-prop1

!*di2q

st_ad_numsorttree

expand_rule

cl_susiupdknowl1

ev_max!#

containerml

ps!:constmult!-erule

mkempspmat

insoccs

module

!*xadd

chkrn!*

!*a2f

lalr_extract_nonterminals

Finished reading "$reduce/cslbuild/generated-c/u32.lsp"

Reading "$reduce/cslbuild/generated-c/u33.lsp"

nil

triplesetprolongedby

!*tayexp2q

vdelete

omatpir

suchp

!*pf2sq

s_actual_world1

subs2chk

simp!-prop!-condense

lambda_rfde09ec49c92

skp_ordp

gitimes!:

ofsf_ir2atl

repr_a

dip_ilcomb2r

ev_2a

bvarrd

!:dmtimeslst

prop!-simp

red_topred

list_is_all_free

general!-horner!-rule!-mod!-p

!*a2k

formbool

talp_sumd

sets

alg_plus

matrixp

amatch

groebnormalform

evload

toolongexpp

find_buble

log_assignment

arglength

fs!:onep!:

red!=hide

dummyp

ratdif

letexprn

poly!-to!-vector

lex_process_directive

arg1of2

profile_a_package

vp2

pasf_exprng

Finished reading "$reduce/cslbuild/generated-c/u33.lsp"

Reading "$reduce/cslbuild/generated-c/u34.lsp"

nil

mapcarcar

matrixom

close_forall

lispreadp

reval3

color!-roads

remchkf

split_cov_cont_ids

proper!-simpsqrt

make!-x!-to!-p

lex_skip_line_comment

sortedpolynomlistinsert

multdfconst

mri_congp

rat_abs

applyfnrd

ps!:times!-erule

matsm1

recaliasbacksubst

dipprodin

difference!:

evaluate!-horner

indexsymmetrize

po!:statep

color!-strand

greaterpcdr

clogsq!*

fs!:prin

dfprintfn

msolve!-poly1

cde_replace_nth

ra_qmk

aex_lc

polynomwrite

taydegree!<

gen!+can!+bas

cl_bvarl1

qqe_ofsf_varlat

cl_susiinter

ev_dif

bc_mkat

vectorml

delyzz

make!-unique!-freevars

fieldp

dipsimpcont

greaterp!:

calc_coeff

Finished reading "$reduce/cslbuild/generated-c/u34.lsp"

Reading "$reduce/cslbuild/generated-c/u35.lsp"

nil

log_freevars_list

ratfunpri1

mo_zero!?

!*f2di

msolve!-polyn

reduce!-mod!-eigf

ra_u

vdp_putprop

listrd

ps!:sqrt!-erule

resume

evinvlexcomp

vdpilcomb1

unplus

!*!*a2i

dv_ind2var

lalr_warn_shift_reduce_conflict

dvfsf_v

plusdf

get!*inverse

cgp_lbc

getargsrd

valuecoefft

evaluate

assert_procstat!-argl

ad_splitname

difbf

order_of_der_mind

lalr_get_lex_codes

polynomcompare

ofsf_smcpknowl

multdf

talp_specsub

ithlistelem

maxl

sc_subtrsq

getrlist

plubf

sublap

min0

indordl2

getphystypeall

deletez1

realvaluedp

assert_formproc

subeval1

remchkf1

subcare

mo!=zero

gvar1

ofsf_lnegrel

Finished reading "$reduce/cslbuild/generated-c/u35.lsp"

Reading "$reduce/cslbuild/generated-c/u36.lsp"

nil

mk!+real!+inner!+product

sqfrf

fnrd

physoptimes

prop!-simp1

liennewstruc

dp_neworder

rl_fvarl

give!*position

pasf_smwcpknowl

ciml

sparpri

groebspolynom3

evalb

string2bytelist

lf!=zero

clean_numid

drnconv

ra_intequiv0

lex_init

ofsf_sippsubst1

even_action_sf

maxfrom1

get!-denom!-l

talp_maxd

symbolsom

degreef

sc_mkmatrix

collectphysops_reversed

contr2

listsub

fs!:make!-nullangle

groeb!=crita

split!-further

rl_transform

evalnumberp

rl_convertarg

mconv1

setrd

exdff0

r2findindex1

chkint!*

innprodpex

rootextractf

Finished reading "$reduce/cslbuild/generated-c/u36.lsp"

Reading "$reduce/cslbuild/generated-c/u37.lsp"

nil

lessppair

lalr_print_first_information

smt_prin2x

ofsf_simplequal

pasf_exprng!-gand

bvarom

s!-nextarg

wedgef

apply_e

diff_vertex

assert_kernelp

evalgreaterp

solvealgdepends

make!-image

giplus!:

ext_mult

gcd!-with!-number

aex_sgn

containerom

mkexdf

z!-roads

msolve!-psys1

ratlessp

lastcar

aex_divposcnt

settcollectnonmultiprolongations

processpartitie1list1

mk!+outer!+list

repr_ldeg

dip_f2dip2

setfuncsnaryrd

sqprint

red_tailreddriver

getavalue

reduce!-eival!-powers

find!-null!-space

set_parser

sq_member

orddf

cl_susiupdknowl

gftimes

calc_den_tar

no!-side!-effectp

atom_compare

lalr_expand_grammar

aex_stchsgnch1

janettreenodebuild

even_action_term

testord

my!+nullsq!+p

pasf_varlat

rl_surep

minusrd

assoc2

rewrite

ndepends

Finished reading "$reduce/cslbuild/generated-c/u37.lsp"

Reading "$reduce/cslbuild/generated-c/u38.lsp"

nil

weak_xreduce1

intrdsortin

all_defined_vertex

listeval0

num_signsort

lambda_ygm6np4pcqv31

lpos

makeqn!-maybe

lalr_lr0_initial_itemset

aex_mklcnt

multerm

mri_opn

dip_sum

ofsf_factsf

determinantrd

greatertype

mkupf

!:!:quotient

calc_coeffmap_

lalr_make_compressed_goto_table

setqinsertlist

cl_bvarl

pasf_smwupdknowl

omattrir

sptransmat

vdpcleanup

contposp

toolongassignp

simppartdf

s_world_names

dp_from_ei

createmonomunit

pickbasicset

mri_ofsf2mriat

intervalom

remzzzz

sc_rowscalarproduct

simpunion

gbfplus

indxsymp

getphystypeexpt

fs!:minusp

squashsqrt

ofsf_decdeg2

mk!+scal!+mult!+mat

cl_susiupdknowl2

gcdld

matrixelems

f2dip1

add_item

bflessp

spp

s_noparents

xremf

vector!-to!-poly

Finished reading "$reduce/cslbuild/generated-c/u38.lsp"

Reading "$reduce/cslbuild/generated-c/u39.lsp"

nil

lex_keywords

cl_atnum

cl_pnf1

fnom

plusrd

simpimpart

genexp

exdfprn

aceq

log_freevars

bas_make

pst_subpst

appn

multivariatep

lalr_augment_grammar

createsinglevariablemonom

my_freeof

giintgcd

talp_nextt1

rl_onp

vectorrd

ldf!-simp

transmat1

on!-double1

getupper

replace2_parents

prepsq!*1

reduce

fs!:minusp!:

xnsiz

lalr_collect_nonterminals

simpexpt2

pasf_uprap

lowupperlimitrd

spcol_dim

inszzz

qsum!-simpexpt1

simp_without_resimp

groebinvokecritm

sc_columnscalarproduct

mkbc

applysetop

mod!-dump1

quotodd

Finished reading "$reduce/cslbuild/generated-c/u39.lsp"

Reading "$reduce/cslbuild/generated-c/u40.lsp"

nil

lengthreval

ra_intequiv

component_action

fctargs

rl_mk!*fof

rl_bnfsimpl

repr_n

matrixrd

fnreval

evweightedcomp1

pa_list2vect

fd2q

outer!-simpsqrt

oddext

polynomread

expf

mri_2ofsfat

quotfx1

rl_multsurep

upperlimitrd

compl

suspend

vdpequal

evinsert

simpwedge

divide!-by!-power!-of!-ten

cvitimes2

ratnump

miller!-rabin

dfp!-sub

redall

get!-current!-representation

prepsq!*0

isimp1

rl_qefsolset

intervalrd

prlist

letmtr

a2bc

gfplus

numprintlen

mk_binding

equiv!-coeffs

taylorp

lesspcar

rl_qe

cl_apply2ats1

maxfrom

mk!+mat!+plus!+mat

ezgcd!-comfac

transposerd

Finished reading "$reduce/cslbuild/generated-c/u40.lsp"

Reading "$reduce/cslbuild/generated-c/u41.lsp"

nil

extbrsea

copy_mat

exdf0

multiply!-by!-power!-of!-ten

formsetq0

simp!-prop!-dist

lambda_iff2c8okfzyq1

lambda_iff2c8okfzyq1

list2vect!*

which_first

talp_trygaussvar

cl_gand!-col

pasf_susibinad

ctx_get

symbolsrd

findelem2

init

size_of_matrix

fl2bf

list!-evaluate

consrecip

splitup

simpquot

mchsarg

algmodep

xnp

lalr_set_nonterminal_codes

talp_invtscc

pasf_sacat

diffrd

insertocc

xreadlist

incident1

set!-weights

!*g2lex

!*n2a

basic!-kern

noncomfree

gadd

mk!+equation

talp_invtscsimpl

repr_new

prsubsetrd

Finished reading "$reduce/cslbuild/generated-c/u41.lsp"

Reading "$reduce/cslbuild/generated-c/u42.lsp"

nil

findoptrow

diplmon2sq

remove_least_item

listpri

r2speclist1

mkassign

ev!-edgeloop

primep27

nonmult

xquotient!-mod!-p

mkcrn

extadd

read!-comment1

sfto_yun!-updecf

rl_identity1

pasf_anegateat

bc_sum

ciom

f4

evzero

chksymmetries!&sub1

strand!-alg!-top

cali!=min

appr

sfto_psrem

co_hfn

ofsf_updsigndom

change!+int!+to!+sq

cl_subfof

rl_sacatlp

conditionml

simpu

qsimpcomb_standard_integer_part_sf

a2vdp

markedvarp

evalwhereexp

mv!-compact2

extract_vars

expand_terminal

not_included

valuechk

cgp_greenp

integralir

specrd!:times

dip2a

evalmember

gbfdiff

gpargp

indexvp

mk_simpl_map_

simpdfp

balance_mod

super_vectorfield

rtypepart

fctlength

Finished reading "$reduce/cslbuild/generated-c/u42.lsp"

Reading "$reduce/cslbuild/generated-c/u43.lsp"

nil

gigcdsq

subtractinds

mk!+resimp!+mat

freeof!-dfl

pasf_coeflst

vdp_mred

vsl_subatsq

numir

diford

remdiff

xpartitop

gfdiffer

reduce!-columns

groeb!=testc1

mk_dummy_ids

aex_mult

createtriple

mksfpf

enter!-sorted

pasf_premf

vsl_boundtype1

cols2rows2

reduceroots

ps!:set!-term

ldf!-dep!-var

o!-nextarg

e!*

physoppri

ev!-poles

quotofd

negex

revalpart

prepcadr

ra_wrapper

qqe_simplbtat

pasf_ordatp

conditionrd

Finished reading "$reduce/cslbuild/generated-c/u43.lsp"

Reading "$reduce/cslbuild/generated-c/u44.lsp"

nil

diffp

get!:const

nspaces

all_defined_map_

quotexf!*

general!-multiply!-by!-constant!-mod!-p

rl_nnfnot

makecoeffpairshom

pasf_exprng!-gball

matrixml

convprc2

findhr

r2oaddspecies

ordpl

evalletsub

lieninstruc

gcdlist

nlist

pasf_ceil

lowupperlimitml

ps!:plus!-erule

make_spoly_pair

simpsetdiff

defined_all_edge

Finished reading "$reduce/cslbuild/generated-c/u44.lsp"

Reading "$reduce/cslbuild/generated-c/u45.lsp"

nil

applsmacro

prsum

subs2p

prim!-part

totalcompareconstants

quotientml

simpsqrtsq

ps!:arg!-values

wedgewedge

mksqrt

fermionicp

rule

depend!-f

mri_ofsf2mri

csymbolrd

!*rn2rd

dipcontevmin

subfindices

gd_gcasesimpl

ofsf_sippsignchkf

mri_prifloor

make!-image!-mod!-p

matrixir

simpdf

findhc

gfstorval

fortassign

new_prove

sign!-abs

setmatelem

dfp!-rule!-found

fs!:timescoeff

mkindxlist

inormmat

no_of_tm_sf_limited

settreset

ofsf_updsignvar

mkexpt

iv_cutn

bc_gcd

cnml

znumrnil

scar

copy_vect

partitwedge

endmodule

mkforttab

coeff_calc

split!-comfac!-part

listminimize

zfactor1

precision

mkrootsql

talp_simplatlinv

Finished reading "$reduce/cslbuild/generated-c/u45.lsp"

Reading "$reduce/cslbuild/generated-c/u46.lsp"

nil

pasf_smwmkatl

gb_searchinlist

d2int

tchscheme2

sroot1

xregister_spoly_pair

evaluate2

mv!-compact

simp!-prop

try!-all!-constants

polynomlistautoreduce

ofsf_qesubqat

tayexp!-max2

cl_replace!-varl

qqe_simplqneq

pdiffvars

rnfix!*

newsym1

nestzerop!:

dipdivmon

sc_scalarproduct

delete_edge

mkimpart

mv2sf

nodum_varp

mkrootsq

ofsf_facequal

polynomreduceby

cl_sacat

aex_simplenumberp

operator_fn

qsum!-simpexpt

calc_atlas

rfirst

reduce!-ratios

check_letop

cl_identifyonoff

mri_simplat1

limitom

solvealgtrig01

gfftimes

asymmetrize!-inds

ctx_union

monomcomparelex

Finished reading "$reduce/cslbuild/generated-c/u46.lsp"

Reading "$reduce/cslbuild/generated-c/u47.lsp"

nil

ofsf_smmkatl!-and1

simpx1

vdp_monp

dip!-nc!-ev!-prod

lndepends

listquotient

vecsimp!*

verify_tens_ids

evaluate!-in!-order!-mod!-p

domainp_list

!*a2kwoweight

drop_dec_with

cl_sordp

rl_sacat

acfsf_clnegrel

dipretimes

indordln

free

!*multf

nonlnr

janettreeinsert

ofsf_smeqtable

ev_init

spinnerprod

dipequal

natnump

defined_vertex

reduce!-weights

fs!:prin!:

bagp

bfminus

get!-new!-prime

girationalize!:

talp_lssimpl

bc_dcont

cr!:prep

vdplsort

Finished reading "$reduce/cslbuild/generated-c/u47.lsp"

Reading "$reduce/cslbuild/generated-c/u48.lsp"

nil

maprintla

mkdmoderr

reset_opnums

mk_names_map_2

njets

pst_mkpst

general!-modular!-difference

aex_psrem

f2df

get_dimension_in

talp_qesolset

cl_susicpknowl

gpexpp

mo_support

addnew

flattens1

mkexpvec

qroundup

aex_unbind

min2!-order

mk!+inner!+product

mri_simplfloor1

cl_bnfsimpl

vdp_zero

countof

evalgeq

lengthn

spmatlength

sfpf

pnth!*

generic_arguments

fs!:subang

cali_bc_from_a

dv_skel2factor

alistp

add!-factor

dfdeg

talp_get!-idx

iv_new

mulpower

parfool

spmatsm!*

matsm!*

f2dip

dim!<!=deg

mk_parents_prim

expand!-imrepartpow

bfrsq

sfchk

replace!-next

talp_mkinvop

bc_zero

gfquotient

mkrepart

mo!=expvec2a1

sub01

depend!-sq

mri_irsplit1

pasf_smordtable

den

groebcplistmerge

subs2pf

!:log2

lispcodeexp

physopsubs

Finished reading "$reduce/cslbuild/generated-c/u48.lsp"

Reading "$reduce/cslbuild/generated-c/u49.lsp"

nil

mk_world1

fs!:zerop!:

dp!=retimes

st_sorttree1

even_action

dvfsf_0mk2

nextu

xadd!*

pasf_smordtable2

rat_leq

prload

dipcontenti

!:log10

monic

pa_part2list

baglistp

random!-small!-prime

acell_getsp

ofsf_smmkatl!-and

impartsq

qqe_length!-graph!-neighbor!-edge

ev_divides!?

addexptsdf

mkunarywedge

newvar

endofstmtp

get!-all!-kernels

evaluate!-in!-vector

atree_rootcell

ofsf_anegrel

mktag

makecoeffpairs

pasf_leqp

ldf!-deg

!*ff2a

groebcplistsort

groebreduceonestepint

mk!-contract!-coeff

isimp2

derivative!-mod!-p

ofsf_bestgaussp

taymindegreel

vdp_fdip

ldf!-sep!-var

sprow_dim

dm!-lt

vdpsimpcont

force!-to!-dm

is_buble

positive!-powp

reddom_zeros

red_prepare

general!-difference!-mod!-p

remainder!-mod!-p

ofsf_sippatl

constructinvolutivebasis

Finished reading "$reduce/cslbuild/generated-c/u49.lsp"

Reading "$reduce/cslbuild/generated-c/u50.lsp"

nil

ofsf_sminsert1

opfchk!!

get!*order

talp_try2

reprod

groebmakepair

al1_defined_vertex

coeffs!-to!-form1

freeoflist

updkorder

ofsf_smwrmknowl

gd_simpl

!*multsq

talp_simplatfn

qqe_length!-graph!-neighbors

arprep!:

make_wedge_pair

coeff_sortl

rule!-list

df!-chain!-rule

cali_bc_power

test!-bool

pst_d1

dnform

count!-linear!-factors!-mod!-p

ofsf_smdbgetrel

qqe_length!-graph!-marked

pasf_dnf

division!-test

ldf!-spf!-var

dipreplus

ratmean

indordlp

simp!-prop!-form

can_rep_cell

even_action_pow

quotf!*

talp_cocc

sfto_deggcd1

vdpfmon

xexptpf

latexprint

denlist

hdiff

eval!-yetunknowntypeexpr

gigcd!:

matrix_input_test

Finished reading "$reduce/cslbuild/generated-c/u50.lsp"

Reading "$reduce/cslbuild/generated-c/u51.lsp"

nil

symmetrize!-inds

combin

dv_skelsplit

simpdot

coeff_totder

ofsf_smmkatl!-or1

change!+sq!+to!+int

qqe_simplqequal

acfsf_varlat

gb_buchcrit4t

transferrow1

vdpmember

exptbf

preproc

coeff1_calc

subs2chkex

red_redpol

ofsf_smmkatl!-or

simp!-sign2

talp_try1

tchscheme

cos!*

requote1

store_edges

normmat

extract_numid

eval_uni_poly

exports

smt_liter

giprim

qqe_prefix!-length

rl_simplb

intconv

splitrec

f2dip2

xpartitk

sqprla

physop!*sq

precision1

merge_lists

update_components

ofsf_irl2atl

ofsf_evalatp

Finished reading "$reduce/cslbuild/generated-c/u51.lsp"

Reading "$reduce/cslbuild/generated-c/u52.lsp"

nil

mk_resimp_rep

bc_minus!?

expttermp

expvec2a1

multsqpf

rand!-mons!-sparse

exp!*

atlas_edges

actual_arguments

dp!=comp

rl_identifyonoff

addfactors

rule!*

constant_exprp

pasf_smordtable1

ps!:difference!-erule

getvariables

gbftimes

r2oreaction

binc

dp_2a

cde_list2id

subdf

talp_mk!-invs

qqe_dfs

i2ps

ldf!-pow!-var

fast!-augment!-columns

decimal2internal

dvertex!-to!-projector

clogsq

lf!=tovarlessp

dummy_nam

st_extract_symcells1

mod!/

cr2rderr

quotfexf!*1

texexplode

dip_monp

parseml

mkratnum

poly!-remainder

xpartitsq

acmemb

redassignp

adjp

calc_world

!*sq2fourier

!*v2j

ic_taglist

initmonomials

depend!-p

ofsf_simpat

force!-lc

simpsqrt2

cr!:zerop

varsinsf

row_dim

xpndwedge

find_bubles_coeff

lf!=less

general!-negate!-term

allbkern

Finished reading "$reduce/cslbuild/generated-c/u52.lsp"

Reading "$reduce/cslbuild/generated-c/u53.lsp"

nil

ofsf_sminsert

addinds

multtaylorsq

talp_nextt

qqe_length!-graph!-bterm

!*kp2q

physopplus

mk!-strand!-vertex

lchk

rationalizef

all_index_lst

bfprin0x

addcoeffs

mrv_constantp

equal!+matrices!+p

bc_pmon

vevzero!?1

remove_critical_pairs

noncom1

bassoc

gak

square!-free!-mod!-p

sfto_b!:cquot

operator

tidysqrt

subscriptedvarp2

expttermp1

dipcontenti1

evalsubset

all_defined

pa_vect2list

lowestdeg

rl_ex

ofsf_exploitknowl

get!*nr!*real!*irred!*reps

constant_expr_listp

qqe_simpat

ieval

column_dim

vdpappendmon

xriterion_2

gffdot

r2speclist

new_provev

dpmat_gbtag

general!-minus!-mod!-p

simprd

cde_alglistp

find_active_components

!*invsq

null!+vec!+p

cl_strict!-gdnf

bc_abs

dip_comp1

subsubf

deflate1

ev!-tades

restore_props

sc_create

Finished reading "$reduce/cslbuild/generated-c/u53.lsp"

Reading "$reduce/cslbuild/generated-c/u54.lsp"

nil

rtrnda

radd

coeffs!-to!-form

aex_psremseq

rl_!*qe

mkuniquewedge

minprec

tvectorp

ext_edges

liendimcom

mo!=pair

gi

!*sf2exb

prepsqyy

ordexp

cde_mkset

small!-random!-number

ofsf_updsignpow

chrstrem

no_of_tm_sf

giminusp!:

qqe_qadd!-inside

dip_reduceconti

crprimp

rewrite2

weak_xreduce

rand!-comb

Finished reading "$reduce/cslbuild/generated-c/u54.lsp"

Reading "$reduce/cslbuild/generated-c/u55.lsp"

nil

partitindexvar

mk!-coeff1

modroots1

mkg1

gd_newtype

dfmax

uterm

talp_try3

simpsqrt3

ps!:value

setprev

gvarlis

xreduce1

calc_map_tar

!*ex2sf

red_extract

!*hfac

sep_tens_from_other

sqlessp

generate_multiindex

sfto_mindeg1

cl_ex

ofsf_canegrel

get_rep_of_generator

rl_reval

pasf_univnlp

remk

irp_aex

mod!-domainvalchk

remove_root_item

calc_map_2d

depend1

zfactor

simprad

crn!:zerop

imports

monomispommaretdivisibleby

talp_raf

Finished reading "$reduce/cslbuild/generated-c/u55.lsp"

Reading "$reduce/cslbuild/generated-c/u56.lsp"

nil

search_att

mo_from_ei

boolean!-eval2

distri_pol

aex_xtothen

get!-min!-degreelist

available!*p

talp_get!-minfct

mri_irsplit

subsqnew

implicitdec

bccheckz

xnormalise

unshift

simpabs

!*sf2ex

compactf3

extodd

ofsf_facneq!*

cl_subfof1

applyml

product!-set2

dip!-nc!-m!*p!-distleft

vdplsortin

validrule

preproc1

basisvectorp

new_edge

solvevars

rlval

ra_i2ra

Finished reading "$reduce/cslbuild/generated-c/u56.lsp"

Reading "$reduce/cslbuild/generated-c/u57.lsp"

nil

gcdlist1

preptaylor!*!*

ev_2f

redpar

cr!:minusp

vdpenumerate

listofvarnames

p_eq_vertex

intargfn

fillin

compactf1

tensor_has_dummy_idx

cdr_signsort

x!*!*p!-w

uniquifyf

add!-to!-sorted!-tree

getsetvarlis

gd_applyscheme

absodeg

depend!-l

rl_print!*fof

cl_susimkatl

ev_compless!?

appends

groebsaveltermbc

simpintersection

rand!-mons!-dense

lispcondp

actual_world

groeb!=testb

nrootnn

ofsf_qesubq

makecoeffpairs1

ev_lcm

cd_ordatp

unary

tidysqrtf

dm!-quotient

rm_neg_pow

mkuniquewedge1

!:dmexpt

rep_parents

dp_prod

Finished reading "$reduce/cslbuild/generated-c/u57.lsp"

Reading "$reduce/cslbuild/generated-c/u58.lsp"

nil

sc_repkern

lambda_1x539vlzlwg93

super_product_sq

setqdeletedescendants

ofsf_ordrelp

yetunknowntypeeval

let0

get_rep_matrix_entry

mri_dettype

qqe_length!-graph!-remove!-mark

aex_fromsf

ps!:expansion!-point

nestprep!:

bfdivide

calc_map_

rappend

formclear

partsym_zerop

modroots2

r2flbf

order_of_der

talp_gaussand

rl_b2atl

rat_0

ldt!-dep

pm!:gensym

groebsimpcontnormalform

!:quotient

matcheq

tot!-asym!-indp

!*s2arg

com43

affinep

deg

odd_action

ra_onep

aex_diff

lto_hentry

put!-avalue

talp_prepat

Finished reading "$reduce/cslbuild/generated-c/u58.lsp"

Reading "$reduce/cslbuild/generated-c/u59.lsp"

nil

pasf_premf1

search4facf

frlp

xvarp

kernelp

mo_deletecomp

algebnp

ratleqp

gcdk

interglue

pasf_qff2ivl

cfrmconstant

cflot

partitpartdf

propagator

invbase!*

st_flatten

dependsp

bf2rn1

anu_mk

conjgd

mk_character

rl_cput

acfsf_smmkatl

vp1

ps!:depvar

numberofoccs

!:mod!:units

idealp

lexorder

pst_partition

lambda_sorneshiwvd12

bibasis

evalleq

taysimpsq!*

repr_atfnew

ev_disjointp

exdfp0

rand_functionp

partdff

find_triangl_coeff

Finished reading "$reduce/cslbuild/generated-c/u59.lsp"

Reading "$reduce/cslbuild/generated-c/u60.lsp"

nil

lie4

make!-image!-lc!-list1

rdzchk

memlis

modular!-factor!-count

ofsf_chsimpat1

clearrules

negdf

get!*generators

formopr

rnfloor!*

codfac

qsimpcomb_standard_qexp_part_sf

xreorder

exdfpf

texaeval1

getphystypestate

Finished reading "$reduce/cslbuild/generated-c/u60.lsp"