+++ Transcript to lalr.log started at Wed May 11 11:31:08 2016 +++
REDUCE (3648), 11-May-16 ...

on echo;

lisp;
nil


enable!-errorset(3,3);
(0 . 3)

 % CSL speciality to get diagnostics on error
remprop('yyparse, 'number!-of!-args);
nil

 % Get rid of historical info.
on comp;
nil


in "lalr.red"$
nil

lalr

nil

nil

nil

nil

nil

nil

 in "yylex.red"$
nil

nil

0

1

2

3

4

((0 . !:eof) (1 . !:symbol) (2 . !:string) (3 . !:number) (4 . !:list))

5

nil

nil

0

1

3

2

4
+++ lex_unicode_alphabetic compiled, 24 + 24 bytes

lex_unicode_alphabetic
+++ lex_unicode_numeric compiled, 12 + 16 bytes

lex_unicode_numeric
+++ lex_keywords compiled, 223 + 92 bytes

lex_keywords
+++ lex_cleanup compiled, 30 + 36 bytes

lex_cleanup
+++ lex_save_context compiled, 26 + 16 bytes

lex_save_context
+++ lex_restore_context compiled, 65 + 40 bytes

lex_restore_context
+++ lex_export_codes compiled, 4 + 20 bytes

lex_export_codes
+++ yyreadch compiled, 32 + 40 bytes

yyreadch
+++ yyerror compiled, 89 + 68 bytes

yyerror

nil
+++ lex_init compiled, 30 + 52 bytes

lex_init
+++ yylex compiled, 275 + 140 bytes

yylex
+++ lex_conditional compiled, 27 + 24 bytes

lex_conditional
+++ lex_skipping compiled, 81 + 52 bytes

lex_skipping

nil
+++ lex_basic_token compiled, 438 + 168 bytes

lex_basic_token

46

41

93
+++ read_s_expression compiled, 209 + 100 bytes

read_s_expression

nil

nil

 in "yyparse.red"$
nil

nil

nil

nil

nil
+++ set_parser compiled, 40 + 40 bytes

set_parser
+++ get_goto compiled, 27 + 12 bytes

get_goto
+++ get_action_without_lookahead compiled, 11 + 12 bytes

get_action_without_lookahead
+++ get_action compiled, 27 + 12 bytes

get_action
+++ yyparse compiled, 355 + 168 bytes

yyparse

nil

nil

 
in "genparser.red"$
nil
+++ lalr_precedence compiled, 9 + 12 bytes

lalr_precedence
+++ lalr_associativity compiled, 9 + 12 bytes

lalr_associativity

nil

nil

nil
+++ lalr_add_goto compiled, 19 + 20 bytes

lalr_add_goto
+++ lalr_goto compiled, 16 + 16 bytes

lalr_goto
+++ lalr_productions compiled, 4 + 12 bytes

lalr_productions
+++ lalr_create_parser compiled, 60 + 76 bytes

lalr_create_parser
+++ lalr_cleanup compiled, 31 + 28 bytes

lalr_cleanup
+++ lalr_set_grammar compiled, 92 + 76 bytes

lalr_set_grammar
+++ lalr_augment_grammar compiled, 17 + 12 bytes

lalr_augment_grammar
+++ lalr_create_precedence_table compiled, 82 + 24 bytes

lalr_create_precedence_table
+++ lalr_set_nonterminal_codes compiled, 56 + 40 bytes

lalr_set_nonterminal_codes
+++ lalr_process_productions compiled, 136 + 24 bytes

lalr_process_productions
+++ lalr_precalculate_first_sets compiled, 116 + 36 bytes

lalr_precalculate_first_sets
+++ lalr_collect_nonterminals compiled, 42 + 12 bytes

lalr_collect_nonterminals
+++ lalr_collect_terminals compiled, 57 + 16 bytes

lalr_collect_terminals
+++ lalr_get_lex_codes compiled, 39 + 32 bytes

lalr_get_lex_codes
+++ lalr_generate_lr0_collection compiled, 83 + 32 bytes

lalr_generate_lr0_collection
+++ lalr_lr0_initial_itemset compiled, 18 + 24 bytes

lalr_lr0_initial_itemset
+++ lalr_compute_lr0_goto compiled, 29 + 16 bytes

lalr_compute_lr0_goto
+++ lalr_lr0_move_dot compiled, 38 + 12 bytes

lalr_lr0_move_dot
+++ lalr_lr0_closure compiled, 110 + 24 bytes

lalr_lr0_closure
+++ lalr_generate_collection compiled, 63 + 48 bytes

lalr_generate_collection
+++ lalr_lr0_itemset_to_lalr_kernel compiled, 29 + 16 bytes

lalr_lr0_itemset_to_lalr_kernel
+++ lalr_add_lookahead compiled, 19 + 8 bytes

lalr_add_lookahead
+++ lalr_propagate_lookaheads compiled, 52 + 16 bytes

lalr_propagate_lookaheads
+++ lalr_analyze_lookaheads compiled, 129 + 44 bytes

lalr_analyze_lookaheads
+++ lalr_item_with_rule compiled, 18 + 8 bytes

lalr_item_with_rule
+++ lalr_closure compiled, 131 + 36 bytes

lalr_closure
+++ lalr_first compiled, 53 + 12 bytes

lalr_first
+++ lalr_make_compressed_action_table compiled, 36 + 24 bytes

lalr_make_compressed_action_table
+++ lalr_make_compressed_action_row compiled, 12 + 20 bytes

lalr_make_compressed_action_row
+++ lalr_resolve_conflicts compiled, 216 + 44 bytes

lalr_resolve_conflicts
+++ lalr_list_of_actions compiled, 115 + 44 bytes

lalr_list_of_actions
+++ lalr_remove_duplicates compiled, 29 + 8 bytes

lalr_remove_duplicates
+++ lalr_make_compressed_action_row1 compiled, 89 + 28 bytes

lalr_make_compressed_action_row1
+++ lalr_most_common_reduction compiled, 79 + 20 bytes

lalr_most_common_reduction
+++ lalr_make_compressed_goto_table compiled, 44 + 32 bytes

lalr_make_compressed_goto_table
+++ lalr_make_compressed_goto_column compiled, 78 + 20 bytes

lalr_make_compressed_goto_column
+++ lalr_most_common_dest compiled, 61 + 12 bytes

lalr_most_common_dest
+++ lalr_process_reductions compiled, 164 + 56 bytes

lalr_process_reductions
+++ lalr_reduction_index compiled, 13 + 12 bytes

lalr_reduction_index
+++ lalr_construct_fn compiled, 28 + 36 bytes

lalr_construct_fn
+++ lalr_make_arglist compiled, 52 + 20 bytes

lalr_make_arglist

nil

 in "genparserprint.red"$
nil
+++ lalr_print_compressed_action_table compiled, 102 + 52 bytes

lalr_print_compressed_action_table
+++ lalr_print_compressed_goto_table compiled, 113 + 60 bytes

lalr_print_compressed_goto_table
+++ lalr_prin_action compiled, 30 + 28 bytes

lalr_prin_action
+++ lalr_prin_reduction compiled, 54 + 56 bytes

lalr_prin_reduction
+++ lalr_print_lr0_collection compiled, 116 + 56 bytes

lalr_print_lr0_collection
+++ lalr_print_collection compiled, 149 + 72 bytes

lalr_print_collection
+++ lalr_print_first_information compiled, 50 + 36 bytes

lalr_print_first_information
+++ lalr_print_terminals_and_codes compiled, 82 + 48 bytes

lalr_print_terminals_and_codes
+++ lalr_print_nonterminals_and_productions compiled, 98 + 72 bytes

lalr_print_nonterminals_and_productions
+++ lalr_prin_semantic_action compiled as link to prin

lalr_prin_semantic_action
+++ lalr_prin_rhs compiled, 24 + 20 bytes

lalr_prin_rhs
+++ lalr_prin_symbol compiled, 51 + 24 bytes

lalr_prin_symbol
+++ lalr_prin_nonterminal compiled, 22 + 16 bytes

lalr_prin_nonterminal
+++ lalr_warn_reduce_reduce_conflict compiled, 45 + 36 bytes

lalr_warn_reduce_reduce_conflict
+++ lalr_prin_production compiled, 10 + 20 bytes

lalr_prin_production
+++ lalr_warn_shift_reduce_conflict compiled, 46 + 36 bytes

lalr_warn_shift_reduce_conflict

nil

nil



on lalr_verbose;
nil



in "lalr.tst";% Test cases for the parser generator. This all runs in symbolic mode...


%
% This is where (for now) I will put documentation of the syntax I
% will use when creating a grammer. There is a main function called
% lalr_create_parser and that is passed a list that describes
% a grammar. It is in the form of a sequence of productions, and the first
% one given is taken to be the top-level target.
%
% Each production is in the form
%     (LHS   ((rhs1.1 rhs1.2 ...) a1.1 a1.2 ...)
%            ((rhs2.1 rhs2.1 ...) a2.1 a2.2 ...)
%            ...)
% which in regular publication style for grammars might be interpreted
% as meaning
%      LHS ::= rhs1.1 rhs1.2 ... { a1.1 a1.2 ... }
%          |   rhs2.1 rhs2.2 ... { a2.1 a2.2 ... }
%          ...
%          ;
%
% Each LHS is treated as a non-terminal symbol and is specified as a simple
% name. Note that by default the Reduce parser will be folding characters
% within names to lower case and so it will be best to choose names for
% non-terminals that are unambiguous even when case-folded, but I would like
% to establish a convention that in source code they are written in capitals.
%
% The rhs items may be either non-terminals (identified because they are
% present in the left hand side of some production) or terminals. Terminal
% symbols can be specified in two different ways.
% The lexer has built-in recipies that decode certain sequences of characters
% and return the special markers for !:symbol, !:number, !:string, !:list for
% commonly used cases. In these cases the variable yylval gets left set
% to associated data, so for instance in the case of !:symbol it gets set
% to the particular symbol concerned.
% The token type :list is used for Lisp or rlisp-like notation where the
% input contains
%     'expression
% or  `expression
% so for instance the input `(a b c) leads to the lexer returning !:list and
% yylvel being set to (backquote (a b c)). This treatment is specialised for
% handling rlisp-like syntax.
%
% Other terminals are indicated by writing a string. That may either
% consist of characters that would otherwise form a symbol (ie a letter
% followed by letters, digits and underscores) or a sequence of
% non-alphanumeric characters. In the latter case if a sequence of three or
% more punctuation marks make up a terminal then all the shorter prefixes
% of it will also be grouped to form single entities. So if "<-->" is a
% terminal then '<', '<-' and '<--' will each by parsed as single tokens, and
% any of them that are not used as terminals will be classified as !:symbol.
%
% As well as terminals and non-terminals (which are wrirrent as symbols or
% strings) it is possible to write one of
%     (OPT s1 s2 ...)           0 or 1 instances of the sequence s1, ...
%     (STAR s1 s2 ...)          0, 1, 2, ... instances
%     (PLUS s1 s2 ...)          1, 2, 3, ... instances
%     (LIST sep s1 s2 ...)      like (STAR s1 s2 ...) but with the single
%                               item sep between each instance.
%     (LISTPLUS sep s1 ...)     like (PLUS s2 ...) but with sep interleaved.
%     (OR s1 s2 ...)            one or other of the tokens shown.
%
% When the lexer processes input it will return a numeric code that identifies
% the type of the item seen, so in a production one might write
%     (!:symbol ":=" EXPRESSION)
% and as it recognises the first two tokens the lexer will return a numeric
% code for !:symbol (and set yylval to the actual symbol as seen) and then
% a numeric code that it allocates for ":=". In the latter case it will
% also set yylval to the symbol !:!= in case that is useful.
%
% Precedence can be set using lalr_precedence. See examples lower down in this
% file.

% Limitations are
% (1) At present the parser generator will not cope with large grammars
%     because it does not merge rules promptly enough.
% (2) The lexer is hand-written and can not readily be reconfigured for
%     use with languages other than rlisp. For instance it has use of "!"
%     as a character escape built into it.
%
%


symbolic;


nil


% Before testing parser generation I will demonstrate the lexer..
% If I was jumpy about the exact behaviour of the lexer I could go
%               on tracelex;
% to get some more tracing.

lex_cleanup();


nil


lex_keywords '("begin" "<=>" "<==");


nil


% The output from this is expected to be

%  Result: (2 symbol)
%  Result: (4 200)
%  Result: (4 3.542)
%  Result: (3 "a string")
%  Result: (2 nil)
%  Result: (5 (quote (quoted lisp)))
%  Result: (5 (backquote (backquoted (!, comma) (!,!@ comma_at))))
%  Result: (2 !+)
%  Result: (7 !<!=!>)
%  Result: (2 !-)
%  Result: (2 !=)
%  Result: (2 !>)
%  Result: (9 !<)
%  Result: (8 !<!=)
%  Result: (5 begin)
%  Result: (2 !;)
%  Result: (2 !;)
%  Result: (2 !;)
%
%  nil

% The row of "; ; ;" at the end provides some protection so that
% if faults in the lexer were to cause it to read more or less than it ought
% to then what is left over is reasonably likely to remain as valid rlisp
% syntax and so the rest of this test file will be able to continue happily.


<< off echo;
   lex_init();
   for i := 1:18 do <<
     tt := yylex();
     if not zerop posn() then terpri();
     princ "Result: ";
     print list(tt, yylval) >>;
   on echo >>;

Result: (1 symbol)
Result: (3 200)
Result: (3 3.542)
Result: (2 "a string")
Result: (4 (quote (quoted lisp)))
Result: (4 (backquote (backquoted (!, comma) (!,!@ comma_at))))
Result: (1 !+)
Result: (6 !<!=!>)
Result: (1 !-)
Result: (1 !=)
Result: (1 !>)
Result: (8 !<)
Result: (7 !<!=)
Result: (5 begin)
Result: (1 !;)
Result: (1 !;)
Result: (1 !;)
Result: (1 !;)

nil



on lalr_verbose;


nil


% Here I set up a sample grammar
%    S' -> S
%    S  -> C C        { }
%    C  -> "c" C      { }
%        | "d"        { }
% This is example 4.42 from Aho, Sethi and Ullman's Red Dragon book.
% It is example 4.54 in the more recent Purple book.

% Note that this grammar will introduce "c" and "d" as keywords rather than
% being general symbols. When I construct a subsequent grammar that will
% undo that setting. I will omit semantic actions here so that the default
% action of building a form of tree is used.

% There seems to be an issue here in that if I use a name for a non-terminal
% that is the same as one used for a terminal thinsg get confused. So I had
% originally hoped and expected to write just 'c' for the name of the
% non-terminal here are use '"c"' to denote the terminal. However when I
% try that I find that internally the names and up clashing to rather bad
% effect. I will look into this later since it is merely a matter of surface
% notation!  Also in the input to semantic actions the values passed when a
% terminal is matched may at present be the internal numeric code allocated
% to that terminal, not a "sensible" value. Agian this is a small issue.

grammar := '(
  (s  ((cc cc)  )   % One production for S, no explicit semantic here
  )
  (cc (("c" cc) (list 'c !$2))   % First production for C
      (("d")    'd           )   % Second production for C
  ));


((s ((cc cc))) (cc (("c" cc) (list (quote c) !$2)) (("d") (quote d))))


g := lalr_create_parser(nil, grammar);

=== Terminal symbols ===
   d [6]
   c [5]

"=== Nonterminal symbols ==="
[-1] S'             : S                         { nil }

[0] S               : CC CC                     { nil }

[1] CC              : d                         { ((quote d)) }
                    | c CC                      { ((list (quote c) !$2)) }


=== FIRST sets for each nonterminal ===
S':                 c d 
S:                  d c 
CC:                 c d 

=== LALR ITEMSET COLLECTION ===

Itemset 0
 S' -> . S [$]
 CC -> . d [c/d]
 CC -> . c CC [c/d]
 S -> . CC CC [$]
GOTO(S) = 1
GOTO(CC) = 2
GOTO(d) = 3
GOTO(c) = 4

Itemset 1
 S' -> S . [$]

Itemset 2
 CC -> . d [$]
 CC -> . c CC [$]
 S -> CC . CC [$]
GOTO(CC) = 6
GOTO(d) = 3
GOTO(c) = 4

Itemset 3
 CC -> d . [$/d/c]

Itemset 4
 CC -> . d [c/d/$]
 CC -> . c CC [c/d/$]
 CC -> c . CC [$/d/c]
GOTO(CC) = 5
GOTO(d) = 3
GOTO(c) = 4

Itemset 5
 CC -> c CC . [c/d/$]

Itemset 6
 S -> CC CC . [$]

=== ACTION TABLE ===
STATE TERMINAL      ACTION
0     c             shift to state 4
      d             shift to state 3
1     <any>         accept
2     c             shift to state 4
      d             shift to state 3
3     <any>         reduce by #2: CC -> [1 symbols] action0001
4     c             shift to state 4
      d             shift to state 3
5     <any>         reduce by #3: CC -> [2 symbols] action0002
6     <any>         reduce by #1: S -> [2 symbols] 

=== GOTO TABLE ===
NONTERMINAL         SRC     DEST
S                   <any>   1
CC                  4       5
                    2       6
                    <any>   2


(((nil 6 . d) (nil 5 . c) (nil 0 . !:eof) (nil 1 . !:symbol) (nil 2 . !:string)
(nil 3 . !:number) (nil 4 . !:list)) [(((5 . 4) (6 . 3))) (nil . 0) (((5 . 4) (6
. 3))) (nil . -2) (((5 . 4) (6 . 3))) (nil . -3) (nil . -1)] ([nil nil
action0001 action0002] #V8(1 2 1 2) #V16(-1 0 1 1 7730 0 0 0)) [(nil . 1) (((4 .
5) (2 . 6)) . 2) nil] ((-1 . !S!') (1 . cc) (0 . s)) ((6 . d) (5 . c) (4 .
!:list) (3 . !:number) (2 . !:string) (1 . !:symbol) (0 . !:eof)))


symbolic procedure pparse g;
  begin
    scalar r;
    r := yyparse g;
    terpri();
    princ "= ";
    print r
  end;

+++ pparse compiled, 14 + 16 bytes

pparse


pparse g$



c Shift token 5 onto stack, and shift to state 4
c Shift token 5 onto stack, and shift to state 4
c Shift token 5 onto stack, and shift to state 4
d Shift token 6 onto stack, and shift to state 3
sym = 6
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
On lookahead -1, reduce 1 symbols to nonterminal CC, and goto state 5
sym = d
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
sym = 5
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
On lookahead -1, reduce 2 symbols to nonterminal CC, and goto state 5
sym = (c d)
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
sym = 5
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
On lookahead -1, reduce 2 symbols to nonterminal CC, and goto state 5
sym = (c (c d))
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
sym = 5
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
On lookahead -1, reduce 2 symbols to nonterminal CC, and goto state 2
c Shift token 5 onto stack, and shift to state 4
d Shift token 6 onto stack, and shift to state 3
sym = 6
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
On lookahead -1, reduce 1 symbols to nonterminal CC, and goto state 5
sym = d
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
sym = 5
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
On lookahead -1, reduce 2 symbols to nonterminal CC, and goto state 6
sym = (c d)
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
sym = (c (c (c d)))
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
On lookahead -1, reduce 2 symbols to nonterminal S, and goto state 1
Seems to have finished... 
= ((c (c (c d))) (c d))
;


nil


pparse g$



d Shift token 6 onto stack, and shift to state 3
sym = 6
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
On lookahead -1, reduce 1 symbols to nonterminal CC, and goto state 2
d Shift token 6 onto stack, and shift to state 3
sym = 6
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
On lookahead -1, reduce 1 symbols to nonterminal CC, and goto state 6
sym = d
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
sym = d
terminal_codes = ((6 . d) (5 . c) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof))
On lookahead -1, reduce 2 symbols to nonterminal S, and goto state 1
Seems to have finished... 
= (d d)
;


nil



% Now switch off the tracing. It is useful whiloe debugging this
% package but is typically rather over the top for normal use.

off tracelex, lalr_verbose;


nil


% Example 4.46 from the Red Dragon (4.61 in Aho, Lam, Sethi and Ullman,
% "Compilers: principles, techniques and tools", second edition 2007).
%
% This is used there as an example of a grammar that is not SLR(1) but
% that can be handled by LALR .

% The semantic actions here contain print statements that will
% print some sort of trace as the parsing progresses.

symbolic procedure neatprintc x;
 << if not zerop posn() then terpri();
    printc x >>;

+++ neatprintc compiled, 11 + 8 bytes

neatprintc


g4_46 := '((s   ((l "=" r)   (neatprintc "## S => L = R")
                             (list 'equal !$1 !$3))
                ((r)         (neatprintc "## S => R")
                             !$1))
           (l   (("*" r)     (neatprintc "## L => * R")
                             (list 'star !$2))
                ((!:symbol)  (neatprintc "## L => symbol")
                             !$1))
           (r   ((l)         (neatprintc "## R => L")
                             !$1)));


((s ((l "=" r) (neatprintc "## S => L = R") (list (quote equal) !$1 !$3)) ((r) (
neatprintc "## S => R") !$1)) (l (("*" r) (neatprintc "## L => * R") (list (
quote star) !$2)) ((!:symbol) (neatprintc "## L => symbol") !$1)) (r ((l) (
neatprintc "## R => L") !$1)))


g := lalr_create_parser(nil, g4_46);


(((nil 6 . !*) (nil 5 . !=) (nil 0 . !:eof) (nil 1 . !:symbol) (nil 2 . !:string
) (nil 3 . !:number) (nil 4 . !:list)) [(((1 . 4) (6 . 5))) (nil . 0) (((5 . 8))
. -5) (nil . -1) (nil . -3) (((1 . 4) (6 . 5))) (nil . -5) (nil . -4) (((1 . 4)
(6 . 5))) (nil . -2)] ([nil action0003 action0004 action0005 action0006
action0007] #V8(1 1 3 1 2 1 0 0) #V16(-1 0 0 1 1 2 0 0 8754 0)) [(nil . 1) (((0
. 2)) . 6) (((5 . 7) (8 . 9)) . 3) nil] ((-1 . !S!') (1 . cc) (0 . s)) ((6 . !*)
(5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol) (0 . !:eof)))


pparse g$



leftsym sym = leftsym
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## L => symbol
= rightsym sym = rightsym
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## L => symbol
sym = rightsym
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## R => L
sym = rightsym
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
sym = 5
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
sym = leftsym
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## S => L = R

= (equal leftsym rightsym)
;


nil



pparse g$



****abc sym = abc
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## L => symbol
sym = abc
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## R => L
sym = abc
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
sym = 6
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## L => * R
sym = (star abc)
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## R => L
sym = (star abc)
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
sym = 6
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## L => * R
sym = (star (star abc))
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## R => L
sym = (star (star abc))
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
sym = 6
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## L => * R
sym = (star (star (star abc)))
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## R => L
sym = (star (star (star abc)))
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
sym = 6
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## L => * R
= *def sym = def
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## L => symbol
sym = def
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## R => L
sym = def
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
sym = 6
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## L => * R
sym = (star def)
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## R => L
sym = (star def)
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
sym = 5
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
sym = (star (star (star (star abc))))
terminal_codes = ((6 . !*) (5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (
1 . !:symbol) (0 . !:eof))
## S => L = R

= (equal (star (star (star (star abc)))) (star def))
;


nil


% This next example is expected to be reasonably representative of
% small grammars. It needs precedence rules to disambiguate the
% grammar, and illustrates both left and right associativity, and
% cases where two operators have the same precedence.

gtest := '((s  ((p))
               ((s "^" s) (list 'expt !$1 !$3))
               ((s "**" s) (list 'expt !$1 !$3))
               ((s "*" s) (list 'times !$1 !$3))
               ((s "/" s) (list 'quotient !$1 !$3))
               ((s "+" s) (list 'plus !$1 !$3))
               ((s "-" s) (list 'difference !$1 !$3))
               ((s "=" s) (list 'equal !$1 !$3))
               (("-" s) (list 'minus !$2))
               (("+" s) !$2))

           (p  (("(" s ")") !$2)
               ((!:symbol))
               ((!:string))
               ((!:number))));


((s ((p)) ((s "^" s) (list (quote expt) !$1 !$3)) ((s "**" s) (list (quote expt)
!$1 !$3)) ((s "*" s) (list (quote times) !$1 !$3)) ((s "/" s) (list (quote
quotient) !$1 !$3)) ((s "+" s) (list (quote plus) !$1 !$3)) ((s "-" s) (list (
quote difference) !$1 !$3)) ((s "=" s) (list (quote equal) !$1 !$3)) (("-" s) (
list (quote minus) !$2)) (("+" s) !$2)) (p (("(" s ")") !$2) ((!:symbol)) ((
!:string)) ((!:number))))


% "^" and "**" both have the same high precedence and are right
% associative. Next come "*" and "/" which are left associative,
% and after that "+" and "-". Finally "=" has lowest precedence and
% must not associate with itself, so (a=b=c) should be a syntax error.

p := '(!:right ("^" "**") !:left ("*" "/") ("+" "-") !:none "=");


(!:right ("^" "**") !:left ("*" "/") ("+" "-") !:none "=")


g := lalr_create_parser(p, gtest);


(((nil 13 . !)) (nil 12 . !() (nil 11 . !=) (nil 10 . !-) (nil 9 . !+) (nil 8 .
!/) (((!* . !*!*)) 7 . !*) (nil 6 . !*!*) (nil 5 . !^) (nil 0 . !:eof) (nil 1 .
!:symbol) (nil 2 . !:string) (nil 3 . !:number) (nil 4 . !:list)) [(((1 . 5) (2
. 4) (3 . 3) (9 . 8) (10 . 7) (12 . 6))) (((5 . 16) (6 . 15) (7 . 14) (8 . 13) (
9 . 12) (10 . 11) (11 . 10)) . 0) (nil . -9) (nil . -10) (nil . -10) (nil . -10)
(((1 . 5) (2 . 4) (3 . 3) (9 . 8) (10 . 7) (12 . 6))) (((1 . 5) (2 . 4) (3 . 3)
(9 . 8) (10 . 7) (12 . 6))) (((1 . 5) (2 . 4) (3 . 3) (9 . 8) (10 . 7) (12 . 6))
) (((5 . 16) (6 . 15) (7 . 14) (8 . 13)) . -1) (((1 . 5) (2 . 4) (3 . 3) (9 . 8)
(10 . 7) (12 . 6))) (((1 . 5) (2 . 4) (3 . 3) (9 . 8) (10 . 7) (12 . 6))) (((1 .
5) (2 . 4) (3 . 3) (9 . 8) (10 . 7) (12 . 6))) (((1 . 5) (2 . 4) (3 . 3) (9 . 8)
(10 . 7) (12 . 6))) (((1 . 5) (2 . 4) (3 . 3) (9 . 8) (10 . 7) (12 . 6))) (((1 .
5) (2 . 4) (3 . 3) (9 . 8) (10 . 7) (12 . 6))) (((1 . 5) (2 . 4) (3 . 3) (9 . 8)
(10 . 7) (12 . 6))) (((5 . 16) (6 . 15)) . -8) (((5 . 16) (6 . 15)) . -8) (((5 .
16) (6 . 15)) . -7) (((5 . 16) (6 . 15)) . -6) (((5 . 16) (6 . 15) (7 . 14) (8 .
13)) . -5) (((5 . 16) (6 . 15) (7 . 14) (8 . 13)) . -4) (((5 . 16) (6 . 15) (7 .
14) (8 . 13) (9 . 12) (10 . 11)) . -3) (((5 . 16) (6 . 15) (7 . 14) (8 . 13)) .
-2) (((5 . 16) (6 . 15) (7 . 14) (8 . 13) (9 . 12) (10 . 11) (11 . 10) (13 . 26)
)) (nil . -11)] ([nil action0008 action0009 action0010 action0011 action0012
action0013 action0014 action0015 nil nil action0016] #V8(1 2 2 3 3 3 3 3 3 1 1 3
) #V16(-1 0 0 0 0 0 0 0 0 0 1 1 11826 0 0 0)) [(((8 . 9) (16 . 17) (15 . 18) (14
. 19) (13 . 20) (12 . 21) (11 . 22) (10 . 23) (7 . 24) (6 . 25)) . 1) (nil . 2)
nil] ((-1 . !S!') (1 . cc) (0 . s)) ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9
. !+) (8 . !/) (7 . !*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 .
!:string) (1 . !:symbol) (0 . !:eof)))


pparse g$


a^sym = a
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = a
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
b^sym = b
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = b
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
c;sym = c
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = c
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = c
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = 5
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = b
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = (expt b c)
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = 5
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = a
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))

= (expt a (expt b c))


pparse g$


a*sym = a
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = a
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
b+sym = b
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = b
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = b
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = 7
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = a
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
c*sym = c
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = c
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
d;sym = d
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = d
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = d
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = 7
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = c
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = (times c d)
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = 9
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = (times a b)
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))

= (plus (times a b) (times c d))


pparse g$


a sym = a
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = a
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
* (b/sym = b
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = b
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
c sym = c
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = c
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
+sym = c
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = 8
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = b
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
 d/sym = d
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = d
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
e/sym = e
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = e
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = e
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = 8
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = d
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
f)sym = f
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = f
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = f
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = 8
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = (quotient d e)
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = (quotient (quotient d e) f)
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = 9
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = (quotient b c)
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = 13
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = (plus (quotient b c) (quotient (quotient d e) f))
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = 12
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = (plus (quotient b c) (quotient (quotient d e) f))
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
 ^ 2 sym = 2
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = !:string
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
^ g sym = g
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = g
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
-sym = g
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = 5
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = !:string
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = (expt !:string g)
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = 5
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = (plus (quotient b c) (quotient (quotient d e) f))
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = (expt (plus (quotient b c) (quotient (quotient d e) f)) (expt !:string g))
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = 7
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = a
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
 "str" sym = "str"
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = "str"
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
;sym = "str"
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = 10
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))
sym = (times a (expt (plus (quotient b c) (quotient (quotient d e) f)) (expt
!:string g)))
terminal_codes = ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9 . !+) (8 . !/) (7 .
!*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol
) (0 . !:eof))

= (difference (times a (expt (plus (quotient b c) (quotient (quotient d e) f)) (
expt !:string g))) "str")


% Demonstrate various of the short-hand notations...

g := lalr_create_parser(nil, '(
 (s
% (opt ...) means that the included material is optional.
          (("begin" (opt "and" "also") "end")))));

+++ Error: intern (not a string) (opt "and" "also")
Inside: lalr_process_productions
Arg 1: ((!S!' ((s))) (s (("begin" (opt "and" "also") "end"))))
Arg 2: ((6 . end) (5 . begin) (4 . !:list) (3 . !:number) (2 . !:string) (1 . 
!:symbol) (0 . !:eof))
Inside: lalr_set_grammar
Arg 1: nil
Arg 2: ((!S!' ((s))) (s (("begin" (opt "and" "also") "end"))))
Inside: lalr_create_parser
Arg 1: nil
Arg 2: ((s (("begin" (opt "and" "also") "end"))))

Cont? (Y or N)



eType Y or N
n
d;
+++ Error unset variable: d


Inside: filenderr

Inside: filenderr

Inside: filenderr

Inside: filenderr

Inside: filenderr

*** End-of-file read 

+++ Transcript closed at end of run +++
