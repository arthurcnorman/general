\chapter{Introduction}


% Title changed to allude to "Mathematics made Difficult" (Linderholm, 1971 or
% 2) even though our agenda is not exactly the same. But it means that each
% chapter can (indeed should!) end up with something that is seriously
% tough and deep (and WAY beyond anything a reasonable beginner can manage).
% Well our agenda is really not at all that of Linderholm, but 36 years on
% it may be OK to pillage his title...

% The Computer Laboratory has a major problem with recruitment, both in
% quantity and quality. Part of this problem relates to people at school
% level not having a clear vision of what the agenda of a computer science
% department will be, and having a lot of input on what the word ``computer''
% should be associated with: website creation, word processing, training in
% the use of commercial software, Access ``databases'' that our database
% people would not view as interesting enough to deserve being called that,
% gaming, file-sharing, ...
%
% Participating in a series of master-classes provides a way to reach out
% to the top end of those in schools and give them some awareness of  the
% range of our interests. Interest will only really last if the
% participants have an active role in the proceedings, so mere lectures or
% demonstrations given by us will not fully fit the bill --- we want our
% visitors to do something that they find challenging while here and take
% home more challenges that they can work on between the monthly sessions
% that are envisaged.
%
% Strengths: The Cambridge ``brand'' is very strong, and the long history
% from Wilkes onwards can be capitalised on. The Gates building provides a
% venue. Our subject has a number of attractive but respectably small-scale
% facets that can be deployed.
%
% Weaknesses: If we have any practical work we will have to limit numbers
% to say 60. Finding enough demonstrators may be hard. Microsoft Research
% having a building adjacent (and probably them volunteering to help)
% dilutes our brand and muddies the message about academic vs. commercial
% that we might otherwise want to focus on. In general our experience in
% judging what will be accessible to a young audience is limited.
%
% Opportunities: At present many schools do not understand our mind-set and
% ethos. This is a major opportunity to recruit. If we aim at GCSE-year (or
% even one below) pupils we can be in time to influence A-level choices and
% University subject aims. in general school pupils have not studied any
% Computer Science liable to clash with anything we want to do, and if we
% waited until they were AS or A2 level they would still not have done a
% lot that would help us. This leaves us a clear flexible run. This is an
% excellent state to be in that the Mathematicians and Physicists can not
% match.
%
% Threats: Because there is no useful school syllabus to build on we have
% to start from scratch. Finding topics where that is truly feasible in the
% time-scale available may be touch. The pragmatics of driving computers
% may get in the way of students being able to address the intellectual
% meat we are trying to offer. Building the course-ware may prove too
% expensive. Some participants may have done all sorts of stuff on their
% own and could be bored of we cover it again at a speed suitable for the
% least clued up ones.
%
%
% The overall plan I explore here is to have a series of (probably 8)
% sessions where most start with 2 hours (before lunch) of in effect
% lecture (that would be two or possibly three lecturers talking about
% slightly different aspects of the topic of the day). Then one hopes that
% participants talk over lunch, but they then have a 90-minute ``practical
% session'' to attempt a task or tasks as set earlier. At the end of the day
% there can be 30 minutes (well try to keep it to 20) of summing up. A
% take-home sheet or pamphlet reminding about the morning's presentation
% and giving a couple more challenges is provided so that keener people can
% continue the activity using their own computers at home or school. Some
% flavour of network based submission of solutions might make sense and a
% general bulletin board (if it could be kept sufficiently spam-free and
% obscenity-free) would seem like natural backup, and having the handouts
% etc. (and videos of the sessions?) on-line might make some of what was
% done available to a yet wider audience.
%
% My expectation is that while we MAY have one or two big sessions for an
% audience of 200, those would have to be on topics where computer access
% was not required for the practical work. For the majority of our sessions
% we would set a limit of (say) 60 participants. If we make each session
% (almost) independent of all others we can have a significant number of
% people who come to just one  or two sessions, rather than expecting or
% demanding that somebody sign up for the lot. This may help with
% selection: we can give priority to those who have not been before, but
% can direct those we have to turn down to the web-cast version.
%
%
%
%
% So our first big internal challenge is to decide two things. One is what
% we believe the spirit or ethos of our subject is and hence what we want
% to participants to gain. The second is the strategic aspect of how we
% deliver this. My response to these two questions is
% \begin{enumerate}
% \item Computer Science includes programming, algorithms, design, theory and all sorts of very
% nice applications. I want to give people at least a glimpse of the
% breadth and avoid getting them too bogged down in the routine frustration
% that is also a key and important feature of our subject! I drafted a note
% for another purpose discussing at much greater length what I felt
% Computer Science was, and will attach a copy of that.
% \item I vote for using
% a different notation to describe computation in each session. I want to
% ``describe a computation'' more than ``write a program''. So each session
% will introduce its own mini-notation for a schema tuned to its needs. The
% effect is that I am not proposing that we use Python or ML (or Visual
% Basic) as a single consistent language. You will see my attempts to do
% this in my concrete session plans what are what comes next.
% \end{enumerate}
%
% To try to convince that my plan is viable I offer a collection of
% potential sessions. Since these are just the ones I have though of in one
% day several of them will in fact be infeasible, but others will be able
% to contribute other ideas. But these are ones where I have reasonable
% confidence that I could work up at least half of them into viable
% activities!
%
% I have left out C, C++, Java, Python, Quicksort, the Dutch National Flag
% and tried to find things that may manage to fit as stand-alone topics,
% much feel fun(ish) and in general are things I would hope to be able to
% work up into standard hour-long talk to undergraduates at some university
% society etc. Understanding them will indeed call for our audience to be
% Gifted and Talented and the presenter can be full of Gin and Tonic  but
% given both of those one hopes for a session that is Good and
% Transformational.
%
% I should pick up some notation from another couple of sessions on
% Education I attended last year, and try to characterise some of the
% following as ``threshold'' topics, where grasping them opens up new modes
% of thought or understanding...


To make something properly complicated the best thing to do is to start by
showing that is starts off very simple, and so the intent here is that the
first part of every chapter is showing how simple some aspect of
computing is. These initial sections cover a range of topics that are
to do with the broad area that people sometimes refer to as ``computing'',
``informatics'', ``computer science'' or mix up with ``information
technology''. The middle part of each chapter then sets a sequence of
puzzles, projects or challenges relating to the topic involved. In general
these do not need much particular prior knowledge of computers or how to use
them --- and in particular they do not start with any assumption that you have
done a lot of programming before or have special deep knowledge about
particular makes or models of computer. They just suppose that you have read
and thought about the initial and specifically easy part of the chapter, but
the intent is that despite this the material covered will provide glimpses
into the areas that Computer Scientists spend some of their time thinking
about, and some of the more important results that exist in that area. Each
chapter ends with a few case studies of a much more substantial nature, and
in at least a few cases these will introduce challanges that have not yet
been solved at all. The material earlier in the chapter should provide a
good basis for understanding what the problems concerned are and why they might
be both interesting and important to solve, but any serious attack on them
would call for some more background reading!




A citation here --- I like Dijkstra\cite{discipline} as a base for rigorous
work with computers. When I have put in a load more citations scattered through
the chapters this sample one can be removed!