+++ Transcript to garnet.log started at Wed May 25 22:32:34 2016 +++
Reduce (Free CSL version, revision 3684), 23-May-16 ...


nil


nil

 % set some useful (I hope) options

% The existing "rubi_red" package provides a way to access all the
% Rubi rules... But in fact I will set up my own short list...

% load_package rubi_red;

fluid '(rubi_rules);
nil



% To start with I will have just ONE rule!

% (a + b*x^n)^p
% where n*(p+1)=-1
% eg let me try n=1, p=-2, so I get
% (a + b*x^1)^(-2)

rubi_rules := '(

(!/!;
   (!:!=
      (!Int
         (expt (plus (!_ a) (times (!_!. b) (expt (!_ x) (!_ n)))) (!_ p))
         (!_ x !Symbol))
      (quotient (times x (expt (plus a (times b (expt x n))) (plus p 1))) a))
   (and
      (!Free!Q (bracelist a b n p) x)
      (!Zero!Q (plus (times n (plus p 1)) 1))))


)$



algebraic operator unsimplified_int;


symbolic procedure simpgarnet u;
  begin
    scalar a, x, r;
    if length u neq 2 then rederr "garnet requires two arguments";
    a := car u;
    x := cadr u;
    if posn() neq 0 then terpri();
    princ "Integrate "; prin a; princ " wrt "; print x;
% The arguments arrive here are totally unprocessed, and so for instance
% if you write "w := <something>; var := x; garnet(w, var);" what you
% receive will be "w" and "var" not sensible values. I have special code
% to deal with this!
    a := garnet!-simp a;
    x := garnet!-simp x;
    r := garnet_integrate(a, x);
% I hand back a list of length 2 - the first item is the result that
% garnet generates, the second is what the existing old Reduce integrator
% makes of the example.
    return simp list('list, r, list('int, a, x));
  end;
+++ simpgarnet compiled, 60 + 52 bytes

simpgarnet



put('garnet, 'simpfn, 'simpgarnet);
simpgarnet



% This takes a formula and "evaluates" it by evaluating all the variables
% present in it while trying to preserve the structure around the, So if you
% hand it (x-1)^10 where x has some messy value it will return the expression
% (<messy-value> - 1)^10 rather than multiplying things out. Just in case
% the varibles used had previously been simplified in a way that expanded
% them this does some factorization to try to return things to a "neat"
% form. If substituting values for variables would introduce cases of
% (expression + 0) or (expression^1) it does some minor tidying up to
% make things seem nicer.

symbolic procedure garnet!-simp u;
  if numberp u then u
  else if atom u then garnet!-simpatom u
  else begin
    scalar w;
    w := for each v in cdr u collect garnet!-simp v;
    if car u = 'plus then return garnet!-simp!-plus w
    else if car u = 'difference then return garnet!-simp!-difference w
    else if car u = 'times then return garnet!-simp!-times w
    else if car u = 'quotient then return garnet!-simp!-quotient w
    else if car u = 'expt then return garnet!-simp!-expt w
    else if car u = 'minus then return garnet!-simp!-minus w
    else return car u . w
  end;
+++ garnet!-simp compiled, 107 + 60 bytes

garnet!-simp



% Following might be redundant - commented out for the moment

%symbolic procedure garnet!-simp!-plus l;
%  begin
%    scalar r;
%    for each x in l do if not zerop x then r := x . r;
%    if null r then return 0
%    else if nuill cdr r then return car r
%    else return 'plus . reverse r
%  end;

% The next few reconstruct prefix forms performing only the very simplest
% transformations such as (x + 0) => x and (x * 1) => x. They may even
% go as far as (2 + 2) => 4, but do not guarantee even that! Note that
% "simplifications" along the lines illustrated here are naive and not
% in general an effective way to tidy things up.
 
symbolic procedure garnet!-simp!-plus l;
  begin
    scalar r, n;
    n := 0;
    for each x in l do
       if numberp x then n := n + x
       else r := x . r;
% Puts any numeric constant as first item in result version.
    if not zerop n then r := n . reverse r
% Sean-To-do: figure out why reverse
% Arthur answer: the for-each loop builds up the result list r by putting
% items on its front and that reverses the original input, so the reverese
% here restores it.
    else r := reverse r;
% If only one item left return it, otherwise return a sum.
    if null cdr r then return car r
    else return 'plus . r
  end;
+++ garnet!-simp!-plus compiled, 58 + 16 bytes

garnet!-simp!-plus



symbolic procedure garnet!-simp!-times l;
  begin
    scalar r, n;
    n := 1;
    for each x in l do
       if numberp x then n := n * x
       else r := x . r;
    if zerop n then return 0
    else if not onep n then r := n . reverse r
    else r := reverse r;
    if null cdr r then return car r
    else return 'times . r
  end;
+++ garnet!-simp!-times compiled, 64 + 20 bytes

garnet!-simp!-times



symbolic procedure garnet!-simp!-difference l;
  begin
    scalar a, b;
    a := car l;
    b := cadr l;
    if numberp a and numberp b then return a-b
    else if zerop a then return garnet!-simp!-minus list b
    else if zerop b then return a
    else return list('difference, a, b)
  end;
+++ garnet!-simp!-difference compiled, 37 + 16 bytes

garnet!-simp!-difference



symbolic procedure garnet!-simp!-quotient l;
  begin
    scalar a, b;
    a := car l;
    b := cadr l;
    if zerop a then return 0
    else if onep b then return a
    else return list('quotient, a, b)
  end;
+++ garnet!-simp!-quotient compiled, 22 + 16 bytes

garnet!-simp!-quotient



% Adding garnet!-simp!-expt l
% Sean-To-do: seems that we cannot just simplify expt component
symbolic procedure garnet!-simp!-expt l;
  begin
    scalar a, b;
    a := car l;
    b := cadr l;
    return list('expt, a, b)
%    if zerop b then return 1
%    else if onep b then return a
%    else if zerop a then return 0
%    else if onep a then return a
%    else return list('expt, a, b)
  end;
+++ garnet!-simp!-expt compiled, 11 + 12 bytes

garnet!-simp!-expt



symbolic procedure garnet!-simp!-minus l;
  begin
    scalar a;
    a := car l;
    if numberp a then return -a
    else if eqcar(a, 'minus) then return cadr a
    else return list('minus, a)
  end;
+++ garnet!-simp!-minus compiled, 21 + 12 bytes

garnet!-simp!-minus



symbolic procedure garnet!-simpatom x;
  begin
    scalar w, n, d;
% Start by "simplifying" to get a Standard Quotient
    w := simp x;
% Factorize the polynomials in numerator and denominator;
    n := prepfctr fctrf numr w;
    d := prepfctr fctrf denr w;
    if d = 1 then return n
    else return list('quotient, n, d)
  end;
+++ garnet!-simpatom compiled, 22 + 28 bytes

garnet!-simpatom



% fctrf returns a numerical content on the front of a list of
% factors and multiplicities. If it is (c . (f1 . n1) (f2 . n2)) I will
% return (times c (expt f1 n1) (expt f2 n2)). But can omit bits if any
% multiplicity is 1, or if c=1, or if there is only one factor shown at
% all.

symbolic procedure prepfctr u;
  begin
    scalar r;
    r := for each f in cdr u collect
      if cdr f = 1 then prepf car f
      else list('expt, prepf car f, cdr f);
    if null r then return car u
    else if car u = 1 then <<
      if null cdr r then return car r
      else return 'times . r >>
    else return 'times . car u . r
  end;
+++ prepfctr compiled, 88 + 24 bytes

prepfctr



tr garnet!-simpatom, fctrf, prepfctr;
(garnet!-simpatom fctrf prepfctr)




% going through all the rules one by one for pattern matching

symbolic procedure garnet_integrate(a, x);
  begin
    scalar rules, w;
    rules := rubi_rules;
top:
    if null rules then return list('unsimplified_int, a, x);
% apply_rules returns a non-nil answer if it finds an integral, or nil
% if the rules will not apply.
    if w := apply_rule(car rules, a, x) then
       return garnet_check_inside w;
    rules := cdr rules;
    go to top;
  end;
+++ garnet_integrate compiled, 28 + 24 bytes

garnet_integrate



global '(trace_counter);
nil


trace_counter := 0;
0



% The high-level pattern matcher, match a rule against an expression
% calls trymatch to create bindings
% returns nil if fail to match
%
symbolic procedure apply_rule(rule, a, x);
  begin
    scalar lhs, rhs, conditions, w, bindings;
    if (trace_counter := trace_counter+1) < 5 then <<
        %Sean-To-do: look up posn()
        %Arthur: posn() tells you the current output column, so this
        % forces a new line unless you are already at the start of a line.
       if posn() neq 0 then terpri(); 
       prin trace_counter; princ ": ";
       princ "looking at "; prin a; princ " wrt "; print x;
       princ "Try rule "; prettyprint rule; terpri() >>;
    if not eqcar(rule, '!/!;) then <<
       printc "Expecting /; at top of rule";
       return nil >>;
    w := cadr rule;
    conditions := caddr rule;
    if not eqcar(w, '!:!=) then <<
       printc "Expecting := at top of rewrite";
       return nil >>;
    lhs := cadr w;
    rhs := caddr w;
% trymatch will return either a list of bindings or the special symbol
% 'fail to indicate that matching was not possible.
    bindings := trymatch(list('!Int, a, x), lhs, nil);
    princ "Bindings = "; print bindings;
    if bindings = 'fail then return nil;
% Here I need to check conditions
    if conditions_fail(conditions, bindings) then return nil;
    return subla(bindings, rhs);
  end;
+++ apply_rule compiled, 113 + 76 bytes

apply_rule



% ===================== Conditions Section ======================
symbolic procedure conditions_fail(c, b);
% Question from Sean: is this begin-end necessary?
  begin
    princ "Conditions are: "; print c; 
    princ "Bindings are: "; print b;
    if not eqcar(c, 'and) then << 
      printc "Expecting and at the top of conditions"; return 'fail; 
      >>;
    return check_condition_list(cdr c, b);
  end;
+++ conditions_fail compiled, 25 + 32 bytes

conditions_fail



symbolic procedure check_condition_list(c, b);
  begin
    if null c then return nil;
    if fail_single_condition(car c, b) then return 'fail
    else return check_condition_list(cdr c, b);
  end;
+++ check_condition_list compiled, 17 + 16 bytes

check_condition_list




symbolic procedure fail_single_condition(c, b);
  begin
    if eqcar(c, '!Free!Q) then return fail_free_q(cdr c, b)
    else if eqcar(c, '!Zero!Q) then return fail_zero_q(cdr c, b);
    return nil;
  end;
+++ fail_single_condition compiled, 20 + 24 bytes

fail_single_condition



symbolic procedure fail_free_q(c, b);
  nil;
*** local variable c in procedure fail_free_q not used 

*** local variable b in procedure fail_free_q not used 
+++ fail_free_q compiled, 1 + 8 bytes

fail_free_q



symbolic procedure fail_zero_q(c, b);
  begin
    d := subla(b, c);
    if zerop reval(car d) then return nil
    else return 'fail;
  end;
+++ d declared fluid
+++ fail_zero_q compiled, 15 + 20 bytes

fail_zero_q



% ===================== Conditions Section End ======================


% the low-level recursive pattern matcher that generates bindings
% returns binding if succeed, 'fail otherwise
% bindings in the following format:
% (( rule_variable_name . expression_variable_name) (...) ...)
symbolic procedure trymatch(u, pattern, env);
  begin
%    princ "u = "; print u;
%    princ "pattern = "; print pattern;
%    princ "env = "; print env;
% Sean-To-do: what happens when there is '!_ or '!_!.??
    if eqcar(pattern, '!_) then
       return (cadr pattern . u) . env
    else if eqcar(pattern, '!_!.) then
       return (cadr pattern . u) . env
    else if u = pattern then return env
    else if atom pattern or atom u then return 'fail
    else if not (car u = car pattern) then return 'fail
    else return trymatchlist(cdr u, cdr pattern, env)    
  end;
+++ trymatch compiled, 44 + 24 bytes

trymatch



symbolic procedure trymatchlist(lu, lpattern, env);
  if null lu and null lpattern then env
  else if null lu or null lpattern then 'fail
  else begin
    scalar w;
    w := trymatch(car lu, car lpattern, env);
    if w = 'fail then return 'fail
    else return trymatchlist(cdr lu, cdr lpattern, w)
  end;
+++ trymatchlist compiled, 32 + 16 bytes

trymatchlist



% A rule may transform an integral into something where there is an
% integral sign left within what is generated. Scan to spot such cases and
% call garnet again to process that.

symbolic procedure garnet_check_inside u;
  if atom u then u
  else if eqcar(u, 'int) then garnet_integrate(cadr u, caddr u)
  else car u . for each a in cdr u collect garnet_check_inside a;
+++ garnet_check_inside compiled, 58 + 16 bytes

garnet_check_inside



% A possibly useful function for noting constants. NOT TESTED AT ALL YET.

%Sean-To-do: will try to incorporate this at later stage

fluid '(garnet_hash);
nil


garnet_hash := mkhash(15, 0, 2.0);
#H(0 0 15 2.0 [0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0
SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0
SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0
SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0
SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0
SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0
SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0
SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0
SPID_HASH0 SPID_HASH0 SPID_HASH0 SPID_HASH0])



symbolic procedure mark_constants(u, x);
  begin
    clrhash garnet_hash;
    mark_constants_1(u, x)
  end;
+++ mark_constants compiled, 6 + 20 bytes

mark_constants



% The idea is that this will enter data into the hash table for every
% part of the input that is "constant" in u (with respect to x). So complex
% formulae like sin(pi/sqrt(a^2+b^2)) are constant with respect to x, in that
% the given formula has no x in it. However exactly the same formula would not
% be independent of a or b.
% The functio also returns true it its argument u is independent of x,
% This is to implement the InvolvesQ predicate.

symbolic procedure mark_constants_1(u, x);
  if u = x then nil
  else if atom u then << puthash(u, garnet_hash, t); t >>
  else begin
    scalar overall;
    overall := t;
% overall is going to tell if this whole expression seems constant.
    for each s in cdr u do
       if not mark_constants_1(s, x) then overall := nil;
    if overall then puthash(u, garnet_hash, t);
    return overall
  end;
+++ mark_constants_1 compiled, 51 + 20 bytes

mark_constants_1



% check by using "gethash(u, garnet_hash)"

% Small test/demo of above

symbolic procedure test_constants(u, x);
  begin
    mark_constants(u, x);
    testconst u
  end;
+++ test_constants compiled, 6 + 16 bytes

test_constants



symbolic procedure testconst u;
  begin
    prin u;
    if posn() > 49 then terpri();
    ttab 50;
    print gethash(u, garnet_hash);
    if atom u then return nil;
    for each s in cdr u do testconst s
  end;
+++ testconst compiled, 40 + 24 bytes

testconst



test_constants('(plus (times 2 x)
                 (sin (quotient pi (sqrt (plus (expt a 2) (expt b 2)))))),
               'x);(plus (times 2 x) (sin (quotient pi (sqrt (plus (expt a 2) (
expt b 2))))))                                    nil
(times 2 x)                                       nil
2                                                 t
x                                                 nil
(sin (quotient pi (sqrt (plus (expt a 2) (expt b 2)))))
                                                  t
(quotient pi (sqrt (plus (expt a 2) (expt b 2)))) t
pi                                                t
(sqrt (plus (expt a 2) (expt b 2)))               t
(plus (expt a 2) (expt b 2))                      t
(expt a 2)                                        t
a                                                 t
2                                                 t
(expt b 2)                                        t
b                                                 t
2                                                 t

nil







algebraic;


% I now have some cases - where SOME of them should match the rule that
% I have got.

tr trymatch, trymatchlist;
(trymatch trymatchlist)



garnet((u + v*z^1)^(-2), z);
Integrate (expt (plus u (times v (expt z 1))) -2) wrt z
Tail calling garnet!-simpatom (1 arg) from garnet!-simp
Arg1: u
fctrf called (1 arg)
arg1: (((u . 1) . 1))
fctrf = (1 ((((u . 1) . 1)) . 1))
Entering prepfctr (1 arg)
Arg1: (1 ((((u . 1) . 1)) . 1))
prepfctr = u
fctrf called (1 arg)
arg1: 1
fctrf = (1)
Entering prepfctr (1 arg)
Arg1: (1)
prepfctr = 1
Tail calling garnet!-simpatom (1 arg) from garnet!-simp
Arg1: v
fctrf called (1 arg)
arg1: (((v . 1) . 1))
fctrf = (1 ((((v . 1) . 1)) . 1))
Entering prepfctr (1 arg)
Arg1: (1 ((((v . 1) . 1)) . 1))
prepfctr = v
fctrf called (1 arg)
arg1: 1
fctrf = (1)
Entering prepfctr (1 arg)
Arg1: (1)
prepfctr = 1
Tail calling garnet!-simpatom (1 arg) from garnet!-simp
Arg1: z
fctrf called (1 arg)
arg1: (((z . 1) . 1))
fctrf = (1 ((((z . 1) . 1)) . 1))
Entering prepfctr (1 arg)
Arg1: (1 ((((z . 1) . 1)) . 1))
prepfctr = z
fctrf called (1 arg)
arg1: 1
fctrf = (1)
Entering prepfctr (1 arg)
Arg1: (1)
prepfctr = 1
Tail calling garnet!-simpatom (1 arg) from garnet!-simp
Arg1: z
fctrf called (1 arg)
arg1: (((z . 1) . 1))
fctrf = (1 ((((z . 1) . 1)) . 1))
Entering prepfctr (1 arg)
Arg1: (1 ((((z . 1) . 1)) . 1))
prepfctr = z
fctrf called (1 arg)
arg1: 1
fctrf = (1)
Entering prepfctr (1 arg)
Arg1: (1)
prepfctr = 1
1: looking at (expt (plus u (times v (expt z 1))) -2) wrt z
Try rule (!/!;
            (!:!=
               (!Int
                  (expt
                     (plus (!_ a) (times (!_!. b) (expt (!_ x) (!_ n))))
                     (!_ p))
                  (!_ x !Symbol))
               (quotient
                  (times x (expt (plus a (times b (expt x n))) (plus p 1)))
                  a))
            (and
               (!Free!Q (bracelist a b n p) x)
               (!Zero!Q (plus (times n (plus p 1)) 1))))

Entering trymatch (3 args)
Arg1: (!Int (expt (plus u (times v (expt z 1))) -2) z)
Arg2: (!Int (expt (plus (!_ a) (times (!_!. b) (expt (!_ x) (!_ n)))) (!_ p)) (
!_ x !Symbol))
Arg3: nil
Tail calling trymatchlist (3 args) from trymatch
Arg1: ((expt (plus u (times v (expt z 1))) -2) z)
Arg2: ((expt (plus (!_ a) (times (!_!. b) (expt (!_ x) (!_ n)))) (!_ p)) (!_ x 
!Symbol))
Arg3: nil
Entering trymatch (3 args)
Arg1: (expt (plus u (times v (expt z 1))) -2)
Arg2: (expt (plus (!_ a) (times (!_!. b) (expt (!_ x) (!_ n)))) (!_ p))
Arg3: nil
Tail calling trymatchlist (3 args) from trymatch
Arg1: ((plus u (times v (expt z 1))) -2)
Arg2: ((plus (!_ a) (times (!_!. b) (expt (!_ x) (!_ n)))) (!_ p))
Arg3: nil
Entering trymatch (3 args)
Arg1: (plus u (times v (expt z 1)))
Arg2: (plus (!_ a) (times (!_!. b) (expt (!_ x) (!_ n))))
Arg3: nil
Tail calling trymatchlist (3 args) from trymatch
Arg1: (u (times v (expt z 1)))
Arg2: ((!_ a) (times (!_!. b) (expt (!_ x) (!_ n))))
Arg3: nil
Entering trymatch (3 args)
Arg1: u
Arg2: (!_ a)
Arg3: nil
trymatch = ((a . u))
Tail calling trymatchlist (3 args) from trymatchlist
Arg1: ((times v (expt z 1)))
Arg2: ((times (!_!. b) (expt (!_ x) (!_ n))))
Arg3: ((a . u))
Entering trymatch (3 args)
Arg1: (times v (expt z 1))
Arg2: (times (!_!. b) (expt (!_ x) (!_ n)))
Arg3: ((a . u))
Tail calling trymatchlist (3 args) from trymatch
Arg1: (v (expt z 1))
Arg2: ((!_!. b) (expt (!_ x) (!_ n)))
Arg3: ((a . u))
Entering trymatch (3 args)
Arg1: v
Arg2: (!_!. b)
Arg3: ((a . u))
trymatch = ((b . v) (a . u))
Tail calling trymatchlist (3 args) from trymatchlist
Arg1: ((expt z 1))
Arg2: ((expt (!_ x) (!_ n)))
Arg3: ((b . v) (a . u))
Entering trymatch (3 args)
Arg1: (expt z 1)
Arg2: (expt (!_ x) (!_ n))
Arg3: ((b . v) (a . u))
Tail calling trymatchlist (3 args) from trymatch
Arg1: (z 1)
Arg2: ((!_ x) (!_ n))
Arg3: ((b . v) (a . u))
Entering trymatch (3 args)
Arg1: z
Arg2: (!_ x)
Arg3: ((b . v) (a . u))
trymatch = ((x . z) (b . v) (a . u))
Tail calling trymatchlist (3 args) from trymatchlist
Arg1: (1)
Arg2: ((!_ n))
Arg3: ((x . z) (b . v) (a . u))
Entering trymatch (3 args)
Arg1: 1
Arg2: (!_ n)
Arg3: ((x . z) (b . v) (a . u))
trymatch = ((n . 1) (x . z) (b . v) (a . u))
Tail calling trymatchlist (3 args) from trymatchlist
Arg1: nil
Arg2: nil
Arg3: ((n . 1) (x . z) (b . v) (a . u))
trymatch = ((n . 1) (x . z) (b . v) (a . u))
Tail calling trymatchlist (3 args) from trymatchlist
Arg1: nil
Arg2: nil
Arg3: ((n . 1) (x . z) (b . v) (a . u))
trymatch = ((n . 1) (x . z) (b . v) (a . u))
Tail calling trymatchlist (3 args) from trymatchlist
Arg1: nil
Arg2: nil
Arg3: ((n . 1) (x . z) (b . v) (a . u))
trymatch = ((n . 1) (x . z) (b . v) (a . u))
Tail calling trymatchlist (3 args) from trymatchlist
Arg1: (-2)
Arg2: ((!_ p))
Arg3: ((n . 1) (x . z) (b . v) (a . u))
Entering trymatch (3 args)
Arg1: -2
Arg2: (!_ p)
Arg3: ((n . 1) (x . z) (b . v) (a . u))
trymatch = ((p . -2) (n . 1) (x . z) (b . v) (a . u))
Tail calling trymatchlist (3 args) from trymatchlist
Arg1: nil
Arg2: nil
Arg3: ((p . -2) (n . 1) (x . z) (b . v) (a . u))
trymatch = ((p . -2) (n . 1) (x . z) (b . v) (a . u))
Tail calling trymatchlist (3 args) from trymatchlist
Arg1: (z)
Arg2: ((!_ x !Symbol))
Arg3: ((p . -2) (n . 1) (x . z) (b . v) (a . u))
Entering trymatch (3 args)
Arg1: z
Arg2: (!_ x !Symbol)
Arg3: ((p . -2) (n . 1) (x . z) (b . v) (a . u))
trymatch = ((x . z) (p . -2) (n . 1) (x . z) (b . v) (a . u))
Tail calling trymatchlist (3 args) from trymatchlist
Arg1: nil
Arg2: nil
Arg3: ((x . z) (p . -2) (n . 1) (x . z) (b . v) (a . u))
trymatch = ((x . z) (p . -2) (n . 1) (x . z) (b . v) (a . u))
Bindings = ((x . z) (p . -2) (n . 1) (x . z) (b . v) (a . u))
Conditions are: (and (!Free!Q (bracelist a b n p) x) (!Zero!Q (plus (times n (
plus p 1)) 1)))
Bindings are: ((x . z) (p . -2) (n . 1) (x . z) (b . v) (a . u))
fctrf called (1 arg)
arg1: (((u . 1) . 1) ((v . 1) ((z . 1) . 1)))
fctrf = (1 ((((u . 1) . 1) ((v . 1) ((z . 1) . 1))) . 1))

      z            z
{------------,------------}
   2            2
  u  + u*v*z   u  + u*v*z


% garnet((u + z^1)^(-2), z);
% garnet((u + v*z)^(-2), z);
% garnet((u + z)^(-2), z);

% Now the same four but with a level of indirection...
%w := (u + v*z^1)^(-2); garnet(w, z);
%w := (u + z^1)^(-2); garnet(w, z);
%w := (u + v*z)^(-2); garnet(w, z);
%w := (u + z)^(-2); garnet(w, z);


end;







*** End-of-file read 

+++ Transcript closed at end of run +++
